<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="技术，分享， 热爱">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="洪笳淏">
    
    <title>
        
            微服务可用性设计 |
        
        Hao&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"jiahaohong1997.github.io","root":"/","language":"en","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#CC9999","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/ay9bh-ow8ve.svg","description":"Go Big or Go Home."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="洪笳淏的个人博客" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/wallhaven-439594_100x100.png">
                </a>
            
            <a class="logo-title" href="/">
                Hao&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                LINKS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">LINKS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">微服务可用性设计</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">洪笳淏</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-12-29 15:00:00
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E5%BC%80%E5%8F%91/">开发</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h1><p>&emsp;&emsp;本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。</p>
<ul>
<li>服务隔离</li>
</ul>
<ol>
<li><p>动静隔离</p>
<p> 小到 CPU 的 cacheline <a class="link" target="_blank" rel="noopener" href="https://www.cnblogs.com/cyfonly/p/5800758.html">false sharing<i class="fas fa-external-link-alt"></i></a>、数据库 mysql 表设计中避免 bufferpool 频繁过期，隔离动静表，大到架构设计中的图片、静态资源等缓存加速。本质上都体现的一样的思路，即加速/缓存访问变换频次小的。<br> 案例一： CDN 场景中，将静态资源和动态 API 分离，也是体现了隔离的思路:<br><img lazyload src="/images/loading.svg" data-src="CDN.png" alt="avatar"></p>
<p> *. 降低了应用服务器的负载，静态文件访问负载全部通过CDN；<br> *. 对象存储费用最低；<br> *. 海量存储空间，无需考虑存储架构的升级；<br> *. 静态CDN带宽加速，延迟低。</p>
<p>案例二：用户创作稿件库<br> archive: 稿件表，存储稿件的名称、作者、分类、tag、状态等信息，表示稿件的基本信息。在一个投稿流程中，一旦稿件创建改动的频率比较低。<br> archive_stat: 稿件统计表，表示稿件的播放、点赞、收藏、投币数量，比较高频的更新。随着稿件获取流量，稿件被用户所消费，各类计数信息更新比较频繁。<br><img lazyload src="/images/loading.svg" data-src="archive.png" alt="avatar"><br> MySQL BufferPool 是用于缓存 DataPage 的，DataPage 可以理解为缓存了表的行，那么如果频繁更新 DataPage 不断会置换，会导致命中率下降的问题，所以我们在表设计中，仍然可以沿用类似的思路，其主表基本更新，在上游 Cache 未命中，透穿到 MySQL，仍然有 BufferPool 的缓存。</p>
</li>
<li><p>读写分离：主从、Replicaset、CQRS</p>
</li>
</ol>
<ul>
<li>轻重隔离</li>
</ul>
<ol>
<li><p>核心隔离</p>
<p> 业务按照 Level 进行资源池划分（L0/L1/L2）<br><img lazyload src="/images/loading.svg" data-src="level.png" alt="avatar"><br> 核心/非核心的故障域的差异性隔离（机器资源、依赖资源）<br> 多集群，通过冗余资源来提升吞吐和容灾能力。</p>
</li>
<li><p>快慢隔离<br>&emsp;&emsp;我们可以把服务的吞吐想象为一个池，当突然洪流进来时，池子需要一定时间才能排放完，这时候其他支流在池子里待的时间取决于前面的排放能力，耗时就会增高，对小请求产生影响。</p>
</li>
</ol>
<p>日志传输体系的架构设计中，整个流都会投放到一个 kafka topic 中（早期设计目的: 更好的顺序 IO），流内会区分不同的 logid，logid 会有不同的 sink 端，它们之前会出现差速，比如 HDFS 抖动吞吐下降，ES 正常水位，全局数据就会整体反压。<br><img lazyload src="/images/loading.svg" data-src="kafka.png" alt="avatar"><br>按照各种纬度隔离：sink、部门、业务、logid、重要性（S/A/B/C）。<br>业务日志也属于某个 logid，日志等级就可以作为隔离通道。</p>
<ol start="3">
<li>热点隔离(也是解决缓存击穿的策略)</li>
</ol>
<p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行缓存。比如：<br>小表广播（单起一个goroutine，采用copy-on-write的方式更新localcache）: 从 remotecache 提升为 localcache，app 定时更新，甚至可以让运营平台支持广播刷新 localcache。<a class="link" target="_blank" rel="noopener" href="https://pkg.go.dev/sync/atomic">atomic.Value<i class="fas fa-external-link-alt"></i></a><br><img lazyload src="/images/loading.svg" data-src="atomic.png" alt="avatar"><br>主动预热（旁路监控方式，类似地震前30秒的预警，提前一段时间将缓存中的热点数据变成localcache 存储）: 比如直播房间页高在线情况下 bypass 监控主动防御。<br><img lazyload src="/images/loading.svg" data-src="monitor.png" alt="avatar"></p>
<ul>
<li>物理隔离</li>
</ul>
<ol>
<li><p>线程隔离<br>&emsp;&emsp;主要通过线程池进行隔离，也是实现服务隔离的基础。把业务进行分类并交给不同的线程池进行处理，当某个线程池处理一种业务请求发生问题时，不会讲故障扩散和影响到其他线程池，保证服务可用。<br>对于 Go 来说，所有 IO 都是 Nonblocking，且托管给了 Runtime，只会阻塞 Goroutine，不阻塞 M，我们只需要考虑 Goroutine 总量的控制，不需要线程模型语言的线程隔离。<br><img lazyload src="/images/loading.svg" data-src="java.png" alt="avatar"></p>
</li>
<li><p>进程隔离<br>&emsp;&emsp;容器化（docker），容器编排引擎（k8s）。我们15年在 KVM 上部署服务；16年使用 Docker Swarm；17年迁移到 Kubernetes，到年底在线应用就全托管了，之后很快在线应用弹性公有云上线；20年离线 Yarn 和 在线 K8s 做了在离线混部（错峰使用），之后计划弹性公有云配合自建 IDC 做到离线的混合云架构。</p>
</li>
<li><p>集群隔离<br>&emsp;&emsp;过多集群方案，即逻辑上是一个应用，物理上部署多套应用，通过 cluster 区分。</p>
</li>
</ol>
<h2 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h2><ol>
<li>转码集群被超大视频攻击，导致转码大量延迟。</li>
</ol>
<p>&emsp;&emsp;针对大视频、较大视频、重要视频分别设置转码集群，当再遭遇转码攻击，只会影响部分的服务器，还能维持整体的可用。</p>
<ol start="2">
<li>缩略图服务，被大图实时缩略吃完所有 CPU，导致正常的小图缩略被丢弃，大量503。</li>
</ol>
<p>&emsp;&emsp;对于请求的图像，不会专门针对所有设备都预设好图片的尺寸，会根据用户的设备大小进行实时的缩略。如果请求了大量的 gif，那么对 gif的每一帧都要进行实时缩略，耗时比图像要久很多。把 gif 和正常图像分为两个集群来处理，将全剧故障化解为局部故障。</p>
<ol start="3">
<li><p> 数据库实例 cgroup 未隔离，导致大 SQL 引起的集体故障。</p>
</li>
<li><p> INFO 日志量过大，导致异常 ERROR 日志采集延迟。</p>
</li>
</ol>
<h1 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h1><p>&emsp;&emsp;超时控制，我们的组件能够快速失效（fail fast），因为我们不希望等到断开的实例直到超时。没有什么比挂起的请求和无响应的界面更令人失望。这不仅浪费资源，而且还会让用户体验变得更差。我们的服务是互相调用的，所以在这些延迟叠加前，应该特别注意防止那些超时的操作。<br><img lazyload src="/images/loading.svg" data-src="timeout.png" alt="avatar"></p>
<ul>
<li>网路传递具有不确定性。</li>
<li>客户端和服务端不一致的超时策略导致资源浪费。</li>
<li>默认值”策略。(不建议使用“永不超时”默认值)</li>
<li>高延迟服务导致 client 浪费资源等待，使用超时传递: 进程间传递 + 跨进程传递。</li>
</ul>
<p>&emsp;&emsp;超时控制是微服务可用性的第一道关，良好的超时策略，可以尽可能让服务不堆积请求，尽快清空高延迟的请求，释放 Goroutine。</p>
<h2 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h2><p>&emsp;&emsp;实际业务开发中，我们依赖的微服务的超时策略并不清楚，或者随着业务迭代耗时超生了变化，意外的导致依赖者出现了超时。<br>处理策略：</p>
<ul>
<li> 服务提供者定义好 latency SLO，更新到 gRPC Proto 定义中，服务后续迭代，都应保证 SLO。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> google.example.library.v1;</span><br><span class="line"></span><br><span class="line">service LibraryService &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Lagency SLO: 95th in 100ms, 99th in 150ms.</span></span><br><span class="line"></span><br><span class="line"> rpc CreateBook(CreateBookRequest) returns (Book);</span><br><span class="line"></span><br><span class="line"> rpc GetBook(GetBookRequest) returns Book);</span><br><span class="line"></span><br><span class="line"> rpc ListBooks(ListBooksRequest) returns (ListBooksResponse);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>避免出现意外的默认超时策略，或者意外的配置超时策略。</p>
<ul>
<li>kit 基础库兜底默认超时，比如 100ms，进行配置防御保护，避免出现类似 60s 之类的超大超时策略。</li>
<li>配置中心公共模版，对于未配置的服务使用公共配置。</li>
</ul>
<h3 id="超时传递"><a href="#超时传递" class="headerlink" title="超时传递"></a>超时传递</h3><p> &emsp;&emsp;超时传递: 当上游服务已经超时返回 504，但下游服务仍然在执行，会导致浪费资源做无用功。超时传递指的是把当前服务的剩余 Quota 传递到下游服务中，继承超时策略，控制请求级别的全局超时控制。<br> <img lazyload src="/images/loading.svg" data-src="timetransfer.png" alt="avatar"><br> 取配置的超时控制策略与剩余时间的最小值。</p>
<ul>
<li><p>进程内超时控制<br>&emsp;&emsp;一个请求在每个阶段(网络请求)开始前，就要检查是否还有足够的剩余来处理请求，以及继承他的超时策略，使用 Go 标准库的 <a class="link" target="_blank" rel="noopener" href="https://pkg.go.dev/context">context.WithTimeout<i class="fas fa-external-link-alt"></i></a>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *asiiConn)</span> <span class="title">Get</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="params">(result \*Item, err error)</span></span> &#123;</span><br><span class="line">	c.conn.SetWriteDeadline(shrinkDeadline(ctx, c.writeTimeout))</span><br><span class="line">	<span class="keyword">if</span> _, err = fmt.Fprintf(c.rw, <span class="string">&quot;gets %s\r\n&quot;</span>, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>多进程的超时控制<br><img lazyload src="/images/loading.svg" data-src="processcontrol.png" alt="avatar"></p>
</li>
</ul>
<ol>
<li>A gRPC 请求 B，1s超时。</li>
<li>B 使用了300ms 处理请求，再转发请求 C。</li>
<li>C 配置了600ms 超时，但是实际只用了500ms。</li>
<li>到其他的下游，发现余量不足，取消传递。</li>
</ol>
<p>在需要强制执行时，下游的服务可以覆盖上游的超时传递和配额。<br>在 gRPC 框架中，会依赖 gRPC Metadata Exchange，基于 HTTP2 的 Headers 传递 grpc-timeout 字段，自动传递到下游，构建带 timeout 的 context。</p>
<p><img lazyload src="/images/loading.svg" data-src="Bimodel.png" alt="avatar"></p>
<ul>
<li>双峰分布: 95%的请求耗时在100ms内，5%的请求可能永远不会完成（长超时）。</li>
<li>对于监控不要只看 mean，可以看看耗时分布统计，比如 95th，99th。</li>
<li>设置合理的超时，拒绝超长请求，或者当Server 不可用要主动失败。</li>
</ul>
<p><strong>超时决定着服务线程耗尽。</strong></p>
<h2 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h2><ul>
<li>SLB 入口 Nginx 没配置超时导致连锁故障。</li>
<li>服务依赖的 DB 连接池漏配超时，导致请求阻塞，最终服务集体 OOM。</li>
<li>下游服务发版耗时增加，而上游服务配置超时过短，导致上游请求失败。</li>
</ul>
<h1 id="过载保护和限流"><a href="#过载保护和限流" class="headerlink" title="过载保护和限流"></a>过载保护和限流</h1><h2 id="过载保护"><a href="#过载保护" class="headerlink" title="过载保护"></a>过载保护</h2><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>   一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：</p>
<ul>
<li>假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。</li>
<li>桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝。</li>
<li>当一个 n 个字节大小的数据包到达，将从桶中删除n 个令牌，接着数据包被发送到网络上。</li>
<li>如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="token-bucket.png" alt="avatar"><br>token-bucket rate limit algorithm: <a class="link" target="_blank" rel="noopener" href="https://pkg.go.dev/golang.org/x/time/rate">/x/time/rate<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>作为计量工具（The Leaky Bucket Algorithm as a Meter）时，可以用于流量整形（Traffic Shaping）和流量控制（TrafficPolicing），漏桶算法的描述如下：</p>
<ul>
<li> 一个固定容量的漏桶，按照常量固定速率流出水滴。</li>
<li>如果桶是空的，则不需流出水滴。</li>
<li>可以以任意速率流入水滴到漏桶。</li>
<li>如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。<br><img lazyload src="/images/loading.svg" data-src="leaky-bucket.png" alt="avatar"><br>leaky-bucket rate limit algorithm: <a class="link" target="_blank" rel="noopener" href="https://pkg.go.dev/go.uber.org/ratelimit">/go.uber.org/ratelimit<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h3 id="令牌桶和漏桶算法的弊端"><a href="#令牌桶和漏桶算法的弊端" class="headerlink" title="令牌桶和漏桶算法的弊端"></a>令牌桶和漏桶算法的弊端</h3><p>&emsp;&emsp;漏斗桶/令牌桶确实能够保护系统不被拖垮, 但不管漏斗桶还是令牌桶, 其防护思路都是设定一个指标, 当超过该指标后就阻止或减少流量的继续进入，当系统负载降低到某一水平后则恢复流量的进入。但其通常都是被动的，其实际效果取决于限流阈值设置是否合理，但往往设置合理不是一件容易的事情。</p>
<ul>
<li>集群增加机器或者减少机器限流阈值是否要重新设置?</li>
<li>设置限流阈值的依据是什么?</li>
<li>人力运维成本是否过高?</li>
<li>当调用方反馈429时, 这个时候重新设置限流, 其实流量高峰已经过了重新评估限流是否有意义?</li>
</ul>
<p>&emsp;&emsp;这些其实都是采用漏斗桶/令牌桶的缺点, 总体来说就是太被动, 不能快速适应流量变化。因此我们需要一种自适应的限流算法，即: 过载保护，根据系统当前的负载自动丢弃流量。</p>
<h3 id="根据系统负载做过载保护"><a href="#根据系统负载做过载保护" class="headerlink" title="根据系统负载做过载保护"></a>根据系统负载做过载保护</h3><p>&emsp;&emsp;计算系统临近过载时的峰值吞吐作为限流的阈值来进行流量控制，达到系统保护。</p>
<ul>
<li>服务器临近过载时，主动抛弃一定量的负载，目标是自保。</li>
<li>在系统稳定的前提下，保持系统的吞吐量。</li>
</ul>
<p>常见做法：利特尔法则<br><img lazyload src="/images/loading.svg" data-src="lierte.png" alt="avatar"></p>
<ul>
<li>CPU、内存作为信号量进行节流。</li>
<li>队列管理: 队列长度、LIFO。</li>
<li>可控延迟算法: <a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/72849893">Co<i class="fas fa-external-link-alt"></i></a><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/72849893">D<i class="fas fa-external-link-alt"></i></a><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/72849893">el<i class="fas fa-external-link-alt"></i></a>。</li>
</ul>
<p>如何计算接近峰值时的系统吞吐？</p>
<ul>
<li><p>CPU: 使用一个独立的线程采样，每隔 250ms 触发一次。在计算均值时，使用了简单滑动平均去除峰值的影响。<br><img lazyload src="/images/loading.svg" data-src="cpu.png" alt="avatar"></p>
</li>
<li><p>Inflight: 当前服务中正在进行的请求的数量。</p>
</li>
<li><p>Pass&amp;RT: 最近5s，pass 为每100ms采样窗口内成功请求的数量，rt 为单个采样窗口中平均响应时间。<br><img lazyload src="/images/loading.svg" data-src="slide.png" alt="avatar"></p>
</li>
<li><p>使用 CPU 的滑动均值（CPU &gt; 800）作为启发阈值，一旦触发进入到过载保护阶段，算法为：(pass* rt) &lt; inflight</p>
</li>
<li><p>限流效果生效后，CPU 会在临界值（800）附近抖动，如果不使用冷却时间，那么一个短时间的 CPU 下降就可能导致大量请求被放行，严重时会打满 CPU。</p>
</li>
<li><p>在冷却时间后，重新判断阈值（CPU &gt; 800 ），是否持续进入过载保护。</p>
</li>
</ul>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>&amp;emsp&emsp;在一段时间内，定义某个客户或应用可以接收或处理多少个请求的技术。例如，通过限流，你可以过滤掉产生流量峰值的客户和微服务，或者可以确保你的应用程序在自动扩展（Auto Scaling）失效前都不会出现过载的情况。</p>
<ul>
<li>令牌桶、漏桶 针对单个节点，无法分布式限流。</li>
<li>QPS 限流<ul>
<li>不同的请求可能需要数量迥异的资源来处理。</li>
<li>某种静态 QPS 限流不是特别准。</li>
</ul>
</li>
<li>给每个用户设置限制<ul>
<li>全局过载发生时候，针对某些“异常”进行控制。</li>
<li>一定程度的“超卖”配额。</li>
</ul>
</li>
<li>按照优先级丢弃。</li>
<li>拒绝请求也需要成本。<br><img lazyload src="/images/loading.svg" data-src="rateLimitEnabled.png" alt="avatar"></li>
</ul>
<h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p>&emsp;&emsp; 分布式限流，是为了控制某个应用全局的流量，而非真对单个节点纬度。</p>
<ul>
<li>单个大流量的接口，使用 redis 容易产生热点。</li>
<li>pre-request 模式对性能有一定影响，高频的网络往返。  </li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="distributed.png" alt="avatar"></p>
<p>思考：<br>&emsp;&emsp;从获取单个 quota 升级成批量 quota。quota: 表示速率，获取后使用令牌桶算法来限制。</p>
<ul>
<li>每次心跳后，异步批量获取 quota，可以大大减少请求 redis 的频次，获取完以后本地消费，基于令牌桶拦截</li>
<li>每次申请的配额需要手动设定静态值略欠灵活，比如每次要20，还是50</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="redis.png" alt="avatar"></p>
<p>如何基于单个节点按需申请，并且避免出现不公平的现象？<br>初次使用默认值，一旦有过去历史窗口的数据，可以基于历史窗口数据进行 quota 请求。</p>
<p>思考：<br>我们经常面临给一组用户划分稀有资源的问题，他们都享有等价的权利来获取资源，但是其中一些用户实际上只需要比其他用户少的资源。那么我们如何来分配资源呢？一种在实际中广泛使用的分享技术称作“最大最小公平分享”（Max-Min Fairness）。<br><img lazyload src="/images/loading.svg" data-src="max-min.png" alt="avatar"></p>
<p>直观上，公平分享分配给每个用户想要的可以满足的最小需求，然后将没有使用的资源均匀的分配给需要‘大资源’的用户。</p>
<p>最大最小公平分配算法的形式化定义如下：<br>•资源按照需求递增的顺序进行分配。<br>•不存在用户得到的资源超过自己的需求。<br>•未得到满足的用户等价的分享资源。</p>
<p><img lazyload src="/images/loading.svg" data-src="compare.png" alt="avatar"></p>
<h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>&emsp;&emsp;每个接口配置阈值，运营工作繁重，最简单的我们配置服务级别 quota，更细粒度的，我们可以根据不同重要性设定 quota，我们引入了重要性（criticality）:</p>
<p>•最重要 CRITICAL_PLUS，为最终的要求预留的类型，拒绝这些请求会造成非常严重的用户可见的问题。<br>•重要 CRITICAL，生产任务发出的默认请求类型。拒绝这些请求也会造成用户可见的问题。但是可能没那么严重。<br>•可丢弃的 SHEDDABLE_PLUS 这些流量可以容忍某种程度的不可用性。这是批量任务发出的请求的默认值。这些请求通常可以过几分钟、几小时后重试。<br>•可丢弃的 SHEDDABLE 这些流量可能会经常遇到部分不可用情况，偶尔会完全不可用。</p>
<p>&emsp;&emsp;gRPC 系统之间，需要自动传递重要性信息。如果后端接受到请求 A，在处理过程中发出了请求 B 和 C 给其他后端，请求 B 和 C 会使用与 A 相同的重要性属性。</p>
<p>•全局配额不足时，优先拒绝低优先级的。<br>•全局配额，可以按照重要性分别设置。<br>•过载保护时，低优先级的请求先被拒绝。</p>
<h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>&emsp;&emsp;断路器（Circuit Breakers）: 为了限制操作的持续时间，我们可以使用超时，超时可以防止挂起操作并保证系统可以响应。因为我们处于高度动态的环境中，几乎不可能确定在每种情况下都能正常工作的准确的时间限制。断路器以现实世界的电子元件命名，因为它们的行为是都是相同的。断路器在分布式系统中非常有用，因为重复的故障可能会导致雪球效应，并使整个系统崩溃。</p>
<ul>
<li>服务依赖的资源出现大量错误。</li>
<li>某个用户超过资源配额时，后端任务会快速拒绝请求，返回“配额不足”的错误，但是拒绝回复仍然会消耗一定资源。有可能后端忙着不停发送拒绝请求，导致过载。<br><img lazyload src="/images/loading.svg" data-src="rongduan.png" alt="avatar"></li>
</ul>
<p>Google SRE<br>max(0, (requests - K*accepts) / (requests + 1))<br><img lazyload src="/images/loading.svg" data-src="google.png" alt="avatar"><br><img lazyload src="/images/loading.svg" data-src="google1.png" alt="avatar"></p>
<h3 id="Gutter"><a href="#Gutter" class="headerlink" title="Gutter"></a>Gutter</h3><p>&emsp;&emsp;基于熔断的 gutter kafka ，用于接管自动修复系统运行过程中的负载，这样只需要付出10%的资源就能解决部分系统可用性问题。我们经常使用 failover 的思路，但是完整的 failover 需要翻倍的机器资源，平常不接受流量时，资源浪费。高负载情况下接管流量又不一定完整能接住。所以这里核心利用熔断的思路，是把抛弃的流量转移到 gutter 集群，如果 gutter 也接受不住的流量，重新回抛到主集群，最大力度来接受。<br><img lazyload src="/images/loading.svg" data-src="gutter.png" alt="avatar"></p>
<h3 id="客户端流控"><a href="#客户端流控" class="headerlink" title="客户端流控"></a>客户端流控</h3><p>positive feedback: 用户总是积极重试，访问一个不可达的服务。<br>•客户端需要限制请求频次，retry backoff 做一定的请求退让。<br><img lazyload src="/images/loading.svg" data-src="backoff.png" alt="avatar"><br>•可以通过接口级别的 error_details，挂载到每个 API 返回的响应里。<br><img lazyload src="/images/loading.svg" data-src="error.png" alt="avatar"></p>
<h3 id="Case-1"><a href="#Case-1" class="headerlink" title="Case"></a>Case</h3><ol>
<li>二层缓存穿透、大量回源导致的核心服务（例如Mysql）故障。</li>
</ol>
<p>通过限流策略，控制到达Mysql的请求速率，让Mysql的缓存逐步建立，避免被海量的请求直接打死。</p>
<ol start="2">
<li>异常客户端引起的服务故障（query of death）</li>
</ol>
<ul>
<li>请求放大。</li>
<li>资源数放大</li>
</ul>
<p>针对相应的用户做专门的限制，比如最多只放行 k 个请求。</p>
<ol start="3">
<li>用户重试导致的大面积故障。</li>
</ol>
<p>在客户端限制用户的请求频次。</p>
<h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><p>&emsp;&emsp;通过降级回复来减少工作量，或者丢弃不重要的请求。而且需要了解哪些流量可以降级，并且有能力区分不同的请求。我们通常提供降低回复的质量来答复减少所需的计算量或者时间。我们自动降级通常需要考虑几个点：<br>•确定具体采用哪个指标作为流量评估和优雅降级的决定性指标（如，CPU、延迟、队列长度、线程数量、错误等）。<br>•当服务进入降级模式时，需要执行什么动作？<br>•流量抛弃或者优雅降级应该在服务的哪一层实现？是否需要在整个服务的每一层都实现，还是可以选择某个高层面的关键节点来实现？</p>
<p>同时我们要考虑一下几点：<br>•优雅降级不应该被经常触发 - 通常触发条件现实了容量规划的失误，或者是意外的负载。<br>•演练，代码平时不会触发和使用，需要定期针对一小部分的流量进行演练，保证模式的正常。<br>•应该足够简单。</p>
<h2 id="降级本质为-提供有损服务。"><a href="#降级本质为-提供有损服务。" class="headerlink" title="降级本质为: 提供有损服务。"></a>降级本质为: 提供有损服务。</h2><ol>
<li><p>UI 模块化，非核心模块降级。</p>
<ul>
<li>BFF 层聚合 API，模块降级。<br><img lazyload src="/images/loading.svg" data-src="bilibili.png" alt="avatar"></li>
</ul>
</li>
<li><p>页面上一次缓存副本。</p>
</li>
<li><p>默认值、热门推荐等。</p>
</li>
<li><p>流量拦截 + 定期数据缓存(过期副本策略)。</p>
</li>
</ol>
<p>处理策略<br>•页面降级、延迟服务、写/读降级、缓存降级<br>•抛异常、返回约定协议、Mock 数据、Fallback 处理<br><img lazyload src="/images/loading.svg" data-src="fallback.png" alt="avatar"></p>
<h2 id="Case-2"><a href="#Case-2" class="headerlink" title="Case"></a>Case</h2><ol>
<li>客户端解析协议失败，app 奔溃。</li>
</ol>
<p>要返回的默认降级数据（空数组、nil）一定要和客户端的开发人员进行沟通，否则会导致客户端解析失败而闪退。</p>
<ol start="2">
<li>客户端部分协议不兼容，导致页面失败。</li>
<li> local cache 数据源缓存，发版失效 + 依赖接口故障，引起的白屏。</li>
</ol>
<p>解决方案：在远程remote cache 中再保存一份。</p>
<h1 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h1><p>&emsp;&emsp;当请求返回错误（例: 配额不足、超时、内部错误等），对于 backend 部分节点过载的情况下，倾向于立刻重试，但是需要留意重试带来的流量放大:</p>
<p>•限制重试次数和基于重试分布的策略（重试比率: 10%）。<br>•随机化、指数型递增的重试周期: exponential ackoff + jitter。<br>•client 测记录重试次数直方图，传递到 server，进行分布判定，交由 server 判定拒绝。<br>•只应该在失败的这层进行重试，当重试仍然失败，全局约定错误码“过载，无须重试”，避免级联重试。</p>
<h2 id="Case-3"><a href="#Case-3" class="headerlink" title="Case"></a>Case</h2><ol>
<li>Nginx upstream retry 过大，导致服务雪崩。</li>
</ol>
<ol start="2">
<li><p>业务不幂等，导致的重试，数据重复。<br>•全局唯一 ID: 根据业务生成一个全局唯一 ID，在调用接口时会传入该 ID，接口提供方会从相应的存储系统比如 redis 中去检索这个全局 ID 是否存在，如果存在则说明该操作已经执行过了，将拒绝本次服务请求；否则将相应该服务请求并将全局 ID 存入存储系统中,之后包含相同业务 ID 参数的请求将被拒绝。<br>•去重表: 这种方法适用于在业务中有唯一标识的插入场景。比如在支付场景中，一个订单只会支付一次，可以建立一张去重表,将订单 ID 作为唯一索引。把支付并且写入支付单据到去重表放入一个事务中了，这样当出现重复支付时，数据库就会抛出唯一约束异常,操作就会回滚。这样保证了订单只会被支付一次。<br>•多版本并发控制: 适合对更新请求作幂等性控制,比如要更新商品的名字，这是就可以在更新的接口中增加一个版本号来做幂等性控制。</p>
</li>
<li><p>多层级重试传递，放大流量引起雪崩。</p>
</li>
</ol>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="数据中心内部的负载均衡"><a href="#数据中心内部的负载均衡" class="headerlink" title="数据中心内部的负载均衡"></a>数据中心内部的负载均衡</h2><p>&emsp;&emsp;在理想情况下，某个服务的负载会完全均匀地分发给所有的后端任务。在任何时刻，最忙和最不忙的节点永远消耗同样数量的CPU。<br>目标：<br>•均衡的流量分发。<br>•可靠的识别异常节点。<br>•scale-out，增加同质节点扩容。<br>•减少错误，提高可用性。<br><img lazyload src="/images/loading.svg" data-src="SLB.png" alt="avatar"></p>
<p>   在 backend 之间的 load 差异比较大：</p>
<ul>
<li>每个请求的处理成本不同。</li>
<li>物理机环境的差异:<ul>
<li>服务器很难强同质性。</li>
<li>存在共享资源争用（内存缓存、带宽、IO等）。</li>
</ul>
</li>
<li>性能因素:<ul>
<li>FullGC。</li>
<li>JVM JIT。<br><img lazyload src="/images/loading.svg" data-src="load.png" alt="avatar"></li>
</ul>
</li>
</ul>
<p>参考JSQ（最闲轮训）负载均衡算法带来的问题，缺乏的是服务端全局视图，因此我们目标需要综合考虑：负载+可用性。<br><img lazyload src="/images/loading.svg" data-src="LB.png" alt="avatar"></p>
<p><img lazyload src="/images/loading.svg" data-src="S.png" alt="avatar"></p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ul>
<li>变更管理:<ul>
<li>70％的问题是由变更引起的，恢复可用代码并不总是坏事。</li>
</ul>
</li>
<li>避免过载:<ul>
<li>过载保护、流量调度等。</li>
</ul>
</li>
<li>依赖管理:<ul>
<li>任何依赖都可能故障，做 chaos monkey testing，注入故障测试。</li>
</ul>
</li>
<li>优雅降级:<ul>
<li>有损服务，避免核心链路依赖故障。</li>
</ul>
</li>
<li>重试退避:<ul>
<li>退让算法，冻结时间，API retry detail 控制策略。</li>
</ul>
</li>
<li>超时控制:<ul>
<li>进程内 + 服务间 超时控制。</li>
</ul>
</li>
<li>极限压测 + 故障演练。</li>
<li>扩容 + 重启 + 消除有害流量。</li>
</ul>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：微服务可用性设计</li>
        <li>Post author：洪笳淏</li>
        <li>Create time：2021-12-29 15:00:00</li>
        <li>
            Post link：https://jiahaohong1997.github.io/2021/12/29/微服务可用性设计/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/01/05/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Redis学习笔记（二）</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/12/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item"></span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div id="gitalk-container"></div>
    <script data-pjax
            src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
    <script data-pjax>

        function loadGitalk() {
            let __gitalk__pathname = decodeURI(location.pathname);
            const __gitalk__pathnameLength = __gitalk__pathname.length;
            const __gitalk__pathnameMaxLength = 50;
            if (__gitalk__pathnameLength > __gitalk__pathnameMaxLength) {
                __gitalk__pathname = __gitalk__pathname.substring(0, __gitalk__pathnameMaxLength - 3) + '...';
            }

            try {
                Gitalk && new Gitalk({
                    clientID: '9f01169dad8b4c5b8cf4',
                    clientSecret: 'fed95d2960e49d8d37cdf0f41fcc912044c5132d',
                    repo: 'comment',
                    owner: 'JiahaoHong1997',
                    admin: ['JiahaoHong1997'],
                    id: __gitalk__pathname,
                    language: 'en'
                }).render('gitalk-container');

            } catch (e) {
                window.Gitalk = null;
            }
        }

        if ('true') {
            const loadGitalkTimeout = setTimeout(() => {
                loadGitalk();
                clearTimeout(loadGitalkTimeout);
            }, 1000);
        } else {
            window.addEventListener('DOMContentLoaded', loadGitalk);
        }
    </script>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>&nbsp;-&nbsp;
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">洪笳淏</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB"><span class="nav-number">1.</span> <span class="nav-text">隔离</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Case"><span class="nav-number">1.1.</span> <span class="nav-text">Case</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B6%85%E6%97%B6"><span class="nav-number">2.</span> <span class="nav-text">超时</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6"><span class="nav-number">2.1.</span> <span class="nav-text">超时控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E4%BC%A0%E9%80%92"><span class="nav-number">2.1.1.</span> <span class="nav-text">超时传递</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Case-Study"><span class="nav-number">2.2.</span> <span class="nav-text">Case Study</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4%E5%92%8C%E9%99%90%E6%B5%81"><span class="nav-number">3.</span> <span class="nav-text">过载保护和限流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4"><span class="nav-number">3.1.</span> <span class="nav-text">过载保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">令牌桶算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.2.</span> <span class="nav-text">漏桶算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A4%E7%89%8C%E6%A1%B6%E5%92%8C%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="nav-number">3.1.3.</span> <span class="nav-text">令牌桶和漏桶算法的弊端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E5%81%9A%E8%BF%87%E8%BD%BD%E4%BF%9D%E6%8A%A4"><span class="nav-number">3.1.4.</span> <span class="nav-text">根据系统负载做过载保护</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E6%B5%81"><span class="nav-number">3.2.</span> <span class="nav-text">限流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81"><span class="nav-number">3.2.1.</span> <span class="nav-text">分布式限流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-number">3.2.2.</span> <span class="nav-text">重要性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%86%94%E6%96%AD"><span class="nav-number">3.2.3.</span> <span class="nav-text">熔断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gutter"><span class="nav-number">3.2.4.</span> <span class="nav-text">Gutter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E6%8E%A7"><span class="nav-number">3.2.5.</span> <span class="nav-text">客户端流控</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Case-1"><span class="nav-number">3.2.6.</span> <span class="nav-text">Case</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%8D%E7%BA%A7"><span class="nav-number">4.</span> <span class="nav-text">降级</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%8D%E7%BA%A7%E6%9C%AC%E8%B4%A8%E4%B8%BA-%E6%8F%90%E4%BE%9B%E6%9C%89%E6%8D%9F%E6%9C%8D%E5%8A%A1%E3%80%82"><span class="nav-number">4.1.</span> <span class="nav-text">降级本质为: 提供有损服务。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Case-2"><span class="nav-number">4.2.</span> <span class="nav-text">Case</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%AF%95"><span class="nav-number">5.</span> <span class="nav-text">重试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Case-3"><span class="nav-number">5.1.</span> <span class="nav-text">Case</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">6.</span> <span class="nav-text">负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E5%86%85%E9%83%A8%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">6.1.</span> <span class="nav-text">数据中心内部的负载均衡</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">7.</span> <span class="nav-text">最佳实践</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
