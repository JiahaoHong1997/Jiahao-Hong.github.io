<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洪笳淏的个人博客</title>
  
  
  <link href="http://jiahaohong1997.github.io/atom.xml" rel="self"/>
  
  <link href="http://jiahaohong1997.github.io/"/>
  <updated>2021-04-10T16:38:00.831Z</updated>
  <id>http://jiahaohong1997.github.io/</id>
  
  <author>
    <name>洪笳淏</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BFS算法框架</title>
    <link href="http://jiahaohong1997.github.io/2021/04/08/BFS%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/"/>
    <id>http://jiahaohong1997.github.io/2021/04/08/BFS%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/</id>
    <published>2021-04-08T15:25:24.000Z</published>
    <updated>2021-04-10T16:38:00.831Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本系列文章是我在阅读<a class="link"   href="https://labuladong.gitbook.io/algo/" >《labuladong的算法小抄》<i class="fas fa-external-link-alt"></i></a>一书，再结合自己在Leetcode上刷题后的一些体会和总结。读者若需要了解更多的细节，还请阅读此书并结合实际多刷刷题。</p><h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><h3 id="BFS的应用场景"><a href="#BFS的应用场景" class="headerlink" title="BFS的应用场景"></a>BFS的应用场景</h3><p>&emsp;&emsp;此类问题的本质就是在一幅「图」(树是特殊的图)中找到起始点(start)到终点(target)的最近距离。实际上，此类问题利用DFS也能做到，但是DFS实质上就是回溯算法，时间复杂度很高。BFS的时间代价是O(N)，其代价就是空间复杂度很高。在二叉树中，BFS对应的就是二叉树的层序遍历。</p><p>&emsp;&emsp;这类问题可以有各种各样的变体，比如：1.走迷宫，迷宫中有的格子是围墙，不能通过，要求从起点到终点的最短距离是多少？2.两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？3.连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？这些问题都没啥奇技淫巧，本质上就是一幅「图」，让你从一个起点，走到终点，问最短路径。这就是 BFS 的本质，框架搞清楚了直接默写就好。</p><h3 id="算法思路-Golang"><a href="#算法思路-Golang" class="headerlink" title="算法思路(Golang)"></a>算法思路(Golang)</h3><p>&emsp;&emsp;所有的BFS问题的核心数据结构：队列q用于存储节点。用node指向当前要出队的节点，当该节点出队时，其相邻节点入队。对于非二叉树这种结构(没有子节点到父节点的指针，不会走回头路)的数据形式，还需要一个建立一个map类型来保存已经走过的节点，防止走回头路。</p><p>&emsp;&emsp;BFS最常见于二叉树中，先给一个二叉树的BFS(层序遍历)框架。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">二叉树：[3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层序遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFS</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ret := [][]<span class="keyword">int</span>&#123;&#125;  <span class="comment">// 因为该示例要按每层返回遍历结果，所以要初始化一个二维切片</span></span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  <span class="comment">// 如果根节点为空，返回空切片</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  q := []*TreeNode&#123;root&#125;  <span class="comment">// 初始化队列用于存储节点</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; <span class="built_in">len</span>(q)&gt;<span class="number">0</span>; i++ &#123;  <span class="comment">// 当队列不为空，说明还有节点没有遍历完，继续循环</span></span><br><span class="line">    ret = <span class="built_in">append</span>(ret, []<span class="keyword">int</span>&#123;&#125;)  <span class="comment">// 初始化用于存储树的每一层的切片</span></span><br><span class="line">    p := []*TreeNode&#123;&#125;  <span class="comment">// 切片p用于记录树的每一层节点</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(q); j++ &#123;</span><br><span class="line">      node := q[j]  <span class="comment">// 某一层的节点顺序出队</span></span><br><span class="line">      ret[i] = <span class="built_in">append</span>(ret[i], node.Val) <span class="comment">// 存入当前节点</span></span><br><span class="line">      <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123; <span class="comment">// 如果左节点不为空，左节点入队</span></span><br><span class="line">        p = <span class="built_in">append</span>(p, node.Left) </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123; <span class="comment">// 如果右节点不为空，右节点入队</span></span><br><span class="line">        p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    q = p; <span class="comment">// 更新队列q，保存下一层的节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果不要求用二维数组分别保存每一层的节点，可以不需要切片p，直接在每个节点出队时将其左右节点送入队列p即可。</p><p>&emsp;&emsp;通用框架，主要区别在于多了一个map类型用来记录已经遍历过的节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define num is the number of node</span></span><br><span class="line"><span class="comment"> * Define the Type of node if NodeType</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFS</span><span class="params">(start NodeType, target NodeType)</span></span> &#123;</span><br><span class="line">  q := []NodeType&#123;start&#125; <span class="comment">// 起始节点入队</span></span><br><span class="line">  m := <span class="built_in">make</span>(<span class="keyword">map</span>[NodeType]<span class="keyword">int</span>, num) <span class="comment">// 避免走回头路</span></span><br><span class="line">  m[start] = <span class="number">1</span> <span class="comment">// 记录起始节点</span></span><br><span class="line">  step := <span class="number">0</span>  <span class="comment">// 记录扩散的步数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(q)</span><br><span class="line">    p := []NodeType&#123;&#125;</span><br><span class="line">    <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">      node := q[i]</span><br><span class="line">      <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">      <span class="keyword">if</span> node = target &#123;</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 将 node 的相邻节点加入队列 */</span></span><br><span class="line">      <span class="keyword">for</span> Node x : node.adj() &#123; <span class="comment">// 判断node是否有相邻节点，根据数据形式自行更改</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := m[x]; !ok &#123; <span class="comment">// 如果节点没有被记录过，则可以入队</span></span><br><span class="line">          p = <span class="built_in">append</span>(p, x)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">    step++</span><br><span class="line">    q = p <span class="comment">// 该层所有节点遍历介绍，q保存下一层节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际案例-二叉树"><a href="#实际案例-二叉树" class="headerlink" title="实际案例(二叉树)"></a>实际案例(二叉树)</h2><p>我们来看几道Leetcode上的题目。</p><h3 id="1-103-二叉树的锯齿形层序遍历"><a href="#1-103-二叉树的锯齿形层序遍历" class="headerlink" title="1.103. 二叉树的锯齿形层序遍历"></a>1.<a class="link"   href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" >103. 二叉树的锯齿形层序遍历<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p><pre><code>        3   / \  9  20    /  \   15   7</code></pre><p>返回锯齿形层序遍历如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>​        怎么套到 BFS 的框架里呢？首先明确一下起点 start 和终点 target 是什么，怎么判断到达了终点？</p><p><strong>显然起点就是</strong> <strong>root</strong> <strong>根节点，终点就是最后一个叶子节点。</strong>不过在存储的过程中要注意，奇数行要倒序排列，偶数行正序排列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    ret := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; <span class="built_in">len</span>(q)&gt;<span class="number">0</span>; i++ &#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">        p := []*TreeNode&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(q) ; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span> &#123; <span class="comment">// 如果是偶数行，则正序排列</span></span><br><span class="line">                node := q[j]</span><br><span class="line">                ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是奇数行，则倒叙排列</span></span><br><span class="line">                node := q[<span class="built_in">len</span>(q)<span class="number">-1</span>-j]</span><br><span class="line">                ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line">            &#125;</span><br><span class="line">            nodeInP := q[j]</span><br><span class="line">            <span class="keyword">if</span> nodeInP.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, nodeInP.Left)</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> nodeInP.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, nodeInP.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-111-二叉树的最小深度"><a href="#2-111-二叉树的最小深度" class="headerlink" title="2.111. 二叉树的最小深度"></a>2.<a class="link"   href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" >111. 二叉树的最小深度<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg"                      alt="avatar"                ></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [2,null,3,null,4,null,5,null,6]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 <code>[0, 105]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p><strong>显然起点就是</strong> <strong><code>root</code></strong> <strong>根节点，终点就是最靠近根节点的那个「叶子节点」</strong>，叶子节点就是两个子节点都是 <code>nil</code> 的节点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    step := <span class="number">1</span>  <span class="comment">// 记录层数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        p := []*TreeNode&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">            node := q[i]</span><br><span class="line">            <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123; <span class="comment">// 当遇到第一个子节点，就返回该节点所在层数</span></span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际案例-其他数据结构方式"><a href="#实际案例-其他数据结构方式" class="headerlink" title="实际案例(其他数据结构方式)"></a>实际案例(其他数据结构方式)</h2><h3 id="1-200-岛屿数量"><a href="#1-200-岛屿数量" class="headerlink" title="1.200. 岛屿数量"></a>1.<a class="link"   href="https://leetcode-cn.com/problems/number-of-islands/" >200. 岛屿数量<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m &#x3D;&#x3D; grid.length</span><br><span class="line">n &#x3D;&#x3D; grid[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 300</span><br><span class="line">grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39;</span><br></pre></td></tr></table></figure><p>算法思路：</p><p>&emsp;&emsp;遍历整个二维网格，当节点值为1时，以这个节点为起始进行广度优先搜索，当其相邻节点值为1时，进入队列，并将这些入队的节点值置为0。当不再有节点入队，说明已经达到了岛屿的边界，返回原始的循环。同时可以初始化一个map用于记录已经遍历过的节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>  <span class="comment">// 初始化map类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">len</span>(grid) <span class="comment">// 行数</span></span><br><span class="line">    c := <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="comment">// 列数</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, r*c) <span class="comment">// 用于记录已经遍历过的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;r; i++ &#123; <span class="comment">// 遍历整个二维网格</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;c; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;0&#x27;</span> || m[i*c+j] == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当节点值为&#x27;1&#x27;时以该节点为起始进行广度优先搜索</span></span><br><span class="line">                count++                </span><br><span class="line">                BFS(grid, i, j)</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span> <span class="comment">// 将当前遍历节点置&#x27;0&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFS</span><span class="params">(grid [][]<span class="keyword">byte</span>, i <span class="keyword">int</span>, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">len</span>(grid)</span><br><span class="line">    c := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    q := []<span class="keyword">int</span>&#123;i*c+j&#125; <span class="comment">// 队列中保存的是节点编号，以行优先的方式对所有节点编号</span></span><br><span class="line">    m[i*c+j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        p := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k:=<span class="number">0</span>; k&lt;<span class="built_in">len</span>(q); k++ &#123;</span><br><span class="line">            node := q[k]</span><br><span class="line">            nodeR := node/c <span class="comment">// 当前节点的行号</span></span><br><span class="line">            nodeC := node%c <span class="comment">// 当前节点的列号</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nodeR&gt;<span class="number">0</span> &amp;&amp; grid[nodeR<span class="number">-1</span>][nodeC] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的上方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[(nodeR<span class="number">-1</span>)*c+nodeC]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, (nodeR<span class="number">-1</span>)*c+nodeC)</span><br><span class="line">                    grid[nodeR<span class="number">-1</span>][nodeC] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[(nodeR<span class="number">-1</span>)*c+nodeC] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nodeR&lt;r<span class="number">-1</span> &amp;&amp; grid[nodeR+<span class="number">1</span>][nodeC] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的下方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[(nodeR+<span class="number">1</span>)*c+nodeC]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, (nodeR+<span class="number">1</span>)*c+nodeC)</span><br><span class="line">                    grid[nodeR+<span class="number">1</span>][nodeC] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[(nodeR+<span class="number">1</span>)*c+nodeC] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nodeC&gt;<span class="number">0</span> &amp;&amp; grid[nodeR][nodeC<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的左方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[nodeR*c+(nodeC<span class="number">-1</span>)]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, nodeR*c+(nodeC<span class="number">-1</span>))</span><br><span class="line">                    grid[nodeR][nodeC<span class="number">-1</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[nodeR*c+(nodeC<span class="number">-1</span>)] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nodeC&lt;c<span class="number">-1</span> &amp;&amp; grid[nodeR][nodeC+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的右方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[nodeR*c+(nodeC+<span class="number">1</span>)]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, nodeR*c+(nodeC+<span class="number">1</span>))</span><br><span class="line">                    grid[nodeR][nodeC+<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[nodeR*c+(nodeC+<span class="number">1</span>)] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p <span class="comment">// 进入下一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-207-课程表"><a href="#2-207-课程表" class="headerlink" title="2.207. 课程表"></a>2.<a class="link"   href="https://leetcode-cn.com/problems/course-schedule/" >207. 课程表<i class="fas fa-external-link-alt"></i></a></h3><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p><p>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p><p><strong>示例 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;&#x3D; numCourses &lt;&#x3D; 105</span><br><span class="line">0 &lt;&#x3D; prerequisites.length &lt;&#x3D; 5000</span><br><span class="line">prerequisites[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; ai, bi &lt; numCourses</span><br><span class="line">prerequisites[i] 中的所有课程对 互不相同</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;算法思路：我们使用一个队列来进行广度优先搜索。初始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。并初始化一个长度为numCourses的切片precourse，用于记录每个节点(课程)的入度。在广度优先搜索的每一步中，我们取出队首的节点 ，将该节点的相邻边(也就是将本课程作为预修课程的其他课程)减1(precource对应索引的值减1)。当节点入度为0时，将其作为下一层节点加入队列中。最后遍历precourse切片，若切片中所有元素为0，说明找到了一种拓扑排序，返回true，否则返回false。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    precourse := <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(prerequisites); i++ &#123; <span class="comment">// 初始化所有节点的入度(记录所有课程的预修课程数)</span></span><br><span class="line">        precourse[prerequisites[i][<span class="number">0</span>]]++</span><br><span class="line">    &#125;</span><br><span class="line">    q := []<span class="keyword">int</span>&#123;&#125; <span class="comment">// 初始化队列用于存储入度为0的节点(不需要预修课程的课)</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> precourse[i] == <span class="number">0</span> &#123; <span class="comment">// 将入度为0的节点入队</span></span><br><span class="line">            q = <span class="built_in">append</span>(q, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        p := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">            node := q[i]</span><br><span class="line">            <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(prerequisites); j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> prerequisites[j][<span class="number">1</span>] == node &#123; <span class="comment">// 查看所有以当前课程为预修课程的课</span></span><br><span class="line">                    precourse[prerequisites[j][<span class="number">0</span>]]-- <span class="comment">// 入度减1</span></span><br><span class="line">                    <span class="keyword">if</span> precourse[prerequisites[j][<span class="number">0</span>]] == <span class="number">0</span> &#123; <span class="comment">// 当入度为0，入队</span></span><br><span class="line">                        p = <span class="built_in">append</span>(p, prerequisites[j][<span class="number">0</span>])</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123; <span class="comment">// 查看是否所有节点入度为0</span></span><br><span class="line">        <span class="keyword">if</span> precourse[i] != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-279-完全平方数"><a href="#3-279-完全平方数" class="headerlink" title="3.279. 完全平方数"></a>3.<a class="link"   href="https://leetcode-cn.com/problems/perfect-squares/" >279. 完全平方数<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 &#x3D; 4 + 4 + 4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 &#x3D; 4 + 9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 104</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;算法思路：本题可以采用贪心+BFS的策略，实际上是从上到下逐层构造 N 元树。我们以 BFS（广度优先搜索）的方式遍历它。在 N 元树的每一级，我们都在枚举相同大小的组合。其中每个节点表示数字 n 的余数减去一个完全平方数的组合，我们的任务是在树中找到一个节点，该节点满足两个条件：</p><p>(1) 节点的值（即余数）也是一个完全平方数。<br>(2) 在满足条件（1）的所有节点中，节点和根之间的距离应该最小。</p><p>下面是这棵树的样子：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjc5LzI3OV9ncmVlZHlfdHJlZS5wbmc?x-oss-process=image/format,png"                      alt="avatar"                ></p><ul><li>首先，我们准备小于给定数字 n 的完全平方数列表（即 powlist）。</li><li>然后创建 q队列 遍历，该变量将保存所有剩余项在每个级别的枚举。在主循环中，我们迭代 q 变量。在每次迭代中，我们检查余数是否是一个完全平方数。如果余数不是一个完全平方数，就用其中一个完全平方数减去它，得到一个新余数，然后将新余数添加到 p 中，以进行下一级的迭代。一旦遇到一个完全平方数的余数，我们就会跳出循环，这也意味着我们找到了解。</li><li>注意：这里我们使用 set ，以消除同一级别中的剩余项的冗余。</li></ul><p>&emsp;&emsp;如果看文字难以理解，最好以n=12为例，画一画整个树的层级结构，能有更深的理解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSquares</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    powlist := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i*i&lt;=n; i++ &#123; <span class="comment">// 完全平方数表</span></span><br><span class="line">        powlist = <span class="built_in">append</span>(powlist, i*i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">10000</span>) <span class="comment">// 用于记录冗余项，只需要在每层中第一次出现时保存，就能保证层数最少</span></span><br><span class="line">    level := <span class="number">0</span> <span class="comment">// 记录层级</span></span><br><span class="line">    q := []<span class="keyword">int</span>&#123;n&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        level++</span><br><span class="line">        p := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">            node := q[i] <span class="comment">// 当前节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _,value := <span class="keyword">range</span> powlist &#123; <span class="comment">// 贪心算法，构造树</span></span><br><span class="line">                <span class="keyword">if</span> value == node &#123; <span class="comment">// 第一次出现完全平方数，说明在这一层级就能解决问题，直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> level</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; node &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> set[node-value] == <span class="literal">false</span> &#123; <span class="comment">// 相当于剪枝操作</span></span><br><span class="line">                        p = <span class="built_in">append</span>(p, node-value) <span class="comment">// 记录下一层级的节点</span></span><br><span class="line">                        set[node-value] = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a class="link"   href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/bfs-suan-fa/bfs-kuang-jia" >BFS 算法解题套路框架<i class="fas fa-external-link-alt"></i></a></p><p>2.<a class="link"   href="https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/" >完全平方数<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;本系列文章是我在阅读&lt;a class=&quot;link&quot;   href=&quot;https://labuladong.gitbook.io/algo/&quot; &gt;《labuladong的算法小抄》&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="面试题" scheme="http://jiahaohong1997.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
