<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洪笳淏的个人博客</title>
  
  
  <link href="http://jiahaohong1997.github.io/atom.xml" rel="self"/>
  
  <link href="http://jiahaohong1997.github.io/"/>
  <updated>2022-04-24T15:48:27.341Z</updated>
  <id>http://jiahaohong1997.github.io/</id>
  
  <author>
    <name>洪笳淏</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>早起刷题（Day 17）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/24/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2017%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/24/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2017%EF%BC%89/</id>
    <published>2022-04-24T10:00:00.000Z</published>
    <updated>2022-04-24T15:48:27.341Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 2022.04.24 周赛的回顾</p><h2 id="LeetCode6041-多个数组求交集"><a href="#LeetCode6041-多个数组求交集" class="headerlink" title="LeetCode6041. 多个数组求交集"></a><a class="link" href="https://leetcode-cn.com/problems/intersection-of-multiple-arrays/">LeetCode6041. 多个数组求交集<i class="fas fa-external-link-alt"></i></a></h2><p>#map </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个二维整数数组 nums ，其中 nums[i] 是由 不同 正整数组成的一个非空数组，按 升序排列 返回一个数组，数组中的每个元素在 nums 所有数组 中都出现过。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]</span><br><span class="line">输出：[3,4]</span><br><span class="line">解释：</span><br><span class="line">nums[0] &#x3D; [3,1,2,4,5]，nums[1] &#x3D; [1,2,3,4]，nums[2] &#x3D; [3,4,5,6]，在 nums 中每个数组中都出现的数字是 3 和 4 ，所以返回 [3,4] 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [[1,2,3],[4,5,6]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">不存在同时出现在 nums[0] 和 nums[1] 的整数，所以返回一个空列表 [] 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 1000</span><br><span class="line">1 &lt;&#x3D; sum(nums[i].length) &lt;&#x3D; 1000</span><br><span class="line">1 &lt;&#x3D; nums[i][j] &lt;&#x3D; 1000</span><br><span class="line">nums[i] 中的所有值 互不相同</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 统计二维数组中每一个数字出现的次数，使用 <code>map</code> 保存；<br>(2). 遍历 <code>map</code>，如果数字出现的次数等于 <code>len(nums)</code>，那么说明每一个数组中都出现过该数字；<br>(3). 对结果进行排序。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(N^2)$</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersection</span><span class="params">(nums [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(nums[i]); j++ &#123;</span><br><span class="line">m[nums[i][j]]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> num, v := <span class="keyword">range</span> m &#123;</span><br><span class="line"><span class="keyword">if</span> v == n &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Ints(ret)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode6042-统计圆内格点数目"><a href="#LeetCode6042-统计圆内格点数目" class="headerlink" title="LeetCode6042. 统计圆内格点数目"></a><a class="link" href="https://leetcode-cn.com/problems/count-lattice-points-inside-a-circle/">LeetCode6042. 统计圆内格点数目<i class="fas fa-external-link-alt"></i></a></h2><p>#枚举 </p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个二维整数数组 circles ，其中 circles[i] = [xi, yi, ri] 表示网格上圆心为 (xi, yi) 且半径为 ri 的第 i 个圆，返回出现在 至少一个 圆内的 格点数目 。<br>注意：</p><ul><li>格点 是指整数坐标对应的点。</li><li>圆周上的点 也被视为出现在圆内的点。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="exa-11.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：circles &#x3D; [[2,2,1]]</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">给定的圆如上图所示。</span><br><span class="line">出现在圆内的格点为 (1, 2)、(2, 1)、(2, 2)、(2, 3) 和 (3, 2)，在图中用绿色标识。</span><br><span class="line">像 (1, 1) 和 (1, 3) 这样用红色标识的点，并未出现在圆内。</span><br><span class="line">因此，出现在至少一个圆内的格点数目是 5 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="exa-22.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：circles &#x3D; [[2,2,2],[3,4,1]]</span><br><span class="line">输出：16</span><br><span class="line">解释：</span><br><span class="line">给定的圆如上图所示。</span><br><span class="line">共有 16 个格点出现在至少一个圆内。</span><br><span class="line">其中部分点的坐标是 (0, 2)、(2, 0)、(2, 4)、(3, 2) 和 (4, 4) 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; circles.length &lt;&#x3D; 200</span><br><span class="line">circles[i].length &#x3D;&#x3D; 3</span><br><span class="line">1 &lt;&#x3D; xi, yi &lt;&#x3D; 100</span><br><span class="line">1 &lt;&#x3D; ri &lt;&#x3D; min(xi, yi)</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先注意本题的数据范围：<code>1 &lt;= circles.length &lt;= 200</code>，那么就可以通过枚举这最多 <code>400</code> 个点来看是否符合情况（当然也可以使用 <code>map</code> 来记录，但是鉴于本题的数据量，直接枚举会更好）；<br>(2). 先对 <code>circles</code> 数组进行排序，排序的优先级是较大的半径在前，这样就可以囊括更多的点，节约遍历 <code>circles</code> 数组的时间；<br>(3). 对每个点是否在所有的圆中进行判定，如果在某个圆中，则输出结果 +1。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(400*log(N))$</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countLatticePoints</span><span class="params">(circles [][]<span class="keyword">int</span>)</span> <span class="params">(ans <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按半径从大到小排序，这样能更早遇到包含 (x,y) 的圆</span></span><br><span class="line">sort.Slice(circles, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> circles[i][<span class="number">2</span>] &gt; circles[j][<span class="number">2</span>] &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt;= <span class="number">200</span>; x++ &#123;</span><br><span class="line"><span class="keyword">for</span> y := <span class="number">0</span>; y &lt;= <span class="number">200</span>; y++ &#123;</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> circles &#123;</span><br><span class="line"><span class="comment">// 判断 (x,y) 是否在圆 c 内</span></span><br><span class="line"><span class="keyword">if</span> (x-c[<span class="number">0</span>])*(x-c[<span class="number">0</span>])+(y-c[<span class="number">1</span>])*(y-c[<span class="number">1</span>]) &lt;= c[<span class="number">2</span>]*c[<span class="number">2</span>] &#123;</span><br><span class="line">ans++</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode6043-统计包含每个点的矩形数目"><a href="#LeetCode6043-统计包含每个点的矩形数目" class="headerlink" title="LeetCode6043. 统计包含每个点的矩形数目"></a><a class="link" href="https://leetcode-cn.com/problems/count-number-of-rectangles-containing-each-point/">LeetCode6043. 统计包含每个点的矩形数目<i class="fas fa-external-link-alt"></i></a></h2><p>#二分查找 </p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个二维整数数组 rectangles ，其中 $rectangles[i] = [l_i, h_i]$ 表示第 i 个矩形长为 $l_i$ 高为 $h_i$ 。给你一个二维整数数组 $points$ ，其中 $points[j] = [x_j, y_j]$ 是坐标为 $(x_j, y_j)$ 的一个点。<br>第 i 个矩形的 左下角 在 $(0, 0)$ 处，右上角 在 $(l_i, h_i)$。<br>请你返回一个整数数组 $count$ ，长度为 $points.length$，其中 $count[j]$是 包含 第 $j$ 个点的矩形数目。<br>如果 $0 &lt;= x_j &lt;= l_i$ 且 $0 &lt;= y_j &lt;= h_i$ ，那么我们说第 i 个矩形包含第 j 个点。如果一个点刚好在矩形的 边上 ，这个点也被视为被矩形包含。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="qwdsa.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles &#x3D; [[1,2],[2,3],[2,5]], points &#x3D; [[2,1],[1,4]]</span><br><span class="line">输出：[2,1]</span><br><span class="line">解释：</span><br><span class="line">第一个矩形不包含任何点。</span><br><span class="line">第二个矩形只包含一个点 (2, 1) 。</span><br><span class="line">第三个矩形包含点 (2, 1) 和 (1, 4) 。</span><br><span class="line">包含点 (2, 1) 的矩形数目为 2 。</span><br><span class="line">包含点 (1, 4) 的矩形数目为 1 。</span><br><span class="line">所以，我们返回 [2, 1] 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="sfdcsaf.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles &#x3D; [[1,1],[2,2],[3,3]], points &#x3D; [[1,3],[1,1]]</span><br><span class="line">输出：[1,3]</span><br><span class="line">解释：</span><br><span class="line">第一个矩形只包含点 (1, 1) 。</span><br><span class="line">第二个矩形只包含点 (1, 1) 。</span><br><span class="line">第三个矩形包含点 (1, 3) 和 (1, 1) 。</span><br><span class="line">包含点 (1, 3) 的矩形数目为 1 。</span><br><span class="line">包含点 (1, 1) 的矩形数目为 3 。</span><br><span class="line">所以，我们返回 [1, 3] 。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; rectangles.length, points.length &lt;&#x3D; 5 * 10^4</span><br><span class="line">rectangles[i].length &#x3D;&#x3D; points[j].length &#x3D;&#x3D; 2</span><br><span class="line">1 &lt;&#x3D; li, xj &lt;&#x3D; 10^9</span><br><span class="line">1 &lt;&#x3D; hi, yj &lt;&#x3D; 100</span><br><span class="line">所有 rectangles 互不相同 。</span><br><span class="line">所有 points 互不相同 。</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先关注一下题目给的数据范围，可以观察到：$1 &lt;= l_i, x_j &lt;= 10^9$，且 $1 &lt;= h_i, y_j &lt;= 100$；<br>(2). 那么就意味着矩形的高最大也就是 $100$，那么就可以使用二分法，最多在 $y$ 轴上进行 $100$ 次二分就能得出答案；<br>(3). 首先就是要构造一个二维数组，该数组的外层索引是高度，内层索引是所有是该高度的矩形的宽的列表；<br>(4). 要使用二分那么就要使得列表有序，为避免重复排序，创建一个 <code>bool</code> 数组来记录是否已经排过序；<br>(5). 二分法的判断条件是找到第一个 <strong>大于等于</strong> 点横坐标的索引号，返回的是 <strong>列表长度 - 该索引号</strong>，表明包含了该点的矩形个数。</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countRectangles</span><span class="params">(rectangles [][]<span class="keyword">int</span>, points [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">length := <span class="built_in">len</span>(rectangles)</span><br><span class="line">m := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">101</span>)</span><br><span class="line">sorted := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">101</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;length; i++ &#123;</span><br><span class="line">x, y := rectangles[i][<span class="number">0</span>], rectangles[i][<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;=y; j++ &#123;</span><br><span class="line">m[j] = <span class="built_in">append</span>(m[j], x)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> judgeCount <span class="function"><span class="keyword">func</span><span class="params">([]<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">judgeCount = <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">r := <span class="built_in">len</span>(arr)<span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> target &gt; arr[r] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n := sort.Search(<span class="built_in">len</span>(arr), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> arr[i] &gt;= target</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n == <span class="built_in">len</span>(arr) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(arr)-n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(points))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(points); i++ &#123;</span><br><span class="line">x, y := points[i][<span class="number">0</span>], points[i][<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(m[y]) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !sorted[y] &#123;</span><br><span class="line">sort.Ints(m[y])</span><br><span class="line">sorted[y] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret[i] = judgeCount(m[y], x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h3><p>&emsp;&emsp;由于出现在 <code>rectangles</code> 数组中的矩形不能囊括所有的纵坐标，所以在更新对应纵坐标的二维数组时，要同时更新小于该纵坐标的二维数组的列表值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是对 2022.04.24 周赛的回顾&lt;/p&gt;
&lt;h2 id=&quot;LeetCode6041-多个数组求交集&quot;&gt;&lt;a href=&quot;#LeetCode6041-多个数组求交集&quot; class=&quot;headerlink&quot; title=&quot;LeetCode6041. 多个数组求交集&quot;&gt;</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 16）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/18/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2016%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/18/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2016%EF%BC%89/</id>
    <published>2022-04-17T22:00:00.000Z</published>
    <updated>2022-04-17T23:44:43.665Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 2022.04.17 周赛的回顾</p><h2 id="LeetCode6070-计算字符串的数字和"><a href="#LeetCode6070-计算字符串的数字和" class="headerlink" title="LeetCode6070. 计算字符串的数字和"></a><a class="link" href="https://leetcode-cn.com/problems/calculate-digit-sum-of-a-string/">LeetCode6070. 计算字符串的数字和<i class="fas fa-external-link-alt"></i></a></h2><p>#字符串 #模拟 </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个由若干数字（0 - 9）组成的字符串 s ，和一个整数。<br>如果 s 的长度大于 k ，则可以执行一轮操作。在一轮操作中，需要完成以下工作：<br>将 s 拆分 成长度为 k 的若干 连续数字组 ，使得前 k 个字符都分在第一组，接下来的 k 个字符都分在第二组，依此类推。注意，最后一个数字组的长度可以小于 k 。<br>用表示每个数字组中所有数字之和的字符串来 替换 对应的数字组。例如，”346” 会替换为 “13” ，因为 3 + 4 + 6 = 13 。<br>合并 所有组以形成一个新字符串。如果新字符串的长度大于 k 则重复第一步。<br>返回在完成所有轮操作后的 s 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;11111222223&quot;, k &#x3D; 3</span><br><span class="line">输出：&quot;135&quot;</span><br><span class="line">解释：</span><br><span class="line">- 第一轮，将 s 分成：&quot;111&quot;、&quot;112&quot;、&quot;222&quot; 和 &quot;23&quot; 。</span><br><span class="line">  接着，计算每一组的数字和：1 + 1 + 1 &#x3D; 3、1 + 1 + 2 &#x3D; 4、2 + 2 + 2 &#x3D; 6 和 2 + 3 &#x3D; 5 。 </span><br><span class="line">  这样，s 在第一轮之后变成 &quot;3&quot; + &quot;4&quot; + &quot;6&quot; + &quot;5&quot; &#x3D; &quot;3465&quot; 。</span><br><span class="line">- 第二轮，将 s 分成：&quot;346&quot; 和 &quot;5&quot; 。</span><br><span class="line">  接着，计算每一组的数字和：3 + 4 + 6 &#x3D; 13 、5 &#x3D; 5 。</span><br><span class="line">  这样，s 在第二轮之后变成 &quot;13&quot; + &quot;5&quot; &#x3D; &quot;135&quot; 。 </span><br><span class="line">现在，s.length &lt;&#x3D; k ，所以返回 &quot;135&quot; 作为答案。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;00000000&quot;, k &#x3D; 3</span><br><span class="line">输出：&quot;000&quot;</span><br><span class="line">解释：</span><br><span class="line">将 &quot;000&quot;, &quot;000&quot;, and &quot;00&quot;.</span><br><span class="line">接着，计算每一组的数字和：0 + 0 + 0 &#x3D; 0 、0 + 0 + 0 &#x3D; 0 和 0 + 0 &#x3D; 0 。 </span><br><span class="line">s 变为 &quot;0&quot; + &quot;0&quot; + &quot;0&quot; &#x3D; &quot;000&quot; ，其长度等于 k ，所以返回 &quot;000&quot; 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; s.length &lt;&#x3D; 100</span><br><span class="line">2 &lt;&#x3D; k &lt;&#x3D; 100</span><br><span class="line">s 仅由数字（0 - 9）组成。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 总体思路就是反复合并的过程，直到字符串长度小于等于 <code>k</code>；<br>(2). 需要注意的就是怎样寻找每个长度为 <code>k</code>（最后一个小于等于 <code>k</code>）的子串的起始索引。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digitSum</span><span class="params">(s <span class="keyword">string</span>, k <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= k &#123;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(s) &gt; k &#123;</span><br><span class="line"></span><br><span class="line">t := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=(<span class="built_in">len</span>(s)/k)*k; i=i+k &#123;</span><br><span class="line">x := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> i == (<span class="built_in">len</span>(s)/k)*k &#123;</span><br><span class="line">x = s[i:]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x = s[i:i+k]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(x); j++ &#123;</span><br><span class="line">n += <span class="keyword">int</span>(x[j])-<span class="string">&#x27;0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t += strconv.Itoa(n)</span><br><span class="line">&#125;</span><br><span class="line">s = t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode6071-完成所有任务需要的最少轮数"><a href="#LeetCode6071-完成所有任务需要的最少轮数" class="headerlink" title="LeetCode6071. 完成所有任务需要的最少轮数"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-rounds-to-complete-all-tasks/">LeetCode6071. 完成所有任务需要的最少轮数<i class="fas fa-external-link-alt"></i></a></h2><p>#动态规划 #枚举 </p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个下标从 0 开始的整数数组 tasks ，其中 tasks[i] 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 相同难度级别 的任务。<br>返回完成所有任务需要的 最少 轮数，如果无法完成所有任务，返回 -1 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：tasks &#x3D; [2,2,3,3,2,4,4,4,4,4]</span><br><span class="line">输出：4</span><br><span class="line">解释：要想完成所有任务，一个可能的计划是：</span><br><span class="line">- 第一轮，完成难度级别为 2 的 3 个任务。 </span><br><span class="line">- 第二轮，完成难度级别为 3 的 2 个任务。 </span><br><span class="line">- 第三轮，完成难度级别为 4 的 3 个任务。 </span><br><span class="line">- 第四轮，完成难度级别为 4 的 2 个任务。 </span><br><span class="line">可以证明，无法在少于 4 轮的情况下完成所有任务，所以答案为 4 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：tasks &#x3D; [2,3,3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：难度级别为 2 的任务只有 1 个，但每一轮执行中，只能选择完成 2 个或者 3 个相同难度级别的任务。因此，无法完成所有任务，答案为 -1 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; tasks.length &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; tasks[i] &lt;&#x3D; 10^9</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 本题中并不关心具体的任务难度的差别，任务难度的级别仅仅是作为对任务的区分，相当于任务的编号；<br>(2). 首先要计算每种任务各有多少个，并且记录下最多的某类任务个数；<br>(3). 然后就可以使用动态规划，创建数组，数组的长度是最多的任务个数+1；<br>(4). 然后就转变为类似跳台阶的问题；<br>(5). 之后枚举所有任务，根据动态规划数组计算总轮数。</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimumRounds</span><span class="params">(tasks []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">maxNum := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(tasks); i++ &#123;</span><br><span class="line">m[tasks[i]]++</span><br><span class="line">maxNum = max(maxNum, m[tasks[i]])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> maxNum &lt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, maxNum+<span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>], dp[<span class="number">1</span>], dp[<span class="number">2</span>] = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">3</span>; i&lt;=maxNum; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">3</span> &#123;</span><br><span class="line">dp[i] = <span class="number">1</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> dp[i<span class="number">-2</span>] == <span class="number">0</span> &amp;&amp; dp[i<span class="number">-3</span>] == <span class="number">0</span> &#123;</span><br><span class="line">dp[i] = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> dp[i<span class="number">-2</span>] == <span class="number">0</span> &#123;</span><br><span class="line">dp[i] = dp[i<span class="number">-3</span>]+<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> dp[i<span class="number">-3</span>] == <span class="number">0</span> &#123;</span><br><span class="line">dp[i] = dp[i<span class="number">-2</span>]+<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i] = min(dp[i<span class="number">-2</span>], dp[i<span class="number">-3</span>])+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _,v := <span class="keyword">range</span> m &#123;</span><br><span class="line"><span class="keyword">if</span> dp[v] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">ret += dp[v]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode6072-转角路径的乘积中最多能有几个尾随零"><a href="#LeetCode6072-转角路径的乘积中最多能有几个尾随零" class="headerlink" title="LeetCode6072. 转角路径的乘积中最多能有几个尾随零"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-trailing-zeros-in-a-cornered-path/">LeetCode6072. 转角路径的乘积中最多能有几个尾随零<i class="fas fa-external-link-alt"></i></a></h2><p>#前缀和 #枚举 </p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个二维整数数组 grid ，大小为 m x n，其中每个单元格都含一个正整数。<br>转角路径 定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全 向水平方向 或者 向竖直方向 移动过弯（如果存在弯），而不能访问之前访问过的单元格。在过弯之后，路径应当完全朝 另一个 方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。<br>一条路径的 乘积 定义为：路径上所有值的乘积。<br>请你从 grid 中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。</p></blockquote><blockquote><p>注意：</p><ul><li> <strong>水平</strong> 移动是指向左或右移动。</li><li><strong>竖直</strong> 移动是指向上或下移动。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="ex1new211.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]</span><br><span class="line">输出：3</span><br><span class="line">解释：左侧的图展示了一条有效的转角路径。</span><br><span class="line">其乘积为 15 * 20 * 6 * 1 * 10 &#x3D; 18000 ，共计 3 个尾随零。</span><br><span class="line">可以证明在这条转角路径的乘积中尾随零数目最多。</span><br><span class="line">中间的图不是一条有效的转角路径，因为它有不止一个弯。</span><br><span class="line">右侧的图也不是一条有效的转角路径，因为它需要重复访问已经访问过的单元格。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="ex221d.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：grid &#x3D; [[4,3,2],[7,6,1],[8,8,8]]</span><br><span class="line">输出：0</span><br><span class="line">解释：网格如上图所示。</span><br><span class="line">不存在乘积含尾随零的转角路径。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">m &#x3D;&#x3D; grid.length</span><br><span class="line">n &#x3D;&#x3D; grid[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; m * n &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; grid[i][j] &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 尾零的个数就是路径上的数的因子 <code>2</code> 的个数和，与因子 <code>5</code> 的个数之和的较小值；<br>(2). 那么数越多越好，路径的起点和终点都应该在边界上。预处理因子的前缀和，然后枚举所有的路径：</p><ul><li>从上往下走，枚举左拐/右拐；</li><li>从下往上走，枚举左拐/右拐；<br>(3). 所有路径上的 $min(s_2,s_5)$ 的最大值即为答案，这里 $s_2$ 为路径上的因子 <code>2</code> 的个数之和，$s_5$ 为路径上的因子 <code>5</code> 的个数之和。</li></ul><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c25 [<span class="number">1001</span>][<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 预处理：递推算出每个数的因子 2 的个数和因子 5 的个数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123; c25[i][<span class="number">0</span>] = c25[i/<span class="number">2</span>][<span class="number">0</span>] + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">5</span> == <span class="number">0</span> &#123; c25[i][<span class="number">1</span>] = c25[i/<span class="number">5</span>][<span class="number">1</span>] + <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxTrailingZeros</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="params">(ans <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">s := <span class="built_in">make</span>([][][<span class="number">2</span>]<span class="keyword">int</span>, m)</span><br><span class="line"><span class="keyword">for</span> i, row := <span class="keyword">range</span> grid &#123;</span><br><span class="line">s[i] = <span class="built_in">make</span>([][<span class="number">2</span>]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> j, v := <span class="keyword">range</span> row &#123;</span><br><span class="line">s[i][j+<span class="number">1</span>][<span class="number">0</span>] = s[i][j][<span class="number">0</span>] + c25[v][<span class="number">0</span>] <span class="comment">// 每行的因子 2 的前缀和</span></span><br><span class="line">s[i][j+<span class="number">1</span>][<span class="number">1</span>] = s[i][j][<span class="number">1</span>] + c25[v][<span class="number">1</span>] <span class="comment">// 每行的因子 5 的前缀和</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">s2, s5 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, row := <span class="keyword">range</span> grid &#123; <span class="comment">// 从上往下，枚举左拐还是右拐</span></span><br><span class="line">s2 += c25[row[j]][<span class="number">0</span>]</span><br><span class="line">s5 += c25[row[j]][<span class="number">1</span>]</span><br><span class="line">ans = max(ans, max(min(s2+s[i][j][<span class="number">0</span>], s5+s[i][j][<span class="number">1</span>]), min(s2+s[i][n][<span class="number">0</span>]-s[i][j+<span class="number">1</span>][<span class="number">0</span>], s5+s[i][n][<span class="number">1</span>]-s[i][j+<span class="number">1</span>][<span class="number">1</span>])))</span><br><span class="line">&#125;</span><br><span class="line">s2, s5 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123; <span class="comment">// 从下往上，枚举左拐还是右拐</span></span><br><span class="line">s2 += c25[grid[i][j]][<span class="number">0</span>]</span><br><span class="line">s5 += c25[grid[i][j]][<span class="number">1</span>]</span><br><span class="line">ans = max(ans, max(min(s2+s[i][j][<span class="number">0</span>], s5+s[i][j][<span class="number">1</span>]), min(s2+s[i][n][<span class="number">0</span>]-s[i][j+<span class="number">1</span>][<span class="number">0</span>], s5+s[i][n][<span class="number">1</span>]-s[i][j+<span class="number">1</span>][<span class="number">1</span>])))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">if</span> a &lt; b &#123; <span class="keyword">return</span> b &#125;; <span class="keyword">return</span> a &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">if</span> a &gt; b &#123; <span class="keyword">return</span> b &#125;; <span class="keyword">return</span> a &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是对 2022.04.17 周赛的回顾&lt;/p&gt;
&lt;h2 id=&quot;LeetCode6070-计算字符串的数字和&quot;&gt;&lt;a href=&quot;#LeetCode6070-计算字符串的数字和&quot; class=&quot;headerlink&quot; title=&quot;LeetCode6070. 计算字符串</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 15）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/17/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2015%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/17/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2015%EF%BC%89/</id>
    <published>2022-04-17T09:25:00.000Z</published>
    <updated>2022-04-17T23:17:25.070Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 2022.04.16 双周赛的回顾</p><h2 id="LeetCode6060-找到最接近-0-的数字"><a href="#LeetCode6060-找到最接近-0-的数字" class="headerlink" title="LeetCode6060. 找到最接近 0 的数字"></a><a class="link" href="https://leetcode-cn.com/problems/find-closest-number-to-zero/">LeetCode6060. 找到最接近 0 的数字<i class="fas fa-external-link-alt"></i></a></h2><p>#数组 </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，请你返回 <code>nums</code> 中最 <strong>接近</strong> <code>0</code> 的数字。如果有多个答案，请你返回它们中的 <strong>最大值</strong> 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [-4,-2,1,4,8]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">-4 到 0 的距离为 |-4| &#x3D; 4 。</span><br><span class="line">-2 到 0 的距离为 |-2| &#x3D; 2 。</span><br><span class="line">1 到 0 的距离为 |1| &#x3D; 1 。</span><br><span class="line">4 到 0 的距离为 |4| &#x3D; 4 。</span><br><span class="line">8 到 0 的距离为 |8| &#x3D; 8 。</span><br><span class="line">所以，数组中距离 0 最近的数字为 1 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [2,-1,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：1 和 -1 都是距离 0 最近的数字，所以返回较大值 1 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 1000</span><br><span class="line">-10^5 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 先排序数组，然后看数组是否全体 <strong>大于等于</strong> 0 或者 <strong>小于等于</strong> 0，是的话就直接输出答案了；<br>(2). 否则一次遍历数组，用一个变量记录最大的负数，当遍历到 <code>0</code>，直接输出 <code>0</code>，如果遍历到第一个正数，则比较最大的负数和最小的正数谁距离 <code>0</code> 更近。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(Nlog(N))</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findClosestNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">sort.Ints(nums)</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">if</span> nums[<span class="number">0</span>] &gt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[n<span class="number">-1</span>] &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] &lt; <span class="number">0</span> &#123;</span><br><span class="line">a = nums[i]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span>-a &lt; nums[i] &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode6061-买钢笔和铅笔的方案数"><a href="#LeetCode6061-买钢笔和铅笔的方案数" class="headerlink" title="LeetCode6061. 买钢笔和铅笔的方案数"></a><a class="link" href="https://leetcode-cn.com/problems/number-of-ways-to-buy-pens-and-pencils/">LeetCode6061. 买钢笔和铅笔的方案数<i class="fas fa-external-link-alt"></i></a></h2><p>#动态规划 #枚举</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个整数 total ，表示你拥有的总钱数。同时给你两个整数 cost1 和 cost2 ，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。<br>请你返回购买钢笔和铅笔的 不同方案数目 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：total &#x3D; 20, cost1 &#x3D; 10, cost2 &#x3D; 5</span><br><span class="line">输出：9</span><br><span class="line">解释：一支钢笔的价格为 10 ，一支铅笔的价格为 5 。</span><br><span class="line">- 如果你买 0 支钢笔，那么你可以买 0 ，1 ，2 ，3 或者 4 支铅笔。</span><br><span class="line">- 如果你买 1 支钢笔，那么你可以买 0 ，1 或者 2 支铅笔。</span><br><span class="line">- 如果你买 2 支钢笔，那么你没法买任何铅笔。</span><br><span class="line">所以买钢笔和铅笔的总方案数为 5 + 3 + 1 &#x3D; 9 种。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：total &#x3D; 5, cost1 &#x3D; 10, cost2 &#x3D; 10</span><br><span class="line">输出：1</span><br><span class="line">解释：钢笔和铅笔的价格都为 10 ，都比拥有的钱数多，所以你没法购买任何文具。所以只有 1 种方案：买 0 支钢笔和 0 支铅笔。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; total, cost1, cost2 &lt;&#x3D; 10^6</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 仔细观察示例的解题过程，是通过枚举钢笔的数量来确定铅笔可能的数量，那么我们也可以使用枚举的方式来判断；<br>(2). 那么怎样能够快速的枚举呢？可以先通过动态规划，确定在总金额不变的情况下，全部用来买钢笔或铅笔能够最多买多少支；<br>(3). 在枚举钢笔数量的时候，剩余的钱全都可以用来购买铅笔，那么总方案数就可以根据这两者来确定。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waysToBuyPensPencils</span><span class="params">(total <span class="keyword">int</span>, cost1 <span class="keyword">int</span>, cost2 <span class="keyword">int</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"></span><br><span class="line">dp1 := <span class="built_in">make</span>([]<span class="keyword">int64</span>, total+<span class="number">1</span>)</span><br><span class="line">dp2 := <span class="built_in">make</span>([]<span class="keyword">int64</span>, total+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 背包问题</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=total; i++ &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &lt; cost1 &#123;</span><br><span class="line">dp1[i] = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp1[i] = dp1[i-cost1]+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &lt; cost2 &#123;</span><br><span class="line">dp2[i] = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp2[i] = dp2[i-cost2]+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">var</span> ret <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=<span class="keyword">int</span>(dp1[total]); i++ &#123;</span><br><span class="line">rest := total-i*cost1</span><br><span class="line">ret += dp2[rest]+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode6062-设计一个-ATM-机器"><a href="#LeetCode6062-设计一个-ATM-机器" class="headerlink" title="LeetCode6062. 设计一个 ATM 机器"></a><a class="link" href="https://leetcode-cn.com/problems/design-an-atm-machine/">LeetCode6062. 设计一个 ATM 机器<i class="fas fa-external-link-alt"></i></a></h2><p>#模拟 #贪心</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>一个 ATM 机器，存有 5 种面值的钞票：20 ，50 ，100 ，200 和 500 美元。初始时，ATM 机是空的。用户可以用它存或者取任意数目的钱。<br>取款时，机器会优先取 较大 数额的钱。</p><ul><li>比方说，你想取 $300 ，并且机器里有 2 张 $50 的钞票，1 张 $100 的钞票和1 张 $200 的钞票，那么机器会取出 $100 和 $200 的钞票。</li><li>但是，如果你想取 $600 ，机器里有 3 张 $200 的钞票和1 张 $500 的钞票，那么取款请求会被拒绝，因为机器会先取出 $500 的钞票，然后无法取出剩余的 $100 。注意，因为有 $500 钞票的存在，机器 不能 取 $200 的钞票。</li></ul></blockquote><blockquote><p>请你实现 ATM 类：</p><ul><li>ATM() 初始化 ATM 对象。</li><li>void deposit(int[] banknotesCount) 分别存入 $20 ，$50，$100，$200 和 $500 钞票的数目。</li><li>int[] withdraw(int amount) 返回一个长度为 5 的数组，分别表示 $20 ，$50，$100 ，$200 和 $500 钞票的数目，并且更新 ATM 机里取款后钞票的剩余数量。如果无法取出指定数额的钱，请返回 [-1] （这种情况下 <strong>不</strong> 取出任何钞票）。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;ATM&quot;, &quot;deposit&quot;, &quot;withdraw&quot;, &quot;deposit&quot;, &quot;withdraw&quot;, &quot;withdraw&quot;]</span><br><span class="line">[[], [[0,0,1,2,1]], [600], [[0,1,0,1,1]], [600], [550]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, [0,0,1,0,1], null, [-1], [0,1,0,0,1]]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">ATM atm &#x3D; new ATM();</span><br><span class="line">atm.deposit([0,0,1,2,1]); &#x2F;&#x2F; 存入 1 张 $100 ，2 张 $200 和 1 张 $500 的钞票。</span><br><span class="line">atm.withdraw(600);        &#x2F;&#x2F; 返回 [0,0,1,0,1] 。机器返回 1 张 $100 和 1 张 $500 的钞票。机器里剩余钞票的数量为 [0,0,0,2,0] 。</span><br><span class="line">atm.deposit([0,1,0,1,1]); &#x2F;&#x2F; 存入 1 张 $50 ，1 张 $200 和 1 张 $500 的钞票。</span><br><span class="line">                          &#x2F;&#x2F; 机器中剩余钞票数量为 [0,1,0,3,1] 。</span><br><span class="line">atm.withdraw(600);        &#x2F;&#x2F; 返回 [-1] 。机器会尝试取出 $500 的钞票，然后无法得到剩余的 $100 ，所以取款请求会被拒绝。</span><br><span class="line">                          &#x2F;&#x2F; 由于请求被拒绝，机器中钞票的数量不会发生改变。</span><br><span class="line">atm.withdraw(550);        &#x2F;&#x2F; 返回 [0,1,0,0,1] ，机器会返回 1 张 $50 的钞票和 1 张 $500 的钞票。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">banknotesCount.length &#x3D;&#x3D; 5</span><br><span class="line">0 &lt;&#x3D; banknotesCount[i] &lt;&#x3D; 10^9</span><br><span class="line">1 &lt;&#x3D; amount &lt;&#x3D; 10^9</span><br><span class="line">总共 最多有 5000 次 withdraw 和 deposit 的调用。</span><br><span class="line">函数 withdraw 和 deposit 至少各有 一次 调用。</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先我们构建 <code>ATM</code> 类，这个类需要什么元素呢？</p><ul><li>首先需要一个数组 <code>paperAmount</code> 来保存所有的钞票面额</li><li>一个 <code>map</code> 来记录对应面额的数量</li><li>一个变量记录总金额</li><li>一个变量记录最大面额对应的 <code>paperAmount</code> 数组中的索引号<br>(2). 对于 <code>Deposit</code> 方法，每次更新对应的元素即可；<br>(3). 令输出为 <code>ret</code>，首先看银行内总金额是否能支持 <code>amount</code> 数额的兑取，然后 <code>ret</code> 是一个长度为 <code>5</code> 的数组，用于保存各类型钞票的数量；<br>(4). 对于 <code>Withdraw</code> 方法，先看是否有对应的面额正好是 <code>amount</code> 的值，如果是的话直接取出；否则就要看最大面额的钞票是否超过了 <code>amount</code>，如果没有超过，则必须从最大面额中先取出，为了避免超时，这里需要尽可能的将能用最大面额 cover 的部分全部取出来；如果超过了，那么就从次大的面额到最小面额依次比对，直到能满足要求；<br>(5). 如果没有任何面额能够满足剩余金额的要求，那么只能证明无法取出这个 <code>amount</code> 对应的钞票，要将之前取出来的钞票重新存进银行，那么就要调用 <code>Deposit</code> 方法，将 <code>ret</code> 数组存入银行。</li></ul><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ATM <span class="keyword">struct</span> &#123;</span><br><span class="line">paperCount <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">totalCount <span class="keyword">int</span></span><br><span class="line">paperAmount []<span class="keyword">int</span></span><br><span class="line">maxIndex <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">ATM</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ATM &#123;</span><br><span class="line">paperCount : <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span> &#123;</span><br><span class="line"><span class="number">20</span> : <span class="number">0</span>,</span><br><span class="line"><span class="number">50</span> : <span class="number">0</span>,</span><br><span class="line"><span class="number">100</span> : <span class="number">0</span>,</span><br><span class="line"><span class="number">200</span> : <span class="number">0</span>,</span><br><span class="line"><span class="number">500</span> : <span class="number">0</span>,</span><br><span class="line">&#125;,</span><br><span class="line">totalCount : <span class="number">0</span>,</span><br><span class="line">paperAmount : []<span class="keyword">int</span>&#123;<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">500</span>&#125;,</span><br><span class="line">maxIndex : <span class="number">-1</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ATM)</span> <span class="title">Deposit</span><span class="params">(banknotesCount []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">this.paperCount[<span class="number">20</span>] += banknotesCount[<span class="number">0</span>]</span><br><span class="line">this.paperCount[<span class="number">50</span>] += banknotesCount[<span class="number">1</span>]</span><br><span class="line">this.paperCount[<span class="number">100</span>] += banknotesCount[<span class="number">2</span>]</span><br><span class="line">this.paperCount[<span class="number">200</span>] += banknotesCount[<span class="number">3</span>]</span><br><span class="line">this.paperCount[<span class="number">500</span>] += banknotesCount[<span class="number">4</span>]</span><br><span class="line">this.totalCount += <span class="number">20</span>*banknotesCount[<span class="number">0</span>] + <span class="number">50</span>*banknotesCount[<span class="number">1</span>] + <span class="number">100</span>*banknotesCount[<span class="number">2</span>] + <span class="number">200</span>*banknotesCount[<span class="number">3</span>] + <span class="number">500</span>*banknotesCount[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">4</span>; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">x := this.paperAmount[i]</span><br><span class="line"><span class="keyword">if</span> this.paperCount[x] &gt; <span class="number">0</span> &#123;</span><br><span class="line">this.maxIndex = i</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ATM)</span> <span class="title">Withdraw</span><span class="params">(amount <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> amount &gt; this.totalCount &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> amount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> amount == this.paperAmount[i] &amp;&amp; this.paperCount[this.paperAmount[i]] &gt; <span class="number">0</span> &#123;</span><br><span class="line">ret[i]++</span><br><span class="line">x := this.paperAmount[i]</span><br><span class="line">this.totalCount -= x</span><br><span class="line">this.paperCount[x]--</span><br><span class="line"><span class="keyword">if</span> this.paperCount[x] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=this.maxIndex<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">y := this.paperAmount[i]</span><br><span class="line"><span class="keyword">if</span> this.paperCount[y] &gt; <span class="number">0</span> &#123;</span><br><span class="line">this.maxIndex = i</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> this.paperAmount[this.maxIndex] &lt; amount &#123;</span><br><span class="line">x := this.paperAmount[this.maxIndex]</span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> this.paperCount[x] &gt;= amount/x &#123;</span><br><span class="line">n = amount/x</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">n = this.paperCount[x]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">amount -= x*n</span><br><span class="line">ret[this.maxIndex] += n</span><br><span class="line">this.paperCount[x] -= n</span><br><span class="line"><span class="keyword">if</span> this.paperCount[x] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=this.maxIndex<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">y := this.paperAmount[i]</span><br><span class="line"><span class="keyword">if</span> this.paperCount[y] &gt; <span class="number">0</span> &#123;</span><br><span class="line">this.maxIndex = i</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.totalCount -= x *n</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">i := this.maxIndex<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> ; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">x := this.paperAmount[i]</span><br><span class="line"><span class="keyword">if</span> x &lt; amount &amp;&amp; this.paperCount[x] &gt; <span class="number">0</span> &#123;</span><br><span class="line">amount -= x</span><br><span class="line">this.totalCount -= x</span><br><span class="line">this.paperCount[x]--</span><br><span class="line">ret[i]++</span><br><span class="line">f = <span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> f == <span class="number">0</span> &#123;</span><br><span class="line">this.Deposit(ret)</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> amount == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.Deposit(ret)</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your ATM object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* obj := Constructor();</span></span><br><span class="line"><span class="comment">* obj.Deposit(banknotesCount);</span></span><br><span class="line"><span class="comment">* param_2 := obj.Withdraw(amount);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="LeetCode6063-节点序列的最大得分"><a href="#LeetCode6063-节点序列的最大得分" class="headerlink" title="LeetCode6063. 节点序列的最大得分"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-score-of-a-node-sequence/">LeetCode6063. 节点序列的最大得分<i class="fas fa-external-link-alt"></i></a></h2><p>#图 #枚举 </p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个 n 个节点的 无向图 ，节点编号为 0 到 n - 1 。<br>给你一个下标从 0 开始的整数数组 scores ，其中 scores[i] 是第 i 个节点的分数。同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] ，表示节点 ai 和 bi 之间有一条 无向 边。<br>一个合法的节点序列如果满足以下条件，我们称它是 合法的 ：</p><ul><li>序列中每 <strong>相邻</strong> 节点之间有边相连。</li><li>序列中没有节点出现超过一次。<br>节点序列的分数定义为序列中节点分数之 <strong>和</strong> 。<br>请你返回一个长度为 <code>4</code> 的合法节点序列的最大分数。如果不存在这样的序列，请你返回 <code>-1</code> 。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="ex1new3.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：scores &#x3D; [5,2,9,8,4], edges &#x3D; [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]</span><br><span class="line">输出：24</span><br><span class="line">解释：上图为输入的图，节点序列为 [0,1,2,3] 。</span><br><span class="line">节点序列的分数为 5 + 2 + 9 + 8 &#x3D; 24 。</span><br><span class="line">观察可知，没有其他节点序列得分和超过 24 。</span><br><span class="line">注意节点序列 [3,1,2,0] 和 [1,0,2,3] 也是合法的，且分数为 24 。</span><br><span class="line">序列 [0,3,2,4] 不是合法的，因为没有边连接节点 0 和 3 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="ex2.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：scores &#x3D; [9,20,6,4,11,12], edges &#x3D; [[0,3],[5,3],[2,4],[1,3]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：上图为输入的图。</span><br><span class="line">没有长度为 4 的合法序列，所以我们返回 -1 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">n &#x3D;&#x3D; scores.length</span><br><span class="line">4 &lt;&#x3D; n &lt;&#x3D; 5 * 10^4</span><br><span class="line">1 &lt;&#x3D; scores[i] &lt;&#x3D; 10^8</span><br><span class="line">0 &lt;&#x3D; edges.length &lt;&#x3D; 5 * 10^4</span><br><span class="line">edges[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; ai, bi &lt;&#x3D; n - 1</span><br><span class="line">ai !&#x3D; bi</span><br><span class="line">不会有重边。</span><br></pre></td></tr></table></figure><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 试试枚举可不可以。（做题时优先考虑最简单的算法）枚举谁呢？可以枚举点，也可以枚举边；<br>(2). <strong>简化问题</strong>可以帮助我们找到思路。如果序列只要求 33 个点，要如何枚举？只要求 33 个点的话，可以枚举端点，也可以枚举中间的点；<br>(3). 枚举中间的点是最方便的，算出与其相邻的分数最大的两个点即可。这意味着枚举<strong>中间</strong>的相比枚举两边的要更好写，效率也更高。顺着这个思路去思考原问题；<br>(4). 设序列为 <code>a−x−y−b</code>（<code>−</code> 表示边），枚举 <code>edges</code> 中的每条边，作为序列正中间的那条边，即 <code>x−y</code>；<br>(5). 我们需要把与 <code>x</code> 相邻的点中，分数最大且不同于 <code>y</code> 和 <code>b</code> 的点作为 <code>a</code>；把与 <code>y</code> 相邻的点中，分数最大且不同于 <code>x</code> 和 <code>a</code> 的点作为 <code>b</code>；<br>(6). 与 <code>x</code> 相邻的点中，由于只需要与 <code>y</code> 和 <code>b</code> 不一样，我们仅需要保留分数最大的三个点，<code>a</code> 必定在这三个点中；<br>(7). 剩下要做的，就是在枚举 <code>edges</code> 前，预处理出这三个点。代码实现时，可以用排序、堆、分治（nth_element）或者手动维护求前三大。最优的时间复杂度为 <code>O(n+m)</code>。</p><h3 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumScore</span><span class="params">(scores []<span class="keyword">int</span>, edges [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">to <span class="keyword">int</span></span><br><span class="line">score <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e := <span class="built_in">make</span>([][]node, <span class="built_in">len</span>(scores))</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(edges); i++ &#123;</span><br><span class="line">x, y := edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]</span><br><span class="line">e[x] = <span class="built_in">append</span>(e[x], node&#123;y, scores[y]&#125;)</span><br><span class="line">e[y] = <span class="built_in">append</span>(e[y], node&#123;x, scores[x]&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(e); i++ &#123;</span><br><span class="line">sort.Slice(e[i], <span class="function"><span class="keyword">func</span><span class="params">(k, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> e[i][k].score &gt; e[i][j].score</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(e[i]) &gt; <span class="number">3</span> &#123;</span><br><span class="line">e[i] = e[i][:<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(edges); i++ &#123;</span><br><span class="line">x, y := edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(e[x]); j++ &#123;</span><br><span class="line"><span class="keyword">for</span> k:=<span class="number">0</span>; k&lt;<span class="built_in">len</span>(e[y]); k++ &#123;</span><br><span class="line"><span class="keyword">if</span> e[x][j].to != e[y][k].to &amp;&amp; e[x][j].to != y &amp;&amp; e[y][k].to != x &#123;</span><br><span class="line">ret = max(ret, e[x][j].score+scores[x]+scores[y]+e[y][k].score)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是对 2022.04.16 双周赛的回顾&lt;/p&gt;
&lt;h2 id=&quot;LeetCode6060-找到最接近-0-的数字&quot;&gt;&lt;a href=&quot;#LeetCode6060-找到最接近-0-的数字&quot; class=&quot;headerlink&quot; title=&quot;LeetCode6060. </summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 14）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/16/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2014%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/16/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2014%EF%BC%89/</id>
    <published>2022-04-16T03:00:00.000Z</published>
    <updated>2022-04-16T03:46:14.009Z</updated>
    
    <content type="html"><![CDATA[<p>又没早起，上海这疫情何时是个头啊😮‍💨</p><h2 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a class="link" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值<i class="fas fa-external-link-alt"></i></a></h2><p>#动态规划 </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt; grid.length &lt;&#x3D; 200</span><br><span class="line">0 &lt; grid[0].length &lt;&#x3D; 200</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 使用 BFS —— 爆内存；<br>(2). 使用 DFS —— 超时；<br>(3). 那就老老实实动态规划吧。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(M*N)</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxValue</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(grid))</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(grid); i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(grid[<span class="number">0</span>]); i++ &#123;</span><br><span class="line">dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-1</span>] + grid[<span class="number">0</span>][i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(grid); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;<span class="built_in">len</span>(grid[<span class="number">0</span>]); j++ &#123;</span><br><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i][j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[<span class="built_in">len</span>(grid)<span class="number">-1</span>][<span class="built_in">len</span>(grid[<span class="number">0</span>])<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode245-最短单词距离-III"><a href="#LeetCode245-最短单词距离-III" class="headerlink" title="LeetCode245. 最短单词距离 III"></a><a class="link" href="https://leetcode-cn.com/problems/shortest-word-distance-iii/">LeetCode245. 最短单词距离 III<i class="fas fa-external-link-alt"></i></a></h2><p>#数组 </p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个字符串数组 wordsDict 和两个字符串 word1 和 word2 ，返回列表中这两个单词之间的最短距离。<br>注意：word1 和 word2 是有可能相同的，并且它们将分别表示为列表中 两个独立的单词 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：wordsDict &#x3D; [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;], word1 &#x3D; &quot;makes&quot;, word2 &#x3D; &quot;coding&quot;</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：wordsDict &#x3D; [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;], word1 &#x3D; &quot;makes&quot;, word2 &#x3D; &quot;makes&quot;</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; wordsDict.length &lt;&#x3D; 105</span><br><span class="line">1 &lt;&#x3D; wordsDict[i].length &lt;&#x3D; 10</span><br><span class="line">wordsDict[i] 由小写英文字母组成</span><br><span class="line">word1 和 word2 都在 wordsDict 中</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 分两种情况讨论，当 <code>word1 == word2</code> 时 和 <code>word1 != word2</code> 时；<br>(2). 当 <code>word1 == word2</code> 时，遍历 <code>wordDict</code>，将 <code>word1</code> 的索引号用数组保存，之后再通过一次遍历，计算相邻索引号最小的差；<br>(3). 当 <code>word1 != word2</code> 时，通过两个标记 <code>idx1</code> 和 <code>idx2</code>，分别记录下每次出现 <code>word1</code> 和 <code>word2</code> 的索引号，然后通过一次遍历 <code>wordDict</code>，计算出最小的差。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortestWordDistance</span><span class="params">(wordsDict []<span class="keyword">string</span>, word1 <span class="keyword">string</span>, word2 <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">idx1, idx2 := <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">ret := math.MaxInt32</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> word1 == word2 &#123;</span><br><span class="line">l := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(wordsDict); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> wordsDict[i] == word1 &#123;</span><br><span class="line">l = <span class="built_in">append</span>(l, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(l); i++ &#123;</span><br><span class="line">ret = min(ret, l[i]-l[i<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(wordsDict); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> wordsDict[i] == word1 &#123;</span><br><span class="line">idx1 = i</span><br><span class="line"><span class="keyword">if</span> idx2 != <span class="number">-1</span> &#123;</span><br><span class="line">ret = min(ret, abs(idx1,idx2))</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> wordsDict[i] == word2 &#123;</span><br><span class="line">idx2 = i</span><br><span class="line"><span class="keyword">if</span> idx1 != <span class="number">-1</span> &#123;</span><br><span class="line">ret = min(ret, abs(idx1,idx2))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a-b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b-a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;又没早起，上海这疫情何时是个头啊😮‍💨&lt;/p&gt;
&lt;h2 id=&quot;剑指-Offer-47-礼物的最大价值&quot;&gt;&lt;a href=&quot;#剑指-Offer-47-礼物的最大价值&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 47. 礼物的最大价值&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 13）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/15/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2013%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/15/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2013%EF%BC%89/</id>
    <published>2022-04-14T23:00:00.000Z</published>
    <updated>2022-04-15T00:35:25.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode366-寻找二叉树的叶子节点"><a href="#LeetCode366-寻找二叉树的叶子节点" class="headerlink" title="LeetCode366. 寻找二叉树的叶子节点"></a><a class="link" href="https://leetcode-cn.com/problems/find-leaves-of-binary-tree/">LeetCode366. 寻找二叉树的叶子节点<i class="fas fa-external-link-alt"></i></a></h2><p>#二叉树 #DFS </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一棵二叉树，请按以下要求的顺序收集它的全部节点：</p><ol><li> 依次从左到右，每次收集并删除所有的叶子节点</li><li> 重复如上过程直到整棵树为空</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">  </span><br><span class="line">          1</span><br><span class="line">         &#x2F; \</span><br><span class="line">        2   3</span><br><span class="line">       &#x2F; \     </span><br><span class="line">      4   5    </span><br><span class="line"></span><br><span class="line">输出: [[4,5,3],[2],[1]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">1. 删除叶子节点 [4,5,3] ，得到如下树结构：</span><br><span class="line"></span><br><span class="line">          1</span><br><span class="line">         &#x2F; </span><br><span class="line">        2          </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">2. 现在删去叶子节点 [2] ，得到如下树结构：</span><br><span class="line"></span><br><span class="line">          1          </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">3. 现在删去叶子节点 [1] ，得到空树：</span><br><span class="line"></span><br><span class="line">          []         </span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 将叶子结点收集的过程相当于是收集树高相同的节点，所以只需要统计每个节点的高度并且将相同高度的节点加入同一索引的数组中；<br>(2). 创建一个二维数组 <code>ret [][]int</code> 来保存所有叶子结点，当节点的高度小于 <code>len(ret)</code> 时，可以直接在对应的高度索引数组中插入节点的值；否则就要 <code>append</code> <code>ret</code>  的长度。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Left *TreeNode</span></span><br><span class="line"><span class="comment">* Right *TreeNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLeaves</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">ret := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> backTracking <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span> <span class="title">int</span></span></span><br><span class="line">backTracking = <span class="function"><span class="keyword">func</span><span class="params">(p *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">height := <span class="number">1</span>+max(backTracking(p.Left), backTracking(p.Right))</span><br><span class="line"><span class="keyword">if</span> height &lt; <span class="built_in">len</span>(ret) &#123;</span><br><span class="line">ret[height] = <span class="built_in">append</span>(ret[height], p.Val)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, []<span class="keyword">int</span>&#123;p.Val&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">backTracking(root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode474-一和零"><a href="#LeetCode474-一和零" class="headerlink" title="LeetCode474. 一和零"></a><a class="link" href="https://leetcode-cn.com/problems/ones-and-zeroes/">LeetCode474. 一和零<i class="fas fa-external-link-alt"></i></a></h2><p>#动态规划 </p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。<br>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。<br>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：strs &#x3D; [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m &#x3D; 5, n &#x3D; 3</span><br><span class="line">输出：4</span><br><span class="line">解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。</span><br><span class="line">其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：strs &#x3D; [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m &#x3D; 1, n &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; strs.length &lt;&#x3D; 600</span><br><span class="line">1 &lt;&#x3D; strs[i].length &lt;&#x3D; 100</span><br><span class="line">strs[i] 仅由 &#39;0&#39; 和 &#39;1&#39; 组成</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 100</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 这道题可以看作是背包问题，但是和经典的背包问题只有一种容量不同，这道题有两种容量，即选取的字符串子集中的 0 和 1 的数量上限；<br>(2). 经典的背包问题可以使用二维动态规划求解，两个维度分别是物品和容量。这道题有两种容量，因此需要使用三维动态规划求解，三个维度分别是字符串、0 的容量和 1 的容量；<br>(3). 定义三维数组 <code>dp</code>，其中 <code>dp[i][j][k]</code> 表示在前 i 个字符串中，使用 j 个 0 和 k 个 1 的情况下最多可以得到的字符串数量。假设数组 <code>strs</code> 的长度为 l，则最终答案为 <code>dp[l][m][n]</code>。<br>(4). 当 0 和 1 的容量分别是 j 和 k 时，考虑以下两种情况：</p><ul><li>如果 <code>j&lt;zeros</code> 或 <code>k&lt;ones</code>，则不能选第 i 个字符串，此时有 <code>dp[i][j][k]=dp[i−1][j][k]</code>；</li><li>如果<code>j≥zeros</code> 且 <code>k≥ones</code>，则如果不选第 i 个字符串，有 <code>dp[i][j][k]=dp[i−1][j][k]</code>，如果选第 i 个字符串，有 <code>dp[i][j][k]=dp[i−1][j−zeros][k−ones]+1</code>，<code>dp[i][j][k]</code> 的值应取上面两项中的最大值。<br>因此状态转移方程如下：<br>$d p[i][j][k]= \begin{cases}d p[i-1][j][k], &amp; j&lt;\text { zeros } \mid k&lt;\text { ones } \ \max (d p[i-1][j][k], d p[i-1][j-\text { zeros }][k-\text { ones }]+1), &amp; j \geq \text { zeros } &amp; k \geq \text { ones }\end{cases}$</li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(L*M*N)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxForm</span><span class="params">(strs []<span class="keyword">string</span>, m <span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([][][]<span class="keyword">int</span>, <span class="built_in">len</span>(strs)+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numCount <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line">numCount = <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">zeros, ones := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">zeros++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ones++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> zeros, ones</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=<span class="built_in">len</span>(strs); i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([][]<span class="keyword">int</span>, m+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;=m; j++ &#123;</span><br><span class="line">dp[i][j] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k:=<span class="number">0</span>; k&lt;=n; k++ &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">dp[i][j][k] = <span class="number">0</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">zeros, ones := numCount(strs[i<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">if</span> j&lt;zeros || k&lt;ones &#123;</span><br><span class="line">dp[i][j][k] = dp[i<span class="number">-1</span>][j][k]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j][k] = max(dp[i<span class="number">-1</span>][j][k], dp[i<span class="number">-1</span>][j-zeros][k-ones]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[<span class="built_in">len</span>(strs)][m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LeetCode366-寻找二叉树的叶子节点&quot;&gt;&lt;a href=&quot;#LeetCode366-寻找二叉树的叶子节点&quot; class=&quot;headerlink&quot; title=&quot;LeetCode366. 寻找二叉树的叶子节点&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot; hre</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>GFS 论文阅读</title>
    <link href="http://jiahaohong1997.github.io/2022/04/14/GFS%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://jiahaohong1997.github.io/2022/04/14/GFS%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2022-04-14T11:40:00.000Z</published>
    <updated>2022-04-16T16:55:58.404Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本文是阅读了 《The Google File System》论文，并且学习了 MIT6.824 之后的总结。</p><h1 id="分布式存储系统的难点"><a href="#分布式存储系统的难点" class="headerlink" title="分布式存储系统的难点"></a>分布式存储系统的难点</h1><p>&emsp;&emsp;下面这幅图很好的展示了分布式系统在设计中绕不开的三个话题 —— <strong>高性能</strong>、<strong>高容错</strong>、以及系统的<strong>一致性</strong>问题 之间的关系。<br><img lazyload src="/images/loading.svg" data-src="whyhard.png" alt="avatar"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;本文是阅读了 《The Google File System》论文，并且学习了 MIT6.824 之后的总结。&lt;/p&gt;
&lt;h1 id=&quot;分布式存储系统的难点&quot;&gt;&lt;a href=&quot;#分布式存储系统的难点&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="分布式系统" scheme="http://jiahaohong1997.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="mit6.824" scheme="http://jiahaohong1997.github.io/tags/mit6-824/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 12）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/14/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2012%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/14/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2012%EF%BC%89/</id>
    <published>2022-04-14T02:00:00.000Z</published>
    <updated>2022-04-14T07:12:47.740Z</updated>
    
    <content type="html"><![CDATA[<p>今日未早起，淦！</p><h2 id="LeetCode1151-最少交换次数来组合所有的-1"><a href="#LeetCode1151-最少交换次数来组合所有的-1" class="headerlink" title="LeetCode1151. 最少交换次数来组合所有的 1"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together/">LeetCode1151. 最少交换次数来组合所有的 1<i class="fas fa-external-link-alt"></i></a></h2><p>#滑动窗口</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给出一个二进制数组 <code>data</code>，你需要通过交换位置，将数组中 <strong>任何位置</strong> 上的 1 组合到一起，并返回所有可能中所需 <strong>最少的交换次数</strong>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: data &#x3D; [1,0,1,0,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">有三种可能的方法可以把所有的 1 组合在一起：</span><br><span class="line">[1,1,1,0,0]，交换 1 次；</span><br><span class="line">[0,1,1,1,0]，交换 2 次；</span><br><span class="line">[0,0,1,1,1]，交换 1 次。</span><br><span class="line">所以最少的交换次数为 1。</span><br><span class="line"></span><br><span class="line">示例  2:</span><br><span class="line">输入：data &#x3D; [0,0,0,1,0]</span><br><span class="line">输出：0</span><br><span class="line">解释： </span><br><span class="line">由于数组中只有一个 1，所以不需要交换。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入：data &#x3D; [1,0,1,0,1,0,0,1,1,0,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">交换 3 次，一种可行的只用 3 次交换的解决方案是 [0,0,0,0,0,1,1,1,1,1,1]。</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: data &#x3D; [1,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1]</span><br><span class="line">输出: 8</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line">1 &lt;&#x3D; data.length &lt;&#x3D; 105</span><br><span class="line">data[i] &#x3D;&#x3D; 0 or 1.</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 我们需要得到的输出的最终效果是数组中所有的 $1$ 都被聚集于一个子数组中，这个子数组的长度就是数组中所有 $1$ 的数量 <code>totalOnes</code>；<br>(2). 那么我们只需要判断所有长度等于 <code>totalOnes</code> 的子数组中含有 $1$ 最多的个数是多少就可以了，因为 $0$ 的个数就是需要交换的最少次数；<br>(3). 怎么快速的统计所有该长度的子数组的含 $1$ 数量呢？这里就可以使用滑动窗口；<br>(4). 首先统计第一个窗口内 $1$ 的个数，之后只需要移动滑动窗口，再分别加上移入窗口和移出窗口的元素即可，避免了对每个窗口遍历统计。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSwaps</span><span class="params">(data []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">totalOnes := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> data[i] == <span class="number">1</span> &#123;</span><br><span class="line">totalOnes++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l, r := <span class="number">0</span>, totalOnes</span><br><span class="line">countOnes := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=l; i&lt;r; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> data[i] == <span class="number">1</span> &#123;</span><br><span class="line">countOnes++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">maxWindowOnes := countOnes</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r &lt; <span class="built_in">len</span>(data) &#123;</span><br><span class="line">x := data[r]</span><br><span class="line">r++</span><br><span class="line"></span><br><span class="line">countOnes += x-data[l]</span><br><span class="line">maxWindowOnes = max(maxWindowOnes, countOnes)</span><br><span class="line"></span><br><span class="line">l++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> totalOnes-maxWindowOnes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="249-移位字符串分组"><a href="#249-移位字符串分组" class="headerlink" title="249. 移位字符串分组"></a><a class="link" href="https://leetcode-cn.com/problems/group-shifted-strings/">249. 移位字符串分组<i class="fas fa-external-link-alt"></i></a></h2><p>#map #字符串 </p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个字符串，对该字符串可以进行 “移位” 的操作，也就是将字符串中每个字母都变为其在字母表中后续的字母，比如：”abc” -&gt; “bcd”。这样，我们可以持续进行 “移位” 操作，从而生成如下移位序列：<br><code>&quot;abc&quot; -&gt; &quot;bcd&quot; -&gt; ... -&gt; &quot;xyz&quot;</code><br>给定一个包含仅小写字母字符串的列表，将该列表中所有满足 “移位” 操作规律的组合进行分组并返回。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[&quot;abc&quot;, &quot;bcd&quot;, &quot;acef&quot;, &quot;xyz&quot;, &quot;az&quot;, &quot;ba&quot;, &quot;a&quot;, &quot;z&quot;]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [&quot;abc&quot;,&quot;bcd&quot;,&quot;xyz&quot;],</span><br><span class="line">  [&quot;az&quot;,&quot;ba&quot;],</span><br><span class="line">  [&quot;acef&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;z&quot;]</span><br><span class="line">]</span><br><span class="line">解释：可以认为字母表首尾相接，所以 &#39;z&#39; 的后续为 &#39;a&#39;，所以 [&quot;az&quot;,&quot;ba&quot;] 也满足 “移位” 操作规律。</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 对于初始字符串数组中给定的所有元素，我们都要找到其对应的所有变换后的字符串，然后再在初始字符串数组中查找是否有这些变换后的字符串；<br>(2). 对于查找操作，用 <code>map</code> 是时间代价最小的方式，所以我们要先遍历整个字符串数组，将所有字符串存入 <code>map</code> 中；<br>(4). 在对某一个序列中应该出现的所有字符串的形态都进行查找后，再次遍历到属于该序列的某一个字符串时，就不用重新查找整个序列。所以要再使用一个 <code>map</code> 来记录已经遍历过且在初始字符串数组中的元素，因为存在重复元素，所以 <code>map</code> 的 <code>value</code> 要使用 <code>int</code> 类型记录出现的次数，并且在生成序列的时候要生成对应次数的该字符串；<br>(5). 因为最终的序列要按照字典序排列，那么对于遍历到的某一个元素，要在其序列的头部插入字典序在其前面的字符串，在其后面插入字典序在其后面的字符串。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(26*N)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">groupStrings</span><span class="params">(strings []<span class="keyword">string</span>)</span> [][]<span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">traveled := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(strings); i++ &#123;</span><br><span class="line">m[strings[i]] = <span class="literal">true</span></span><br><span class="line">traveled[strings[i]]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> judgeUp <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line">judgeUp = <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ret <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">x := s[i]</span><br><span class="line"><span class="keyword">if</span> x == <span class="string">&#x27;a&#x27;</span> &#123;</span><br><span class="line">ret += <span class="string">&quot;z&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret += <span class="keyword">string</span>(x<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> judgeDown <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line">judgeDown = <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ret <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">x := s[i]</span><br><span class="line"><span class="keyword">if</span> x == <span class="string">&#x27;z&#x27;</span> &#123;</span><br><span class="line">ret += <span class="string">&quot;a&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret += <span class="keyword">string</span>(x+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret := [][]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(strings); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> traveled[strings[i]] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">x := strings[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x[<span class="number">0</span>] != <span class="string">&#x27;a&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> m[x] &#123;</span><br><span class="line"><span class="keyword">for</span> traveled[x] &gt; <span class="number">0</span> &#123;</span><br><span class="line">t = <span class="built_in">append</span>([]<span class="keyword">string</span>&#123;x&#125;, t...)</span><br><span class="line">traveled[x]--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">x = judgeUp(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m[x] &amp;&amp; traveled[x] &gt; <span class="number">0</span> &#123;</span><br><span class="line">t = <span class="built_in">append</span>([]<span class="keyword">string</span>&#123;x&#125;, t...)</span><br><span class="line">traveled[x]--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x = judgeDown(strings[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x[<span class="number">0</span>] != <span class="string">&#x27;z&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> m[x] &#123;</span><br><span class="line"><span class="keyword">for</span> traveled[x] &gt; <span class="number">0</span> &#123;</span><br><span class="line">t = <span class="built_in">append</span>(t, x)</span><br><span class="line">traveled[x]--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">x = judgeDown(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x[<span class="number">0</span>] == <span class="string">&#x27;z&#x27;</span> &amp;&amp; m[x] &amp;&amp; traveled[x] &gt; <span class="number">0</span> &#123;</span><br><span class="line">t = <span class="built_in">append</span>(t, x)</span><br><span class="line">traveled[x]--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">append</span>(ret, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a class="link" href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵<i class="fas fa-external-link-alt"></i></a></h2><p>#模拟题 </p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="spiral1.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="spiral2.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">m &#x3D;&#x3D; matrix.length</span><br><span class="line">n &#x3D;&#x3D; matrix[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 10</span><br><span class="line">-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 本题主要注意两点：如何确保外层矩阵不重复遍历；如果保证遍历的方向；<br>(2). 对于外层矩阵，可以采用四个变量 <code>left</code>、<code>right</code>、<code>top</code>、<code>bottom</code> 限制矩阵的收缩范围；<br>(3). 对于最终行/列的遍历方向问题，设置两个 <code>bool</code> 变量 <code>down</code> 和 <code>turnRight</code>，在向下\右遍历过后，将这两个变量置为 <code>false</code>，否则置为 <code>true</code>，就能保证下次是和上次相反的遍历方向。</p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(M*N)</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">high = <span class="number">0</span></span><br><span class="line">low = <span class="built_in">len</span>(matrix)<span class="number">-1</span></span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = <span class="built_in">len</span>(matrix[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ret := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">down := <span class="literal">true</span></span><br><span class="line">turnRight := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &gt;= high &amp;&amp; right &gt;= left &#123;</span><br><span class="line"><span class="keyword">if</span> low == high &#123;</span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> turnRight &#123;</span><br><span class="line">x, y = left, right</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x, y = right, left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := x; i &lt;= y; i++ &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, matrix[low][i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> left == right &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> down &#123;</span><br><span class="line">x, y = high, low</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x, y = low, high</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=x; i&lt;=y; i++ &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, matrix[i][left])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := left; i&lt;right; i++ &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, matrix[high][i])</span><br><span class="line">turnRight = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=high; i&lt;low; i++ &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, matrix[i][right])</span><br><span class="line">down = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=right; i&gt;left; i-- &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, matrix[low][i])</span><br><span class="line">turnRight = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=low; i&gt;high; i-- &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, matrix[i][left])</span><br><span class="line">down = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">high++</span><br><span class="line">left++</span><br><span class="line">low--</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今日未早起，淦！&lt;/p&gt;
&lt;h2 id=&quot;LeetCode1151-最少交换次数来组合所有的-1&quot;&gt;&lt;a href=&quot;#LeetCode1151-最少交换次数来组合所有的-1&quot; class=&quot;headerlink&quot; title=&quot;LeetCode1151. 最少交换次数来组</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 11）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/13/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2011%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/13/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2011%EF%BC%89/</id>
    <published>2022-04-12T22:00:00.000Z</published>
    <updated>2022-04-13T00:16:01.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode353-贪吃蛇"><a href="#LeetCode353-贪吃蛇" class="headerlink" title="LeetCode353. 贪吃蛇"></a><a class="link" href="https://leetcode-cn.com/problems/design-snake-game/">LeetCode353. 贪吃蛇<i class="fas fa-external-link-alt"></i></a></h2><p>#队列 #设计题</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>请你设计一个 贪吃蛇游戏，该游戏将会在一个 屏幕尺寸 = 宽度 x 高度 的屏幕上运行。如果你不熟悉这个游戏，可以 点击这里 在线试玩。<br>起初时，蛇在左上角的 (0, 0) 位置，身体长度为 1 个单位。<br>你将会被给出一个数组形式的食物位置序列 food ，其中 food[i] = (ri, ci) 。当蛇吃到食物时，身子的长度会增加 1 个单位，得分也会 +1 。<br>食物不会同时出现，会按列表的顺序逐一显示在屏幕上。比方讲，第一个食物被蛇吃掉后，第二个食物才会出现。<br>当一个食物在屏幕上出现时，保证 不会 出现在被蛇身体占据的格子里。<br>如果蛇越界（与边界相撞）或者头与 移动后 的身体相撞（即，身长为 4 的蛇无法与自己相撞），游戏结束。</p></blockquote><blockquote><p>实现 <code>SnakeGame</code> 类：<br>SnakeGame(int width, int height, int[][] food) 初始化对象，屏幕大小为 height x width ，食物位置序列为 food<br>int move(String direction) 返回蛇在方向 direction 上移动后的得分。如果游戏结束，返回 -1 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="snake.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;SnakeGame&quot;, &quot;move&quot;, &quot;move&quot;, &quot;move&quot;, &quot;move&quot;, &quot;move&quot;, &quot;move&quot;]</span><br><span class="line">[[3, 2, [[1, 2], [0, 1]]], [&quot;R&quot;], [&quot;D&quot;], [&quot;R&quot;], [&quot;U&quot;], [&quot;L&quot;], [&quot;U&quot;]]</span><br><span class="line">输出：</span><br><span class="line">[null, 0, 0, 1, 1, 2, -1]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">SnakeGame snakeGame &#x3D; new SnakeGame(3, 2, [[1, 2], [0, 1]]);</span><br><span class="line">snakeGame.move(&quot;R&quot;); &#x2F;&#x2F; 返回 0</span><br><span class="line">snakeGame.move(&quot;D&quot;); &#x2F;&#x2F; 返回 0</span><br><span class="line">snakeGame.move(&quot;R&quot;); &#x2F;&#x2F; 返回 1 ，蛇吃掉了第一个食物，同时第二个食物出现在 (0, 1)</span><br><span class="line">snakeGame.move(&quot;U&quot;); &#x2F;&#x2F; 返回 1</span><br><span class="line">snakeGame.move(&quot;L&quot;); &#x2F;&#x2F; 返回 2 ，蛇吃掉了第二个食物，没有出现更多食物</span><br><span class="line">snakeGame.move(&quot;U&quot;); &#x2F;&#x2F; 返回 -1 ，蛇与边界相撞，游戏结束</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; width, height &lt;&#x3D; 104</span><br><span class="line">1 &lt;&#x3D; food.length &lt;&#x3D; 50</span><br><span class="line">food[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; ri &lt; height</span><br><span class="line">0 &lt;&#x3D; ci &lt; width</span><br><span class="line">direction.length &#x3D;&#x3D; 1</span><br><span class="line">direction is &#39;U&#39;, &#39;D&#39;, &#39;L&#39;, or &#39;R&#39;.</span><br><span class="line">最多调用 104 次 move 方法</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先明确结构体中需要什么元素，首先需要一个二维数组来记录蛇身体在的位置，其次还需要一个索引号来记录当前出现的食物是第几个；<br>(2). 在移动的过程中，首先要根据移动的方向确认🐍头应该出现在的新位置的坐标是否在界限内。然后根据食物应该出现的位置（或者食物被吃完）确定🐍头是否碰触到食物；<br>(3). 如果碰触到，那么就吃掉，并且食物索引号 +1；如果没有碰触到，那么就判断是否会“咬到”自己的身体。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SnakeGame <span class="keyword">struct</span> &#123;</span><br><span class="line">snakePos [][]<span class="keyword">int</span></span><br><span class="line">width <span class="keyword">int</span></span><br><span class="line">height <span class="keyword">int</span></span><br><span class="line">food [][]<span class="keyword">int</span></span><br><span class="line">foodIndex <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(width <span class="keyword">int</span>, height <span class="keyword">int</span>, food [][]<span class="keyword">int</span>)</span> <span class="title">SnakeGame</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> SnakeGame &#123;</span><br><span class="line">snakePos : [][]<span class="keyword">int</span>&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;&#125;,</span><br><span class="line">width : width,</span><br><span class="line">height : height,</span><br><span class="line">food : food,</span><br><span class="line">foodIndex : <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SnakeGame)</span> <span class="title">Move</span><span class="params">(direction <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">h, w := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">switch</span> direction &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;R&quot;</span>:</span><br><span class="line">h, w = this.snakePos[<span class="number">0</span>][<span class="number">0</span>], this.snakePos[<span class="number">0</span>][<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;L&quot;</span>:</span><br><span class="line">h, w = this.snakePos[<span class="number">0</span>][<span class="number">0</span>], this.snakePos[<span class="number">0</span>][<span class="number">1</span>]<span class="number">-1</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;U&quot;</span>:</span><br><span class="line">h, w = this.snakePos[<span class="number">0</span>][<span class="number">0</span>]<span class="number">-1</span>, this.snakePos[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;D&quot;</span>:</span><br><span class="line">h, w = this.snakePos[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1</span>, this.snakePos[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (h &lt; <span class="number">0</span> || h &gt;= this.height) || (w &lt; <span class="number">0</span> || w &gt;= this.width) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.snakePos = <span class="built_in">append</span>([][]<span class="keyword">int</span>&#123;&#123;h,w&#125;&#125;, this.snakePos...)</span><br><span class="line"><span class="keyword">if</span> this.foodIndex &lt; <span class="built_in">len</span>(this.food) &#123;</span><br><span class="line"><span class="keyword">if</span> h == this.food[this.foodIndex][<span class="number">0</span>] &amp;&amp; w == this.food[this.foodIndex][<span class="number">1</span>] &#123;</span><br><span class="line">this.foodIndex++</span><br><span class="line"><span class="keyword">return</span> this.foodIndex</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">this.snakePos = this.snakePos[:<span class="built_in">len</span>(this.snakePos)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(this.snakePos); i++ &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> this.snakePos[i][<span class="number">0</span>] == h &amp;&amp; this.snakePos[i][<span class="number">1</span>] == w &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> this.foodIndex</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">this.snakePos = this.snakePos[:<span class="built_in">len</span>(this.snakePos)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(this.snakePos); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> this.snakePos[i][<span class="number">0</span>] == h &amp;&amp; this.snakePos[i][<span class="number">1</span>] == w &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> this.foodIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your SnakeGame object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* obj := Constructor(width, height, food);</span></span><br><span class="line"><span class="comment">* param_1 := obj.Move(direction);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="LeetCode256-粉刷房子"><a href="#LeetCode256-粉刷房子" class="headerlink" title="LeetCode256. 粉刷房子"></a><a class="link" href="https://leetcode-cn.com/problems/paint-house/">LeetCode256. 粉刷房子<i class="fas fa-external-link-alt"></i></a></h2><p>#动态规划</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。<br>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。<br>例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。<br>请计算出粉刷完所有房子最少的花费成本。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: costs &#x3D; [[17,2,17],[16,16,5],[14,3,19]]</span><br><span class="line">输出: 10</span><br><span class="line">解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。</span><br><span class="line">     最少花费: 2 + 5 + 3 &#x3D; 10。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">示例 2：</span><br><span class="line">输入: costs &#x3D; [[7,6,2]]</span><br><span class="line">输出: 2</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line">costs.length &#x3D;&#x3D; n</span><br><span class="line">costs[i].length &#x3D;&#x3D; 3</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 100</span><br><span class="line">1 &lt;&#x3D; costs[i][j] &lt;&#x3D; 20</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>动态规划，实时更新分别使用三种油漆作为最后一栋房子的结果。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCost</span><span class="params">(costs [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">a, b, c := costs[<span class="number">0</span>][<span class="number">0</span>], costs[<span class="number">0</span>][<span class="number">1</span>], costs[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(costs); i++ &#123;</span><br><span class="line">a, b, c = min(b, c)+costs[i][<span class="number">0</span>], min(a, c)+costs[i][<span class="number">1</span>], min(a, b)+costs[i][<span class="number">2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> min(a, min(b, c))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode186-翻转字符串里的单词-II"><a href="#LeetCode186-翻转字符串里的单词-II" class="headerlink" title="LeetCode186. 翻转字符串里的单词 II"></a><a class="link" href="https://leetcode-cn.com/problems/reverse-words-in-a-string-ii/">LeetCode186. 翻转字符串里的单词 II<i class="fas fa-external-link-alt"></i></a></h2><p>#字符串 #双指针</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个字符串，逐个翻转字符串中的每个单词。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入: [&quot;t&quot;,&quot;h&quot;,&quot;e&quot;,&quot; &quot;,&quot;s&quot;,&quot;k&quot;,&quot;y&quot;,&quot; &quot;,&quot;i&quot;,&quot;s&quot;,&quot; &quot;,&quot;b&quot;,&quot;l&quot;,&quot;u&quot;,&quot;e&quot;]</span><br><span class="line">输出: [&quot;b&quot;,&quot;l&quot;,&quot;u&quot;,&quot;e&quot;,&quot; &quot;,&quot;i&quot;,&quot;s&quot;,&quot; &quot;,&quot;s&quot;,&quot;k&quot;,&quot;y&quot;,&quot; &quot;,&quot;t&quot;,&quot;h&quot;,&quot;e&quot;]</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">单词的定义是不包含空格的一系列字符</span><br><span class="line">输入字符串中不会包含前置或尾随的空格</span><br><span class="line">单词与单词之间永远是以单个空格隔开的</span><br><span class="line"></span><br><span class="line">进阶：使用 O(1) 额外空间复杂度的原地解法。</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>单词以空格分隔，先对每个单词进行reverse，再对整个字符串reverse，即可得到翻转单词顺序，但是单词中字母顺序不变的效果。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(s []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reverse <span class="function"><span class="keyword">func</span><span class="params">([]<span class="keyword">byte</span>)</span></span></span><br><span class="line">reverse = <span class="function"><span class="keyword">func</span><span class="params">(b []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(b)/<span class="number">2</span>; i++ &#123;</span><br><span class="line">b[i], b[<span class="built_in">len</span>(b)-i<span class="number">-1</span>] = b[<span class="built_in">len</span>(b)-i<span class="number">-1</span>], b[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="built_in">len</span>(s) || s[i] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">reverse(s[first:i])</span><br><span class="line">first = i+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LeetCode353-贪吃蛇&quot;&gt;&lt;a href=&quot;#LeetCode353-贪吃蛇&quot; class=&quot;headerlink&quot; title=&quot;LeetCode353. 贪吃蛇&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode-c</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 10）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/11/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2010%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/11/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%2010%EF%BC%89/</id>
    <published>2022-04-10T22:00:00.000Z</published>
    <updated>2022-04-11T00:03:38.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode28-实现-strStr"><a href="#LeetCode28-实现-strStr" class="headerlink" title="LeetCode28. 实现 strStr()"></a><a class="link" href="https://leetcode-cn.com/problems/implement-strstr/">LeetCode28. 实现 strStr()<i class="fas fa-external-link-alt"></i></a></h2><p>#字符串</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>实现 strStr() 函数。<br>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。<br>说明：<br>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">输出：-1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：haystack &#x3D; &quot;&quot;, needle &#x3D; &quot;&quot;</span><br><span class="line">输出：0</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 104</span><br><span class="line">haystack 和 needle 仅由小写英文字符组成</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>直接一次遍历比对即可</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(M-N)$</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="keyword">string</span>, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">m, n := <span class="built_in">len</span>(haystack), <span class="built_in">len</span>(needle)</span><br><span class="line"><span class="keyword">if</span> m &lt; n &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;m-n+<span class="number">1</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> haystack[i:i+n] == needle &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode1442-形成两个异或相等数组的三元组数目"><a href="#LeetCode1442-形成两个异或相等数组的三元组数目" class="headerlink" title="LeetCode1442. 形成两个异或相等数组的三元组数目"></a><a class="link" href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/">LeetCode1442. 形成两个异或相等数组的三元组数目<i class="fas fa-external-link-alt"></i></a></h2><p>#位运算 #前缀异或</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个整数数组 arr 。<br>现需要从数组中取三个下标 i、j 和 k ，其中 (0 &lt;= i &lt; j &lt;= k &lt; arr.length) 。<br>a 和 b 定义如下：<br>a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1]<br>b = arr[j] ^ arr[j + 1] ^ … ^ arr[k]<br>注意：^ 表示 按位异或 操作。<br>请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：arr &#x3D; [2,3,1,6,7]</span><br><span class="line">输出：4</span><br><span class="line">解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：arr &#x3D; [1,1,1,1,1]</span><br><span class="line">输出：10</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：arr &#x3D; [2,3]</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：arr &#x3D; [1,3,5,7,9]</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 5：</span><br><span class="line">输入：arr &#x3D; [7,11,12,9,5,2,7,17,22]</span><br><span class="line">输出：8</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; arr.length &lt;&#x3D; 300</span><br><span class="line">1 &lt;&#x3D; arr[i] &lt;&#x3D; 10^8</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 一开始很直观想到枚举全部三元组，然后再根据规则，从 <code>i</code> 遍历到 <code>j-1</code>，再从 <code>j</code> 遍历到 <code>k</code> 来判断是否是合法三元组，但是时间复杂度是 $O(N^4)$；<br>(2). 然后思考优化的思路，那么在哪里可以简化呢？其实可以从异或的过程入手，我们可能比较熟悉 <code>前缀和</code> 了，那么同样可以思考到 <code>前缀异或</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">假设我们有数组 arr: [1, 2, 3, 4, 7, 9]; </span><br><span class="line">前零项的异或值为: 0 &#x3D; 0</span><br><span class="line">前一项的异或值为: 1 &#x3D; 1</span><br><span class="line">前二项的异或值为: 1 ⊕ 2 &#x3D; 3</span><br><span class="line">前三项的异或值为: 1 ⊕ 2 ⊕ 3 &#x3D; 0</span><br><span class="line">前四项的异或值为: 1 ⊕ 2 ⊕ 3 ⊕ 4 &#x3D; 4</span><br><span class="line">前五项的异或值为: 1 ⊕ 2 ⊕ 3 ⊕ 4 ⊕ 7 &#x3D; 3</span><br><span class="line">前六项的异或值为: 1 ⊕ 2 ⊕ 3 ⊕ 4 ⊕ 7 ⊕ 9 &#x3D; 10</span><br><span class="line"></span><br><span class="line">因此它的前缀异或数组为 preXOR: [0, 1, 3, 0, 4, 3, 10];</span><br><span class="line"></span><br><span class="line">假设现在我们想求第 3 项到第 6 项的异或值， 此时我们不需要去暴力计算 &quot;3 ⊕ 4 ⊕ 7 ⊕ 9&quot;</span><br><span class="line">我们知道 (3 ⊕ 4 ⊕ 7 ⊕ 9) &#x3D; (1 ⊕ 2) ⊕ (1 ⊕ 2 ⊕ 3 ⊕ 4 ⊕ 7 ⊕ 9) </span><br><span class="line">我们可以使用前缀异或的数组来计算第 3 项到第 6 项的异或值</span><br><span class="line">(1 ⊕ 2) 为前 2 项的异或值为 “3”</span><br><span class="line">(1 ⊕ 2 ⊕ 3 ⊕ 4 ⊕ 7 ⊕ 9) 为前 6 项异或值为 “10”</span><br><span class="line">因此第 3 项到第 6 项的异或值为：3 ⊕ 10 &#x3D; 9</span><br><span class="line">所有对于前缀异或我们同样也可以用O(1)的时间计算区间内的异或值</span><br></pre></td></tr></table></figure><p>这样可以有效节省时间开销，此时时间复杂度是 $O(N^3)$；<br>(3). 再考虑进行优化，利用异或的性质 题目让我们找到满足 <code>a == b</code> 的坐标，那么当 <code>a</code> 等于 <code>b</code> 时满足什么性质? <code>a ⊕ b = 0</code>! 我们就可以得到 <code>arr[i] ^...^ arr[j-1]^ arr[j] ^...^ arr[k] = 0</code>。因此在 <code>i</code> 之前的前缀异或值到 <code>k</code> 时不会变。因为<code>[i，k]</code> 的区间异或值为0，可以得到： <code>xor[i] == preXor[k+1]</code>。其另一点重点在于在区间 <code>[i, k]</code>内 <code>j</code> 在哪并不重要， 因为无论 <code>j</code> 在哪，<code>i</code> 到 <code>k</code> 的异或值都等于 0，不影响结果。此时时间复杂度是 <code>O(N^2)</code><br>(4). 对于下标 <code>k</code>，若下标 i=$i_1$,$i_2$,…,$i_m$ 时均满足 $xor_i$ = $xor_{k+1}$，根据之前方法，这些二元组 $(i_1,k),(i_2,k),…,(i_m,k)$对答案的贡献之和为:<br>$\left(k-i_{1}\right)+\left(k-i_{2}\right)+\cdots+\left(k-i_{m}\right)=m \cdot k-\left(i_{1}+i_{2}+\cdots+i_{m}\right)$<br>也就是说，当遍历下标 <code>k</code> 时，我们需要知道所有满足$xor_i$ = $xor_{k+1}$ 的</p><ul><li>下标 <code>i</code> 的出现次数 <code>m</code></li><li>下标 <code>i</code> 之和<br>我们可以在计算异或前缀和的同时计算答案，从而做到仅遍历 <code>arr</code> 一次就计算出答案。此时时间复杂度可以压缩到 $O(N)$</li></ul><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><p>暴力：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countTriplets</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">var</span> opration <span class="function"><span class="keyword">func</span><span class="params">(i, j, k <span class="keyword">int</span>)</span> <span class="title">bool</span></span>  </span><br><span class="line"> opration = <span class="function"><span class="keyword">func</span><span class="params">(i, j, k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;  </span><br><span class="line">a, b := <span class="number">0</span>, <span class="number">0</span>  </span><br><span class="line"><span class="keyword">for</span> idx1 := i; idx1 &lt;= j<span class="number">-1</span>; idx1++ &#123;  </span><br><span class="line"> a ^= arr[idx1]  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">for</span> idx2 := j; idx2 &lt;= k; idx2++ &#123;  </span><br><span class="line"> b ^= arr[idx2]  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a == b  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   count := <span class="number">0</span>  </span><br><span class="line"> path := []<span class="keyword">int</span>&#123;&#125;  </span><br><span class="line">   <span class="keyword">var</span> backTacking <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span>  </span><br><span class="line">   backTacking = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">      <span class="keyword">if</span> k == <span class="number">0</span> &#123;  </span><br><span class="line">         <span class="keyword">if</span> opration(path[<span class="number">0</span>], path[<span class="number">1</span>], path[<span class="number">2</span>]) &#123;  </span><br><span class="line">            <span class="comment">// fmt.Println(path)  </span></span><br><span class="line"> count++  </span><br><span class="line"> &#125;  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(arr); i++ &#123;  </span><br><span class="line">         path = <span class="built_in">append</span>(path, i)  </span><br><span class="line">         <span class="keyword">if</span> k == <span class="number">3</span> &#123;  </span><br><span class="line">            backTacking(i+<span class="number">1</span>, k<span class="number">-1</span>)  </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            backTacking(i, k<span class="number">-1</span>)  </span><br><span class="line">         &#125;  </span><br><span class="line">  </span><br><span class="line">         path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   backTacking(<span class="number">0</span>, <span class="number">3</span>)  </span><br><span class="line">   <span class="keyword">return</span> count  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力+前缀和优化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countTriplets</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;  </span><br><span class="line">  </span><br><span class="line">   xor := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(arr)+<span class="number">1</span>)  </span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="built_in">len</span>(arr); i++ &#123;  </span><br><span class="line">      xor[i] = xor[i<span class="number">-1</span>] ^ arr[i<span class="number">-1</span>]  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">var</span> opration <span class="function"><span class="keyword">func</span><span class="params">(i, j, k <span class="keyword">int</span>)</span> <span class="title">bool</span></span>  </span><br><span class="line"> opration = <span class="function"><span class="keyword">func</span><span class="params">(i, j, k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;  </span><br><span class="line">      a, b := <span class="number">0</span>, <span class="number">0</span>  </span><br><span class="line"> a = xor[j] ^ xor[i]  </span><br><span class="line">      b = xor[k+<span class="number">1</span>] ^ xor[j]  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> a == b  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   count := <span class="number">0</span>  </span><br><span class="line"> path := []<span class="keyword">int</span>&#123;&#125;  </span><br><span class="line">   <span class="keyword">var</span> backTacking <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span>  </span><br><span class="line">   backTacking = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">      <span class="keyword">if</span> k == <span class="number">0</span> &#123;  </span><br><span class="line">         <span class="keyword">if</span> opration(path[<span class="number">0</span>], path[<span class="number">1</span>], path[<span class="number">2</span>]) &#123;  </span><br><span class="line">            <span class="comment">// fmt.Println(path)  </span></span><br><span class="line"> count++  </span><br><span class="line"> &#125;  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(arr); i++ &#123;  </span><br><span class="line">         path = <span class="built_in">append</span>(path, i)  </span><br><span class="line">         <span class="keyword">if</span> k == <span class="number">3</span> &#123;  </span><br><span class="line">            backTacking(i+<span class="number">1</span>, k<span class="number">-1</span>)  </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            backTacking(i, k<span class="number">-1</span>)  </span><br><span class="line">         &#125;  </span><br><span class="line">  </span><br><span class="line">         path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   backTacking(<span class="number">0</span>, <span class="number">3</span>)  </span><br><span class="line">   <span class="keyword">return</span> count  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用异或性质两次遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countTriplets</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">xor := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(arr)+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=<span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">xor[i] = xor[i<span class="number">-1</span>]^arr[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(arr)<span class="number">-1</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> k:=i+<span class="number">1</span>; k&lt;<span class="built_in">len</span>(arr); k++ &#123;</span><br><span class="line"><span class="keyword">if</span> xor[i] == xor[k+<span class="number">1</span>] &#123;</span><br><span class="line">count += k-i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一次遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countTriplets</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="params">(ans <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">cnt := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">total := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">s := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, val := <span class="keyword">range</span> arr &#123;</span><br><span class="line"><span class="keyword">if</span> m, has := cnt[s^val]; has &#123;</span><br><span class="line">ans += m*k - total[s^val]</span><br><span class="line">&#125;</span><br><span class="line">cnt[s]++</span><br><span class="line">total[s] += k</span><br><span class="line">s ^= val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LeetCode28-实现-strStr&quot;&gt;&lt;a href=&quot;#LeetCode28-实现-strStr&quot; class=&quot;headerlink&quot; title=&quot;LeetCode28. 实现 strStr()&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot; href=&quot;h</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 9）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/10/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%209%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/10/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%209%EF%BC%89/</id>
    <published>2022-04-10T14:00:00.000Z</published>
    <updated>2022-04-10T15:25:45.257Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 2022.04.09 周赛的复盘</p><h2 id="LeetCode6037-按奇偶性交换后的最大数字"><a href="#LeetCode6037-按奇偶性交换后的最大数字" class="headerlink" title="LeetCode6037. 按奇偶性交换后的最大数字"></a><a class="link" href="https://leetcode-cn.com/problems/largest-number-after-digit-swaps-by-parity/">LeetCode6037. 按奇偶性交换后的最大数字<i class="fas fa-external-link-alt"></i></a></h2><p>#数组</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个正整数 <code>num</code> 。你可以交换 <code>num</code> 中 <strong>奇偶性</strong> 相同的任意两位数字（即，都是奇数或者偶数）。<br>返回交换 <strong>任意</strong> 次之后 <code>num</code> 的 <strong>最大</strong> 可能值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：num &#x3D; 1234</span><br><span class="line">输出：3412</span><br><span class="line">解释：交换数字 3 和数字 1 ，结果得到 3214 。</span><br><span class="line">交换数字 2 和数字 4 ，结果得到 3412 。</span><br><span class="line">注意，可能存在其他交换序列，但是可以证明 3412 是最大可能值。</span><br><span class="line">注意，不能交换数字 4 和数字 1 ，因为它们奇偶性不同。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：num &#x3D; 65875</span><br><span class="line">输出：87655</span><br><span class="line">解释：交换数字 8 和数字 6 ，结果得到 85675 。</span><br><span class="line">交换数字 5 和数字 7 ，结果得到 87655 。</span><br><span class="line">注意，可能存在其他交换序列，但是可以证明 87655 是最大可能值。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; num &lt;&#x3D; 109</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 初始化三个数组 <code>array</code>、<code>array1</code>、<code>array2</code>，<code>array</code>用于记录数字对应位置上是奇数还是偶数、<code>array1</code>用于保存并排序所有的偶数、<code>array2</code>用于保存并排序所有的奇数；<br>(2). 根据 <code>array</code> 保存的对应位置的奇偶行，从大到小依次取出<code>array1</code>或<code>array2</code> 中的数；</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestInteger</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">array1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">array2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">array := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">x := num % <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> x%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">array1 = <span class="built_in">append</span>(array1, x)</span><br><span class="line">array = <span class="built_in">append</span>(array, <span class="literal">true</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">array2 = <span class="built_in">append</span>(array2, x)</span><br><span class="line">array = <span class="built_in">append</span>(array, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num /= <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Ints(array1)</span><br><span class="line">sort.Ints(array2)</span><br><span class="line"></span><br><span class="line">ret := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="built_in">len</span>(array)<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">ret *= <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> array[i] &#123;</span><br><span class="line">ret += array1[<span class="built_in">len</span>(array1)<span class="number">-1</span>]</span><br><span class="line">array1 = array1[:<span class="built_in">len</span>(array1)<span class="number">-1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret += array2[<span class="built_in">len</span>(array2)<span class="number">-1</span>]</span><br><span class="line">array2 = array2[:<span class="built_in">len</span>(array2)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode6038-向表达式添加括号后的最小结果"><a href="#LeetCode6038-向表达式添加括号后的最小结果" class="headerlink" title="LeetCode6038. 向表达式添加括号后的最小结果"></a><a class="link" href="https://leetcode-cn.com/problems/minimize-result-by-adding-parentheses-to-expression/">LeetCode6038. 向表达式添加括号后的最小结果<i class="fas fa-external-link-alt"></i></a></h2><p>#字符串</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个下标从 0 开始的字符串 expression ，格式为 “&lt;num1&gt;+&lt;num2&gt;” ，其中 &lt;num1&gt; 和 &lt;num2&gt; 表示正整数。<br>请你向 expression 中添加一对括号，使得在添加之后， expression 仍然是一个有效的数学表达式，并且计算后可以得到 最小 可能值。左括号 必须 添加在 ‘+’ 的左侧，而右括号必须添加在 ‘+’ 的右侧。<br>返回添加一对括号后形成的表达式 expression ，且满足 expression 计算得到 最小 可能值。如果存在多个答案都能产生相同结果，返回任意一个答案。<br>生成的输入满足：expression 的原始值和添加满足要求的任一对括号之后 expression 的值，都符合 32-bit 带符号整数范围。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：expression &#x3D; &quot;247+38&quot;</span><br><span class="line">输出：&quot;2(47+38)&quot;</span><br><span class="line">解释：表达式计算得到 2 * (47 + 38) &#x3D; 2 * 85 &#x3D; 170 。</span><br><span class="line">注意 &quot;2(4)7+38&quot; 不是有效的结果，因为右括号必须添加在 &#39;+&#39; 的右侧。</span><br><span class="line">可以证明 170 是最小可能值。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：expression &#x3D; &quot;12+34&quot;</span><br><span class="line">输出：&quot;1(2+3)4&quot;</span><br><span class="line">解释：表达式计算得到 1 * (2 + 3) * 4 &#x3D; 1 * 5 * 4 &#x3D; 20 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：expression &#x3D; &quot;999+999&quot;</span><br><span class="line">输出：&quot;(999+999)&quot;</span><br><span class="line">解释：表达式计算得到 999 + 999 &#x3D; 1998 。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">3 &lt;&#x3D; expression.length &lt;&#x3D; 10</span><br><span class="line">expression 仅由数字 &#39;1&#39; 到 &#39;9&#39; 和 &#39;+&#39; 组成</span><br><span class="line">expression 由数字开始和结束</span><br><span class="line">expression 恰好仅含有一个 &#39;+&#39;.</span><br><span class="line">expression 的原始值和添加满足要求的任一对括号之后 expression 的值，都符合 32-bit 带符号整数范围</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先要完成一个对特定字符串结果的计算函数，这个函数主要是筛选出计算表达式的前中后三个部分即可；<br>(2). 分别将 “+” 前后的数字字符串提取出来，分别在可能的位置添加正反括号；<br>(3). 对于 ‘(‘ 而言，可能添加的位置在 <code>b1</code> 的 <code>[0,len(b1))</code>；<br>(3). 对于 ‘)’ 而言，可能添加的位置在 <code>b2</code> 的 <code>[1,len(b2)]</code>；</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><code>O(len(s1)*len(s2))</code></p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimizeResult</span><span class="params">(expression <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cal <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line">cal = <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">s1 := <span class="string">&quot;&quot;</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line">s1 += s[i:i+<span class="number">1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i++</span><br><span class="line">a, b, pre := <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> ; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; pre &#123;</span><br><span class="line">a += s[i:i+<span class="number">1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;+&#x27;</span> &#123;</span><br><span class="line">pre = <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; !pre &#123;</span><br><span class="line">b += s[i:i+<span class="number">1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> preNum <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> s1 == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">preNum = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">preNum, _ = strconv.Atoi(s1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mid1, _ := strconv.Atoi(a)</span><br><span class="line">mid2, _ := strconv.Atoi(b)</span><br><span class="line"></span><br><span class="line">s2 := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> ; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line">s2 += s[i:i+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s2 != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">lastNum, _ := strconv.Atoi(s2)</span><br><span class="line"><span class="keyword">return</span> preNum*(mid1+mid2)*lastNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> preNum*(mid1+mid2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str := strings.Split(expression, <span class="string">&quot;+&quot;</span>)</span><br><span class="line">x1, _ := strconv.Atoi((str[<span class="number">0</span>]))</span><br><span class="line">x2, _ := strconv.Atoi(str[<span class="number">1</span>])</span><br><span class="line">ret := x1+x2</span><br><span class="line">retS := <span class="string">&quot;(&quot;</span>+expression+<span class="string">&quot;)&quot;</span></span><br><span class="line"></span><br><span class="line">b1 := []<span class="keyword">byte</span>(str[<span class="number">0</span>])</span><br><span class="line">b2 := []<span class="keyword">byte</span>(str[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(b1); i++ &#123;</span><br><span class="line">b1 = <span class="built_in">append</span>(b1[:i], <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;<span class="string">&#x27;(&#x27;</span>&#125;, b1[i:]...)...)</span><br><span class="line"><span class="comment">// fmt.Println(b1)</span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;=<span class="built_in">len</span>(b2); j++ &#123;</span><br><span class="line"></span><br><span class="line">b2 = <span class="built_in">append</span>(b2[:j], <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;<span class="string">&#x27;)&#x27;</span>&#125;, b2[j:]...)...)</span><br><span class="line">t := cal(<span class="keyword">string</span>(b1)+<span class="string">&quot;+&quot;</span>+<span class="keyword">string</span>(b2))</span><br><span class="line"><span class="comment">//fmt.Println(string(b1)+&quot;+&quot;+string(b2), t)</span></span><br><span class="line"><span class="keyword">if</span> t &lt; ret &#123;</span><br><span class="line">ret = t</span><br><span class="line">retS = <span class="keyword">string</span>(b1)+<span class="string">&quot;+&quot;</span>+<span class="keyword">string</span>(b2)</span><br><span class="line">&#125;</span><br><span class="line">b2 = <span class="built_in">append</span>(b2[:j], b2[j+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b1 = <span class="built_in">append</span>(b1[:i], b1[i+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> retS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode6039-K-次增加后的最大乘积"><a href="#LeetCode6039-K-次增加后的最大乘积" class="headerlink" title="LeetCode6039. K 次增加后的最大乘积"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-product-after-k-increments/">LeetCode6039. K 次增加后的最大乘积<i class="fas fa-external-link-alt"></i></a></h2><p>#数组</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个非负整数数组 nums 和一个整数 k 。每次操作，你可以选择 nums 中 任一 元素并将它 增加 1 。<br>请你返回 至多 k 次操作后，能得到的 nums的 最大乘积 。由于答案可能很大，请你将答案对 109 + 7 取余后返回。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [0,4], k &#x3D; 5</span><br><span class="line">输出：20</span><br><span class="line">解释：将第一个数增加 5 次。</span><br><span class="line">得到 nums &#x3D; [5, 4] ，乘积为 5 * 4 &#x3D; 20 。</span><br><span class="line">可以证明 20 是能得到的最大乘积，所以我们返回 20 。</span><br><span class="line">存在其他增加 nums 的方法，也能得到最大乘积。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [6,3,3,2], k &#x3D; 2</span><br><span class="line">输出：216</span><br><span class="line">解释：将第二个数增加 1 次，将第四个数增加 1 次。</span><br><span class="line">得到 nums &#x3D; [6, 4, 3, 3] ，乘积为 6 * 4 * 3 * 3 &#x3D; 216 。</span><br><span class="line">可以证明 216 是能得到的最大乘积，所以我们返回 216 。</span><br><span class="line">存在其他增加 nums 的方法，也能得到最大乘积。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; nums.length, k &lt;&#x3D; 105</span><br><span class="line">0 &lt;&#x3D; nums[i] &lt;&#x3D; 106</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 先从大到小排序数组；<br>(2). 进入循环，循环的结束条件是 <code>k&lt;0</code>；<br>(3). 从数组的末尾向前遍历，如果当前数字等于上一次循环中未进行更改的后面数字，那么将当前数字加 1；<br>(4). 如果当前数字大于输一次循环中为进行更改的后面数字，那么回到数组末尾进行循环；<br>(5). 当从后向前遍历完整个数组，再次回到数组末尾；<br>(6). 跳出循环后，从头到尾计算结果。</p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(k*N)</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumProduct</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Max = <span class="number">1000000007</span></span><br><span class="line">sort.Slice(nums, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[i] &gt; nums[j]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">i := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">x := nums[i]</span><br><span class="line"><span class="keyword">for</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] == x &#123;</span><br><span class="line">nums[i]++</span><br><span class="line">i--</span><br><span class="line">k--</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] &gt;= x+<span class="number">1</span> &#123;</span><br><span class="line">i = <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">x = nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">i = <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">x = nums[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Println(nums)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fmt.Println(nums)</span></span><br><span class="line">ret := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">ret = ret*nums[i]%Max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode6040-花园的最大总美丽值"><a href="#LeetCode6040-花园的最大总美丽值" class="headerlink" title="LeetCode6040. 花园的最大总美丽值"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-total-beauty-of-the-gardens/">LeetCode6040. 花园的最大总美丽值<i class="fas fa-external-link-alt"></i></a></h2><p>#二分查找 #前缀和</p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>Alice 是 n 个花园的园丁，她想通过种花，最大化她所有花园的总美丽值。<br>给你一个下标从 0 开始大小为 n 的整数数组 flowers ，其中 flowers[i] 是第 i 个花园里已经种的花的数目。已经种了的花 不能 移走。同时给你 newFlowers ，表示 Alice 额外可以种花的 最大数目 。同时给你的还有整数 target ，full 和 partial 。<br>如果一个花园有 至少 target 朵花，那么这个花园称为 完善的 ，花园的 总美丽值 为以下分数之 和 ：<br>完善 花园数目乘以 full.<br>剩余 不完善 花园里，花的 最少数目 乘以 partial 。如果没有不完善花园，那么这一部分的值为 0 。<br>请你返回 Alice 种最多 newFlowers 朵花以后，能得到的 最大 总美丽值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：flowers &#x3D; [1,3,1,1], newFlowers &#x3D; 7, target &#x3D; 6, full &#x3D; 12, partial &#x3D; 1</span><br><span class="line">输出：14</span><br><span class="line">解释：Alice 可以按以下方案种花</span><br><span class="line">- 在第 0 个花园种 2 朵花</span><br><span class="line">- 在第 1 个花园种 3 朵花</span><br><span class="line">- 在第 2 个花园种 1 朵花</span><br><span class="line">- 在第 3 个花园种 1 朵花</span><br><span class="line">花园里花的数目为 [3,6,2,2] 。总共种了 2 + 3 + 1 + 1 &#x3D; 7 朵花。</span><br><span class="line">只有 1 个花园是完善的。</span><br><span class="line">不完善花园里花的最少数目是 2 。</span><br><span class="line">所以总美丽值为 1 * 12 + 2 * 1 &#x3D; 12 + 2 &#x3D; 14 。</span><br><span class="line">没有其他方案可以让花园总美丽值超过 14 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：flowers &#x3D; [2,4,5,3], newFlowers &#x3D; 10, target &#x3D; 5, full &#x3D; 2, partial &#x3D; 6</span><br><span class="line">输出：30</span><br><span class="line">解释：Alice 可以按以下方案种花</span><br><span class="line">- 在第 0 个花园种 3 朵花</span><br><span class="line">- 在第 1 个花园种 0 朵花</span><br><span class="line">- 在第 2 个花园种 0 朵花</span><br><span class="line">- 在第 3 个花园种 2 朵花</span><br><span class="line">花园里花的数目为 [5,4,5,5] 。总共种了 3 + 0 + 0 + 2 &#x3D; 5 朵花。</span><br><span class="line">有 3 个花园是完善的。</span><br><span class="line">不完善花园里花的最少数目为 4 。</span><br><span class="line">所以总美丽值为 3 * 2 + 4 * 6 &#x3D; 6 + 24 &#x3D; 30 。</span><br><span class="line">没有其他方案可以让花园总美丽值超过 30 。</span><br><span class="line">注意，Alice可以让所有花园都变成完善的，但这样她的总美丽值反而更小。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; flowers.length &lt;&#x3D; 105</span><br><span class="line">1 &lt;&#x3D; flowers[i], target &lt;&#x3D; 105</span><br><span class="line">1 &lt;&#x3D; newFlowers &lt;&#x3D; 1010</span><br><span class="line">1 &lt;&#x3D; full, partial &lt;&#x3D; 105</span><br></pre></td></tr></table></figure><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 将 <code>flowers</code> 从小到大排序；<br>(2). 贪心：让靠后的 <code>flowers[i]</code> 增加至 <code>target</code>，其余的 <code>flowers</code> 的最小值尽量大；<br>(3). 外层循环在枚举完善花园个数的前提下，内层循环我们要去计算剩余<code>newFlowers</code> 花朵数目下不完善花园区间内能拿到的最小值，这里面我们通过二分查找的方式来枚举最小值（具有二段性），<code>check</code> 函数里面先找到大于等于<code>mid</code> 的位置，然后判断剩下的数全部补充到 <code>mid</code> 朵花够不够，最后二分的结果就是当前不完善花园区间内能拿到的最小值，更新答案即可。<br>注： 外层循环枚举时特判一下ii等于00的情况，因为此时<code>j = i - 1</code>会越界。</p><h3 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumBeauty</span><span class="params">(flowers []<span class="keyword">int</span>, newFlowers <span class="keyword">int64</span>, target <span class="keyword">int</span>, full <span class="keyword">int</span>, partial <span class="keyword">int</span>)</span> <span class="title">int64</span></span> &#123;  </span><br><span class="line">   sort.Ints(flowers)  </span><br><span class="line">   n := <span class="built_in">len</span>(flowers)  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// count:已经完善的个数  </span></span><br><span class="line"> count := <span class="number">0</span>  </span><br><span class="line"> <span class="comment">// 计算 &gt;= target数目, 退出循环后 flowers[0, idx] &lt; target idx := n - 1  </span></span><br><span class="line"> <span class="keyword">for</span> idx &gt;= <span class="number">0</span> &amp;&amp; flowers[idx] &gt;= target &#123;  </span><br><span class="line">      count++  </span><br><span class="line"> idx--  </span><br><span class="line"> &#125;  </span><br><span class="line">   <span class="comment">//fmt.Println(&quot;idx:&quot;, idx, &quot;count:&quot;, count)  </span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 全部都是完善的  </span></span><br><span class="line"> <span class="keyword">if</span> idx == <span class="number">-1</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">int64</span>(n * full)  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   sum := <span class="built_in">make</span>([]<span class="keyword">int64</span>, n + <span class="number">1</span>)  </span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;  </span><br><span class="line">      sum[i] = sum[i - <span class="number">1</span>] + <span class="keyword">int64</span>(flowers[i - <span class="number">1</span>])  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   check := <span class="function"><span class="keyword">func</span><span class="params">(left, right, remain, t <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;  </span><br><span class="line">      <span class="comment">// 1.找到值 &lt; t的区间的右端点  </span></span><br><span class="line"> <span class="keyword">for</span> left &lt; right &#123;  </span><br><span class="line">         mid := left + (right - left + <span class="number">1</span>) / <span class="number">2</span>  </span><br><span class="line"> <span class="keyword">if</span> flowers[mid] &lt; t &#123;  </span><br><span class="line">            left = mid  </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            right = mid - <span class="number">1</span>  </span><br><span class="line"> &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 2.检查区间[0, left] 是否可以完善为t  </span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">int64</span>(remain) &gt;= <span class="keyword">int64</span>(t * (left + <span class="number">1</span>)) - sum[left + <span class="number">1</span>]  </span><br><span class="line">  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">var</span> res <span class="keyword">int64</span>  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// cnt: 新的变成完善的个数, 从右往左填  </span></span><br><span class="line"> <span class="keyword">for</span> cnt := <span class="number">0</span>; cnt &lt;= idx + <span class="number">1</span>; cnt++ &#123;  </span><br><span class="line">      <span class="comment">// 区间：[idx - cnt + 1,idx]完善, [0, idx - cnt]不完善，并计算[0, idx - cnt]中的最小值的最大值  </span></span><br><span class="line"> <span class="comment">// 填充完区间[idx - cnt + 1, idx]后剩余可种的花的数目  </span></span><br><span class="line"> remain := newFlowers - (<span class="keyword">int64</span>(target * cnt) - (sum[idx + <span class="number">1</span>] - sum[idx - cnt + <span class="number">1</span>]))  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">//fmt.Println(&quot;remain:&quot;, remain)  </span></span><br><span class="line"> <span class="keyword">if</span> remain &lt; <span class="number">0</span> &#123;  </span><br><span class="line">         <span class="keyword">break</span>  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 计算 [0, i - 1]中的最小值, 直接二分答案。  </span></span><br><span class="line"> left, right := flowers[<span class="number">0</span>], target - <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">for</span> left &lt; right &#123;  </span><br><span class="line">         mid := left + (right - left + <span class="number">1</span>) / <span class="number">2</span>  </span><br><span class="line"> <span class="comment">// 检查是否能够将区间[0, idx -cnt]中，值 &lt; mid的区间（假设是区间[0, j]）全部完善为mid  </span></span><br><span class="line"> <span class="keyword">if</span> check(<span class="number">0</span>, idx - cnt, <span class="keyword">int</span>(remain), mid) &#123;  </span><br><span class="line">            left = mid  </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            right = mid - <span class="number">1</span>  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">//fmt.Println(i, count + idx - i + 1, left)  </span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 如果全部完善， 则只有 完善数目 * full if count + cnt == n &#123;  </span></span><br><span class="line">         res = max(res, <span class="keyword">int64</span>((count + cnt) * full))  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">         <span class="comment">// 完善的数量：count + cnt, 未完善中最小值：left  </span></span><br><span class="line"> res = max(res, <span class="keyword">int64</span>((count + cnt) * full + left * partial))  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> res  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int64</span>)</span> <span class="title">int64</span></span> &#123;  </span><br><span class="line">   <span class="keyword">if</span> a &gt;= b &#123;  </span><br><span class="line">      <span class="keyword">return</span> a  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> b  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是对 2022.04.09 周赛的复盘&lt;/p&gt;
&lt;h2 id=&quot;LeetCode6037-按奇偶性交换后的最大数字&quot;&gt;&lt;a href=&quot;#LeetCode6037-按奇偶性交换后的最大数字&quot; class=&quot;headerlink&quot; title=&quot;LeetCode6037.</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 8）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/08/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%208%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/08/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%208%EF%BC%89/</id>
    <published>2022-04-07T22:00:00.000Z</published>
    <updated>2022-04-09T15:15:15.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode536-从字符串生成二叉树"><a href="#LeetCode536-从字符串生成二叉树" class="headerlink" title="LeetCode536. 从字符串生成二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/construct-binary-tree-from-string/">LeetCode536. 从字符串生成二叉树<i class="fas fa-external-link-alt"></i></a></h2><p>#递归 #栈 #二叉树</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>你需要用一个包括括号和整数的字符串构建一棵二叉树。<br>输入的字符串代表一棵二叉树。它包括整数和随后的 0 、1 或 2 对括号。整数代表根的值，一对括号内表示同样结构的子树。<br>若存在子结点，则从左子结点开始构建。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="butree.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入： s &#x3D; &quot;4(2(3)(1))(6(5))&quot;</span><br><span class="line">输出： [4,2,6,3,1,5]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入： s &#x3D; &quot;4(2(3)(1))(6(5)(7))&quot;</span><br><span class="line">输出： [4,2,6,3,1,5,7]</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入： s &#x3D; &quot;-4(2(3)(1))(6(5)(7))&quot;</span><br><span class="line">输出： [-4,2,6,3,1,5,7]</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; s.length &lt;&#x3D; 3 * 104</span><br><span class="line">输入字符串中只包含 &#39;(&#39;, &#39;)&#39;, &#39;-&#39; 和 &#39;0&#39; ~ &#39;9&#39; </span><br><span class="line">空树由 &quot;&quot; 而非&quot;()&quot;表示。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 很明显的递归题，而且题目中包含有对括号的处理，遇到括号首先就是考虑使用栈来记录下合法括号内的字符串；<br>(2). 首先要将父节点的值从字符串中抠出来，然后分别记录下左子树和右子树的字符串，这里可以设置一个哨兵，当左子树被分离出来后，用哨兵记录，那么下一次记录的合法字符串就是右子树。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment">* Left *TreeNode</span></span><br><span class="line"><span class="comment">* Right *TreeNode</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">str2tree</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> backTracking <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span></span><br><span class="line">backTracking = <span class="function"><span class="keyword">func</span><span class="params">(b <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(b) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h* TreeNode</span><br><span class="line"><span class="keyword">var</span> index <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">num := <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ; index&lt;<span class="built_in">len</span>(b); index++ &#123;</span><br><span class="line"><span class="keyword">if</span> b[index] != <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">num += b[index:index+<span class="number">1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x,_ = strconv.Atoi(num)</span><br><span class="line">h = &amp;TreeNode&#123;</span><br><span class="line">Val : x,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bb := <span class="string">&quot;&quot;</span></span><br><span class="line">l := <span class="number">0</span></span><br><span class="line">f := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ; index&lt;<span class="built_in">len</span>(b); index++ &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b[index] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">l++</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l++</span><br><span class="line">bb += <span class="string">&quot;(&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (b[index] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; b[index] &lt;= <span class="string">&#x27;9&#x27;</span>) || b[index] == <span class="string">&#x27;-&#x27;</span> &#123;</span><br><span class="line">bb += b[index:index+<span class="number">1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l--</span><br><span class="line"><span class="keyword">if</span> l != <span class="number">0</span> &#123;</span><br><span class="line">bb += <span class="string">&quot;)&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> f == <span class="number">0</span> &#123;</span><br><span class="line">leftNode := backTracking(bb)</span><br><span class="line">h.Left = leftNode</span><br><span class="line">bb = <span class="string">&quot;&quot;</span></span><br><span class="line">f = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rightNode := backTracking(bb)</span><br><span class="line">h.Right = rightNode</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> backTracking(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode370-区间加法"><a href="#LeetCode370-区间加法" class="headerlink" title="LeetCode370. 区间加法"></a><a class="link" href="https://leetcode-cn.com/problems/range-addition/">LeetCode370. 区间加法<i class="fas fa-external-link-alt"></i></a></h2><p>#差分数组</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，你将会被给出 k 个更新的操作。<br>其中，每个操作会被表示为一个三元组：[startIndex, endIndex, inc]，你需要将子数组 A[startIndex … endIndex]（包括 startIndex 和 endIndex）增加 inc。<br>请你返回 k 次操作后的数组。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: length &#x3D; 5, updates &#x3D; [[1,3,2],[2,4,3],[0,2,-2]]</span><br><span class="line">输出: [-2,0,3,5,3]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">初始状态:</span><br><span class="line">[0,0,0,0,0]</span><br><span class="line"></span><br><span class="line">进行了操作 [1,3,2] 后的状态:</span><br><span class="line">[0,2,2,2,0]</span><br><span class="line"></span><br><span class="line">进行了操作 [2,4,3] 后的状态:</span><br><span class="line">[0,2,5,5,3]</span><br><span class="line"></span><br><span class="line">进行了操作 [0,2,-2] 后的状态:</span><br><span class="line">[-2,0,3,5,3]</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 如果采用暴力的方式，需要在遍历 <code>updates</code> 的同时遍历结果数组，时间代价巨大；<br>(2). 观察到执行 <code>updates</code> 的顺序与最终结果无关。那么我们可以针对区间进行更新；<br>(3). 具体的思路是：对于每一组 <code>updates[i]</code>，我们提取出 <code>left</code>、<code>right</code>、<code>val</code> 这三个值分别代表左边界、右边界、更新值。我们只需要建立一个差分数组 <code>diff</code>，对 <code>diff[left]</code> 加上 <code>val</code>，对 <code>diff[right+1]</code> 减去 <code>val</code>，那么之后就可以通过区间的记录还原最终的输出结果；<br>(4). 最后通过前缀和计算最终的输出结果</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getModifiedArray</span><span class="params">(length <span class="keyword">int</span>, updates [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">nums := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line">diff := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(updates); i++ &#123;</span><br><span class="line">left, right, val := updates[i][<span class="number">0</span>], updates[i][<span class="number">1</span>], updates[i][<span class="number">2</span>]</span><br><span class="line">diff[left] += val</span><br><span class="line"><span class="keyword">if</span> right+<span class="number">1</span> &gt;= length &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">diff[right+<span class="number">1</span>] -= val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nums[<span class="number">0</span>] = diff[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;length; i++ &#123;</span><br><span class="line">nums[i] = nums[i<span class="number">-1</span>]+diff[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode692-前K个高频单词"><a href="#LeetCode692-前K个高频单词" class="headerlink" title="LeetCode692. 前K个高频单词"></a><a class="link" href="https://leetcode-cn.com/problems/top-k-frequent-words/">LeetCode692. 前K个高频单词<i class="fas fa-external-link-alt"></i></a></h2><p>#优先队列 #字典序 </p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个单词列表 words 和一个整数 k ，返回前 k 个出现次数最多的单词。<br>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， 按字典顺序 排序。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: words &#x3D; [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k &#x3D; 2</span><br><span class="line">输出: [&quot;i&quot;, &quot;love&quot;]</span><br><span class="line">解析: &quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为2次。</span><br><span class="line">    注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k &#x3D; 4</span><br><span class="line">输出: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]</span><br><span class="line">解析: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词，</span><br><span class="line">    出现次数依次为 4, 3, 2 和 1 次。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1 &lt;&#x3D; words.length &lt;&#x3D; 500</span><br><span class="line">1 &lt;&#x3D; words[i] &lt;&#x3D; 10</span><br><span class="line">words[i] 由小写英文字母组成。</span><br><span class="line">k 的取值范围是 [1, 不同 words[i] 的数量]</span><br><span class="line"> </span><br><span class="line">进阶：尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决，本题适合使用优先队列，对于这种既要考虑优先级，又要考虑字符串构成的情况，怎样构建优先队列可以参考 <a href="https://jiahaohong1997.github.io/2021/09/27/%E5%A0%86%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/">堆的Go语言实现</a><br>(2). 注意考虑在出现次数一样的情况下，要依赖字符串的字典序排序，可以使用 <code>strings.Compare</code> 方法来比较字典序；<br>(3). 要输出最大的 <code>k</code> 个，可以采取建立容量上限为 <code>k</code> 的小根堆的做法。</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> wordCount <span class="keyword">struct</span> &#123;</span><br><span class="line">word <span class="keyword">string</span></span><br><span class="line">priority <span class="keyword">int</span></span><br><span class="line">index <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> priorityQueue []*wordCount</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq priorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(pq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq priorityQueue)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">pq[i].index = j</span><br><span class="line">pq[j].index = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq priorityQueue)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pq[i].priority == pq[j].priority &#123;</span><br><span class="line"><span class="keyword">if</span> strings.Compare(pq[i].word, pq[j].word) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// pq[i].word 的字典序在 pq[j].word 的后面，那在优先队列中就排前面</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> strings.Compare(pq[i].word, pq[j].word) == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// pq[i].word 的字典序在 pq[j].word 的前面，那在优先队列中就排后面</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pq[i].priority &lt; pq[j].priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *priorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(*pq)</span><br><span class="line">item := x.(*wordCount)</span><br><span class="line">item.index = n</span><br><span class="line">*pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *priorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *pq</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">item := old[n<span class="number">-1</span>]</span><br><span class="line">old[n<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">item.index = <span class="number">-1</span></span><br><span class="line">*pq = old[:n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(words []<span class="keyword">string</span>, k <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pq priorityQueue</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(words); i++ &#123;</span><br><span class="line">m[words[i]]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> w, v := <span class="keyword">range</span> m &#123;</span><br><span class="line"><span class="keyword">if</span> i &lt; k &#123;</span><br><span class="line">wc := &amp;wordCount &#123;</span><br><span class="line">word : w,</span><br><span class="line">index : i,</span><br><span class="line">priority : v,</span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">heap.Push(&amp;pq, wc)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v &gt; pq[<span class="number">0</span>].priority || (v == pq[<span class="number">0</span>].priority &amp;&amp; strings.Compare(w, pq[<span class="number">0</span>].word) == <span class="number">-1</span>) &#123;</span><br><span class="line">heap.Pop(&amp;pq)</span><br><span class="line">wc := &amp;wordCount &#123;</span><br><span class="line">word : w,</span><br><span class="line">index : k<span class="number">-1</span>,</span><br><span class="line">priority : v,</span><br><span class="line">&#125;</span><br><span class="line">heap.Push(&amp;pq, wc)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := <span class="built_in">make</span>([]<span class="keyword">string</span>, k)</span><br><span class="line"><span class="keyword">for</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">ret[k<span class="number">-1</span>] = heap.Pop(&amp;pq).(*wordCount).word</span><br><span class="line">k--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LeetCode536-从字符串生成二叉树&quot;&gt;&lt;a href=&quot;#LeetCode536-从字符串生成二叉树&quot; class=&quot;headerlink&quot; title=&quot;LeetCode536. 从字符串生成二叉树&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot; href=&quot;</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法</title>
    <link href="http://jiahaohong1997.github.io/2022/04/07/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://jiahaohong1997.github.io/2022/04/07/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-07T11:51:00.000Z</published>
    <updated>2022-04-12T02:02:02.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="Go-语言代码"><a href="#Go-语言代码" class="headerlink" title="Go 语言代码"></a>Go 语言代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> backTracking <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(arr) == <span class="number">0</span> || <span class="built_in">len</span>(arr) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l, r := <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span></span><br><span class="line">mid := l</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line"><span class="keyword">for</span> l &lt; r &amp;&amp; arr[r] &gt;= arr[mid] &#123;</span><br><span class="line">r--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> l &lt; r &amp;&amp; arr[l] &lt;= arr[mid] &#123;</span><br><span class="line">l++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[l], arr[r] = arr[r], arr[l]</span><br><span class="line">&#125;</span><br><span class="line">arr[l], arr[mid] = arr[mid], arr[l]</span><br><span class="line"></span><br><span class="line">backTracking(arr[:l])</span><br><span class="line">backTracking(arr[l+<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">backTracking(nums)</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="Go-语言代码-1"><a href="#Go-语言代码-1" class="headerlink" title="Go 语言代码"></a>Go 语言代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> backTracking <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span></span><br><span class="line">backTracking = <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(arr) == <span class="number">0</span> || <span class="built_in">len</span>(arr) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n := <span class="built_in">len</span>(arr)</span><br><span class="line">a := backTracking(arr[:n/<span class="number">2</span>])</span><br><span class="line">b := backTracking(arr[n/<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(a) || j &lt; <span class="built_in">len</span>(b) &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="built_in">len</span>(a) &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, b...)</span><br><span class="line">j = <span class="built_in">len</span>(b)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> j == <span class="built_in">len</span>(b) &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, a...)</span><br><span class="line">i = <span class="built_in">len</span>(a)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a[i] &lt;= b[j] &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, a[i])</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, b[j])</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> backTracking(nums)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>&emsp;&emsp;<strong>基数排序</strong>（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>&emsp;&emsp;基数排序的时间复杂度是 $O(k * N)$，其中 $N$是排序元素个数，$k$ 是数字位数。注意这不是说这个时间复杂度一定优于 $O(NlogN)$，$k$ 的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；$k$ 决定了进行多少轮处理，而 $N$ 是每轮处理的操作数目。</p><h3 id="Go-语言代码-2"><a href="#Go-语言代码-2" class="headerlink" title="Go 语言代码"></a>Go 语言代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">radixSort</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxNum <span class="function"><span class="keyword">func</span><span class="params">(...<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">maxNum = <span class="function"><span class="keyword">func</span><span class="params">(array ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">max := array[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(array); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> array[i] &gt; max &#123;</span><br><span class="line">max = array[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cnt := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"><span class="keyword">for</span> exp:=<span class="number">1</span>; exp&lt;=maxNum(nums...); exp*=<span class="number">10</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">digit := nums[i] / exp % <span class="number">10</span></span><br><span class="line">cnt[digit]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">cnt[i] += cnt[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="built_in">len</span>(nums)<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">digit := nums[i] / exp % <span class="number">10</span></span><br><span class="line">buf[cnt[digit]<span class="number">-1</span>] = nums[i]</span><br><span class="line">cnt[digit]--</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h2&gt;&lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="排序" scheme="http://jiahaohong1997.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 7）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/06/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%207%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/06/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%207%EF%BC%89/</id>
    <published>2022-04-06T09:38:00.000Z</published>
    <updated>2022-04-08T00:08:22.610Z</updated>
    
    <content type="html"><![CDATA[<p>今天没早起刷题，早起抢菜去了。淦！</p><h2 id="LeetCode253-会议室-II"><a href="#LeetCode253-会议室-II" class="headerlink" title="LeetCode253. 会议室 II"></a><a class="link" href="https://leetcode-cn.com/problems/meeting-rooms-ii/">LeetCode253. 会议室 II<i class="fas fa-external-link-alt"></i></a></h2><p>#堆排序</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，返回 所需会议室的最小数量 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：intervals &#x3D; [[0,30],[5,10],[15,20]]</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：intervals &#x3D; [[7,10],[2,4]]</span><br><span class="line">输出：1</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; intervals.length &lt;&#x3D; 104</span><br><span class="line">0 &lt;&#x3D; starti &lt; endi &lt;&#x3D; 106</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 按照最朴素的想法，要给公司部门安排会议，那么一定是优先考虑会议开始得早的部门，那么首先就是要排序。排序的条件就是开始时间越早越靠前；<br>(2). 安排新会议室的原则是所有已申请的会议室都被占用。那么就可以使用一个最小堆，堆中保存的是每场会议的结束时间；<br>(3). 当当前会议开始时，堆顶的会议还没结束，说明堆中所有的会议都不可能结束，那么就要申请新的会议室；<br>(4). 遍历完整个会议的记录，就可以得到要开辟的最大会议室数量。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(Nlog(N))</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> intHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h intHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h intHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h intHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> h[i] &lt; h[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *intHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *intHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[:n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMeetingRooms</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> intervals[i][<span class="number">0</span>] == intervals[j][<span class="number">0</span>] &#123;</span><br><span class="line"><span class="keyword">return</span> intervals[i][<span class="number">1</span>] &lt; intervals[j][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> intervals[i][<span class="number">0</span>] &lt; intervals[j][<span class="number">0</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h intHeap</span><br><span class="line">heap.Push(&amp;h, intervals[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">room := <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;= h[<span class="number">0</span>] &#123;</span><br><span class="line">heap.Pop(&amp;h)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">room++</span><br><span class="line">&#125;</span><br><span class="line">heap.Push(&amp;h, intervals[i][<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> room</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode163-缺失的区间"><a href="#LeetCode163-缺失的区间" class="headerlink" title="LeetCode163. 缺失的区间"></a><a class="link" href="https://leetcode-cn.com/problems/missing-ranges/">LeetCode163. 缺失的区间<i class="fas fa-external-link-alt"></i></a></h2><p>#模拟题</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个排序的整数数组 _<strong>nums</strong>_ ，其中元素的范围在 <strong>闭区间</strong> <strong>[<em>lower, upper</em>]</strong> 当中，返回不包含在数组中的缺失区间。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入: nums &#x3D; [0, 1, 3, 50, 75], lower &#x3D; 0 和 upper &#x3D; 99,</span><br><span class="line">输出: [&quot;2&quot;, &quot;4-&gt;49&quot;, &quot;51-&gt;74&quot;, &quot;76-&gt;99&quot;]</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 这道模拟题挺恶心的，边界处理是关键；<br>(2). 根据数据范围遍历 <code>nums</code>，不能按从 <code>lower</code> 到 <code>upper</code>。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMissingRanges</span><span class="params">(nums []<span class="keyword">int</span>, lower <span class="keyword">int</span>, upper <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">ret := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> lower == upper &#123;</span><br><span class="line">s := strconv.Itoa(lower)</span><br><span class="line">ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s := strconv.Itoa(lower) + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(upper)</span><br><span class="line">ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre := lower</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] != pre &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] == pre+<span class="number">1</span> &#123;</span><br><span class="line">s = strconv.Itoa(pre)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s = strconv.Itoa(pre) + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(nums[i]<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">pre = nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] == pre + <span class="number">2</span> &#123;</span><br><span class="line">s = strconv.Itoa(nums[i]<span class="number">-1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] == pre + <span class="number">1</span> &#123;</span><br><span class="line">s = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s = strconv.Itoa(pre+<span class="number">1</span>) + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(nums[i]<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre = nums[i]</span><br><span class="line"><span class="keyword">if</span> s != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == <span class="built_in">len</span>(nums)<span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] != upper &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] == upper<span class="number">-1</span> &#123;</span><br><span class="line">s = strconv.Itoa(upper)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s = strconv.Itoa(nums[i]+<span class="number">1</span>) + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(upper)</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode694-不同岛屿的数量"><a href="#LeetCode694-不同岛屿的数量" class="headerlink" title="LeetCode694. 不同岛屿的数量"></a><a class="link" href="https://leetcode-cn.com/problems/number-of-distinct-islands/">LeetCode694. 不同岛屿的数量<i class="fas fa-external-link-alt"></i></a></h2><p>#DFS</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个非空 01 二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的 1 组成，你可以认为网格的四周被海水包围。<br>请你计算这个网格中共有多少个形状不同的岛屿。两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。</p></blockquote><p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00011</span><br><span class="line">00011</span><br><span class="line">给定上图，返回结果 1 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">11011</span><br><span class="line">10000</span><br><span class="line">00001</span><br><span class="line">11011</span><br><span class="line">给定上图，返回结果 3 。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">11</span><br><span class="line">1</span><br><span class="line">和</span><br><span class="line"></span><br><span class="line"> 1</span><br><span class="line">11</span><br><span class="line">是不同的岛屿，因为我们不考虑旋转、翻转操作。</span><br></pre></td></tr></table></figure></p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 海岛问题的拓展，一般思路就两种：dfs 或 bfs；<br>(2). 这道题要求输出的是不同形状海岛的数量，那么关键问题就是怎样表示海岛的形状；<br>(3). 回忆一下我们通过 dfs 找海岛的过程，每次都是先找到海岛最左上角的点，然后根据我们预设的方向数组来控制寻找的路径，那么通过这条寻找路径，就能确定海岛的形状；<br>(4). 要注意的是每个海岛左上角的起始点都是其坐标，要将其归零才可以在同一数值范围内进行判断，我们只需要在遍历 <code>grid</code> 的点的时候记录下此时的坐标，就可以计算该海岛上每个点相对于左上角点的坐标位置。</p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N^2)</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDistinctIslands</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">h_idx := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;</span><br><span class="line">w_idx := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;</span><br><span class="line"></span><br><span class="line">height, weight := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">s := <span class="string">&quot;&quot;</span></span><br><span class="line">bi, bj := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">grid[i][j] = <span class="number">0</span></span><br><span class="line">s += fmt.Sprintf(<span class="string">&quot;-%d-%d&quot;</span>, i-bi, j-bj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k:=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++ &#123;</span><br><span class="line">h, w := i+h_idx[k], j+w_idx[k]</span><br><span class="line"><span class="keyword">if</span> h &gt;= <span class="number">0</span> &amp;&amp; h &lt; height &amp;&amp; w &gt;= <span class="number">0</span> &amp;&amp; w &lt; weight &amp;&amp; grid[h][w] == <span class="number">1</span> &#123;</span><br><span class="line">dfs(h,w)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;height; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;weight; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">bi, bj, s = i, j, <span class="string">&quot;&quot;</span></span><br><span class="line">dfs(i,j)</span><br><span class="line">m[s] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for k, _ := range m &#123;</span></span><br><span class="line"><span class="comment">// fmt.Println(k)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="164-最大间距"><a href="#164-最大间距" class="headerlink" title="164. 最大间距"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-gap/">164. 最大间距<i class="fas fa-external-link-alt"></i></a></h2><p>#基数排序</p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。<br>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。</p></blockquote><p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 示例 1:</span><br><span class="line">输入: nums &#x3D; [3,6,9,1]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums &#x3D; [10]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 数组元素个数小于 2，因此返回 0。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 105</span><br><span class="line">0 &lt;&#x3D; nums[i] &lt;&#x3D; 109</span><br></pre></td></tr></table></figure></p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先注意题目的要求：<strong>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。</strong> 这就对选择的算法有了限制。快排和堆排的时间复杂度都是 O(Nlog(N))，基数排序时间复杂度是 O(N)，空间复杂度是 O(N)，符合题目要求；<br>(2). 那么这道题就转化成一道基数排序的算法了。基数排序可以参考另一篇博客<a href="https://jiahaohong1997.github.io/2022/04/07/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">常用排序算法</a></p><h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumGap</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(ans <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    maxVal := max(nums...)</span><br><span class="line">    <span class="keyword">for</span> exp := <span class="number">1</span>; exp &lt;= maxVal; exp *= <span class="number">10</span> &#123;</span><br><span class="line">        cnt := [<span class="number">10</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            digit := v / exp % <span class="number">10</span></span><br><span class="line">            cnt[digit]++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            cnt[i] += cnt[i<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">            digit := nums[i] / exp % <span class="number">10</span></span><br><span class="line">            buf[cnt[digit]<span class="number">-1</span>] = nums[i]</span><br><span class="line">            cnt[digit]--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">copy</span>(nums, buf)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        ans = max(ans, nums[i]-nums[i<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> a[<span class="number">1</span>:] &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; res &#123;</span><br><span class="line">            res = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天没早起刷题，早起抢菜去了。淦！&lt;/p&gt;
&lt;h2 id=&quot;LeetCode253-会议室-II&quot;&gt;&lt;a href=&quot;#LeetCode253-会议室-II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode253. 会议室 II&quot;&gt;&lt;/a&gt;&lt;a cla</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824 Lab 踩坑记录</title>
    <link href="http://jiahaohong1997.github.io/2022/04/06/MIT6.824%20Lab%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://jiahaohong1997.github.io/2022/04/06/MIT6.824%20Lab%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2022-04-06T04:40:00.000Z</published>
    <updated>2022-04-08T13:57:45.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h1><h2 id="go-plugin"><a href="#go-plugin" class="headerlink" title="go plugin"></a>go plugin</h2><h3 id="踩坑场景"><a href="#踩坑场景" class="headerlink" title="踩坑场景"></a>踩坑场景</h3><p>&emsp;&emsp;项目的初始化就是将 Map 和 Reduce 方法分别打包成插件的形式供 worker 端调用。这样设计的理由是测试用例中包含了不同的 Map 和 Reduce 方法，要通过所有的测试用例，使用插件的形式更加自由。<br>&emsp;&emsp;但是在启动项目的一开始就报错：<code>plugin was built with a different version of package runtime</code>。在网上查了很久，只能知道是作为 plugin 的插件文件和调用这个插件的文件编译环境不同导致的。但是问题是我都是在本地编译的，怎么还存在这个问题呢？</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>&emsp;&emsp;无他，重新装了 go 的环境。。。成功解决该问题。巨 tm 魔幻。<br>&emsp;&emsp;另外，<code>mr</code> 包下的任何改动都需要重新 <code>go build --plugin</code>，否则 worker 无法继续使用这个插件编译。</p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>&emsp;&emsp;go plugin 目前还是一个不成熟的方案，受限因素太多，可能会出现各种莫名其妙的问题，建议之后自己的开发中还是避免是用 go plugin。</p><h2 id="for-select-中的break、continue、return"><a href="#for-select-中的break、continue、return" class="headerlink" title="for-select 中的break、continue、return"></a>for-select 中的break、continue、return</h2><h3 id="踩坑场景-1"><a href="#踩坑场景-1" class="headerlink" title="踩坑场景"></a>踩坑场景</h3><p>&emsp;&emsp;在 worker 内部实现 map task 的时候，写了一个外层的 for 函数，里面是一个 select，case 1 是当出现超时（10s），那么就直接返回 false，否则就是 default 执行操作；当读到文件末尾 <code>EOF</code>时，完成操作后需要 break 跳出 for 循环。此时就出现了问题：break只能跳出select，无法跳出for，导致出现死循环。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>方案一：标签<br>看如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBreak</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">tick := time.Tick(time.Second)</span><br><span class="line"><span class="comment">//FOR是标签</span></span><br><span class="line">FOR:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t := &lt;-tick:</span><br><span class="line">fmt.Println(t)</span><br><span class="line"><span class="comment">//break出FOR标签标识的代码</span></span><br><span class="line"><span class="keyword">break</span> FOR</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二：goto</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBreak</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">tick := time.Tick(time.Second)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t := &lt;-tick:</span><br><span class="line">fmt.Println(t)</span><br><span class="line"><span class="comment">//跳到指定位置</span></span><br><span class="line"><span class="keyword">goto</span> END</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">END:</span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这两种方式都能够成功跳出 for 循环，我选择了方案二。</p><blockquote><p>continue：单独在select中是不能使用continue，会编译错误，只能用在for-select中。  <strong>continue的语义就类似for中的语义，select后的代码不会被执行到。</strong><br>return：和函数中的return一样，跳出select，和for，后续代码都不执行</p></blockquote><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><h3 id="踩坑场景-2"><a href="#踩坑场景-2" class="headerlink" title="踩坑场景"></a>踩坑场景</h3><p>&emsp;&emsp;Map 任务需要打开文件后统计单词出现频率，此时有两种读文件的方式。第一种是打开文件后逐行读取，第二种是打开文件后直接全部加载到内存中。第一种方式是用时间换空间的做法，在文件是个超大型文件，但是内存不够的情况下只能使用这种方法，唯一的问题就是很慢，IO 操作相当密集，很影响速度；第二种方式需要占用较大的内存，但是只需要一次性将文件全部加载到内存中即可，时间上会快很多。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>&emsp;&emsp;在本 lab 的场景下，每个 job 只有 10s 的时间处理文件，那么显然应该采用第二种方式。我一开始就是采用的逐行读取的方式，发现有的文件在单 worker 运算时甚至完全无法在 10s 内统计完。<br>&emsp;&emsp;同时还采用了临时文件的方式，临时文件会默认保存在系统的<code>/tmp</code> 路径下，如果要放在当前目录下需要指定，每个临时文件的末尾会带上一串随机的数字，可以在命名的时候做一些约定，方便之后的处理。<br>&emsp;&emsp;对文件的命名带上了递增的 jobId，那么就避免了冲突问题。</p><h3 id="建议-1"><a href="#建议-1" class="headerlink" title="建议"></a>建议</h3><ul><li>因为命名规则可能存在缺陷，采用临时文件的形式可以避免任务失败后，任务被其他的 <code>worker</code> 接管造成的文件冲突；</li><li>还可以通过约定命名规则，比如带上自增的 JobId，那么在之后的流程中只会对成功的 JobId 的文件进行处理。</li></ul><h2 id="chan-int"><a href="#chan-int" class="headerlink" title="[ ]chan int"></a>[ ]chan int</h2><h3 id="踩坑场景-3"><a href="#踩坑场景-3" class="headerlink" title="踩坑场景"></a>踩坑场景</h3><p>&emsp;&emsp;在 <code>Coordinator</code> 结构体中声明了一个切片：<code>workerDone   []chan int</code>，用于接收对应 <code>worker</code> 在规定时间内完成任务的信号。一开始只是建一个固定长度的切片：<code>workerDone := make([]chan int, 20)</code>，在一个新的 <code>worker</code> 建立连接获得工号后如果超出长度，那么就再扩容 20 个位置。可是忽略了了一个事实，这样建立的切片，每个元素其实是 <code>nil</code>，所以一直不能正确的传递信号。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>要通过下面的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.workerDone[workerNum] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样才能正确的完成对应工号的初始化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lab1&quot;&gt;&lt;a href=&quot;#Lab1&quot; class=&quot;headerlink&quot; title=&quot;Lab1&quot;&gt;&lt;/a&gt;Lab1&lt;/h1&gt;&lt;h2 id=&quot;go-plugin&quot;&gt;&lt;a href=&quot;#go-plugin&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="分布式系统" scheme="http://jiahaohong1997.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="踩坑" scheme="http://jiahaohong1997.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824 Lab1</title>
    <link href="http://jiahaohong1997.github.io/2022/04/06/MIT6.824%20Lab1/"/>
    <id>http://jiahaohong1997.github.io/2022/04/06/MIT6.824%20Lab1/</id>
    <published>2022-04-06T04:36:00.000Z</published>
    <updated>2022-04-11T00:11:15.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="任务梳理"><a href="#任务梳理" class="headerlink" title="任务梳理"></a>任务梳理</h1><h2 id="mapreduce-介绍及部署"><a href="#mapreduce-介绍及部署" class="headerlink" title="mapreduce 介绍及部署"></a>mapreduce 介绍及部署</h2><p><img lazyload src="/images/loading.svg" data-src="mapreduce.jpg" alt="avatar"></p><h3 id="lab1-简介"><a href="#lab1-简介" class="headerlink" title="lab1 简介"></a>lab1 简介</h3><p>&emsp;&emsp;实现一个 <code>mapreduce</code> 的 demo，也就是在单机上部署的分布式词频统计系统。至于和实际生产场景上最大的区别就在于文件系统。在单机上部署共用一套文件系统，而实际生产端要复杂很多。</p><h3 id="实际部署"><a href="#实际部署" class="headerlink" title="实际部署"></a>实际部署</h3><p>&emsp;&emsp;完整的部署流程以及实验细节详见 <a class="link" href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">6.824 Lab 1: MapReduce<i class="fas fa-external-link-alt"></i></a></p><ol><li><p>串行化的部署流程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://g.csail.mit.edu/6.824-golabs-2022 6.824</span><br><span class="line">$ <span class="built_in">cd</span> 6.824</span><br><span class="line">$ ls</span><br><span class="line">Makefile src</span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">cd</span> ~/6.824</span><br><span class="line">$ <span class="built_in">cd</span> src/main</span><br><span class="line">$ go build -race -buildmode=plugin ../mrapps/wc.go</span><br><span class="line">$ rm mr-out*</span><br><span class="line">$ go run -race mrsequential.go wc.so pg*.txt</span><br><span class="line">$ more mr-out-0</span><br><span class="line">A 509</span><br><span class="line">ABOUT 2</span><br><span class="line">ACT 8</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>mapreduce 部署流程<br>(1). 使用 go plugin 将 <code>map</code> 和 <code>reduce</code> 函数插件化<br>恶心的 go plugin，是个不成熟的方案，差点让我倒在了第一步，具体的踩坑情况见<a href="https://jiahaohong1997.github.io/2022/04/06/MIT6.824%20Lab%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/">MIT6.824 Lab 踩坑记录</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build -race -buildmode=plugin ../mrapps/wc.go</span><br></pre></td></tr></table></figure></li></ol><p>(2). 启动 <code>coordinator</code> 进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rm mr-out*</span><br><span class="line">$ go run -race mrcoordinator.go pg-*.txt</span><br></pre></td></tr></table></figure><p>(3). 开启多个终端窗口，启动多个 <code>worker</code> 进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run -race mrworker.go wc.so</span><br></pre></td></tr></table></figure><ol start="3"><li>最终测试结果展示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ bash test-mr.sh       </span><br><span class="line">*** Starting wc <span class="built_in">test</span>.</span><br><span class="line">--- wc <span class="built_in">test</span>: PASS</span><br><span class="line">*** Starting indexer <span class="built_in">test</span>.</span><br><span class="line">--- indexer <span class="built_in">test</span>: PASS</span><br><span class="line">*** Starting map parallelism <span class="built_in">test</span>.</span><br><span class="line">--- map parallelism <span class="built_in">test</span>: PASS</span><br><span class="line">*** Starting reduce parallelism <span class="built_in">test</span>.</span><br><span class="line">--- reduce parallelism <span class="built_in">test</span>: PASS</span><br><span class="line">*** Starting job count <span class="built_in">test</span>.</span><br><span class="line">--- job count <span class="built_in">test</span>: PASS</span><br><span class="line">*** Starting early <span class="built_in">exit</span> <span class="built_in">test</span>.</span><br><span class="line">--- early <span class="built_in">exit</span> <span class="built_in">test</span>: PASS</span><br><span class="line">*** Starting crash <span class="built_in">test</span>.</span><br><span class="line">--- crash <span class="built_in">test</span>: PASS</span><br><span class="line">*** PASSED ALL TESTS</span><br></pre></td></tr></table></figure></li></ol><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><p>&emsp;&emsp;整个系统中 <code>worker</code> 和 <code>coordinator</code> 的交互状态包含下图所示的一系列情况：<br><img lazyload src="/images/loading.svg" data-src="keyStatus.png" alt="avatar"></p><h3 id="RPC-通信"><a href="#RPC-通信" class="headerlink" title="RPC 通信"></a>RPC 通信</h3><ol><li>建立连接，给每个 <code>worker</code> 分配专属工号<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ask for WorkerNum and Contruct Connection  </span></span><br><span class="line"><span class="keyword">type</span> HelloArgs <span class="keyword">struct</span> &#123;  </span><br><span class="line">   X <span class="keyword">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> HelloReply <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Y <span class="keyword">int</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;<code>HelloArgs</code> 的 <code>X</code> 元素是双方约定好的字符串，<code>coordinator</code> 只有在收到约定的信息后才能建立连接，分配工号。</p><ol start="2"><li>map 任务的请求与完成<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map tasks Arguments and Reply  </span></span><br><span class="line"><span class="keyword">type</span> MapArgs <span class="keyword">struct</span> &#123;  </span><br><span class="line">WorkerNum <span class="keyword">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> MapReply <span class="keyword">struct</span> &#123;  </span><br><span class="line">NReducer <span class="keyword">int</span>  </span><br><span class="line">Finished <span class="keyword">bool</span>  </span><br><span class="line">FileName <span class="keyword">string</span>  </span><br><span class="line">JobId <span class="keyword">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Finish Map Task  </span></span><br><span class="line"><span class="keyword">type</span> FinishMapArgs <span class="keyword">struct</span> &#123;  </span><br><span class="line">X <span class="keyword">bool</span>  </span><br><span class="line">WorkerNum <span class="keyword">int</span>  </span><br><span class="line">FileName []<span class="keyword">string</span>  </span><br><span class="line">JobId <span class="keyword">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> FinishMapReply <span class="keyword">struct</span> &#123;  </span><br><span class="line">Y <span class="keyword">int</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>请求 <code>map</code> 任务<br><code>worker</code> 请求 <code>map</code> 任务时带上自己的工号，如果被成功分配了 <code>map</code> 任务，那么将会得到 <code>reducer</code> 的数量、是否完成全部 <code>map</code> 任务的信号、要执行的文件名称、被分配的事务 <code>Id</code>（用于命名中间临时文件，避免 <code>crash</code>）。</p></li><li><p>发送结束 <code>map</code> 任务的信号<br><code>worker</code> 在自己的进程中执行完（或未能成功执行），将生成的临时文件名（地址）转告 <code>coordinator</code> 。</p></li></ul><ol start="3"><li>reduce 任务的请求与完成<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reduce Task  </span></span><br><span class="line"><span class="keyword">type</span> ReduceTaskArgs <span class="keyword">struct</span> &#123;  </span><br><span class="line">WorkerNum <span class="keyword">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> ReduceTaskReply <span class="keyword">struct</span> &#123;  </span><br><span class="line">Finished <span class="keyword">bool</span>  </span><br><span class="line">ReducerFile []<span class="keyword">string</span>  </span><br><span class="line">JobId <span class="keyword">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Finish Reduce Task  </span></span><br><span class="line"><span class="keyword">type</span> FinishReduceArgs <span class="keyword">struct</span> &#123;  </span><br><span class="line">X <span class="keyword">bool</span>  </span><br><span class="line">WorkerNum <span class="keyword">int</span>  </span><br><span class="line">File <span class="keyword">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> FinishReduceReply <span class="keyword">struct</span> &#123;  </span><br><span class="line">Y <span class="keyword">int</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;大体思路和 <code>map</code> 任务的请求和结束一直，不过多赘述。</p><ol start="4"><li>map 和 reduce 任务都完成，请求关机<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ask for shutdown  </span></span><br><span class="line"><span class="keyword">type</span> ExitArgs <span class="keyword">struct</span> &#123;  </span><br><span class="line">   X <span class="keyword">bool</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> ExitReply <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Y <span class="keyword">bool</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="coordinator-进程"><a href="#coordinator-进程" class="headerlink" title="coordinator 进程"></a>coordinator 进程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;  </span><br><span class="line">   <span class="comment">// Your definitions here.  </span></span><br><span class="line"> fileName       []<span class="keyword">string</span>  <span class="comment">// 初始文件名列表，待分配队列</span></span><br><span class="line"> unfinishedFile []<span class="keyword">string</span>  <span class="comment">// map任务进行中的文件名列表，待完成队列</span></span><br><span class="line"> nReducer       <span class="keyword">int</span>  </span><br><span class="line"> lock           sync.Mutex  </span><br><span class="line"> jobNum         <span class="keyword">int</span>    <span class="comment">// 事务 id，递增不重复</span></span><br><span class="line">  </span><br><span class="line"> workerNum    <span class="keyword">int</span>    <span class="comment">// worker 编号，递增不重复</span></span><br><span class="line"> workerDone   []<span class="keyword">chan</span> <span class="keyword">int</span>  <span class="comment">// 对应 worker 的任务执行情况</span></span><br><span class="line"> rejectResult []<span class="keyword">bool</span>    <span class="comment">// worker 成功完成任务，但因为通信到达后超时，拒绝该任务</span></span><br><span class="line">  </span><br><span class="line"> mapFinished          <span class="keyword">bool</span>  <span class="comment">// map 完成才能开启 reduce</span></span><br><span class="line"> reduceFiles          [][]<span class="keyword">string</span>  <span class="comment">// [nReducer][]string，待分配队列</span></span><br><span class="line"> unFinishedReduceFile [][]<span class="keyword">string</span>  <span class="comment">// reduce 正在进行中的文件列表，待完成队列</span></span><br><span class="line"> finalFiles           []<span class="keyword">string</span>    <span class="comment">// [nReducer]string，最终文件</span></span><br><span class="line">  </span><br><span class="line"> exitValue atomic.Value    <span class="comment">// 原子量，保证 coordinator 正常关机</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要负责的流程如下：</p><ol><li>接收 <code>worker</code> 的建立连接请求并发放工号；</li><li>分配 <code>map</code> 任务：</li></ol><ul><li>建立待分配、待完成文件队列</li><li>给成功“接单”（成功从待分配队列中获取文件）的 <code>worker</code> 分配唯一的 <code>jobId</code>，并反馈是否已完成所有的 <code>map</code> 任务</li><li>开启计时 goroutine，一旦对应的 <code>map</code> 任务超时，则将对应文件名从待完成队列放入待分配队列</li></ul><ol start="3"><li>分配 <code>reduce</code> 任务：</li></ol><ul><li>在完成所有 <code>map</code> 任务的前提下才会分配 <code>reduce</code> 任务</li><li>其余流程与 <code>map</code> 任务类似</li></ul><ol start="4"><li>shutdown：完成所有 <code>reduce</code> 任务后，<code>worker</code> 会收到结束信号，然后通过 RPC 请求关闭，当所有 <code>worker</code> 都退出后，<code>coordinator</code> 才会关闭。</li></ol><h3 id="worker-进程"><a href="#worker-进程" class="headerlink" title="worker 进程"></a>worker 进程</h3><ol><li>建立与 <code>coordinator</code> 的连接，获取工号；</li><li>请求 <code>map</code> 任务，获得任务后开始执行，响应完成情况后继续请求 <code>map</code> 任务直到再次获取或者所有 <code>map</code> 任务都结束；</li><li>所有 <code>map</code> 任务都结束后，请求 <code>reduce</code> 任务，获得任务后开始执行，响应完成情况后继续请求 <code>reduce</code> 任务直到再次获取 <code>reduce</code> 任务或者所有 <code>reduce</code> 任务结束；</li><li>请求结束连接，关机。</li></ol><h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><ol><li><p>生成的 <code>nReducer</code> 个中间临时文件可以编码成 <code>json</code> 的格式，方便处理，可以在打开的文件中写入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enc := json.NewEncoder(file)</span><br><span class="line"><span class="keyword">for</span> _, kv := ... &#123;</span><br><span class="line">    err := enc.Encode(&amp;kv)</span><br></pre></td></tr></table></figure><p>在打开的文件中读取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">kva = <span class="built_in">append</span>(kva, kv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>worker</code>每次在结束任务后都要重复请求任务（心跳），直到获得任务全部结束的信号。</p></li><li><p>通过维护<code>待分配</code> 和 <code>待完成</code> 两个队列，可以控制任务的发放与 <code>map</code>、<code>reduce</code> 两个大任务的完成情况。</p></li><li><p>可以通过生成临时文件保存临时结果的方式避免因为超时导致的 <code>crash</code>。</p></li><li><p>保存的文件可以带上唯一的 <code>jobId</code> 防止 <code>crash</code>。</p></li><li><p><code>coordinator</code> 对任务的超时控制：采用了一个 select 的结构，第一个分支是超时上下文  <code>ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)</code> 来控制，如果超时，除了处理对应的两个队列外，还需要将对应工号的 <code>rejectResult</code> 置为 <code>true</code>，防止 <code>worker</code> 在规定时间内完成了任务，但是因为 PRC 通信的延迟导致超时出现的   <code>coordinator</code> 和 <code>worker</code> 对临时文件处理不一致的情况；第二个分支是对应工号的 <code>workerDone</code>， <code>coordinator</code> 在规定时间内接收到正确的完成信号后，就会向该无缓冲通道内发送数据，从而选择这一分支，表示任务顺利完成。</p></li><li><p>对锁和原子数据的使用上要注意，避免 <code>data race</code>（编译时通过 <code>-race</code> 进行竞态检测）。</p></li></ol><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a class="link" href="https://github.com/JiahaoHong1997/MIT6.824">GitHub-MIT6.824<i class="fas fa-external-link-alt"></i></a></p><h2 id="关键项目文件结构"><a href="#关键项目文件结构" class="headerlink" title="关键项目文件结构"></a>关键项目文件结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">|- doc</span><br><span class="line">|- src</span><br><span class="line">|- main</span><br><span class="line">|- mrsequential.go</span><br><span class="line">|- mrworker.go</span><br><span class="line">|- mrcoordinator.go</span><br><span class="line">|- test-mr.sh</span><br><span class="line">|- mr</span><br><span class="line">|- coordinator.go&#x2F;&#x2F; coordinator 控制逻辑</span><br><span class="line">|- rpc.go&#x2F;&#x2F; rpc 通信结构</span><br><span class="line">|- worker.go&#x2F;&#x2F; worker 控制逻辑</span><br><span class="line">|- mrapps</span><br><span class="line">|- wc.go</span><br><span class="line">|- indexer.go</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;任务梳理&quot;&gt;&lt;a href=&quot;#任务梳理&quot; class=&quot;headerlink&quot; title=&quot;任务梳理&quot;&gt;&lt;/a&gt;任务梳理&lt;/h1&gt;&lt;h2 id=&quot;mapreduce-介绍及部署&quot;&gt;&lt;a href=&quot;#mapreduce-介绍及部署&quot; class=&quot;header</summary>
      
    
    
    
    <category term="分布式系统" scheme="http://jiahaohong1997.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="mit6.824" scheme="http://jiahaohong1997.github.io/tags/mit6-824/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 6）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/04/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%206%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/04/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%206%EF%BC%89/</id>
    <published>2022-04-04T00:00:00.000Z</published>
    <updated>2022-04-08T00:09:16.517Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对第 287 场周赛的复盘总结</p><h2 id="6055-转化时间需要的最少操作数"><a href="#6055-转化时间需要的最少操作数" class="headerlink" title="6055. 转化时间需要的最少操作数"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-convert-time/">6055. 转化时间需要的最少操作数<i class="fas fa-external-link-alt"></i></a></h2><p>#模拟题</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你两个字符串 current 和 correct ，表示两个 24 小时制时间 。<br>24 小时制时间 按 “HH:MM” 进行格式化，其中 HH 在 00 和 23 之间，而 MM 在 00 和 59 之间。最早的 24 小时制时间为 00:00 ，最晚的是 23:59 。<br>在一步操作中，你可以将 current 这个时间增加 1、5、15 或 60 分钟。你可以执行这一操作 任意 次数。<br>返回将 current 转化为 correct 需要的 最少操作数 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：current &#x3D; &quot;02:30&quot;, correct &#x3D; &quot;04:35&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">可以按下述 3 步操作将 current 转换为 correct ：</span><br><span class="line">- 为 current 加 60 分钟，current 变为 &quot;03:30&quot; 。</span><br><span class="line">- 为 current 加 60 分钟，current 变为 &quot;04:30&quot; 。 </span><br><span class="line">- 为 current 加 5 分钟，current 变为 &quot;04:35&quot; 。</span><br><span class="line">可以证明，无法用少于 3 步操作将 current 转化为 correct 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：current &#x3D; &quot;11:00&quot;, correct &#x3D; &quot;11:01&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：只需要为 current 加一分钟，所以最小操作数是 1 。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">current 和 correct 都符合 &quot;HH:MM&quot; 格式</span><br><span class="line">current &lt;&#x3D; correct</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 本题其实是变种的零钱问题。初始状态是 <code>current</code>，最终状态是 <code>correct</code>，可用“零钱”面额有 <code>[1,5,15,60]</code>；<br>(2). 现将初始、最终两种状态转换成和“零钱”面额一样的计数单位——“分钟”；<br>(3). 使用动态规划，从初始状态一步步向最终状态逼近。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N).</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertTime</span><span class="params">(current <span class="keyword">string</span>, correct <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s1 := strings.Split(current, <span class="string">&quot;:&quot;</span>)</span><br><span class="line">h1, m1 := s1[<span class="number">0</span>], s1[<span class="number">1</span>]</span><br><span class="line">s2 := strings.Split(correct, <span class="string">&quot;:&quot;</span>)</span><br><span class="line">h2, m2 := s2[<span class="number">0</span>], s2[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用分钟代表初始状态</span></span><br><span class="line">nowh, _ := strconv.Atoi(h1)</span><br><span class="line">nowm, _ := strconv.Atoi(m1)</span><br><span class="line">now := nowh*<span class="number">60</span>+nowm</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用分钟代表最终状态</span></span><br><span class="line">th, _ := strconv.Atoi(h2)</span><br><span class="line">tm, _ := strconv.Atoi(m2)</span><br><span class="line">t := th*<span class="number">60</span>+tm</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将状态归一化到 (0,diff) 区间</span></span><br><span class="line">diff := abs(now, t)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可用零钱面额</span></span><br><span class="line">choose := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">60</span>&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, diff+<span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=diff; i++ &#123;</span><br><span class="line">dp[i] = math.MaxInt32</span><br><span class="line"><span class="keyword">for</span> j:=<span class="built_in">len</span>(choose)<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j-- &#123;</span><br><span class="line"><span class="keyword">if</span> choose[j] &gt; i &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">dp[i] = min(dp[i], dp[i-choose[j]]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[diff]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a-b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b-a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5235-找出输掉零场或一场比赛的玩家"><a href="#5235-找出输掉零场或一场比赛的玩家" class="headerlink" title="5235. 找出输掉零场或一场比赛的玩家"></a><a class="link" href="https://leetcode-cn.com/problems/find-players-with-zero-or-one-losses/">5235. 找出输掉零场或一场比赛的玩家<i class="fas fa-external-link-alt"></i></a></h2><p>#map</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个整数数组 matches 其中 matches[i] = [winneri, loseri] 表示在一场比赛中 winneri 击败了 loseri 。<br>返回一个长度为 2 的列表 answer ：<br>answer[0] 是所有 没有 输掉任何比赛的玩家列表。<br>answer[1] 是所有恰好输掉 一场 比赛的玩家列表。<br>两个列表中的值都应该按 递增 顺序返回。</p></blockquote><blockquote><p>注意：<br>只考虑那些参与 至少一场 比赛的玩家。<br>生成的测试用例保证 不存在 两场比赛结果 相同 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：matches &#x3D; [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]</span><br><span class="line">输出：[[1,2,10],[4,5,7,8]]</span><br><span class="line">解释：</span><br><span class="line">玩家 1、2 和 10 都没有输掉任何比赛。</span><br><span class="line">玩家 4、5、7 和 8 每个都输掉一场比赛。</span><br><span class="line">玩家 3、6 和 9 每个都输掉两场比赛。</span><br><span class="line">因此，answer[0] &#x3D; [1,2,10] 和 answer[1] &#x3D; [4,5,7,8] 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：matches &#x3D; [[2,3],[1,3],[5,4],[6,4]]</span><br><span class="line">输出：[[1,2,5,6],[]]</span><br><span class="line">解释：</span><br><span class="line">玩家 1、2、5 和 6 都没有输掉任何比赛。</span><br><span class="line">玩家 3 和 4 每个都输掉两场比赛。</span><br><span class="line">因此，answer[0] &#x3D; [1,2,5,6] 和 answer[1] &#x3D; [] 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; matches.length &lt;&#x3D; 105</span><br><span class="line">matches[i].length &#x3D;&#x3D; 2</span><br><span class="line">1 &lt;&#x3D; winneri, loseri &lt;&#x3D; 105</span><br><span class="line">winneri !&#x3D; loseri</span><br><span class="line">所有 matches[i] 互不相同</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 本题需要输出两个列表：其一是 <strong>入度</strong> 为 $0$ 且 <strong>出度</strong> 大于 $0$ 的编号，其二是 <strong>入度</strong> 恰好为 $1$ 的编号；<br>(2). 使用两个 <code>map</code> 分别保存每个编号的出度和入度；<br>(3). 首先遍历 <strong>入度</strong> <code>map</code>，只要发现其长度为 $1$，那就加入输出中；<br>(4). 然后遍历 <strong>出度</strong> <code>map</code>，检查对应编号的 <strong>入度</strong> 列表如果为 $0$，那么也加入输出中；<br>(5). 排序两个列表。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findWinners</span><span class="params">(matches [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 matches，构建 出度 和 入度 map</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(matches); i++ &#123;</span><br><span class="line">win, lose := matches[i][<span class="number">0</span>], matches[i][<span class="number">1</span>]</span><br><span class="line">m1[lose] = <span class="built_in">append</span>(m1[lose], win)</span><br><span class="line">m2[win] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">1</span> &#123;</span><br><span class="line">ret[<span class="number">1</span>] = <span class="built_in">append</span>(ret[<span class="number">1</span>], k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> m2 &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(m1[k]) == <span class="number">0</span> &#123;</span><br><span class="line">ret[<span class="number">0</span>] = <span class="built_in">append</span>(ret[<span class="number">0</span>], k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Ints(ret[<span class="number">0</span>])</span><br><span class="line">sort.Ints(ret[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5219-每个小孩最多能分到多少糖果"><a href="#5219-每个小孩最多能分到多少糖果" class="headerlink" title="5219. 每个小孩最多能分到多少糖果"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-candies-allocated-to-k-children/">5219. 每个小孩最多能分到多少糖果<i class="fas fa-external-link-alt"></i></a></h2><p>#二分查找</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个 下标从 0 开始 的整数数组 candies 。数组中的每个元素表示大小为 candies[i] 的一堆糖果。你可以将每堆糖果分成任意数量的 子堆 ，但 无法 再将两堆合并到一起。<br>另给你一个整数 k 。你需要将这些糖果分配给 k 个小孩，使每个小孩分到 相同 数量的糖果。每个小孩可以拿走 至多一堆 糖果，有些糖果可能会不被分配。<br>返回每个小孩可以拿走的 最大糖果数目 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：candies &#x3D; [5,8,6], k &#x3D; 3</span><br><span class="line">输出：5</span><br><span class="line">解释：可以将 candies[1] 分成大小分别为 5 和 3 的两堆，然后把 candies[2] 分成大小分别为 5 和 1 的两堆。现在就有五堆大小分别为 5、5、3、5 和 1 的糖果。可以把 3 堆大小为 5 的糖果分给 3 个小孩。可以证明无法让每个小孩得到超过 5 颗糖果。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：candies &#x3D; [2,5], k &#x3D; 11</span><br><span class="line">输出：0</span><br><span class="line">解释：总共有 11 个小孩，但只有 7 颗糖果，但如果要分配糖果的话，必须保证每个小孩至少能得到 1 颗糖果。因此，最后每个小孩都没有得到糖果，答案是 0 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; candies.length &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; candies[i] &lt;&#x3D; 10^7</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; 10^12</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先看一看数据量，明显暴力绝对会超时，那么别无选择，二分法搞起来；<br>(2). 首先判断一下边界情况，当 🍬总数 &lt; 🧒总数 时，显然大家都没得分，return 0；如果 🍬总数 == 🧒总数 ，return 1<br>(3) 二分查找的左边界是 $1$，右边界是 🍬总数/🧒总数 ；<br>(4) 要查找满足条件的右边界，二分超找模板套起来。</p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(Nlog(N))</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumCandies</span><span class="params">(candies []<span class="keyword">int</span>, k <span class="keyword">int64</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(candies); i++ &#123;</span><br><span class="line">total += <span class="keyword">int64</span>(candies[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> total &lt; k &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> total == k &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> satisified <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">satisified = <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(candies); i++ &#123;</span><br><span class="line">count += <span class="keyword">int64</span>(candies[i]/n)</span><br><span class="line"><span class="keyword">if</span> count &gt;= k &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l, r := <span class="number">1</span>, <span class="keyword">int</span>(total/k)</span><br><span class="line"><span class="keyword">if</span> satisified(r) &#123;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">m := l+(r-l)&gt;&gt;<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> satisified(m) &#123;</span><br><span class="line">l = m+<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !satisified(m) &#123;</span><br><span class="line">r = m</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> l<span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5302-加密解密字符串"><a href="#5302-加密解密字符串" class="headerlink" title="5302. 加密解密字符串"></a><a class="link" href="https://leetcode-cn.com/problems/encrypt-and-decrypt-strings/">5302. 加密解密字符串<i class="fas fa-external-link-alt"></i></a></h2><p>#设计题</p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个字符数组 keys ，由若干 互不相同 的字符组成。还有一个字符串数组 values ，内含若干长度为 2 的字符串。另给你一个字符串数组 dictionary ，包含解密后所有允许的原字符串。请你设计并实现一个支持加密及解密下标从 0 开始字符串的数据结构。<br>字符串 加密 按下述步骤进行：<br>1.对字符串中的每个字符 c ，先从 keys 中找出满足 keys[i] == c 的下标 i 。<br>2.在字符串中，用 values[i] 替换字符 c 。<br>字符串 解密 按下述步骤进行：<br>1.将字符串每相邻 2 个字符划分为一个子字符串，对于每个子字符串 s ，找出满足 values[i] == s 的一个下标 i 。如果存在多个有效的 i ，从中选择 任意 一个。这意味着一个字符串解密可能得到多个解密字符串。<br>2.在字符串中，用 keys[i] 替换 s 。<br>实现 Encrypter 类：<br>1.Encrypter(char[] keys, String[] values, String[] dictionary) 用 keys、values 和 dictionary 初始化 Encrypter 类。<br>2.String encrypt(String word1) 按上述加密过程完成对 word1 的加密，并返回加密后的字符串。<br>3.int decrypt(String word2) 统计并返回可以由 word2 解密得到且出现在 dictionary 中的字符串数目。</p></blockquote><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 注意到 <code>values</code> 中有相同的字符串，因此不同的字符串加密后可能是一样的，从而一个字符串解密出的结果可能不是唯一的；<br>(2). 根据提示 1，直接解密较为复杂，不妨逆向思考，即加密 <code>dictionary</code> 中的每个字符串。用哈希表记录每个加密后的字符串的出现次数。这样每次调用 <code>decrypt</code> 时，返回哈希表中 <code>word2</code> 的出现次数即可。</p><h3 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Encrypter <span class="keyword">struct</span> &#123;</span><br><span class="line">mp  [<span class="number">26</span>]<span class="keyword">string</span></span><br><span class="line">cnt <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(keys []<span class="keyword">byte</span>, values, dictionary []<span class="keyword">string</span>)</span> <span class="title">Encrypter</span></span> &#123;</span><br><span class="line">mp := [<span class="number">26</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">mp[key-<span class="string">&#x27;a&#x27;</span>] = values[i]</span><br><span class="line">&#125;</span><br><span class="line">e := Encrypter&#123;mp, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> dictionary &#123;</span><br><span class="line">e.cnt[e.Encrypt(s)]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Encrypter)</span> <span class="title">Encrypt</span><span class="params">(word1 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(word1)*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> word1 &#123;</span><br><span class="line">s := e.mp[ch-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, s...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Encrypter)</span> <span class="title">Decrypt</span><span class="params">(word2 <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> e.cnt[word2] &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是对第 287 场周赛的复盘总结&lt;/p&gt;
&lt;h2 id=&quot;6055-转化时间需要的最少操作数&quot;&gt;&lt;a href=&quot;#6055-转化时间需要的最少操作数&quot; class=&quot;headerlink&quot; title=&quot;6055. 转化时间需要的最少操作数&quot;&gt;&lt;/a&gt;&lt;a class</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 5）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/03/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%205%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/03/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%205%EF%BC%89/</id>
    <published>2022-04-02T22:00:00.000Z</published>
    <updated>2022-04-08T00:11:31.121Z</updated>
    
    <content type="html"><![CDATA[<p>今天早上复盘一下昨天晚上的双周赛</p><h2 id="LeetCode6033-转换数字的最少位翻转次数"><a href="#LeetCode6033-转换数字的最少位翻转次数" class="headerlink" title="LeetCode6033. 转换数字的最少位翻转次数"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-bit-flips-to-convert-number/">LeetCode6033. 转换数字的最少位翻转次数<i class="fas fa-external-link-alt"></i></a></h2><p>#位运算</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>一次 位翻转 定义为将数字 x 二进制中的一个位进行 翻转 操作，即将 0 变成 1 ，或者将 1 变成 0 。<br>比方说，x = 7 ，二进制表示为 111 ，我们可以选择任意一个位（包含没有显示的前导 0 ）并进行翻转。比方说我们可以翻转最右边一位得到 110 ，或者翻转右边起第二位得到 101 ，或者翻转右边起第五位（这一位是前导 0 ）得到 10111 等等。<br>给你两个整数 start 和 goal ，请你返回将 start 转变成 goal 的 最少位翻转 次数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：start &#x3D; 10, goal &#x3D; 7</span><br><span class="line">输出：3</span><br><span class="line">解释：10 和 7 的二进制表示分别为 1010 和 0111 。我们可以通过 3 步将 10 转变成 7 ：</span><br><span class="line">- 翻转右边起第一位得到：1010 -&gt; 1011 。</span><br><span class="line">- 翻转右边起第三位：1011 -&gt; 1111 。</span><br><span class="line">- 翻转右边起第四位：1111 -&gt; 0111 。</span><br><span class="line">我们无法在 3 步内将 10 转变成 7 。所以我们返回 3 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：start &#x3D; 3, goal &#x3D; 4</span><br><span class="line">输出：3</span><br><span class="line">解释：3 和 4 的二进制表示分别为 011 和 100 。我们可以通过 3 步将 3 转变成 4 ：</span><br><span class="line">- 翻转右边起第一位：011 -&gt; 010 。</span><br><span class="line">- 翻转右边起第二位：010 -&gt; 000 。</span><br><span class="line">- 翻转右边起第三位：000 -&gt; 100 。</span><br><span class="line">我们无法在 3 步内将 3 变成 4 。所以我们返回 3 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; start, goal &lt;&#x3D; 109</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 本质上是判断两个数有多少个比特位值是不一样的（包含前导零）；<br>(2). 那就从最后一个比特位开始往前比较就好了。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minBitFlips</span><span class="params">(start <span class="keyword">int</span>, goal <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> judgeLastBit <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">judgeLastBit = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x == <span class="number">0</span> || x^(x<span class="number">-1</span>) != <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> start &gt; <span class="number">0</span> || goal &gt; <span class="number">0</span> &#123;</span><br><span class="line">x1 := judgeLastBit(start)</span><br><span class="line">x2 := judgeLastBit(goal)</span><br><span class="line"><span class="keyword">if</span> (x1 &amp;&amp; !x2) || (!x1 &amp;&amp; x2) &#123;</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line">start &gt;&gt;= <span class="number">1</span></span><br><span class="line">goal &gt;&gt;= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode6034-数组的三角和"><a href="#LeetCode6034-数组的三角和" class="headerlink" title="LeetCode6034. 数组的三角和"></a><a class="link" href="https://leetcode-cn.com/problems/find-triangular-sum-of-an-array/">LeetCode6034. 数组的三角和<i class="fas fa-external-link-alt"></i></a></h2><p>#模拟题</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个下标从 0 开始的整数数组 nums ，其中 nums[i] 是 0 到 9 之间（两者都包含）的一个数字。<br>nums 的 三角和 是执行以下操作以后最后剩下元素的值：<br>1.nums 初始包含 n 个元素。如果 n == 1 ，终止 操作。否则，创建 一个新的下标从 0 开始的长度为 n - 1 的整数数组 newNums 。<br>2.对于满足 0 &lt;= i &lt; n - 1 的下标 i ，newNums[i] 赋值 为 (nums[i] + nums[i+1]) % 10 ，% 表示取余运算。<br>3.将 newNums 替换 数组 nums 。<br>4.从步骤 1 开始 重复 整个过程。<br>5.请你返回 nums 的三角和。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="ex1drawio.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：8</span><br><span class="line">解释：</span><br><span class="line">上图展示了得到数组三角和的过程。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [5]</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">由于 nums 中只有一个元素，数组的三角和为这个元素自己。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; nums[i] &lt;&#x3D; 9</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 太简单了。。没啥好说的</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">triangularSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(nums) &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">nums[i] += nums[i+<span class="number">1</span>]</span><br><span class="line">nums[i] %= <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">nums = nums[:<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode6035-选择建筑的方案数"><a href="#LeetCode6035-选择建筑的方案数" class="headerlink" title="LeetCode6035. 选择建筑的方案数"></a><a class="link" href="https://leetcode-cn.com/problems/number-of-ways-to-select-buildings/">LeetCode6035. 选择建筑的方案数<i class="fas fa-external-link-alt"></i></a></h2><p>#动态规划</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个下标从 0 开始的二进制字符串 s ，它表示一条街沿途的建筑类型，其中：<br>s[i] = ‘0’ 表示第 i 栋建筑是一栋办公楼，<br>s[i] = ‘1’ 表示第 i 栋建筑是一间餐厅。<br>作为市政厅的官员，你需要随机 选择 3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 相邻 的两栋不能是同一类型。<br>比方说，给你 s = “001101” ，我们不能选择第 1 ，3 和 5 栋建筑，因为得到的子序列是 “011” ，有相邻两栋建筑是同一类型，所以 不合 题意。<br>请你返回可以选择 3 栋建筑的 有效方案数 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;001101&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">以下下标集合是合法的：</span><br><span class="line">- [0,2,4] ，从 &quot;001101&quot; 得到 &quot;010&quot;</span><br><span class="line">- [0,3,4] ，从 &quot;001101&quot; 得到 &quot;010&quot;</span><br><span class="line">- [1,2,4] ，从 &quot;001101&quot; 得到 &quot;010&quot;</span><br><span class="line">- [1,3,4] ，从 &quot;001101&quot; 得到 &quot;010&quot;</span><br><span class="line">- [2,4,5] ，从 &quot;001101&quot; 得到 &quot;101&quot;</span><br><span class="line">- [3,4,5] ，从 &quot;001101&quot; 得到 &quot;101&quot;</span><br><span class="line">没有别的合法选择，所以总共有 6 种方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;11100&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：没有任何符合题意的选择。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">3 &lt;&#x3D; s.length &lt;&#x3D; 105</span><br><span class="line">s[i] 要么是 &#39;0&#39; ，要么是 &#39;1&#39; 。</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法一：暴力递归搜索（超时）<br>(1). 类似组合数这种类型的题目，不过要判断一下是否符合最终合法的约定；<br>(2). 当字符串剩下的长度不足以满足要求，剪枝。（实际上这个优化并没什么用，因为剪枝的长度最大也就 3，根本不影响最终的复杂度）</p><p>方法二：统计前缀数量（O(N)）<br>分别定义 5 个变量，<code>n1</code> 代表前缀为 1 的子序列数量，<code>n0</code> 代表前缀为 0 的子序列数量，<code>n01</code> 代表前缀为 01 的子序列数量,<code>n10</code> 代表前缀为 10 的子序列数量，<code>count</code>则是统计合法的子序列数量（<code>010</code> + <code>101</code>）</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><p>方法一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfWays</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int64</span></span><br><span class="line">path := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> backTracking <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span>, rest <span class="keyword">int</span>)</span></span></span><br><span class="line">backTracking = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span> ,rest <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rest == <span class="number">0</span> &#123;</span><br><span class="line">count++</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=start; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> rest &gt; <span class="built_in">len</span>(s[start:]) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">0</span> &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, s[i])</span><br><span class="line">backTracking(i+<span class="number">1</span>, rest<span class="number">-1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] != path[<span class="built_in">len</span>(path)<span class="number">-1</span>] &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, s[i])</span><br><span class="line">backTracking(i+<span class="number">1</span>, rest<span class="number">-1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; <span class="number">0</span> &#123;</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">backTracking(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfWays</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> n0, n1, n01, n10 <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">n01 += n0</span><br><span class="line">n1++</span><br><span class="line">count += n10</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">n10 += n1</span><br><span class="line">n0++</span><br><span class="line">count += n01</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天早上复盘一下昨天晚上的双周赛&lt;/p&gt;
&lt;h2 id=&quot;LeetCode6033-转换数字的最少位翻转次数&quot;&gt;&lt;a href=&quot;#LeetCode6033-转换数字的最少位翻转次数&quot; class=&quot;headerlink&quot; title=&quot;LeetCode6033. 转换数字</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 4）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/02/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%204%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/02/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%204%EF%BC%89/</id>
    <published>2022-04-01T22:00:00.000Z</published>
    <updated>2022-04-08T00:12:46.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode856-括号的分数"><a href="#LeetCode856-括号的分数" class="headerlink" title="LeetCode856. 括号的分数"></a><a class="link" href="https://leetcode-cn.com/problems/score-of-parentheses/">LeetCode856. 括号的分数<i class="fas fa-external-link-alt"></i></a></h2><p>#递归 #栈</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：<br>() 得 1 分。<br>AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。<br>(A) 得 2 * A 分，其中 A 是平衡括号字符串。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：&quot;()&quot;</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：&quot;(())&quot;</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：&quot;()()&quot;</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：&quot;(()(()))&quot;</span><br><span class="line">输出：6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1. S 是平衡括号字符串，且只含有 ( 和 ) 。</span><br><span class="line">2. 2 &lt;&#x3D; S.length &lt;&#x3D; 50</span><br></pre></td></tr></table></figure><p> </p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p> (1). 考虑采用递归 + 栈来解题。括号问题首先天然就会想到使用栈，由于本题不需要考虑括号字符串的合法性，所以栈可以当作一个状态的保存，在栈内部进行递归；<br> (2). 对于嵌套的括号，采用递归的策略，出递归前将递归栈中分数*2 即可；<br> (3). 注意遍历字符串要使用指针以及出递归的条件。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p> O(N).</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scoreOfParentheses</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scoreCount <span class="function"><span class="keyword">func</span><span class="params">(start *<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">scoreCount = <span class="function"><span class="keyword">func</span><span class="params">(start *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ss := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">sc := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ; *start&lt;<span class="built_in">len</span>(s); (*start)++ &#123;</span><br><span class="line">i := *start</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ss) == <span class="number">0</span> &amp;&amp; s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">ss = <span class="built_in">append</span>(ss, <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; <span class="built_in">len</span>(ss) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; ss[<span class="built_in">len</span>(ss)<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">sc++</span><br><span class="line">ss = ss[:<span class="built_in">len</span>(ss)<span class="number">-1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &amp;&amp; <span class="built_in">len</span>(ss) != <span class="number">0</span> &#123;</span><br><span class="line">sc += <span class="number">2</span>*scoreCount(start)</span><br><span class="line">ss = ss[:<span class="built_in">len</span>(ss)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">score := <span class="number">0</span></span><br><span class="line">stack := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">score++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">score += <span class="number">2</span>*scoreCount(&amp;i)</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> score</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a class="link" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表<i class="fas fa-external-link-alt"></i></a></h2><p>#优先队列</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：lists &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：lists &#x3D; [[]]</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">k &#x3D;&#x3D; lists.length</span><br><span class="line">0 &lt;&#x3D; k &lt;&#x3D; 10^4</span><br><span class="line">0 &lt;&#x3D; lists[i].length &lt;&#x3D; 500</span><br><span class="line">-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4</span><br><span class="line">lists[i] 按 升序 排列</span><br><span class="line">lists[i].length 的总和不超过 10^4</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>优先队列，直接看代码吧</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(Nlog(N))，取决于堆排序的时间复杂度</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a[h[i]]&lt;a[h[j]]</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(*h)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[:n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">l := <span class="built_in">len</span>(lists)</span><br><span class="line"><span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h IntHeap</span><br><span class="line">a = <span class="built_in">make</span>([]<span class="keyword">int</span>, l)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;l; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> lists[i] == <span class="literal">nil</span> &#123;</span><br><span class="line">a[i] = <span class="number">-1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">a[i] = lists[i].Val</span><br><span class="line">heap.Push(&amp;h, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(h) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first := heap.Pop(&amp;h).(<span class="keyword">int</span>)</span><br><span class="line">head := lists[first]</span><br><span class="line">a[first] = math.MaxInt32</span><br><span class="line">p := head</span><br><span class="line">lists[first] = head.Next</span><br><span class="line">p.Next = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> lists[first] != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 下面两行注意顺序不能反了，先更改 a，才能排序</span></span><br><span class="line">a[first] = lists[first].Val</span><br><span class="line">heap.Push(&amp;h, first)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(h) &gt; <span class="number">0</span> &#123;</span><br><span class="line">i := heap.Pop(&amp;h).(<span class="keyword">int</span>)</span><br><span class="line">a[i] = math.MaxInt32</span><br><span class="line">p.Next = lists[i]</span><br><span class="line">p = p.Next</span><br><span class="line">lists[i] = lists[i].Next</span><br><span class="line"><span class="keyword">if</span> lists[i] != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 下面两行注意顺序不能反了，先更改 a，才能排序</span></span><br><span class="line">a[i] = lists[i].Val</span><br><span class="line">heap.Push(&amp;h, i)</span><br><span class="line">&#125;</span><br><span class="line">p.Next = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// fmt.Println(a,h,x,i)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LeetCode856-括号的分数&quot;&gt;&lt;a href=&quot;#LeetCode856-括号的分数&quot; class=&quot;headerlink&quot; title=&quot;LeetCode856. 括号的分数&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot; href=&quot;https://leet</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 3）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/01/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%203%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/01/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%203%EF%BC%89/</id>
    <published>2022-03-31T21:30:00.000Z</published>
    <updated>2022-04-08T00:14:45.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode269-火星词典"><a href="#LeetCode269-火星词典" class="headerlink" title="LeetCode269. 火星词典"></a><a class="link" href="https://leetcode-cn.com/problems/alien-dictionary/">LeetCode269. 火星词典<i class="fas fa-external-link-alt"></i></a></h2><p>#拓扑排序</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>现有一种使用英语字母的火星语言，这门语言的字母顺序与英语顺序不同。给你一个字符串列表 words ，作为这门语言的词典，words 中的字符串已经 按这门新语言的字母顺序进行了排序 。请你根据该词典还原出此语言中已知的字母顺序，并 按字母递增顺序 排列。若不存在合法字母顺序，返回 “” 。若存在多种可能的合法字母顺序，返回其中 任意一种 顺序即可。<br>字符串 s 字典顺序小于 字符串 t 有两种情况：<br>1.在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t 中字母之前，那么 s 的字典顺序小于 t 。<br>2.如果前面 min(s.length, t.length) 字母都相同，那么 s.length &lt; t.length 时，s 的字典顺序也小于 t 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：words &#x3D; [&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]</span><br><span class="line">输出：&quot;wertf&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：words &#x3D; [&quot;z&quot;,&quot;x&quot;]</span><br><span class="line">输出：&quot;zx&quot;</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入：words &#x3D; [&quot;z&quot;,&quot;x&quot;,&quot;z&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：不存在合法字母顺序，因此返回 &quot;&quot; 。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先考虑什么情况下会出现不合法的情况：如果在之前判断字母 ‘x’ 的字典序应该大于 ‘y’，可是在后面又出现了 ‘y’ 的字典序应该大于 ‘x’ 的情况，那么此时就出现了矛盾，因此是不合法的；<br>(2). 对于这种只允许单向依赖的情况，考虑使用拓扑排序。首先就要构建邻接表和入度统计。在建立邻接表的时候要考虑一种情况，那就是如果出现在后面的字符串是前面字符串的前缀字符串，那么可以立即判定是不合法的；<br>(3). 在构建好两个数据结构后，使用广度优先搜索查找。将入度为 0 的字母放入队列中，然后再将其对应的邻接表中的字母入度减一，此时相当于在拓扑排序中消除了对该字母的依赖，也可以看作访问数 <code>visited</code> 加 1；<br>(4). 最后判断一下 <code>visited</code> 是否是全体出现过的字母数，相等则说明是一个拓扑排序，不存在循环依赖。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(words.length*words[i].length)</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alienOrder</span><span class="params">(words []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">adjacency := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>][]<span class="keyword">byte</span>) <span class="comment">// 邻接表</span></span><br><span class="line">inDegree := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)<span class="comment">// 入度统计</span></span><br><span class="line">ret := <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buildGraph <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">buildGraph = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(words); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(words[i]); j++ &#123;</span><br><span class="line">adjacency[words[i][j]] = []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(words); i++ &#123;</span><br><span class="line">w1, w2 := words[i<span class="number">-1</span>], words[i]</span><br><span class="line">j := <span class="number">0</span></span><br><span class="line">minLength := min(<span class="built_in">len</span>(w1),<span class="built_in">len</span>(w2))</span><br><span class="line"><span class="keyword">for</span> ; j&lt;minLength; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> w1[j] != w2[j] &#123;</span><br><span class="line">adjacency[w1[j]] = <span class="built_in">append</span>(adjacency[w1[j]], w2[j])</span><br><span class="line">inDegree[w2[j]]++</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> j == minLength &amp;&amp; <span class="built_in">len</span>(w1) &gt; <span class="built_in">len</span>(w2) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> visitedCount <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line">visitedCount = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">visited := <span class="number">0</span></span><br><span class="line">q := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,_ := <span class="keyword">range</span> adjacency &#123;</span><br><span class="line"><span class="keyword">if</span> inDegree[k] == <span class="number">0</span> &#123;</span><br><span class="line">q = <span class="built_in">append</span>(q, k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">p := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">w := q[i]</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(adjacency[w]); j++ &#123;</span><br><span class="line">x := adjacency[w][j]</span><br><span class="line">inDegree[x]--</span><br><span class="line"><span class="keyword">if</span> inDegree[x] == <span class="number">0</span> &#123;</span><br><span class="line">p = <span class="built_in">append</span>(p, x)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visited++</span><br><span class="line">&#125;</span><br><span class="line">ret += <span class="keyword">string</span>(q)</span><br><span class="line">q = p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> visited</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !buildGraph() || visitedCount() != <span class="built_in">len</span>(adjacency) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode8-字符串转换整数-atoi"><a href="#LeetCode8-字符串转换整数-atoi" class="headerlink" title="LeetCode8. 字符串转换整数 (atoi)"></a><a class="link" href="https://leetcode-cn.com/problems/string-to-integer-atoi/">LeetCode8. 字符串转换整数 (atoi)<i class="fas fa-external-link-alt"></i></a></h2><p>#模拟题</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。<br>函数 myAtoi(string s) 的算法如下：<br>1.读入字符串并丢弃无用的前导空格<br>2.检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br>3.读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>4.将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。<br>5.如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。<br>6.返回整数作为最终结果。</p></blockquote><blockquote><p>注意：<br>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：s &#x3D; &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 42 。</span><br><span class="line">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：s &#x3D; &quot;   -42&quot;</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 2 步：&quot;   -42&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入：s &#x3D; &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 4193 。</span><br><span class="line">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; s.length &lt;&#x3D; 200</span><br><span class="line">s 由英文字母（大写和小写）、数字（0-9）、&#39; &#39;、&#39;+&#39;、&#39;-&#39; 和 &#39;.&#39; 组成</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 这是一道很典型的模拟题，对于模拟题，少不了条件判断，建议采用 switch 来代替大量的 if…else，这样代码的逻辑会清晰很多；<br>(2). 这道题唯一值得关心的点就是越界问题，那么就需要将合法数字字符串取出后先去除前导零，然后再根据符号分别判断是否越界。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAtoi</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isNeg := <span class="literal">false</span></span><br><span class="line">prefixLetter := <span class="literal">true</span></span><br><span class="line">str := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">maxNum, minNum := math.MaxInt32, <span class="number">-1</span>*math.MinInt32</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> prefixLetter &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s[i] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">isNeg = <span class="literal">true</span></span><br><span class="line">prefixLetter = <span class="literal">false</span></span><br><span class="line"><span class="keyword">case</span> s[i] == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">prefixLetter = <span class="literal">false</span></span><br><span class="line"><span class="keyword">case</span> s[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> s[i] == <span class="string">&#x27;.&#x27;</span> || (s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">case</span> s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">prefixLetter = <span class="literal">false</span></span><br><span class="line">str = <span class="built_in">append</span>(str, s[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">str = <span class="built_in">append</span>(str, s[i])</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">i = <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(str) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> str[i] != <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">x = i</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> !isNeg &#123;</span><br><span class="line"><span class="keyword">for</span> i:=x; i&lt;<span class="built_in">len</span>(str) ;i++ &#123;</span><br><span class="line">ret *= <span class="number">10</span></span><br><span class="line">ret += <span class="keyword">int</span>(str[i])-<span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">if</span> ret &gt; maxNum &#123;</span><br><span class="line"><span class="keyword">return</span> maxNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=x; i&lt;<span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">ret *= <span class="number">10</span></span><br><span class="line">ret += <span class="keyword">int</span>(str[i])-<span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">if</span> ret &gt; minNum &#123;</span><br><span class="line"><span class="keyword">return</span> math.MinInt32</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ret *= <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LeetCode269-火星词典&quot;&gt;&lt;a href=&quot;#LeetCode269-火星词典&quot; class=&quot;headerlink&quot; title=&quot;LeetCode269. 火星词典&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcod</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 2）</title>
    <link href="http://jiahaohong1997.github.io/2022/03/31/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%202%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/03/31/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%202%EF%BC%89/</id>
    <published>2022-03-30T22:00:00.000Z</published>
    <updated>2022-04-08T00:16:10.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode63-不同路径-II"><a href="#LeetCode63-不同路径-II" class="headerlink" title="LeetCode63. 不同路径 II"></a><a class="link" href="https://leetcode-cn.com/problems/unique-paths-ii/">LeetCode63. 不同路径 II<i class="fas fa-external-link-alt"></i></a></h2><p>#动态规划</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br>网格中的障碍物和空位置分别用 1 和 0 来表示。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="robot1.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br><span class="line"></span><br><span class="line">示例 2:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="robot2.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid &#x3D; [[0,1],[0,0]]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">m &#x3D;&#x3D; obstacleGrid.length</span><br><span class="line">n &#x3D;&#x3D; obstacleGrid[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 100</span><br><span class="line">obstacleGrid[i][j] 为 0 或 1</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 采用二维递归的思路，本题是<a class="link" href="https://leetcode-cn.com/problems/unique-paths/">LeetCode62. 不同路径<i class="fas fa-external-link-alt"></i></a>的变种，实际上是一道题；<br>(2). 在处理初始条件（第一行和第一列）遇到障碍物时，障碍物所在的格子即之后的格子都属于不可到达的坐标，退出循环；<br>(3). 在递归过程中，如果遇到障碍物，直接判断为不可到达 <code>dp[i][j]=0</code>，否则当前格子的路径数等于上面、左面的路径数之和。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O($N^2$).</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m, n := <span class="built_in">len</span>(obstacleGrid), <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, m)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;m; i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;m; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span> &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] != <span class="number">1</span> &#123;</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;m; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">dp[i][j] = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode498-对角线遍历"><a href="#LeetCode498-对角线遍历" class="headerlink" title="LeetCode498. 对角线遍历"></a><a class="link" href="https://leetcode-cn.com/problems/diagonal-traverse/">LeetCode498. 对角线遍历<i class="fas fa-external-link-alt"></i></a></h2><p>#模拟题</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个大小为 <code>m x n</code> 的矩阵 <code>mat</code> ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="diag1-grid.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,4,7,5,3,6,8,9]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：mat &#x3D; [[1,2],[3,4]]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 本题要处理的细节比较多。首先解决边界问题，当 <code>mat</code> 只有一行或一列的时候，直接输出这一行或一列；<br>(2). 要关注三个和转向有关的情况：<code>direction</code> 用于描述当前前进的方向，向右上是为 <code>true</code>，向左下时为 <code>false</code>；<code>rowHalf</code> 用于描述在右上方向前进到顶格时，接下来是要向右还是向下移动一格；<code>columnHalf</code> 用于描述在左下方向前进到顶格时接下来是要向下还是向右前进一格。实际上就是判断有没有分别在行和列上走过 <code>mat</code> 的一半位置。<br>(3). 可以观察到，当前位置的坐标和 <code>i+j</code> 在大于等于行号或列号的时候，走到顶格后转向的方向需要发生改变。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O($M*N$)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDiagonalOrder</span><span class="params">(mat [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">m, n := <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> m == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mat[<span class="number">0</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;m; i++ &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, mat[i][<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">direction := <span class="literal">true</span></span><br><span class="line">rowHalf := <span class="literal">true</span></span><br><span class="line">columnHalf := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i&lt;m &amp;&amp; j&lt;n &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, mat[i][j])</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; direction &amp;&amp; rowHalf) || (j == n<span class="number">-1</span> &amp;&amp; direction &amp;&amp; !rowHalf) &#123;</span><br><span class="line"><span class="keyword">if</span> rowHalf &#123;</span><br><span class="line"><span class="keyword">if</span> j &lt; n<span class="number">-1</span> &#123;</span><br><span class="line">j++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">direction = <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; !direction) || (i == m<span class="number">-1</span> &amp;&amp; !direction &amp;&amp; !columnHalf) &#123;</span><br><span class="line"><span class="keyword">if</span> columnHalf &#123;</span><br><span class="line"><span class="keyword">if</span> i &lt; m<span class="number">-1</span> &#123;</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">direction = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> direction &#123;</span><br><span class="line">i--</span><br><span class="line">j++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">i++</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i+j &gt;= m<span class="number">-1</span> &#123;</span><br><span class="line">columnHalf = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i+j &gt;= n<span class="number">-1</span> &#123;</span><br><span class="line">rowHalf = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode83-删除排序链表中的重复元素"><a href="#LeetCode83-删除排序链表中的重复元素" class="headerlink" title="LeetCode83. 删除排序链表中的重复元素"></a><a class="link" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">LeetCode83. 删除排序链表中的重复元素<i class="fas fa-external-link-alt"></i></a></h2><p>#链表</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个已排序的链表的头 <code>head</code> ， 删除所有重复的元素，使每个元素只出现一次。返回已排序的链表 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：head &#x3D; [1,1,2]</span><br><span class="line">输出：[1,2]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：head &#x3D; [1,1,2,3,3]</span><br><span class="line">输出：[1,2,3]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">链表中节点数目在范围 [0, 300] 内</span><br><span class="line">100 &lt;&#x3D; Node.val &lt;&#x3D; 100</span><br><span class="line">题目数据保证链表已经按升序排列</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 要删除重复的节点，那么就要实时维护三个位置的节点 <code>pre</code>、<code>cur</code>、<code>next</code>，假设要删除 <code>cur</code>，那么删除之后还要将 <code>cur</code> 重新指向 <code>next</code>；<br>(2). 如果 <code>pre</code> 和 <code>cur</code> 的值不相等，那么同时向后移动一位。</p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N).</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre, cur := head, head.Next</span><br><span class="line"><span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">next := cur.Next</span><br><span class="line"><span class="keyword">if</span> cur.Val == pre.Val &#123;</span><br><span class="line">pre.Next = next</span><br><span class="line">cur = next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pre = cur</span><br><span class="line">cur = next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LeetCode63-不同路径-II&quot;&gt;&lt;a href=&quot;#LeetCode63-不同路径-II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode63. 不同路径 II&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot; href=&quot;https://l</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
</feed>
