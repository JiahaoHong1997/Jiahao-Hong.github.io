<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洪笳淏的个人博客</title>
  
  
  <link href="http://jiahaohong1997.github.io/atom.xml" rel="self"/>
  
  <link href="http://jiahaohong1997.github.io/"/>
  <updated>2022-04-07T11:51:19.145Z</updated>
  <id>http://jiahaohong1997.github.io/</id>
  
  <author>
    <name>洪笳淏</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用排序算法</title>
    <link href="http://jiahaohong1997.github.io/2022/04/07/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://jiahaohong1997.github.io/2022/04/07/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-07T11:51:00.000Z</published>
    <updated>2022-04-07T11:51:19.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h2&gt;&lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="排序" scheme="http://jiahaohong1997.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 7）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/06/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%207%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/06/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%207%EF%BC%89/</id>
    <published>2022-04-06T09:38:00.000Z</published>
    <updated>2022-04-07T11:47:21.626Z</updated>
    
    <content type="html"><![CDATA[<p>今天没早起刷题，早起抢菜去了。淦！</p><h2 id="253-会议室-II"><a href="#253-会议室-II" class="headerlink" title="253. 会议室 II"></a><a class="link" href="https://leetcode-cn.com/problems/meeting-rooms-ii/">253. 会议室 II<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，返回 所需会议室的最小数量 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：intervals &#x3D; [[0,30],[5,10],[15,20]]</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：intervals &#x3D; [[7,10],[2,4]]</span><br><span class="line">输出：1</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; intervals.length &lt;&#x3D; 104</span><br><span class="line">0 &lt;&#x3D; starti &lt; endi &lt;&#x3D; 106</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 按照最朴素的想法，要给公司部门安排会议，那么一定是优先考虑会议开始得早的部门，那么首先就是要排序。排序的条件就是开始时间越早越靠前；<br>(2). 安排新会议室的原则是所有已申请的会议室都被占用。那么就可以使用一个最小堆，堆中保存的是每场会议的结束时间；<br>(3). 当当前会议开始时，堆顶的会议还没结束，说明堆中所有的会议都不可能结束，那么就要申请新的会议室；<br>(4). 遍历完整个会议的记录，就可以得到要开辟的最大会议室数量。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(Nlog(N))</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> intHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h intHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h intHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h intHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> h[i] &lt; h[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *intHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *intHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[:n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMeetingRooms</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> intervals[i][<span class="number">0</span>] == intervals[j][<span class="number">0</span>] &#123;</span><br><span class="line"><span class="keyword">return</span> intervals[i][<span class="number">1</span>] &lt; intervals[j][<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> intervals[i][<span class="number">0</span>] &lt; intervals[j][<span class="number">0</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h intHeap</span><br><span class="line">heap.Push(&amp;h, intervals[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">room := <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;= h[<span class="number">0</span>] &#123;</span><br><span class="line">heap.Pop(&amp;h)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">room++</span><br><span class="line">&#125;</span><br><span class="line">heap.Push(&amp;h, intervals[i][<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> room</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="163-缺失的区间"><a href="#163-缺失的区间" class="headerlink" title="163. 缺失的区间"></a><a class="link" href="https://leetcode-cn.com/problems/missing-ranges/">163. 缺失的区间<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个排序的整数数组 _<strong>nums</strong>_ ，其中元素的范围在 <strong>闭区间</strong> <strong>[<em>lower, upper</em>]</strong> 当中，返回不包含在数组中的缺失区间。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入: nums &#x3D; [0, 1, 3, 50, 75], lower &#x3D; 0 和 upper &#x3D; 99,</span><br><span class="line">输出: [&quot;2&quot;, &quot;4-&gt;49&quot;, &quot;51-&gt;74&quot;, &quot;76-&gt;99&quot;]</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 这道模拟题挺恶心的，边界处理是关键；<br>(2). 根据数据范围遍历 <code>nums</code>，不能按从 <code>lower</code> 到 <code>upper</code>。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMissingRanges</span><span class="params">(nums []<span class="keyword">int</span>, lower <span class="keyword">int</span>, upper <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">ret := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> lower == upper &#123;</span><br><span class="line">s := strconv.Itoa(lower)</span><br><span class="line">ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s := strconv.Itoa(lower) + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(upper)</span><br><span class="line">ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre := lower</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] != pre &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] == pre+<span class="number">1</span> &#123;</span><br><span class="line">s = strconv.Itoa(pre)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s = strconv.Itoa(pre) + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(nums[i]<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">pre = nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] == pre + <span class="number">2</span> &#123;</span><br><span class="line">s = strconv.Itoa(nums[i]<span class="number">-1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] == pre + <span class="number">1</span> &#123;</span><br><span class="line">s = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s = strconv.Itoa(pre+<span class="number">1</span>) + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(nums[i]<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre = nums[i]</span><br><span class="line"><span class="keyword">if</span> s != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == <span class="built_in">len</span>(nums)<span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] != upper &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] == upper<span class="number">-1</span> &#123;</span><br><span class="line">s = strconv.Itoa(upper)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s = strconv.Itoa(nums[i]+<span class="number">1</span>) + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(upper)</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="694-不同岛屿的数量"><a href="#694-不同岛屿的数量" class="headerlink" title="694. 不同岛屿的数量"></a><a class="link" href="https://leetcode-cn.com/problems/number-of-distinct-islands/">694. 不同岛屿的数量<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个非空 01 二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的 1 组成，你可以认为网格的四周被海水包围。<br>请你计算这个网格中共有多少个形状不同的岛屿。两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。</p></blockquote><p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00011</span><br><span class="line">00011</span><br><span class="line">给定上图，返回结果 1 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">11011</span><br><span class="line">10000</span><br><span class="line">00001</span><br><span class="line">11011</span><br><span class="line">给定上图，返回结果 3 。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">11</span><br><span class="line">1</span><br><span class="line">和</span><br><span class="line"></span><br><span class="line"> 1</span><br><span class="line">11</span><br><span class="line">是不同的岛屿，因为我们不考虑旋转、翻转操作。</span><br></pre></td></tr></table></figure></p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 海岛问题的拓展，一般思路就两种：dfs 或 bfs；<br>(2). 这道题要求输出的是不同形状海岛的数量，那么关键问题就是怎样表示海岛的形状；<br>(3). 回忆一下我们通过 dfs 找海岛的过程，每次都是先找到海岛最左上角的点，然后根据我们预设的方向数组来控制寻找的路径，那么通过这条寻找路径，就能确定海岛的形状；<br>(4). 要注意的是每个海岛左上角的起始点都是其坐标，要将其归零才可以在同一数值范围内进行判断，我们只需要在遍历 <code>grid</code> 的点的时候记录下此时的坐标，就可以计算该海岛上每个点相对于左上角点的坐标位置。</p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N^2)</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDistinctIslands</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">h_idx := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;</span><br><span class="line">w_idx := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;</span><br><span class="line"></span><br><span class="line">height, weight := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">s := <span class="string">&quot;&quot;</span></span><br><span class="line">bi, bj := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">grid[i][j] = <span class="number">0</span></span><br><span class="line">s += fmt.Sprintf(<span class="string">&quot;-%d-%d&quot;</span>, i-bi, j-bj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k:=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++ &#123;</span><br><span class="line">h, w := i+h_idx[k], j+w_idx[k]</span><br><span class="line"><span class="keyword">if</span> h &gt;= <span class="number">0</span> &amp;&amp; h &lt; height &amp;&amp; w &gt;= <span class="number">0</span> &amp;&amp; w &lt; weight &amp;&amp; grid[h][w] == <span class="number">1</span> &#123;</span><br><span class="line">dfs(h,w)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;height; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;weight; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">bi, bj, s = i, j, <span class="string">&quot;&quot;</span></span><br><span class="line">dfs(i,j)</span><br><span class="line">m[s] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for k, _ := range m &#123;</span></span><br><span class="line"><span class="comment">// fmt.Println(k)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="164-最大间距"><a href="#164-最大间距" class="headerlink" title="164. 最大间距"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-gap/">164. 最大间距<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。<br>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。</p></blockquote><p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 示例 1:</span><br><span class="line">输入: nums &#x3D; [3,6,9,1]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums &#x3D; [10]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 数组元素个数小于 2，因此返回 0。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 105</span><br><span class="line">0 &lt;&#x3D; nums[i] &lt;&#x3D; 109</span><br></pre></td></tr></table></figure></p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先注意题目的要求：<strong>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。</strong> 这就对选择的算法有了限制。快排和堆排的时间复杂度都是 O(Nlog(N))，基数排序时间复杂度是 O(N)，空间复杂度是 O(N)，符合题目要求；<br>(2). 那么这道题就转化成一道基数排序的算法了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天没早起刷题，早起抢菜去了。淦！&lt;/p&gt;
&lt;h2 id=&quot;253-会议室-II&quot;&gt;&lt;a href=&quot;#253-会议室-II&quot; class=&quot;headerlink&quot; title=&quot;253. 会议室 II&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot; href=&quot;https://</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824 Lab 踩坑记录</title>
    <link href="http://jiahaohong1997.github.io/2022/04/06/MIT6.824%20Lab%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://jiahaohong1997.github.io/2022/04/06/MIT6.824%20Lab%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2022-04-06T04:40:00.000Z</published>
    <updated>2022-04-06T06:17:21.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h1><h2 id="go-plugin"><a href="#go-plugin" class="headerlink" title="go plugin"></a>go plugin</h2><h3 id="踩坑场景"><a href="#踩坑场景" class="headerlink" title="踩坑场景"></a>踩坑场景</h3><p>&emsp;&emsp;项目的初始化就是将 Map 和 Reduce 方法分别打包成插件的形式供 worker 端调用。这样设计的理由是测试用例中包含了不同的 Map 和 Reduce 方法，要通过所有的测试用例，使用插件的形式更加自由。<br>&emsp;&emsp;但是在启动项目的一开始就报错：<code>plugin was built with a different version of package runtime</code>。在网上查了很久，只能知道是作为 plugin 的插件文件和调用这个插件的文件编译环境不同导致的。但是问题是我都是在本地编译的，怎么还存在这个问题呢？</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>&emsp;&emsp;无他，重新装了 go 的环境。。。成功解决该问题。巨 tm 魔幻。<br>&emsp;&emsp;另外，<code>mr</code> 包下的任何改动都需要重新 <code>go build --plugin</code>，否则 worker 无法继续使用这个插件编译。</p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>&emsp;&emsp;go plugin 目前还是一个不成熟的方案，受限因素太多，可能会出现各种莫名其妙的问题，建议之后自己的开发中还是避免是用 go plugin。</p><h2 id="for-select-中的break、continue、return"><a href="#for-select-中的break、continue、return" class="headerlink" title="for-select 中的break、continue、return"></a>for-select 中的break、continue、return</h2><h3 id="踩坑场景-1"><a href="#踩坑场景-1" class="headerlink" title="踩坑场景"></a>踩坑场景</h3><p>&emsp;&emsp;在 worker 内部实现 map task 的时候，写了一个外层的 for 函数，里面是一个 select，case 1 是当出现超时（10s），那么就直接返回 false，否则就是 default 执行操作；当读到文件末尾 <code>EOF</code>时，完成操作后需要 break 跳出 for 循环。此时就出现了问题：break只能跳出select，无法跳出for，导致出现死循环。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>方案一：标签<br>看如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBreak</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">tick := time.Tick(time.Second)</span><br><span class="line"><span class="comment">//FOR是标签</span></span><br><span class="line">FOR:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t := &lt;-tick:</span><br><span class="line">fmt.Println(t)</span><br><span class="line"><span class="comment">//break出FOR标签标识的代码</span></span><br><span class="line"><span class="keyword">break</span> FOR</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二：goto</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBreak</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">tick := time.Tick(time.Second)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t := &lt;-tick:</span><br><span class="line">fmt.Println(t)</span><br><span class="line"><span class="comment">//跳到指定位置</span></span><br><span class="line"><span class="keyword">goto</span> END</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">END:</span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这两种方式都能够成功跳出 for 循环，我选择了方案二。</p><blockquote><p>continue：单独在select中是不能使用continue，会编译错误，只能用在for-select中。  <strong>continue的语义就类似for中的语义，select后的代码不会被执行到。</strong><br>return：和函数中的return一样，跳出select，和for，后续代码都不执行</p></blockquote><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><h3 id="踩坑场景-2"><a href="#踩坑场景-2" class="headerlink" title="踩坑场景"></a>踩坑场景</h3><p>&emsp;&emsp;Map 任务需要打开文件后统计单词出现频率，此时有两种读文件的方式。第一种是打开文件后逐行读取，第二种是打开文件后直接全部加载到内存中。第一种方式是用时间换空间的做法，在文件是个超大型文件，但是内存不够的情况下只能使用这种方法，唯一的问题就是很慢，IO 操作相当密集，很影响速度；第二种方式需要占用较大的内存，但是只需要一次性将文件全部加载到内存中即可，时间上会快很多。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>&emsp;&emsp;在本 lab 的场景下，每个 job 只有 10s 的时间处理文件，那么显然应该采用第二种方式。我一开始就是采用的逐行读取的方式，发现有的文件在单 worker 运算时甚至完全无法在 10s 内统计完。<br>&emsp;&emsp;同时还采用了临时文件的方式，临时文件会默认保存在系统的<code>/tmp</code> 路径下，如果要放在当前目录下需要指定，每个临时文件的末尾会带上一串随机的数字，可以在命名的时候做一些约定，方便之后的处理。<br>&emsp;&emsp;对文件的命名带上了递增的 jobId，那么就避免了冲突问题。</p><h3 id="建议-1"><a href="#建议-1" class="headerlink" title="建议"></a>建议</h3><ul><li>因为命名规则可能存在缺陷，采用临时文件的形式可以避免任务失败后，任务被其他的 <code>worker</code> 接管造成的文件冲突；</li><li>还可以通过约定命名规则，比如带上自增的 JobId，那么在之后的流程中只会对成功的 JobId 的文件进行处理。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lab1&quot;&gt;&lt;a href=&quot;#Lab1&quot; class=&quot;headerlink&quot; title=&quot;Lab1&quot;&gt;&lt;/a&gt;Lab1&lt;/h1&gt;&lt;h2 id=&quot;go-plugin&quot;&gt;&lt;a href=&quot;#go-plugin&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="web开发" scheme="http://jiahaohong1997.github.io/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="踩坑" scheme="http://jiahaohong1997.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 6）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/04/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%206%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/04/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%206%EF%BC%89/</id>
    <published>2022-04-04T00:00:00.000Z</published>
    <updated>2022-04-07T11:47:28.078Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对第 287 场周赛的复盘总结</p><h2 id="6055-转化时间需要的最少操作数"><a href="#6055-转化时间需要的最少操作数" class="headerlink" title="6055. 转化时间需要的最少操作数"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-convert-time/">6055. 转化时间需要的最少操作数<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你两个字符串 current 和 correct ，表示两个 24 小时制时间 。<br>24 小时制时间 按 “HH:MM” 进行格式化，其中 HH 在 00 和 23 之间，而 MM 在 00 和 59 之间。最早的 24 小时制时间为 00:00 ，最晚的是 23:59 。<br>在一步操作中，你可以将 current 这个时间增加 1、5、15 或 60 分钟。你可以执行这一操作 任意 次数。<br>返回将 current 转化为 correct 需要的 最少操作数 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：current &#x3D; &quot;02:30&quot;, correct &#x3D; &quot;04:35&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">可以按下述 3 步操作将 current 转换为 correct ：</span><br><span class="line">- 为 current 加 60 分钟，current 变为 &quot;03:30&quot; 。</span><br><span class="line">- 为 current 加 60 分钟，current 变为 &quot;04:30&quot; 。 </span><br><span class="line">- 为 current 加 5 分钟，current 变为 &quot;04:35&quot; 。</span><br><span class="line">可以证明，无法用少于 3 步操作将 current 转化为 correct 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：current &#x3D; &quot;11:00&quot;, correct &#x3D; &quot;11:01&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：只需要为 current 加一分钟，所以最小操作数是 1 。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">current 和 correct 都符合 &quot;HH:MM&quot; 格式</span><br><span class="line">current &lt;&#x3D; correct</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 本题其实是变种的零钱问题。初始状态是 <code>current</code>，最终状态是 <code>correct</code>，可用“零钱”面额有 <code>[1,5,15,60]</code>；<br>(2). 现将初始、最终两种状态转换成和“零钱”面额一样的计数单位——“分钟”；<br>(3). 使用动态规划，从初始状态一步步向最终状态逼近。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N).</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertTime</span><span class="params">(current <span class="keyword">string</span>, correct <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">s1 := strings.Split(current, <span class="string">&quot;:&quot;</span>)</span><br><span class="line">h1, m1 := s1[<span class="number">0</span>], s1[<span class="number">1</span>]</span><br><span class="line">s2 := strings.Split(correct, <span class="string">&quot;:&quot;</span>)</span><br><span class="line">h2, m2 := s2[<span class="number">0</span>], s2[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用分钟代表初始状态</span></span><br><span class="line">nowh, _ := strconv.Atoi(h1)</span><br><span class="line">nowm, _ := strconv.Atoi(m1)</span><br><span class="line">now := nowh*<span class="number">60</span>+nowm</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用分钟代表最终状态</span></span><br><span class="line">th, _ := strconv.Atoi(h2)</span><br><span class="line">tm, _ := strconv.Atoi(m2)</span><br><span class="line">t := th*<span class="number">60</span>+tm</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将状态归一化到 (0,diff) 区间</span></span><br><span class="line">diff := abs(now, t)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可用零钱面额</span></span><br><span class="line">choose := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">60</span>&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, diff+<span class="number">1</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=diff; i++ &#123;</span><br><span class="line">dp[i] = math.MaxInt32</span><br><span class="line"><span class="keyword">for</span> j:=<span class="built_in">len</span>(choose)<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j-- &#123;</span><br><span class="line"><span class="keyword">if</span> choose[j] &gt; i &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">dp[i] = min(dp[i], dp[i-choose[j]]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[diff]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a-b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b-a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5235-找出输掉零场或一场比赛的玩家"><a href="#5235-找出输掉零场或一场比赛的玩家" class="headerlink" title="5235. 找出输掉零场或一场比赛的玩家"></a><a class="link" href="https://leetcode-cn.com/problems/find-players-with-zero-or-one-losses/">5235. 找出输掉零场或一场比赛的玩家<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个整数数组 matches 其中 matches[i] = [winneri, loseri] 表示在一场比赛中 winneri 击败了 loseri 。<br>返回一个长度为 2 的列表 answer ：<br>answer[0] 是所有 没有 输掉任何比赛的玩家列表。<br>answer[1] 是所有恰好输掉 一场 比赛的玩家列表。<br>两个列表中的值都应该按 递增 顺序返回。</p></blockquote><blockquote><p>注意：<br>只考虑那些参与 至少一场 比赛的玩家。<br>生成的测试用例保证 不存在 两场比赛结果 相同 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：matches &#x3D; [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]</span><br><span class="line">输出：[[1,2,10],[4,5,7,8]]</span><br><span class="line">解释：</span><br><span class="line">玩家 1、2 和 10 都没有输掉任何比赛。</span><br><span class="line">玩家 4、5、7 和 8 每个都输掉一场比赛。</span><br><span class="line">玩家 3、6 和 9 每个都输掉两场比赛。</span><br><span class="line">因此，answer[0] &#x3D; [1,2,10] 和 answer[1] &#x3D; [4,5,7,8] 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：matches &#x3D; [[2,3],[1,3],[5,4],[6,4]]</span><br><span class="line">输出：[[1,2,5,6],[]]</span><br><span class="line">解释：</span><br><span class="line">玩家 1、2、5 和 6 都没有输掉任何比赛。</span><br><span class="line">玩家 3 和 4 每个都输掉两场比赛。</span><br><span class="line">因此，answer[0] &#x3D; [1,2,5,6] 和 answer[1] &#x3D; [] 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; matches.length &lt;&#x3D; 105</span><br><span class="line">matches[i].length &#x3D;&#x3D; 2</span><br><span class="line">1 &lt;&#x3D; winneri, loseri &lt;&#x3D; 105</span><br><span class="line">winneri !&#x3D; loseri</span><br><span class="line">所有 matches[i] 互不相同</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 本题需要输出两个列表：其一是 <strong>入度</strong> 为 $0$ 且 <strong>出度</strong> 大于 $0$ 的编号，其二是 <strong>入度</strong> 恰好为 $1$ 的编号；<br>(2). 使用两个 <code>map</code> 分别保存每个编号的出度和入度；<br>(3). 首先遍历 <strong>入度</strong> <code>map</code>，只要发现其长度为 $1$，那就加入输出中；<br>(4). 然后遍历 <strong>出度</strong> <code>map</code>，检查对应编号的 <strong>入度</strong> 列表如果为 $0$，那么也加入输出中；<br>(5). 排序两个列表。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findWinners</span><span class="params">(matches [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 matches，构建 出度 和 入度 map</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(matches); i++ &#123;</span><br><span class="line">win, lose := matches[i][<span class="number">0</span>], matches[i][<span class="number">1</span>]</span><br><span class="line">m1[lose] = <span class="built_in">append</span>(m1[lose], win)</span><br><span class="line">m2[win] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">1</span> &#123;</span><br><span class="line">ret[<span class="number">1</span>] = <span class="built_in">append</span>(ret[<span class="number">1</span>], k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> m2 &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(m1[k]) == <span class="number">0</span> &#123;</span><br><span class="line">ret[<span class="number">0</span>] = <span class="built_in">append</span>(ret[<span class="number">0</span>], k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Ints(ret[<span class="number">0</span>])</span><br><span class="line">sort.Ints(ret[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5219-每个小孩最多能分到多少糖果"><a href="#5219-每个小孩最多能分到多少糖果" class="headerlink" title="5219. 每个小孩最多能分到多少糖果"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-candies-allocated-to-k-children/">5219. 每个小孩最多能分到多少糖果<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个 下标从 0 开始 的整数数组 candies 。数组中的每个元素表示大小为 candies[i] 的一堆糖果。你可以将每堆糖果分成任意数量的 子堆 ，但 无法 再将两堆合并到一起。<br>另给你一个整数 k 。你需要将这些糖果分配给 k 个小孩，使每个小孩分到 相同 数量的糖果。每个小孩可以拿走 至多一堆 糖果，有些糖果可能会不被分配。<br>返回每个小孩可以拿走的 最大糖果数目 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：candies &#x3D; [5,8,6], k &#x3D; 3</span><br><span class="line">输出：5</span><br><span class="line">解释：可以将 candies[1] 分成大小分别为 5 和 3 的两堆，然后把 candies[2] 分成大小分别为 5 和 1 的两堆。现在就有五堆大小分别为 5、5、3、5 和 1 的糖果。可以把 3 堆大小为 5 的糖果分给 3 个小孩。可以证明无法让每个小孩得到超过 5 颗糖果。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：candies &#x3D; [2,5], k &#x3D; 11</span><br><span class="line">输出：0</span><br><span class="line">解释：总共有 11 个小孩，但只有 7 颗糖果，但如果要分配糖果的话，必须保证每个小孩至少能得到 1 颗糖果。因此，最后每个小孩都没有得到糖果，答案是 0 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; candies.length &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; candies[i] &lt;&#x3D; 10^7</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; 10^12</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先看一看数据量，明显暴力绝对会超时，那么别无选择，二分法搞起来；<br>(2). 首先判断一下边界情况，当 🍬总数 &lt; 🧒总数 时，显然大家都没得分，return 0；如果 🍬总数 == 🧒总数 ，return 1<br>(3) 二分查找的左边界是 $1$，右边界是 🍬总数/🧒总数 ；<br>(4) 要查找满足条件的右边界，二分超找模板套起来。</p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(Nlog(N))</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumCandies</span><span class="params">(candies []<span class="keyword">int</span>, k <span class="keyword">int64</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(candies); i++ &#123;</span><br><span class="line">total += <span class="keyword">int64</span>(candies[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> total &lt; k &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> total == k &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> satisified <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">satisified = <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(candies); i++ &#123;</span><br><span class="line">count += <span class="keyword">int64</span>(candies[i]/n)</span><br><span class="line"><span class="keyword">if</span> count &gt;= k &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l, r := <span class="number">1</span>, <span class="keyword">int</span>(total/k)</span><br><span class="line"><span class="keyword">if</span> satisified(r) &#123;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">m := l+(r-l)&gt;&gt;<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> satisified(m) &#123;</span><br><span class="line">l = m+<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !satisified(m) &#123;</span><br><span class="line">r = m</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> l<span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5302-加密解密字符串"><a href="#5302-加密解密字符串" class="headerlink" title="5302. 加密解密字符串"></a><a class="link" href="https://leetcode-cn.com/problems/encrypt-and-decrypt-strings/">5302. 加密解密字符串<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个字符数组 keys ，由若干 互不相同 的字符组成。还有一个字符串数组 values ，内含若干长度为 2 的字符串。另给你一个字符串数组 dictionary ，包含解密后所有允许的原字符串。请你设计并实现一个支持加密及解密下标从 0 开始字符串的数据结构。<br>字符串 加密 按下述步骤进行：<br>1.对字符串中的每个字符 c ，先从 keys 中找出满足 keys[i] == c 的下标 i 。<br>2.在字符串中，用 values[i] 替换字符 c 。<br>字符串 解密 按下述步骤进行：<br>1.将字符串每相邻 2 个字符划分为一个子字符串，对于每个子字符串 s ，找出满足 values[i] == s 的一个下标 i 。如果存在多个有效的 i ，从中选择 任意 一个。这意味着一个字符串解密可能得到多个解密字符串。<br>2.在字符串中，用 keys[i] 替换 s 。<br>实现 Encrypter 类：<br>1.Encrypter(char[] keys, String[] values, String[] dictionary) 用 keys、values 和 dictionary 初始化 Encrypter 类。<br>2.String encrypt(String word1) 按上述加密过程完成对 word1 的加密，并返回加密后的字符串。<br>3.int decrypt(String word2) 统计并返回可以由 word2 解密得到且出现在 dictionary 中的字符串数目。</p></blockquote><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 注意到 <code>values</code> 中有相同的字符串，因此不同的字符串加密后可能是一样的，从而一个字符串解密出的结果可能不是唯一的；<br>(2). 根据提示 1，直接解密较为复杂，不妨逆向思考，即加密 <code>dictionary</code> 中的每个字符串。用哈希表记录每个加密后的字符串的出现次数。这样每次调用 <code>decrypt</code> 时，返回哈希表中 <code>word2</code> 的出现次数即可。</p><h3 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Encrypter <span class="keyword">struct</span> &#123;</span><br><span class="line">mp  [<span class="number">26</span>]<span class="keyword">string</span></span><br><span class="line">cnt <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(keys []<span class="keyword">byte</span>, values, dictionary []<span class="keyword">string</span>)</span> <span class="title">Encrypter</span></span> &#123;</span><br><span class="line">mp := [<span class="number">26</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">mp[key-<span class="string">&#x27;a&#x27;</span>] = values[i]</span><br><span class="line">&#125;</span><br><span class="line">e := Encrypter&#123;mp, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> dictionary &#123;</span><br><span class="line">e.cnt[e.Encrypt(s)]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Encrypter)</span> <span class="title">Encrypt</span><span class="params">(word1 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(word1)*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> word1 &#123;</span><br><span class="line">s := e.mp[ch-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, s...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Encrypter)</span> <span class="title">Decrypt</span><span class="params">(word2 <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> e.cnt[word2] &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是对第 287 场周赛的复盘总结&lt;/p&gt;
&lt;h2 id=&quot;6055-转化时间需要的最少操作数&quot;&gt;&lt;a href=&quot;#6055-转化时间需要的最少操作数&quot; class=&quot;headerlink&quot; title=&quot;6055. 转化时间需要的最少操作数&quot;&gt;&lt;/a&gt;&lt;a class</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 5）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/03/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%205%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/03/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%205%EF%BC%89/</id>
    <published>2022-04-02T22:00:00.000Z</published>
    <updated>2022-04-07T11:47:30.945Z</updated>
    
    <content type="html"><![CDATA[<p>今天早上复盘一下昨天晚上的双周赛</p><h2 id="LeetCode6033-转换数字的最少位翻转次数"><a href="#LeetCode6033-转换数字的最少位翻转次数" class="headerlink" title="LeetCode6033. 转换数字的最少位翻转次数"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-bit-flips-to-convert-number/">LeetCode6033. 转换数字的最少位翻转次数<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>一次 位翻转 定义为将数字 x 二进制中的一个位进行 翻转 操作，即将 0 变成 1 ，或者将 1 变成 0 。<br>比方说，x = 7 ，二进制表示为 111 ，我们可以选择任意一个位（包含没有显示的前导 0 ）并进行翻转。比方说我们可以翻转最右边一位得到 110 ，或者翻转右边起第二位得到 101 ，或者翻转右边起第五位（这一位是前导 0 ）得到 10111 等等。<br>给你两个整数 start 和 goal ，请你返回将 start 转变成 goal 的 最少位翻转 次数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：start &#x3D; 10, goal &#x3D; 7</span><br><span class="line">输出：3</span><br><span class="line">解释：10 和 7 的二进制表示分别为 1010 和 0111 。我们可以通过 3 步将 10 转变成 7 ：</span><br><span class="line">- 翻转右边起第一位得到：1010 -&gt; 1011 。</span><br><span class="line">- 翻转右边起第三位：1011 -&gt; 1111 。</span><br><span class="line">- 翻转右边起第四位：1111 -&gt; 0111 。</span><br><span class="line">我们无法在 3 步内将 10 转变成 7 。所以我们返回 3 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：start &#x3D; 3, goal &#x3D; 4</span><br><span class="line">输出：3</span><br><span class="line">解释：3 和 4 的二进制表示分别为 011 和 100 。我们可以通过 3 步将 3 转变成 4 ：</span><br><span class="line">- 翻转右边起第一位：011 -&gt; 010 。</span><br><span class="line">- 翻转右边起第二位：010 -&gt; 000 。</span><br><span class="line">- 翻转右边起第三位：000 -&gt; 100 。</span><br><span class="line">我们无法在 3 步内将 3 变成 4 。所以我们返回 3 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; start, goal &lt;&#x3D; 109</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 本质上是判断两个数有多少个比特位值是不一样的（包含前导零）；<br>(2). 那就从最后一个比特位开始往前比较就好了。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minBitFlips</span><span class="params">(start <span class="keyword">int</span>, goal <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> judgeLastBit <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">judgeLastBit = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x == <span class="number">0</span> || x^(x<span class="number">-1</span>) != <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> start &gt; <span class="number">0</span> || goal &gt; <span class="number">0</span> &#123;</span><br><span class="line">x1 := judgeLastBit(start)</span><br><span class="line">x2 := judgeLastBit(goal)</span><br><span class="line"><span class="keyword">if</span> (x1 &amp;&amp; !x2) || (!x1 &amp;&amp; x2) &#123;</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line">start &gt;&gt;= <span class="number">1</span></span><br><span class="line">goal &gt;&gt;= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode6034-数组的三角和"><a href="#LeetCode6034-数组的三角和" class="headerlink" title="LeetCode6034. 数组的三角和"></a><a class="link" href="https://leetcode-cn.com/problems/find-triangular-sum-of-an-array/">LeetCode6034. 数组的三角和<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个下标从 0 开始的整数数组 nums ，其中 nums[i] 是 0 到 9 之间（两者都包含）的一个数字。<br>nums 的 三角和 是执行以下操作以后最后剩下元素的值：<br>1.nums 初始包含 n 个元素。如果 n == 1 ，终止 操作。否则，创建 一个新的下标从 0 开始的长度为 n - 1 的整数数组 newNums 。<br>2.对于满足 0 &lt;= i &lt; n - 1 的下标 i ，newNums[i] 赋值 为 (nums[i] + nums[i+1]) % 10 ，% 表示取余运算。<br>3.将 newNums 替换 数组 nums 。<br>4.从步骤 1 开始 重复 整个过程。<br>5.请你返回 nums 的三角和。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="ex1drawio.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：8</span><br><span class="line">解释：</span><br><span class="line">上图展示了得到数组三角和的过程。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [5]</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">由于 nums 中只有一个元素，数组的三角和为这个元素自己。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; nums[i] &lt;&#x3D; 9</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 太简单了。。没啥好说的</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">triangularSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(nums) &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">nums[i] += nums[i+<span class="number">1</span>]</span><br><span class="line">nums[i] %= <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">nums = nums[:<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode6035-选择建筑的方案数"><a href="#LeetCode6035-选择建筑的方案数" class="headerlink" title="LeetCode6035. 选择建筑的方案数"></a><a class="link" href="https://leetcode-cn.com/problems/number-of-ways-to-select-buildings/">LeetCode6035. 选择建筑的方案数<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个下标从 0 开始的二进制字符串 s ，它表示一条街沿途的建筑类型，其中：<br>s[i] = ‘0’ 表示第 i 栋建筑是一栋办公楼，<br>s[i] = ‘1’ 表示第 i 栋建筑是一间餐厅。<br>作为市政厅的官员，你需要随机 选择 3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 相邻 的两栋不能是同一类型。<br>比方说，给你 s = “001101” ，我们不能选择第 1 ，3 和 5 栋建筑，因为得到的子序列是 “011” ，有相邻两栋建筑是同一类型，所以 不合 题意。<br>请你返回可以选择 3 栋建筑的 有效方案数 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;001101&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">以下下标集合是合法的：</span><br><span class="line">- [0,2,4] ，从 &quot;001101&quot; 得到 &quot;010&quot;</span><br><span class="line">- [0,3,4] ，从 &quot;001101&quot; 得到 &quot;010&quot;</span><br><span class="line">- [1,2,4] ，从 &quot;001101&quot; 得到 &quot;010&quot;</span><br><span class="line">- [1,3,4] ，从 &quot;001101&quot; 得到 &quot;010&quot;</span><br><span class="line">- [2,4,5] ，从 &quot;001101&quot; 得到 &quot;101&quot;</span><br><span class="line">- [3,4,5] ，从 &quot;001101&quot; 得到 &quot;101&quot;</span><br><span class="line">没有别的合法选择，所以总共有 6 种方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;11100&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：没有任何符合题意的选择。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">3 &lt;&#x3D; s.length &lt;&#x3D; 105</span><br><span class="line">s[i] 要么是 &#39;0&#39; ，要么是 &#39;1&#39; 。</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法一：暴力递归搜索（超时）<br>(1). 类似组合数这种类型的题目，不过要判断一下是否符合最终合法的约定；<br>(2). 当字符串剩下的长度不足以满足要求，剪枝。（实际上这个优化并没什么用，因为剪枝的长度最大也就 3，根本不影响最终的复杂度）</p><p>方法二：统计前缀数量（O(N)）<br>分别定义 5 个变量，<code>n1</code> 代表前缀为 1 的子序列数量，<code>n0</code> 代表前缀为 0 的子序列数量，<code>n01</code> 代表前缀为 01 的子序列数量,<code>n10</code> 代表前缀为 10 的子序列数量，<code>count</code>则是统计合法的子序列数量（<code>010</code> + <code>101</code>）</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><p>方法一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfWays</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int64</span></span><br><span class="line">path := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> backTracking <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span>, rest <span class="keyword">int</span>)</span></span></span><br><span class="line">backTracking = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span> ,rest <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rest == <span class="number">0</span> &#123;</span><br><span class="line">count++</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=start; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> rest &gt; <span class="built_in">len</span>(s[start:]) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">0</span> &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, s[i])</span><br><span class="line">backTracking(i+<span class="number">1</span>, rest<span class="number">-1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] != path[<span class="built_in">len</span>(path)<span class="number">-1</span>] &#123;</span><br><span class="line">path = <span class="built_in">append</span>(path, s[i])</span><br><span class="line">backTracking(i+<span class="number">1</span>, rest<span class="number">-1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; <span class="number">0</span> &#123;</span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">backTracking(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfWays</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> n0, n1, n01, n10 <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">n01 += n0</span><br><span class="line">n1++</span><br><span class="line">count += n10</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">n10 += n1</span><br><span class="line">n0++</span><br><span class="line">count += n01</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天早上复盘一下昨天晚上的双周赛&lt;/p&gt;
&lt;h2 id=&quot;LeetCode6033-转换数字的最少位翻转次数&quot;&gt;&lt;a href=&quot;#LeetCode6033-转换数字的最少位翻转次数&quot; class=&quot;headerlink&quot; title=&quot;LeetCode6033. 转换数字</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 4）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/02/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%204%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/02/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%204%EF%BC%89/</id>
    <published>2022-04-01T22:00:00.000Z</published>
    <updated>2022-04-07T11:47:34.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode856-括号的分数"><a href="#LeetCode856-括号的分数" class="headerlink" title="LeetCode856. 括号的分数"></a><a class="link" href="https://leetcode-cn.com/problems/score-of-parentheses/">LeetCode856. 括号的分数<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：<br>() 得 1 分。<br>AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。<br>(A) 得 2 * A 分，其中 A 是平衡括号字符串。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：&quot;()&quot;</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：&quot;(())&quot;</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：&quot;()()&quot;</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：&quot;(()(()))&quot;</span><br><span class="line">输出：6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1. S 是平衡括号字符串，且只含有 ( 和 ) 。</span><br><span class="line">2. 2 &lt;&#x3D; S.length &lt;&#x3D; 50</span><br></pre></td></tr></table></figure><p> </p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p> (1). 考虑采用递归 + 栈来解题。括号问题首先天然就会想到使用栈，由于本题不需要考虑括号字符串的合法性，所以栈可以当作一个状态的保存，在栈内部进行递归；<br> (2). 对于嵌套的括号，采用递归的策略，出递归前将递归栈中分数*2 即可；<br> (3). 注意遍历字符串要使用指针以及出递归的条件。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p> O(N).</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scoreOfParentheses</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scoreCount <span class="function"><span class="keyword">func</span><span class="params">(start *<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">scoreCount = <span class="function"><span class="keyword">func</span><span class="params">(start *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ss := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">sc := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ; *start&lt;<span class="built_in">len</span>(s); (*start)++ &#123;</span><br><span class="line">i := *start</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ss) == <span class="number">0</span> &amp;&amp; s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">ss = <span class="built_in">append</span>(ss, <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; <span class="built_in">len</span>(ss) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; ss[<span class="built_in">len</span>(ss)<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">sc++</span><br><span class="line">ss = ss[:<span class="built_in">len</span>(ss)<span class="number">-1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &amp;&amp; <span class="built_in">len</span>(ss) != <span class="number">0</span> &#123;</span><br><span class="line">sc += <span class="number">2</span>*scoreCount(start)</span><br><span class="line">ss = ss[:<span class="built_in">len</span>(ss)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">score := <span class="number">0</span></span><br><span class="line">stack := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">score++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">score += <span class="number">2</span>*scoreCount(&amp;i)</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> score</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a class="link" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：lists &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：lists &#x3D; [[]]</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">k &#x3D;&#x3D; lists.length</span><br><span class="line">0 &lt;&#x3D; k &lt;&#x3D; 10^4</span><br><span class="line">0 &lt;&#x3D; lists[i].length &lt;&#x3D; 500</span><br><span class="line">-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4</span><br><span class="line">lists[i] 按 升序 排列</span><br><span class="line">lists[i].length 的总和不超过 10^4</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>优先队列，直接看代码吧</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(Nlog(N))，取决于堆排序的时间复杂度</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a[h[i]]&lt;a[h[j]]</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(*h)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[:n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">l := <span class="built_in">len</span>(lists)</span><br><span class="line"><span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h IntHeap</span><br><span class="line">a = <span class="built_in">make</span>([]<span class="keyword">int</span>, l)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;l; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> lists[i] == <span class="literal">nil</span> &#123;</span><br><span class="line">a[i] = <span class="number">-1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">a[i] = lists[i].Val</span><br><span class="line">heap.Push(&amp;h, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(h) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first := heap.Pop(&amp;h).(<span class="keyword">int</span>)</span><br><span class="line">head := lists[first]</span><br><span class="line">a[first] = math.MaxInt32</span><br><span class="line">p := head</span><br><span class="line">lists[first] = head.Next</span><br><span class="line">p.Next = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> lists[first] != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 下面两行注意顺序不能反了，先更改 a，才能排序</span></span><br><span class="line">a[first] = lists[first].Val</span><br><span class="line">heap.Push(&amp;h, first)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(h) &gt; <span class="number">0</span> &#123;</span><br><span class="line">i := heap.Pop(&amp;h).(<span class="keyword">int</span>)</span><br><span class="line">a[i] = math.MaxInt32</span><br><span class="line">p.Next = lists[i]</span><br><span class="line">p = p.Next</span><br><span class="line">lists[i] = lists[i].Next</span><br><span class="line"><span class="keyword">if</span> lists[i] != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 下面两行注意顺序不能反了，先更改 a，才能排序</span></span><br><span class="line">a[i] = lists[i].Val</span><br><span class="line">heap.Push(&amp;h, i)</span><br><span class="line">&#125;</span><br><span class="line">p.Next = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// fmt.Println(a,h,x,i)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LeetCode856-括号的分数&quot;&gt;&lt;a href=&quot;#LeetCode856-括号的分数&quot; class=&quot;headerlink&quot; title=&quot;LeetCode856. 括号的分数&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot; href=&quot;https://leet</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 3）</title>
    <link href="http://jiahaohong1997.github.io/2022/04/01/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%203%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/04/01/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%203%EF%BC%89/</id>
    <published>2022-03-31T21:30:00.000Z</published>
    <updated>2022-04-07T11:47:37.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="269-火星词典"><a href="#269-火星词典" class="headerlink" title="269. 火星词典"></a><a class="link" href="https://leetcode-cn.com/problems/alien-dictionary/">269. 火星词典<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>现有一种使用英语字母的火星语言，这门语言的字母顺序与英语顺序不同。给你一个字符串列表 words ，作为这门语言的词典，words 中的字符串已经 按这门新语言的字母顺序进行了排序 。请你根据该词典还原出此语言中已知的字母顺序，并 按字母递增顺序 排列。若不存在合法字母顺序，返回 “” 。若存在多种可能的合法字母顺序，返回其中 任意一种 顺序即可。<br>字符串 s 字典顺序小于 字符串 t 有两种情况：<br>1.在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t 中字母之前，那么 s 的字典顺序小于 t 。<br>2.如果前面 min(s.length, t.length) 字母都相同，那么 s.length &lt; t.length 时，s 的字典顺序也小于 t 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：words &#x3D; [&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]</span><br><span class="line">输出：&quot;wertf&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：words &#x3D; [&quot;z&quot;,&quot;x&quot;]</span><br><span class="line">输出：&quot;zx&quot;</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入：words &#x3D; [&quot;z&quot;,&quot;x&quot;,&quot;z&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：不存在合法字母顺序，因此返回 &quot;&quot; 。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先考虑什么情况下会出现不合法的情况：如果在之前判断字母 ‘x’ 的字典序应该大于 ‘y’，可是在后面又出现了 ‘y’ 的字典序应该大于 ‘x’ 的情况，那么此时就出现了矛盾，因此是不合法的；<br>(2). 对于这种只允许单向依赖的情况，考虑使用拓扑排序。首先就要构建邻接表和入度统计。在建立邻接表的时候要考虑一种情况，那就是如果出现在后面的字符串是前面字符串的前缀字符串，那么可以立即判定是不合法的；<br>(3). 在构建好两个数据结构后，使用广度优先搜索查找。将入度为 0 的字母放入队列中，然后再将其对应的邻接表中的字母入度减一，此时相当于在拓扑排序中消除了对该字母的依赖，也可以看作访问数 <code>visited</code> 加 1；<br>(4). 最后判断一下 <code>visited</code> 是否是全体出现过的字母数，相等则说明是一个拓扑排序，不存在循环依赖。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(words.length*words[i].length)</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alienOrder</span><span class="params">(words []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">adjacency := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>][]<span class="keyword">byte</span>) <span class="comment">// 邻接表</span></span><br><span class="line">inDegree := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)<span class="comment">// 入度统计</span></span><br><span class="line">ret := <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buildGraph <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">buildGraph = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(words); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(words[i]); j++ &#123;</span><br><span class="line">adjacency[words[i][j]] = []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(words); i++ &#123;</span><br><span class="line">w1, w2 := words[i<span class="number">-1</span>], words[i]</span><br><span class="line">j := <span class="number">0</span></span><br><span class="line">minLength := min(<span class="built_in">len</span>(w1),<span class="built_in">len</span>(w2))</span><br><span class="line"><span class="keyword">for</span> ; j&lt;minLength; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> w1[j] != w2[j] &#123;</span><br><span class="line">adjacency[w1[j]] = <span class="built_in">append</span>(adjacency[w1[j]], w2[j])</span><br><span class="line">inDegree[w2[j]]++</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> j == minLength &amp;&amp; <span class="built_in">len</span>(w1) &gt; <span class="built_in">len</span>(w2) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> visitedCount <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line">visitedCount = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">visited := <span class="number">0</span></span><br><span class="line">q := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,_ := <span class="keyword">range</span> adjacency &#123;</span><br><span class="line"><span class="keyword">if</span> inDegree[k] == <span class="number">0</span> &#123;</span><br><span class="line">q = <span class="built_in">append</span>(q, k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">p := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">w := q[i]</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(adjacency[w]); j++ &#123;</span><br><span class="line">x := adjacency[w][j]</span><br><span class="line">inDegree[x]--</span><br><span class="line"><span class="keyword">if</span> inDegree[x] == <span class="number">0</span> &#123;</span><br><span class="line">p = <span class="built_in">append</span>(p, x)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visited++</span><br><span class="line">&#125;</span><br><span class="line">ret += <span class="keyword">string</span>(q)</span><br><span class="line">q = p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> visited</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !buildGraph() || visitedCount() != <span class="built_in">len</span>(adjacency) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a class="link" href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。<br>函数 myAtoi(string s) 的算法如下：<br>1.读入字符串并丢弃无用的前导空格<br>2.检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br>3.读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>4.将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。<br>5.如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。<br>6.返回整数作为最终结果。</p></blockquote><blockquote><p>注意：<br>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：s &#x3D; &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 42 。</span><br><span class="line">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：s &#x3D; &quot;   -42&quot;</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 2 步：&quot;   -42&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入：s &#x3D; &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 4193 。</span><br><span class="line">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; s.length &lt;&#x3D; 200</span><br><span class="line">s 由英文字母（大写和小写）、数字（0-9）、&#39; &#39;、&#39;+&#39;、&#39;-&#39; 和 &#39;.&#39; 组成</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 这是一道很典型的模拟题，对于模拟题，少不了条件判断，建议采用 switch 来代替大量的 if…else，这样代码的逻辑会清晰很多；<br>(2). 这道题唯一值得关心的点就是越界问题，那么就需要将合法数字字符串取出后先去除前导零，然后再根据符号分别判断是否越界。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAtoi</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isNeg := <span class="literal">false</span></span><br><span class="line">prefixLetter := <span class="literal">true</span></span><br><span class="line">str := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">maxNum, minNum := math.MaxInt32, <span class="number">-1</span>*math.MinInt32</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> prefixLetter &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s[i] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">isNeg = <span class="literal">true</span></span><br><span class="line">prefixLetter = <span class="literal">false</span></span><br><span class="line"><span class="keyword">case</span> s[i] == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">prefixLetter = <span class="literal">false</span></span><br><span class="line"><span class="keyword">case</span> s[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> s[i] == <span class="string">&#x27;.&#x27;</span> || (s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">case</span> s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">prefixLetter = <span class="literal">false</span></span><br><span class="line">str = <span class="built_in">append</span>(str, s[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">str = <span class="built_in">append</span>(str, s[i])</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">i = <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(str) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> str[i] != <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">x = i</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> !isNeg &#123;</span><br><span class="line"><span class="keyword">for</span> i:=x; i&lt;<span class="built_in">len</span>(str) ;i++ &#123;</span><br><span class="line">ret *= <span class="number">10</span></span><br><span class="line">ret += <span class="keyword">int</span>(str[i])-<span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">if</span> ret &gt; maxNum &#123;</span><br><span class="line"><span class="keyword">return</span> maxNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=x; i&lt;<span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">ret *= <span class="number">10</span></span><br><span class="line">ret += <span class="keyword">int</span>(str[i])-<span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">if</span> ret &gt; minNum &#123;</span><br><span class="line"><span class="keyword">return</span> math.MinInt32</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ret *= <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;269-火星词典&quot;&gt;&lt;a href=&quot;#269-火星词典&quot; class=&quot;headerlink&quot; title=&quot;269. 火星词典&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode-cn.com/problems/alien-</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 2）</title>
    <link href="http://jiahaohong1997.github.io/2022/03/31/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%202%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/03/31/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%202%EF%BC%89/</id>
    <published>2022-03-30T22:00:00.000Z</published>
    <updated>2022-04-07T11:47:40.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode63-不同路径-II"><a href="#LeetCode63-不同路径-II" class="headerlink" title="LeetCode63. 不同路径 II"></a><a class="link" href="https://leetcode-cn.com/problems/unique-paths-ii/">LeetCode63. 不同路径 II<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br>网格中的障碍物和空位置分别用 1 和 0 来表示。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="robot1.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br><span class="line"></span><br><span class="line">示例 2:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="robot2.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid &#x3D; [[0,1],[0,0]]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">m &#x3D;&#x3D; obstacleGrid.length</span><br><span class="line">n &#x3D;&#x3D; obstacleGrid[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 100</span><br><span class="line">obstacleGrid[i][j] 为 0 或 1</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 采用二维递归的思路，本题是<a class="link" href="https://leetcode-cn.com/problems/unique-paths/">LeetCode62. 不同路径<i class="fas fa-external-link-alt"></i></a>的变种，实际上是一道题；<br>(2). 在处理初始条件（第一行和第一列）遇到障碍物时，障碍物所在的格子即之后的格子都属于不可到达的坐标，退出循环；<br>(3). 在递归过程中，如果遇到障碍物，直接判断为不可到达 <code>dp[i][j]=0</code>，否则当前格子的路径数等于上面、左面的路径数之和。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O($N^2$).</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m, n := <span class="built_in">len</span>(obstacleGrid), <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, m)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;m; i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;m; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span> &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] != <span class="number">1</span> &#123;</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;m; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;n; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">dp[i][j] = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="498-对角线遍历"><a href="#498-对角线遍历" class="headerlink" title="498. 对角线遍历"></a><a class="link" href="https://leetcode-cn.com/problems/diagonal-traverse/">498. 对角线遍历<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个大小为 <code>m x n</code> 的矩阵 <code>mat</code> ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="diag1-grid.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,4,7,5,3,6,8,9]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：mat &#x3D; [[1,2],[3,4]]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 本题要处理的细节比较多。首先解决边界问题，当 <code>mat</code> 只有一行或一列的时候，直接输出这一行或一列；<br>(2). 要关注三个和转向有关的情况：<code>direction</code> 用于描述当前前进的方向，向右上是为 <code>true</code>，向左下时为 <code>false</code>；<code>rowHalf</code> 用于描述在右上方向前进到顶格时，接下来是要向右还是向下移动一格；<code>columnHalf</code> 用于描述在左下方向前进到顶格时接下来是要向下还是向右前进一格。实际上就是判断有没有分别在行和列上走过 <code>mat</code> 的一半位置。<br>(3). 可以观察到，当前位置的坐标和 <code>i+j</code> 在大于等于行号或列号的时候，走到顶格后转向的方向需要发生改变。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O($M*N$)</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDiagonalOrder</span><span class="params">(mat [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">m, n := <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> m == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mat[<span class="number">0</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;m; i++ &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, mat[i][<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">direction := <span class="literal">true</span></span><br><span class="line">rowHalf := <span class="literal">true</span></span><br><span class="line">columnHalf := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i&lt;m &amp;&amp; j&lt;n &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, mat[i][j])</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; direction &amp;&amp; rowHalf) || (j == n<span class="number">-1</span> &amp;&amp; direction &amp;&amp; !rowHalf) &#123;</span><br><span class="line"><span class="keyword">if</span> rowHalf &#123;</span><br><span class="line"><span class="keyword">if</span> j &lt; n<span class="number">-1</span> &#123;</span><br><span class="line">j++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">direction = <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; !direction) || (i == m<span class="number">-1</span> &amp;&amp; !direction &amp;&amp; !columnHalf) &#123;</span><br><span class="line"><span class="keyword">if</span> columnHalf &#123;</span><br><span class="line"><span class="keyword">if</span> i &lt; m<span class="number">-1</span> &#123;</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">direction = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> direction &#123;</span><br><span class="line">i--</span><br><span class="line">j++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">i++</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i+j &gt;= m<span class="number">-1</span> &#123;</span><br><span class="line">columnHalf = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i+j &gt;= n<span class="number">-1</span> &#123;</span><br><span class="line">rowHalf = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a class="link" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个已排序的链表的头 <code>head</code> ， 删除所有重复的元素，使每个元素只出现一次。返回已排序的链表 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：head &#x3D; [1,1,2]</span><br><span class="line">输出：[1,2]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：head &#x3D; [1,1,2,3,3]</span><br><span class="line">输出：[1,2,3]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">链表中节点数目在范围 [0, 300] 内</span><br><span class="line">100 &lt;&#x3D; Node.val &lt;&#x3D; 100</span><br><span class="line">题目数据保证链表已经按升序排列</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 要删除重复的节点，那么就要实时维护三个位置的节点 <code>pre</code>、<code>cur</code>、<code>next</code>，假设要删除 <code>cur</code>，那么删除之后还要将 <code>cur</code> 重新指向 <code>next</code>；<br>(2). 如果 <code>pre</code> 和 <code>cur</code> 的值不相等，那么同时向后移动一位。</p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N).</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Val int</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Next *ListNode</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre, cur := head, head.Next</span><br><span class="line"><span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">next := cur.Next</span><br><span class="line"><span class="keyword">if</span> cur.Val == pre.Val &#123;</span><br><span class="line">pre.Next = next</span><br><span class="line">cur = next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pre = cur</span><br><span class="line">cur = next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LeetCode63-不同路径-II&quot;&gt;&lt;a href=&quot;#LeetCode63-不同路径-II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode63. 不同路径 II&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot; href=&quot;https://l</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>早起刷题（Day 1）</title>
    <link href="http://jiahaohong1997.github.io/2022/03/30/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%201%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/03/30/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%201%EF%BC%89/</id>
    <published>2022-03-29T22:00:00.000Z</published>
    <updated>2022-04-07T11:47:44.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode179-最大数"><a href="#LeetCode179-最大数" class="headerlink" title="LeetCode179. 最大数"></a><a class="link" href="https://leetcode-cn.com/problems/largest-number/">LeetCode179. 最大数<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。<br>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [10,2]</span><br><span class="line">输出：&quot;210&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [3,30,34,5,9]</span><br><span class="line">输出：&quot;9534330&quot;</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1).  本题需要按照字典序排序来生成最终的字符串；<br>(2). 当给定的数组中元素的最高位都不相等时，情况最简单，直接输出字典序即可；<br>(3). 当出现 $4$ 和 $42$ 这种类型的子序列时，如果按照字典序来排序只能得到 $424$，但实际上最大值是 $442$，因此可知根据字典序排序只能得到局部最大值 <code>ans</code>，我们要求的是全局最大值 <code>max</code>；<br>(4). 可以在排序的时候更改一下排序条件，不以字典序为排序条件，而是以两数拼接后的实际大小来排序。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(Nlog(N))。因为有排序算法。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">sort.Slice(nums, <span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span><span class="title">bool</span></span> &#123;</span><br><span class="line">x, y := nums[i], nums[j]</span><br><span class="line">sx, sy := <span class="number">10</span>, <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> sx &lt;= x &#123;</span><br><span class="line">sx *= <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sy &lt;= y &#123;</span><br><span class="line">sy *= <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sy*x+y &gt; sx*y+x</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> nums[<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">ret += strconv.Itoa(nums[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h3><p>&emsp;&emsp;在排序条件中，我们维护了两个变量 <code>sx</code> 和 <code>sy</code>，这两个变量会在拼接操作中为两个数留出对应的位置，方便我们的拼接操作，避免了转换成字符串后再进行拼接。</p><h2 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a><a class="link" href="https://leetcode-cn.com/problems/valid-sudoku/">36. 有效的数独<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>请你判断一个 <code>9 x 9</code> 的数独是否有效。只需要 <strong>根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p><ol><li> 数字 <code>1-9</code> 在每一行只能出现一次。</li><li> 数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）<br>注意：<br>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>空白格用 <code>&#39;.&#39;</code> 表示。</li></ol></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure><p> <img lazyload src="/images/loading.svg" data-src="shudu.png" alt="avatar"><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> 输入：board &#x3D; </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：board &#x3D; </span><br><span class="line">[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：false</span><br><span class="line">解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">board.length &#x3D;&#x3D; 9</span><br><span class="line">board[i].length &#x3D;&#x3D; 9</span><br><span class="line">board[i][j] 是一位数字（1-9）或者 &#39;.&#39;</span><br></pre></td></tr></table></figure></p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p> (1). 先判断行上是否符合标准；<br> (2). 再判断列上是否符合标准；<br> (3). 最后传递每个九宫格的左上角坐标来判断每个九宫格是否符合标准。</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidSudoku</span><span class="params">(board [][]<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> checkRow <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">checkRow = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">check := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">row := board[index]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(row); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> row[i] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> check[<span class="keyword">int</span>(row[i])-<span class="string">&#x27;0&#x27;</span>] == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">check[<span class="keyword">int</span>(row[i])-<span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> checkColumn <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">checkColumn = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">check := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> board[i][index] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> check[<span class="keyword">int</span>(board[i][index])-<span class="string">&#x27;0&#x27;</span>] == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">check[<span class="keyword">int</span>(board[i][index])-<span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> checkGrid <span class="function"><span class="keyword">func</span><span class="params">(r,c <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">checkGrid = <span class="function"><span class="keyword">func</span><span class="params">(r,c <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">check := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i:=r; i&lt;r+<span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j:=c; j&lt;c+<span class="number">3</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> board[i][j] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> check[<span class="keyword">int</span>(board[i][j])-<span class="string">&#x27;0&#x27;</span>] == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">check[<span class="keyword">int</span>(board[i][j])-<span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> !checkRow(i) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !checkColumn(i) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=<span class="number">6</span>; i=i+<span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;=<span class="number">6</span>; j=j+<span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !checkGrid(i,j) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a class="link" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">2 &lt;&#x3D; nums.length &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先我们要明确一点：相同的数字异或等于 0，并且异或操作具备交换性。所以整个数组的异或结果等于两个只出现一次的数的异或；<br>(2). 两个数的异或结果在某一个二进制位上是 $1$，说明这两个数在该位上不同，那么我们可以利用这一性质，将数组中所有的数字根据该二进制位上是 $1$  或 $0$ 分类为两组；<br>(3). 组内的元素再自行进行异或，那么最终两组的结果就是两个只出现过一次的数。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N).</p><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumbers</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x := nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">x ^= nums[i]</span><br><span class="line">&#125;</span><br><span class="line">c := x&amp;(-x)</span><br><span class="line"></span><br><span class="line">a, b := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">x = nums[i]</span><br><span class="line"><span class="keyword">if</span> x&amp;c == c &#123;</span><br><span class="line">a ^= nums[i]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">b ^= nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;a,b&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码细节-1"><a href="#代码细节-1" class="headerlink" title="代码细节"></a>代码细节</h3><p>&emsp;&amp;emsp在找第一个不同的二进制位的操作中，我们使用了 <code>x&amp;(-x)</code> 的形式。首先明确一下，计算一个正数的相反数等于将其二进制表示全部<strong>取反再加 1</strong>，例如 $12 = 01100$，那么 $-12 = 10100$，再进行 <code>&amp;</code> 运算可得 $12 &amp; -12 = 00100$，这样就将最低位为 $1$ 的二进制数表示了出来。之后只要将数组中所有的数与该数进行 <code>&amp;</code> 操作就能完成分类。</p><h2 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a class="link" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：nums &#x3D; [3,4,3,3]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：nums &#x3D; [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; nums[i] &lt; 2^31</span><br></pre></td></tr></table></figure><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 因为约定了除了一个数字外，别的数字都会出现 3 次，那么也就意味着每一个数的二进制位会出现 3 的倍数；<br>(2). 当某一个二进制位上不是 3 的倍数，那么也就意味着是那个只出现了一次的数字肯定占据了一次该二进制位；<br>(3). 利用 (2) 中找到的二进制位组成这个数。</p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N).</p><h3 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">bitCount := [<span class="number">32</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">x := nums[i]</span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x ^ (x<span class="number">-1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">bitCount[j]++</span><br><span class="line">&#125;</span><br><span class="line">j++</span><br><span class="line">x &gt;&gt;= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(bitCount); i++ &#123;</span><br><span class="line">x := bitCount[i]%<span class="number">3</span></span><br><span class="line">ret += x*<span class="keyword">int</span>(math.Pow(<span class="number">2</span>,<span class="keyword">float64</span>(i)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码细节-2"><a href="#代码细节-2" class="headerlink" title="代码细节"></a>代码细节</h3><p>&emsp;&emsp;根据本题的特性，我们很容易就能推广，对于某个数组，除了一个数只出现一次外，其余的数都出现了 $m$ 次，那么利用这种特性，我们也能很轻易地找到这个只出现了一次的数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LeetCode179-最大数&quot;&gt;&lt;a href=&quot;#LeetCode179-最大数&quot; class=&quot;headerlink&quot; title=&quot;LeetCode179. 最大数&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode-c</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="早起刷题" scheme="http://jiahaohong1997.github.io/tags/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>channel 的 range 和 select 比较</title>
    <link href="http://jiahaohong1997.github.io/2022/03/19/channel%20%E7%9A%84%20range%20%E5%92%8C%20select%20%E6%AF%94%E8%BE%83/"/>
    <id>http://jiahaohong1997.github.io/2022/03/19/channel%20%E7%9A%84%20range%20%E5%92%8C%20select%20%E6%AF%94%E8%BE%83/</id>
    <published>2022-03-19T10:14:00.000Z</published>
    <updated>2022-03-21T16:47:55.751Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是对 <a class="link" href="http://golangtutorials.blogspot.com/2011/06/channels-in-go-range-and-select.html">Channels in Go - range and select<i class="fas fa-external-link-alt"></i></a> 的学习</p></blockquote><h1 id="range"><a href="#range" class="headerlink" title="range"></a>range</h1><p>&emsp;&emsp;在 goroutine 之间使用 channel 通信时，数据接收方总是面临这样的问题：什么时候停止等待数据？还会有更多的数据么，还是所有内容都完成了？我应该继续等待还是该做别的了？对于这个问题，一个可选的方式是，持续的访问数据源并检查channel是否已经关闭，但是这并不是高效的解决方式。Go提供了<code>range</code>关键字，将其使用在channel上时，会自动等待channel的动作一直到channel被关闭。</p><p>下面通过一段示例代码来说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">(send <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, num <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=num; i++ &#123;  </span><br><span class="line">      send &lt;- i  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="built_in">close</span>(send)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">(recieve &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">for</span> num := <span class="keyword">range</span> recieve &#123;  </span><br><span class="line">      fmt.Printf(<span class="string">&quot;Now we recieve the number %v\n&quot;</span>, num)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)  </span><br><span class="line">   <span class="keyword">go</span> a(c, <span class="number">8</span>)  </span><br><span class="line">   b(c)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输出结果</span><br><span class="line">Now we recieve the number 1</span><br><span class="line">Now we recieve the number 2</span><br><span class="line">Now we recieve the number 3</span><br><span class="line">Now we recieve the number 4</span><br><span class="line">Now we recieve the number 5</span><br><span class="line">Now we recieve the number 6</span><br><span class="line">Now we recieve the number 7</span><br><span class="line">Now we recieve the number 8</span><br></pre></td></tr></table></figure><p>a 这个 goroutine 一直向 channel 内传递数据，直到这个 channel 被关闭前，b 这个 goroutine 都会通过 <code>range</code>  这个关键字阻塞在循环中一直等待 channel 中的数据。通过这个例子还可以看出，<code>for range</code> 可以接收 channel 中的数据，不然 c 作为一个无缓冲 channel，a 不可能向其中一直发送数据。</p><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p><code>select</code>关键字用于多个channel的结合，这些channel会通过类似于 <strong>are-you-ready polling</strong> 的机制来工作。<code>select</code>中会有<code>case</code>代码块，用于发送或接收数据——不论通过<code>&lt;-</code>操作符指定的发送还是接收操作准备好时，channel也就准备好了。在<code>select</code>中也可以有一个<code>default</code>代码块，其一直是准备好的。那么，在<code>select</code>中，哪一个代码块被执行的算法大致如下：</p><ul><li>检查每个<code>case</code>代码块</li><li>如果任意一个<code>case</code>代码块准备好发送或接收，执行对应内容</li><li>如果多于一个<code>case</code>代码块准备好发送或接收，<strong>随机</strong>选取一个并执行对应内容</li><li>如果任何一个<code>case</code>代码块都没有准备好，等待</li><li>如果有<code>default</code>代码块，并且没有任何<code>case</code>代码块准备好，执行<code>default</code>代码块对应内容</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是对 &lt;a class=&quot;link&quot; href=&quot;http://golangtutorials.blogspot.com/2011/06/channels-in-go-range-and-select.html&quot;&gt;Channels in Go </summary>
      
    
    
    
    <category term="go语言" scheme="http://jiahaohong1997.github.io/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="http://jiahaohong1997.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang 重点问题</title>
    <link href="http://jiahaohong1997.github.io/2022/02/09/Golang%20%E9%87%8D%E7%82%B9%E9%97%AE%E9%A2%98/"/>
    <id>http://jiahaohong1997.github.io/2022/02/09/Golang%20%E9%87%8D%E7%82%B9%E9%97%AE%E9%A2%98/</id>
    <published>2022-02-09T15:50:00.000Z</published>
    <updated>2022-03-04T09:05:12.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-Map-的底层实现"><a href="#Golang-Map-的底层实现" class="headerlink" title="Golang Map 的底层实现"></a>Golang Map 的底层实现</h1><h2 id="一般的-map-的实现"><a href="#一般的-map-的实现" class="headerlink" title="一般的 map 的实现"></a>一般的 map 的实现</h2><p>&emsp;&emsp;一般的Map会包含两个主要结构：</p><ul><li>数组：数组里的值指向一个链表，一般称为桶🪣位</li><li>链表：目的解决hash冲突的问题，并存放键值</li></ul><p>大致结构如下：<br><img lazyload src="/images/loading.svg" data-src="origin_map.jpg" alt="avatar"><br>读取一个key值的过程大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   key</span><br><span class="line">   |</span><br><span class="line">   v                 </span><br><span class="line">+------------------------------------+</span><br><span class="line">|      key通过<span class="built_in">hash</span>函数得到key的<span class="built_in">hash</span>    |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">+------------------------------------+</span><br><span class="line">|       key的<span class="built_in">hash</span>通过取模或者位操作     |</span><br><span class="line">|          得到key在数组上的索引        |</span><br><span class="line">+------------------------------------+</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">+------------------------------------+</span><br><span class="line">|         通过索引找到对应的链表         |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">+------------------------------------+</span><br><span class="line">|       遍历链表对比key和目标key        |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">+------------------------------------+</span><br><span class="line">|              相等则返回value         |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">                   |</span><br><span class="line">                   v </span><br><span class="line">                 value</span><br></pre></td></tr></table></figure><h2 id="Go-语言中-Map-的实现思路"><a href="#Go-语言中-Map-的实现思路" class="headerlink" title="Go 语言中 Map 的实现思路"></a>Go 语言中 Map 的实现思路</h2><p>&emsp;&emsp;Go语言解决hash冲突不是链表，实际<strong>主要</strong>用的数组(内存上的连续空间)，如下图所示：</p><p><img lazyload src="/images/loading.svg" data-src="go_map.png" alt="avatar"></p><p>&emsp;&emsp;但是并不是只使用一个数组(连续内存空间)存放键和值，而是使用了两个数组分别存储键和值，图示如下：<br><img lazyload src="/images/loading.svg" data-src="origin_map1.png" alt="avatar"><br>&emsp;&emsp;上图中：-   分别对应的是两个核心的结构体<code>hmap</code>和<code>bmap</code>， <code>bmap</code>里有两个数组分别存放key和value</p><p>&emsp;&emsp;我们通过一次<code>读操作</code>为例，看看读取某个key的值的一个<strong>大致过程</strong>：</p><ol><li>通过hash函数获取目标key的<strong>哈希</strong>，哈希和数组的长度通过位操作获取数组位置的<strong>索引</strong>(备注：获取索引值的方式一般有取模或位操作，位操作的性能好些)</li><li>遍历bmap里的键，和目标key对比获取<strong>key的索引</strong>(找不到则返回空值)</li><li>根据<strong>key的索引</strong>通过计算偏移量，获取到对应value<br><img lazyload src="/images/loading.svg" data-src="origin_map2.png" alt="avatar"></li></ol><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="核心结构体-hmap"><a href="#核心结构体-hmap" class="headerlink" title="核心结构体 hmap"></a>核心结构体 hmap</h3><p>&emsp;&emsp;<code>hmap</code>的结构其实刚开始看起来其实还是比较复杂的，有不少的字段，具体字段如下图所示：<br><img lazyload src="/images/loading.svg" data-src="hmap.png" alt="avatar"><br>字段释义如下：</p><ol><li>count：键值对的数量</li><li>B：2^B=len(buckets)</li><li>hash0：hash因子</li><li>buckets：指向一个数组(连续内存空间)，数组的类型为[]bmap，bmap类型就是存在键值对的结构下面会详细介绍，这个字段我们可以称之为正常桶。</li><li>oldbuckets：扩容时，存放之前的buckets(Map扩容相关字段)</li><li>extra：溢出桶结构，正常桶里面某个bmap存满了，会使用这里面的内存空间存放键值对</li><li>noverflow：溢出桶里bmap大致的数量</li><li>nevacuate：分流次数，成倍扩容分流操作计数的字段(Map扩容相关字段)</li><li>flags：状态标识，比如正在被写、buckets和oldbuckets在被遍历、等量扩容(Map扩容相关字段)</li></ol><p><img lazyload src="/images/loading.svg" data-src="bmap.png" alt="avatar"><br>&emsp;&emsp;<code>buckets</code>指向了一个数组(连续的内存空间)，数组的元素是<code>bmap</code>类型，这个字段我们称之为正常桶。</p><h3 id="核心结构体-bmap"><a href="#核心结构体-bmap" class="headerlink" title="核心结构体 bmap"></a>核心结构体 bmap</h3><p>&emsp;&emsp;正常桶<code>hmap.buckets</code>的元素是一个<code>bmap</code>结构。<code>bmap</code>的具体字段如下图所示：<br><img lazyload src="/images/loading.svg" data-src="bmap1.png" alt="avatar"><br>字段释义如下：</p><ol><li>topbits：长度为8的数组，[]uint8，元素为：key获取的hash的高8位，遍历时对比使用，提高性能。<strong>如下图所示</strong></li><li>keys：长度为8的数组，[]keytype，元素为：具体的key值。<strong>如下图所示</strong></li><li>elems：长度为8的数组，[]elemtype，元素为：键值对的key对应的值。</li><li>overflow：指向的<code>hmap.extra.overflow</code>溢出桶里的<code>bmap</code>，上面的字段<code>topbits</code>、<code>keys</code>、<code>elems</code>长度为8，最多存8组键值对，存满了就往指向的这个<code>bmap</code>里存</li><li>pad：对齐内存使用的，不是每个bmap都有会这个字段，需要满足一定条件<br><img lazyload src="/images/loading.svg" data-src="bmap2.png" alt="avatar"></li></ol><p>&emsp;&emsp;<strong>结论：每个<code>bmap</code>结构最多存放8组键值对。</strong></p><h3 id="hmap-和-bmap-的基本结构合起来"><a href="#hmap-和-bmap-的基本结构合起来" class="headerlink" title="hmap 和 bmap 的基本结构合起来"></a>hmap 和 bmap 的基本结构合起来</h3><p>&emsp;&emsp;分别了解了<code>hmap</code>和<code>bmap</code>的基本结构后，我们把上面的内容合并起来，就得到如下的Map结构图：<br><img lazyload src="/images/loading.svg" data-src="combine_map.png" alt="avatar"></p><h3 id="溢出桶"><a href="#溢出桶" class="headerlink" title="溢出桶"></a>溢出桶</h3><p>&emsp;&emsp;上面讲<code>bmap</code>的时候，我们不是得到了个结论么“每个<code>bmap</code>结构最多存放8组键值对。”，所以问题来了：</p><blockquote><p>正常桶里的<code>bmap</code>存满了怎么办?</p></blockquote><p>&emsp;&emsp;解决这个问题我们就要说到<code>hmap.extra</code>结构了，<code>hmap.extra</code>是个结构体，结构图示和字段释义如下：<br><img lazyload src="/images/loading.svg" data-src="overflow.png" alt="avatar"></p><ol><li>overflow：称之为<strong>溢出桶</strong>。和<code>hmap.buckets</code>的类型一样也是数组<code>[]bmap</code>，当正常桶<code>bmap</code>存满了的时候就使用<code>hmap.extra.overflow</code>的<code>bmap</code>。</li><li>oldoverflow：扩容时存放之前的overflow(Map扩容相关字段)</li><li>nextoverflow：指向溢出桶里下一个可以使用的<code>bmap</code></li></ol><blockquote><p>问题：正常桶<code>hmap.buckets</code>里的<code>bmap</code>是<strong>怎么关联上</strong>溢出桶<code>hmap.extra.overflow</code>的<code>bmap</code>呢？</p></blockquote><p>答：就是我们介绍<code>bmap</code>结构时里的<code>bmap.overflow</code>字段(如下图所示)。<code>bmap.overflow</code>是个指针类型，存放了对应使用的溢出桶<code>hmap.extra.overflow</code>里的<code>bmap</code>的地址。</p><p><strong>问题又来了</strong>：</p><blockquote><p>正常桶<code>hmap.buckets</code>里的<code>bmap</code>是<strong>什么时候关联上</strong>溢出桶<code>hmap.extra.overflow</code>的<code>bmap</code>呢？</p></blockquote><p>答：Map写操作的时候。</p><p>&emsp;&emsp;<strong>当<code>hmap</code>存在溢出桶时，且当前溢出桶只被使用了一个bmap</strong>时，我们可以得到如下的关系图：<br><img lazyload src="/images/loading.svg" data-src="overflow1.png" alt="avatar"><br>&emsp;&emsp;同时我们可以看出正常桶的<code>bmap</code>和溢出桶的<code>bmap</code>实际构成了链表关系，所以这也解释了开篇我们说到的“Go里面Map的实现<strong>主要</strong>用到了数组”，其次还用到了链表。</p><h2 id="再次分析Map的读"><a href="#再次分析Map的读" class="headerlink" title="再次分析Map的读"></a>再次分析Map的读</h2><p>&emsp;&emsp;我们再次通过一次读操作为例，看看读取某个key的值的一个大致过程：<br><img lazyload src="/images/loading.svg" data-src="readmap.png" alt="avatar"><br>&emsp;&emsp;Go 语言中 map 采用的是哈希查找表，由一个 key 通过哈希函数得到哈希值，64 位系统中就生成一个 64bit 的哈希值，由这个哈希值将 key 对应到不同的桶 （bucket）中，当有多个哈希映射到相同的的桶中时，使用链表解决哈希冲 突。key 经过 hash 后共 64 位，根据 hmap 中 B 的值，计算它到底要落在哪个桶 时，桶的数量为 2^B，如 B=5，那么用 64 位最后 5 位表示第几号桶，在用 hash 值的高 8 位确定在 bucket 中的存储位置，当前 bmap 中的 bucket 未找到，则查 询对应的 overflow bucket，对应位置有数据则对比完整的哈希值，确定是否 是要查找的数据。 如果两个不同的 key 落在的同一个桶上，hash 冲突使用链表法接近，遍历 bucket 中的 key 如果当前处于 map 进行了扩容，处于数据搬移状态，则优先从 oldbuckets 查找。</p><h2 id="Golang-Map-如何扩容"><a href="#Golang-Map-如何扩容" class="headerlink" title="Golang Map 如何扩容"></a>Golang Map 如何扩容</h2><p>装载因子：count/2^B<br>触发条件：</p><ol><li>装填因子是否大于 6.5</li><li>overflow bucket 是否太多</li></ol><p>解决方法：</p><ol><li>双倍扩容：扩容采取了一种称为“渐进式”地方式，原有的 key 并不会一 次性搬迁完毕，每次最多只会搬迁 2 个 bucket</li><li>等量扩容：重新排列，极端情况下，重新排列也解决不了，map 成了链表，性能大大降低，此时哈希种子 hash0 的设置，可以降低此类极端场景的发生。</li></ol><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>&emsp;&emsp;在 Go 语言中，不要通过共享内存来通信，而要通过通信来实现内存共享。Go 的 CSP（Communicating Sequential Process）并发模型，中文叫做通信顺序进程，是通过 goroutine 和 channel 来实现的。所以 channel 收发遵循先进先出 FIFO，分为有缓存和无缓存，channel 中大致有 buffer(当缓冲区大小不为 0 时，是个 ring buffer)、sendq、recvq 当前 channel 因为缓冲区不足而阻塞的队列、使用双向链表存储、还有一个 mutex 锁控制并发、其他原属等。</p><h2 id="channel-的底层实现"><a href="#channel-的底层实现" class="headerlink" title="channel 的底层实现"></a>channel 的底层实现</h2><p><img lazyload src="/images/loading.svg" data-src="hchan.png" alt="avatar"><br>简单说明：<br><code>buf</code>是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表<br><code>sendx</code>和<code>recvx</code>用于记录<code>buf</code>这个循环链表中的 index<br><code>lock</code>是个互斥锁<br><code>recvq</code>和<code>sendq</code>分别是接收(&lt;-channel)或者发送(channel &lt;- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表</p><p>下面我们来详细介绍<code>hchan</code>中各部分是如何使用的。</p><ol><li><p>先从创建开始<br>我们首先创建一个channel：ch := make(chan int, 3)<br><img lazyload src="/images/loading.svg" data-src="hchan1.png" alt="avatar"><br>创建channel实际上就是在内存中实例化了一个<code>hchan</code>的结构体，并返回一个ch指针，我们使用过程中channel在函数之间的传递都是用的这个指针，这就是为什么函数传递中无需使用channel的指针，而直接用channel就行了，因为channel本身就是一个指针。</p></li><li><p>channel中发送send(ch &lt;- xxx)和recv(&lt;- ch)接收<br>先考虑一个问题，如果你想让goroutine以先进先出(FIFO)的方式进入一个结构体中，你会怎么操作？  加锁！对的！channel就是用了一个锁。hchan本身包含一个互斥锁<code>mutex</code></p></li></ol><ul><li>channel中队列是如何实现的<br>channel中有个缓存buf，是用来缓存数据的(假如实例化了带缓存的channel的话)队列。我们先来看看是如何实现“队列”的。当使用<code>send (ch &lt;- xx)</code>或者<code>recv ( &lt;-ch)</code>的时候，首先要锁住<code>hchan</code>这个结构体。<br>所以不难看出，Go中那句经典的话：<code>Do not communicate by sharing memory; instead, share memory by communicating.</code>的具体实现就是利用channel把数据从一端copy到了另一端！<br>还真是符合<code>channel</code>的英文含义：<br><img lazyload src="/images/loading.svg" data-src="hchan_channl.gif" alt="avatar"></li></ul><ol start="3"><li>当channel缓存满了之后会发生什么？这其中的原理是怎样的？<br>使用的时候，我们都知道，当channel缓存满了，或者没有缓存的时候，我们继续send(ch &lt;- xxx)或者recv(&lt;- ch)会阻塞当前goroutine，但是，是如何实现的呢？我们知道，Go的goroutine是用户态的线程(<code>user-space threads</code>)，用户态的线程是需要自己去调度的，Go有运行时的scheduler去帮我们完成调度这件事情。goroutine的阻塞操作，实际上是调用<code>send (ch &lt;- xx)</code>或者<code>recv ( &lt;-ch)</code>的时候主动触发的，具体请看以下内容：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)  </span><br><span class="line">  </span><br><span class="line">ch &lt;- <span class="number">1</span>  </span><br><span class="line">ch &lt;- <span class="number">1</span>  </span><br><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure><img lazyload src="/images/loading.svg" data-src="hchan_block.png" alt="avatar"><br><img lazyload src="/images/loading.svg" data-src="hchan_block1.png" alt="avatar"><br>这个时候G1正在正常运行,当再次进行send操作(ch&lt;-1)的时候，会主动调用Go的调度器(G0)，通过 runtime.gopark 函数让G1等待，并从让出M，让其他G去使用<br><img lazyload src="/images/loading.svg" data-src="hchan_block2.png" alt="avatar"><br>同时G1也会被抽象成含有G1指针和send元素的<code>sudog</code>结构体保存到hchan的<code>sendq</code>中等待被唤醒。<br><img lazyload src="/images/loading.svg" data-src="hchan_blok3.gif" alt="avatar"><br>那么，G1什么时候被唤醒呢？这个时候G2隆重登场。<br><img lazyload src="/images/loading.svg" data-src="hchan_block4.png" alt="avatar"><br>G2执行了recv操作<code>p := &lt;-ch</code>，于是会发生以下的操作：<br><img lazyload src="/images/loading.svg" data-src="hchan_block5.gif" alt="avatar"><br>G2从缓存队列中取出数据，channel会将等待队列中的G1推出，将G1当时send的数据推到缓存中，然后调用Go的scheduler，唤醒G1(runtime.goready)，并把G1放到可运行的Goroutine队列中。通过这种协作式的调度来实现 goroutine 的调度。<br><img lazyload src="/images/loading.svg" data-src="hchan_block6.gif" alt="avatar"></li></ol><ul><li>假如是先进行执行recv操作的G2会怎么样？<br><img lazyload src="/images/loading.svg" data-src="hchan_block7_1.png" alt="avatar"><br>这个时候G2会主动调用Go的调度器,让G2等待，并从让出M，让其他G去使用。<br>G2还会被抽象成含有G2指针和recv空元素的<code>sudog</code>结构体保存到hchan的<code>recvq</code>中等待被唤醒<br><img lazyload src="/images/loading.svg" data-src="hchan_block7.gif" alt="avatar"><br>此时恰好有个goroutine G1开始向channel中推送数据 <code>ch &lt;- 1</code>。<br>此时，非常有意思的事情发生了：<br><img lazyload src="/images/loading.svg" data-src="hchan_block8.gif" alt="avatar"><br>G1并没有锁住channel，然后将数据放到缓存中，而是直接把数据从G1直接copy到了G2的栈中。这种方式非常的赞！在唤醒过程中，G2无需再获得channel的锁，然后从缓存中取数据。减少了内存的copy，提高了效率。<strong>当然这种方法只能在 runtime 下自动执行，需要 runtime 调度 G2 的栈上的变量直接去 G1 的栈上获取数据</strong>。<br><img lazyload src="/images/loading.svg" data-src="hchan_block9.gif" alt="avatar"><br>之后和之前一样，G2 变成 runnable 的状态，被挂到原始的 P 队列中。新版本进行了优化，为了避免 G2 被放到 P  队列末尾会被其他的 P 窃取（work-stealing），G2 会被优先挂载到当前队列正在执行的 goroutine 后面，很快就能得到执行。</li></ul><h2 id="channel-的特性"><a href="#channel-的特性" class="headerlink" title="channel 的特性"></a>channel 的特性</h2><ol><li>给一个 nil channel 发送数据，造成永远阻塞</li><li>从一个 nil channel 接收数据，造成永远阻塞</li><li>给一个已经关闭的 channel 发送数据，引起 panic</li><li>从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值</li><li>无缓冲的 channel 是同步的，而有缓冲的 channel 是非同步的</li><li>关闭一个 nil channel 将会发生 panic<br><img lazyload src="/images/loading.svg" data-src="channel.jpg" alt="avatar"></li></ol><h2 id="Channel-的-ring-buffer-实现"><a href="#Channel-的-ring-buffer-实现" class="headerlink" title="Channel 的 ring buffer 实现"></a>Channel 的 ring buffer 实现</h2><p>&emsp;&emsp;channel 中使用了 ring buffer(环形缓冲区) 来缓存写入的数据。ring buffer 有很多好处，而且非常适合用来实现 FIFO 式的固定长度队列。在 channel 中，ring buffer 的实现如下：<br><img lazyload src="/images/loading.svg" data-src="ring_buffer.jpg" alt="avatar"><br>&emsp;&emsp;有两个与 buffer 相关的变量:recvx 和 sendx。其中 sendx 表示 buffer 中可写的 index，recvx 表示 buffer 中可读的 index。 从 recvx 到 sendx 之间的元素，表示已正常存放入 buffer 中的数据。 我们可以直接使用 buf[recvx]来读取到队列的第一个元素，使用 buf[sendx] = x 来将元素放到队尾。</p><h1 id="Go-并发编程"><a href="#Go-并发编程" class="headerlink" title="Go 并发编程"></a>Go 并发编程</h1><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><h3 id="Mutex-的几种状态"><a href="#Mutex-的几种状态" class="headerlink" title="Mutex 的几种状态"></a>Mutex 的几种状态</h3><ol><li>mutexLocked — 表示互斥锁的锁定状态；</li><li>mutexWoken — 表示从正常模式被从唤醒；</li><li>mutexStarving — 当前的互斥锁进入饥饿状态；</li><li>waitersCount — 当前互斥锁上等待的 Goroutine 个数；</li></ol><h3 id="Mutex-正常模式和饥饿模式"><a href="#Mutex-正常模式和饥饿模式" class="headerlink" title="Mutex 正常模式和饥饿模式"></a>Mutex 正常模式和饥饿模式</h3><ul><li><p><strong>正常模式(非公平锁)</strong><br>&emsp;&emsp;正常模式下，所有等待锁的 goroutine 按照 FIFO(先进先出)顺序等待。唤醒的 goroutine 不会直接拥有锁，而是会和新请求锁的 goroutine 竞争锁的拥有。新请求锁的 goroutine 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的 goroutine 有很大可能在锁竞争中失败。在这种情况下，这个被 唤醒的 goroutine 会加入到等待队列的前面。 如果一个等待的 goroutine 超过 1ms 没有获取锁，那么它将会把锁转变为饥饿模式。</p></li><li><p><strong>饥饿模式(公平锁)</strong><br>&emsp;&emsp;为了解决了等待 G 队列的长尾问题。饥饿模式下，直接由 unlock 把锁交给等待队列中排在第一位的 G(队头)，同时，饥饿模式下，新进来的 G 不会参与抢锁也不会进入自旋状态，会直接进入等待队列的尾部，这样很好的解决了老的 G 一直抢不到锁的场景。 饥饿模式的触发条件，当一个 G 等待锁时间超过 1 毫秒时，或者当前队列只剩 下一个 G 的时候，Mutex 切换到饥饿模式。</p></li></ul><blockquote><p>总结：对于两种模式，正常模式下的性能是最好的，goroutine 可以连续多次获取 锁，饥饿模式解决了取锁公平的问题，但是性能会下降，其实是性能和公平的 一个平衡模式。</p></blockquote><h3 id="Mutex-允许自旋的条件"><a href="#Mutex-允许自旋的条件" class="headerlink" title="Mutex 允许自旋的条件"></a>Mutex 允许自旋的条件</h3><p>&emsp;&emsp;在1个协程获取锁时，另一个协程一直尝试，直到能够获取锁（不断循环），这就是自旋锁。</p><ol><li>锁已被占用，并且锁不处于饥饿模式。</li><li>积累的自旋次数小于最大自旋次数（active_spin=4）。</li><li>cpu 核数大于 1。</li><li>有空闲的 P。</li><li>当前 goroutine 所挂载的 P 下，本地待运行队列为空。</li></ol><h3 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h3><ul><li><p>实现原理<br>&emsp;&emsp;通过记录 readerCount 读锁的数量来进行控制，当有一个写锁的时候，会将读锁数量设置为负数 1&lt;&lt;30。目的是让新进入的读锁等待写锁之后释放通知读锁。同样的写锁也会等等待之前的读锁都释放完毕，才会开始进行后续的操作。 而等写锁释放完之后，会将值重新加上 1&lt;&lt;30, 并通知刚才新进入的读锁 (rw.readerSem)，两者互相限制。</p></li><li><p>注意事项</p></li></ul><ol><li>RWMutex 是单写多读锁，该锁可以加多个读锁或者一个写锁</li><li>读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁</li><li>写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占</li><li>适用于读多写少的场景</li><li>RWMutex 的一个写锁 Lock 去锁定临界区的共享资源，如果临界区的共享资源已被（读锁或写锁）锁定，这个写锁操作的 goroutine 将被阻塞直到 解锁。</li><li>RWMutex 的读锁或写锁在未锁定状态，解锁操作都会引发 panic</li><li>RWMutex 在首次被使用之后就不能再被拷贝</li><li>写锁被解锁后，所有因操作锁定读锁而被阻塞的 goroutine 会被唤醒，并都可以成功锁定读锁。</li><li>读锁被解锁后，在没有被其他读锁锁定的前提下，所有因操作锁定写锁而被阻塞的 goroutine，其中等待时间最长的一个 goroutine 会被唤醒。</li></ol><h2 id="sync-包中的两个对象"><a href="#sync-包中的两个对象" class="headerlink" title="sync 包中的两个对象"></a>sync 包中的两个对象</h2><h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><ol><li>Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。</li><li>Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测试资源。</li><li>sync.Once 只暴露了一个方法 Do，你可以多次调用 Do 方法，但是只有第一次调用 Do 方法时 f 参数才会执行，这里的 f 是一个无参数无返回值的函数。</li></ol><h3 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h3><p>&emsp;&emsp;对于很多需要重复分配、回收内存的地方，sync.Pool 是一个很好的选择。频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺，而 sync.Pool 可以将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。</p><h1 id="Switch-和-Select-的区别"><a href="#Switch-和-Select-的区别" class="headerlink" title="Switch 和 Select 的区别"></a>Switch 和 Select 的区别</h1><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p><code>select</code>只能应用于channel的操作，既可以用于channel的数据接收，也可以用于channel的数据发送。如果<code>select</code>的多个分支都满足条件，则会随机的选取其中一个满足条件的分支。<br><code>default</code>: select中的default是当select发现没有case满足,要block时的选择</p><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p><code>switch</code>可以为各种类型进行分支操作， 设置可以为接口类型进行分支判断(通过i.(type))。<code>switch</code> 分支是顺序执行的，这和<code>select</code>不同。<br><code>default</code>:  switch中的default是默认的意思,当所有case不满足的时候,就会执行default</p><h1 id="Go-runtime"><a href="#Go-runtime" class="headerlink" title="Go runtime"></a>Go runtime</h1><h2 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h2><h3 id="Gorutine"><a href="#Gorutine" class="headerlink" title="Gorutine"></a>Gorutine</h3><p>&emsp;&emsp;Goroutine “Goroutine 是一个与其他 goroutines 并行运行在同一地址空间的 Go 函数或方法。一个运行的程序由一个或更多个 goroutine 组成。它与线程、协程、进 程等不同。它是一个 goroutine” —— Rob Pike<br>&emsp;&emsp;Goroutines 在同一个用户地址空间里并行独立执行 functions，channels 则用于 goroutines 间的通信和同步访问控制。</p><h3 id="GMP-模型"><a href="#GMP-模型" class="headerlink" title="GMP 模型"></a>GMP 模型</h3><ol><li>G（Goroutine）：我们所说的协程，为用户级的轻量级线程，每个 Goroutine 对象中的 sched 保存着其上下文信息.</li><li>M（Machine）：对内核级线程的封装，数量对应真实的 CPU 数（真正干活的对象）</li><li>P（Processor）：即为 G 和 M 的调度对象，用来调度 G 和 M 之间的关联关系， 其数量可通过 GOMAXPROCS()来设置，默认为核心数。</li></ol><p>&emsp;&emsp;调度器把 G 都分配到 M 上，不同的 G 在不同的 M 并发运行时，都需要向系统申请资源，比如堆栈内存等，因为资源是全局的，就会因为资源竞争照成很多性能损耗。为了解决这一的问题 go 从 1.1 版本引入，在运行时系统的时候加入 p 对象，让 P 去管理这个 G 对象，M 想要运行 G，必须绑定 P，才能运行 P 所管理的 G。单纯的 GM 模型会引起以下问题：</p><ol><li>单一全局互斥锁(Sched.Lock)和集中状态存储；</li><li>Goroutine 传递问题（M 经常在 M 之间传递”可运行”的 goroutine）</li><li>每个 M 做内存缓存，导致内存占用过高，数据局部性较差</li><li>频繁 syscall 调用，导致严重的线程阻塞/解锁，加剧额外的性能损耗。</li></ol><h4 id="GMP-调度流程"><a href="#GMP-调度流程" class="headerlink" title="GMP 调度流程"></a>GMP 调度流程</h4><p>&emsp;&emsp;在 Go 中，<strong>线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上</strong>。<br><img lazyload src="/images/loading.svg" data-src="goroutine.jpg" alt="avatar"></p><ol><li>全局队列（Global Queue）：存放等待运行的 G。</li><li>P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。</li><li>P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。</li><li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li></ol><p><strong>Goroutine 调度器和 OS 调度器是通过 M 结合起来的，每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行</strong>。</p><blockquote><p>有关 P 和 M 的个数问题</p><ol><li>P 的数量：由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。这意味着在程序执行的<strong>任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行</strong>。</li><li>M 的数量：（1） go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略。<br>（2） runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量<br>（3）一个 M 阻塞了，会创建新的 M</li></ol><p> <strong>M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。</strong></p></blockquote><blockquote><p>P 和 M 何时被创建</p><ol><li>P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。</li><li>M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。</li></ol></blockquote><h5 id="调度器的设计策略"><a href="#调度器的设计策略" class="headerlink" title="调度器的设计策略"></a>调度器的设计策略</h5><ol><li>work stealing 机制：当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。</li><li>hand off 机制：当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。</li></ol><p><img lazyload src="/images/loading.svg" data-src="gmp.jpg" alt="avatar"></p><ol><li>每个 P 有个局部队列，局部队列保存待执行的 goroutine(流程 2)，当 M 绑定的 P 的的局部队列已经满了之后就会把 goroutine 放到全局队列(流程 2-1)</li><li>每个 P 和一个 M 绑定，M 是真正的执行 P 中 goroutine 的实体(流程 3)，M 从绑定的 P 中的局部队列获取 G 来执行</li><li>当 M 绑定的 P 的局部队列为空时，M 会从全局队列获取到本地队列来执行 G(流程 3.1)，当从全局队列中没有获取到可执行的 G 时候，M 会从其他 P 的局部队列中偷取 G 来执行(流程 3.2)，这种从其他 P 偷的方式称为 work stealing</li><li>当 G 因系统调用(syscall)阻塞时会阻塞 M，此时 P 会和 M 解绑即 hand off，并寻找新的 idle 的 M，若没有 idle 的 M 就会新建一个 M(流程 5.1)。</li><li>当 G 因 channel 或者 network I/O 阻塞时，不会阻塞 M，M 会寻找其他 runnable 的 G；当阻塞的 G 恢复后会重新进入 runnable 进入 P 队列等待执行(流程 5.3)</li><li>当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中。</li></ol><h5 id="特殊的-M0-和-G0"><a href="#特殊的-M0-和-G0" class="headerlink" title="特殊的 M0 和 G0"></a>特殊的 M0 和 G0</h5><p>M0：启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。<br>G0：是每次启动一个 M 都会第一个创建的 goroutine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。</p><h3 id="Go-调度器调度场景过程全解析"><a href="#Go-调度器调度场景过程全解析" class="headerlink" title="Go 调度器调度场景过程全解析"></a>Go 调度器调度场景过程全解析</h3><ol><li><p>场景 1<br>P 拥有 G1，M1 获取 P 后开始运行 G1，G1 使用 <code>go func()</code> 创建了 G2，为了局部性 G2 优先加入到 P1 的本地队列。<br><img lazyload src="/images/loading.svg" data-src="q1.jpg" alt="avatar"></p></li><li><p>场景 2<br>G1 运行完成后 (函数：goexit)，M 上运行的 goroutine 切换为 G0，G0 负责调度时协程的切换（函数：schedule）。从 P 的本地队列取 G2，从 G0 切换到 G2，并开始运行 G2 (函数：execute)。实现了线程 M1 的复用。<br><img lazyload src="/images/loading.svg" data-src="q2.jpg" alt="avatar"></p></li><li><p>场景 3<br>假设每个 P 的本地队列只能存 3 个 G。G2 要创建了 6 个 G，前 3 个 G（G3, G4, G5）已经加入 p1 的本地队列，p1 本地队列满了。<br><img lazyload src="/images/loading.svg" data-src="q3.jpg" alt="avatar"></p></li><li><p>场景 4<br>G2 在创建 G7 的时候，发现 P1 的本地队列已满，需要执行<strong>负载均衡</strong> (把 P1 中本地队列中前一半的 G，还有新创建 G <strong>转移</strong>到全局队列)<br><img lazyload src="/images/loading.svg" data-src="q4.jpg" alt="avatar"></p></li><li><p>G2 创建 G8 时，P1 的本地队列未满，所以 G8 会被加入到 P1 的本地队列。G8 加入到 P1 点本地队列的原因还是因为 P1 此时在与 M1 绑定，而 G2 此时是 M1 在执行。所以 G2 创建的新的 G 会优先放置到自己的 M 绑定的 P 上。<br><img lazyload src="/images/loading.svg" data-src="q5.jpg" alt="avatar"></p></li><li><p>场景 6<br>规定：在创建 G 时，运行的 G 会尝试唤醒其他空闲的 P 和 M 组合去执行。<br><img lazyload src="/images/loading.svg" data-src="q6.jpg" alt="avatar"><br>假定 G2 唤醒了 M2，M2 绑定了 P2，并运行 G0，但 P2 本地队列没有 G，M2 此时为自旋线程<strong>（没有 G 但为运行状态的线程，不断寻找 G）</strong>。</p></li><li><p>场景 7<br>M2 尝试从全局队列 (简称 “GQ”) 取一批 G 放到 P2 的本地队列（函数：<code>findrunnable()</code>）。至少从全局队列取 1 个 g，但每次不要从全局队列移动太多的 g 到 p 本地队列，给其他 p 留点。这是<strong>从全局队列到 P 本地队列的负载均衡</strong>。<br><img lazyload src="/images/loading.svg" data-src="q7.jpg" alt="avatar"></p></li><li><p>场景 8<br>假设 G2 一直在 M1 上运行，经过 2 轮后，M2 已经把 G7、G4 从全局队列获取到了 P2 的本地队列并完成运行，全局队列和 P2 的本地队列都空了，如场景 8 图的左半部分。<br><img lazyload src="/images/loading.svg" data-src="q8.jpg" alt="avatar"></p></li><li><p>场景 9<br>G1 本地队列 G5、G6 已经被其他 M 偷走并运行完成，当前 M1 和 M2 分别在运行 G2 和 G8，M3 和 M4 没有 goroutine 可以运行，M3 和 M4 处于自旋状态，它们不断寻找 goroutine。<br><img lazyload src="/images/loading.svg" data-src="q9.jpg" alt="avatar"></p></li><li><p>场景 10<br>假定当前除了 M3 和 M4 为自旋线程，还有 M5 和 M6 为空闲的线程 (没有得到 P 的绑定，注意我们这里最多就只能够存在 4 个 P，所以 P 的数量应该永远是 M&gt;=P, 大部分都是 M 在抢占需要运行的 P)，G8 创建了 G9，G8 进行了阻塞的系统调用，M2 和 P2 立即解绑，P2 会执行以下判断：如果 P2 本地队列有 G、全局队列有 G 或有空闲的 M，P2 都会立马唤醒 1 个 M 和它绑定，否则 P2 则会加入到空闲 P 列表，等待 M 来获取可用的 p。本场景中，P2 本地队列有 G9，可以和其他空闲的线程 M5 绑定。<br><img lazyload src="/images/loading.svg" data-src="q10.jpg" alt="avatar"></p></li><li><p>场景 11<br>G8 创建了 G9，假如 G8 进行了<strong>非阻塞系统调用</strong>。<br><img lazyload src="/images/loading.svg" data-src="q11.jpg" alt="avatar"><br>M2 和 P2 会解绑，但 M2 会记住 P2，然后 G8 和 M2 进入系统调用状态。当 G8 和 M2 退出系统调用时，会尝试获取 P2，如果无法获取，则获取空闲的 P，如果依然没有，G8 会被记为可运行状态，并加入到全局队列，M2 因为没有 P 的绑定而变成休眠状态 (长时间休眠等待 GC 回收销毁)。</p></li></ol><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><h4 id="协作式的调度"><a href="#协作式的调度" class="headerlink" title="协作式的调度"></a>协作式的调度</h4><p>&emsp;&emsp;在 1.14 版本之前，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度，存在问题:</p><ol><li>某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿</li><li>垃圾回收需要暂停整个程序（Stop-the-world，STW），最长可能需要几分钟的时间，导致整个程序无法工作。</li></ol><h4 id="基于信号的抢占式调度"><a href="#基于信号的抢占式调度" class="headerlink" title="基于信号的抢占式调度"></a>基于信号的抢占式调度</h4><p>&emsp;&emsp;GO 的调度器是迟钝的，它很可能什么都没做，直到 M 阻塞了相当长时间以后，才会发现有一个 P/M 被 syscall 阻塞了。然后，才会用空闲的 M 来强这个 P。通过 sysmon 监控实现的抢占式调度，最快在 20us，最慢在 10-20ms 才 会发现有一个 M 持有 P 并阻塞了。操作系统在 1ms 内可以完成很多次线程调度（一般情况 1ms 可以完成几十次线程调度），Go 发起 IO/syscall 的时候执 行该 G 的 M 会阻塞然后被 OS 调度走，P 什么也不干，sysmon 最慢要 10-20ms 才能发现这个阻塞，说不定那时候阻塞已经结束了，宝贵的 P 资源就这么被阻塞的 M 浪费了。</p><h3 id="GMP-调度过程中存在哪些阻塞"><a href="#GMP-调度过程中存在哪些阻塞" class="headerlink" title="GMP 调度过程中存在哪些阻塞"></a>GMP 调度过程中存在哪些阻塞</h3><ol><li>I/O，select</li><li>block on syscall</li><li>channel</li><li>等待锁</li><li>runtime.Gosched() (G0 调度 goroutine)</li></ol><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="Golang-简要内存划分"><a href="#Golang-简要内存划分" class="headerlink" title="Golang 简要内存划分"></a>Golang 简要内存划分</h3><p><img lazyload src="/images/loading.svg" data-src="mem.jpg" alt="avatar"><br>&emsp;&emsp;可以简单的认为 Golang 程序在启动时，会向操作系统申请一定区域的内存，分为栈（Stack）和堆（Heap）。栈内存会随着函数的调用分配和回收；堆内存由程序申请分配，由垃圾回收器（Garbage Collector）负责回收。性能上，栈内存的使用和回收更迅速一些；尽管Golang 的 GC 很高效，但也不可避免的会带来一些性能损耗。因此，Go 优先使用栈内存进行内存分配。在不得不将对象分配到堆上时，才将特定的对象放到堆中。</p><h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h3><p><img lazyload src="/images/loading.svg" data-src="stackHeap.png" alt="avatar"><br>&emsp;&emnsp;上图展示了一个进程的虚拟内存划分，代码中使用的内存地址都是虚拟内存地址，而不是实际的物理内存地址。栈和堆只是虚拟内存上2块不同功能的内存区域：</p><ul><li>栈在高地址，从高地址向低地址增长。</li><li>堆在低地址，从低地址向高地址增长。</li></ul><blockquote><p><strong>栈和堆相比有这么几个好处</strong>：</p><ol><li> 栈的内存管理简单，分配比堆上快。</li><li>栈的内存不需要回收，而堆需要，无论是主动free，还是被动的垃圾回收，这都需要花费额外的CPU。 </li><li>栈上的内存有更好的局部性，堆上内存访问就不那么友好了，CPU访问的2块数据可能在不同的页上，CPU访问数据的时间可能就上去了。</li></ol></blockquote><h3 id="栈内存分配"><a href="#栈内存分配" class="headerlink" title="栈内存分配"></a>栈内存分配</h3><ol><li>以一段简单的代码作为示例，分析这段代码的内存分配过程。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">n := <span class="number">4</span>  </span><br><span class="line">n2 := square(n)  </span><br><span class="line">fmt.Println(n2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;  </span><br><span class="line"><span class="keyword">return</span> n * n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&emsp;&emsp;代码的功能很简单，一个 main 函数作为程序入口，定义了一个变量n，定义了另一个函数 squire ，返回乘方操作后的 int 值。最后，将返回的值打印到控制台。程序输出为16。下面开始逐行进行分析，解析调用时，go 运行时是如何对内存进行分配的。<br><img lazyload src="/images/loading.svg" data-src="code1.jpg" alt="avatar"><br>&emsp;&emsp;当代码运行到第6行，进入 main 函数时，会在栈上创建一个 Stack frame，存放本函数中的变量信息。包括函数名称，变量等。</li></ol><p><img lazyload src="/images/loading.svg" data-src="code2.jpg" alt="avatar"><br>&emsp;&emsp;当代码运行到第7行时，go 会在栈中压入一个新的 Stack Frame，用于存放调用 square 函数的信息；包括函数名、变量 n 的值等。此时，计算4 * 4 的值，并返回。</p><p><img lazyload src="/images/loading.svg" data-src="code3.jpg" alt="avatar"><br>&emsp;&emsp;当 square 函数调用完成，返回16到 main 函数后，将16赋值给 n2变量。注意，原来的 stack frame 并不会被 go 清理掉，而是如栈左侧的箭头所示，被标记为不合法。上图夹在红色箭头和绿色箭头之间的横线可以理解为 go 汇编代码中的 SP 栈寄存器的值，当程序申请或释放栈内存时，只需要修改 SP 寄存器的值，这种栈内存分配方式省掉了清理栈内存空间的耗时。</p><p><img lazyload src="/images/loading.svg" data-src="code4.jpg" alt="avatar"><br>&emsp;&emsp;接下来，调用 fmt.Println 时，SP 寄存器的值会进一步增加，覆盖掉原来 square 函数的 stack frame，完成 print 后，程序正常退出。</p><ol start="2"><li>指针作为参数情况下的栈内存分配<br>还是同样的过程，看如下这段代码。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">n := <span class="number">4</span>  </span><br><span class="line">increase(&amp;n)  </span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increase</span><span class="params">(i *<span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">*i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;main 作为程序入口，声明了一个变量 n，赋值为4。声明了一个函数   increase，使用一个 int 类型的指针 i 作为参数，increase 函数内，对指针 i 对应的值进行自增操作。最后 main 函数中打印了 n 的值。程序输出为5。</p><p><img lazyload src="/images/loading.svg" data-src="code5.jpg" alt="avatar"><br>&emsp;&emsp;当程序运行到 main 函数的第6行时，go 在栈上分配了一个 stack frame ，对变量 n 进行了赋值，n 在内存中对应的地址为0xc0008771，此时程序将继续向下执行，调用 increase 函数。</p><p><img lazyload src="/images/loading.svg" data-src="code6.jpg" alt="avatar"><br>&emsp;&emsp;这时，increase 函数对应的 stack fream 被创建，i 被赋值为变量 n对应的地址值0xc0008771，然后进行自增操作。</p><p><img lazyload src="/images/loading.svg" data-src="code7.jpg" alt="avatar"><br>&emsp;&emsp;当 increase 函数运行结束后，SP 寄存器会上移，将之前分配的 stack freme 标记为不合法。此时，程序运行正常，并没有因为 SP 寄存器的改动而影响程序的正确性，内存中的值也被正确的修改了。</p><ol start="3"><li>指针作为返回值情况下的栈内存分配<br>&emsp;&emsp;之前的部分分别介绍了普通变量作为参数和将指针作为参数情况下的栈内存使用，本部分来介绍将指针作为返回值，返回给调用方的情况下，内存是如何分配的，并引出内存逃逸相关内容。来看这段代码：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">n := initValue()  </span><br><span class="line">fmt.Println(*n/<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initValue</span><span class="params">()</span> *<span class="title">int</span></span> &#123;  </span><br><span class="line">i := <span class="number">4</span>  </span><br><span class="line"><span class="keyword">return</span> &amp;i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&emsp;&emsp;main 函数中，调用了 initValue 函数，该函数返回一个 int 指针并赋值给 n，指针对应的值为4。随后，main 函数调用 fmt.Println 打印了指针 n / 2对应的值。程序输出为2。</li></ol><p><img lazyload src="/images/loading.svg" data-src="code8.jpg" alt="avatar"><br>&emsp;&emsp;程序调用 initValue 后，将 i 的地址赋值给变量 n 。注意，如果这时，变量 i 的位置在栈上，则可能会随时被覆盖掉。</p><p><img lazyload src="/images/loading.svg" data-src="code9.jpg" alt="avatar"><br>在调用 fmt.Println 时，Stack Frame 会被重新创建，变量 i 被赋值为*n/2也就是2，会覆盖掉原来 n 所指向的变量值。这会导致及其严重的问题。在面对 sharing up 场景时，go 通常会将变量分配到堆中，如下图所示：</p><p><img lazyload src="/images/loading.svg" data-src="code10.jpg" alt="avatar"><br>&emsp;&emsp;通过上面的分析，可以看到在面对被调用的函数返回一个指针类型时将对象分配到栈上会带来严重的问题，因此 Go 将变量分配到了堆上。这种分配方式保证了程序的安全性，但也不可避免的增加了堆内存创建，并需要在将来的某个时候，需要 GC 将不再使用的内存清理掉。</p><blockquote><p>栈上内存分配原则</p><ul><li>在调用方创建的变量或对象，通过参数的形式传递给被调用函数，这时，在调用方创建的内存空间通常在栈上。这种在调用方创建内存，在被调用方使用该内存的“内存共享”方式，称之为 Sharing down</li><li>在被调用函数内创建的对象，以指针的形式返回给调用方的情况下，通常，创建的内存空间在堆上。这种在被调用方创建，在调用方使用的“内存共享”方式，称之为 Sharing up。</li><li>总结：1. 因为栈比堆更高效，不需要 GC，因此 Go 会尽可能的将内存分配到栈上。<ol start="2"><li>当分配到栈上可能引起非法内存访问等问题后，会使用堆，主要场景有：<br>（1）当一个值可能在函数被调用后访问，这个值极有可能被分配到堆上<br>（2）当编译器检测到某个值过大，这个值会被分配到堆上<br>（3）<strong>当编译时，编译器不知道这个值的大小（slice、map…）这个值会被分配到堆上</strong></li></ol></li></ul></blockquote><h3 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h3><p><img lazyload src="/images/loading.svg" data-src="heapmacllo.png" alt="avatar"><br>&emsp;&emsp;当我们说内存管理的时候，主要是指堆内存的管理，因为栈的内存管理不需要程序去操心。这小节看下堆内存管理干的是啥，如上图所示主要是3部分：<strong>分配内存块，回收内存块和组织内存块</strong>。<br>&emsp;&emsp;在一个最简单的内存管理中，堆内存最初会是一个完整的大块，即未分配内存，当来申请的时候，就会从未分配内存，分割出一个小内存块(block)，然后用链表把所有内存块连接起来。需要一些信息描述每个内存块的基本信息，比如大小(size)、是否使用中(used)和下一个内存块的地址(next)，内存块实际数据存储在data中。<br><img lazyload src="/images/loading.svg" data-src="usemem.png" alt="avatar"><br>&emsp;&emsp;一个内存块包含了3类信息，如下图所示，元数据、用户数据和对齐字段，内存对齐是为了提高访问效率。下图申请5Byte内存的时候，就需要进行内存对齐。</p><p><img lazyload src="/images/loading.svg" data-src="malloc.png" alt="avatar"><br>&emsp;&emsp;释放内存实质是把使用的内存块从链表中取出来，然后标记为未使用，当分配内存块的时候，可以从未使用内存块中有先查找大小相近的内存块，如果找不到，再从未分配的内存中分配内存。上面这个简单的设计中还没考虑内存碎片的问题，因为随着内存不断的申请和释放，内存上会存在大量的碎片，降低内存的使用率。为了解决内存碎片，可以将2个连续的未使用的内存块合并，减少碎片。</p><h4 id="TCMalloc"><a href="#TCMalloc" class="headerlink" title="TCMalloc"></a>TCMalloc</h4><p>&emsp;&emsp;TCMalloc 是 Thread Cache Malloc 的简称，是 Go 内存管理的起源。引入虚拟内存后，让内存的并发访问问题的粒度从多进程级别，降低到多线程级别。同一进程的所有线程共享相同的内存空间，他们申请内存时需要加锁，如果不加锁就存在同一块内存被2个线程同时访问的问题。TCMalloc的做法是什么呢？<strong>为每个线程预分配一块缓存，线程申请小内存时，可以从缓存分配内存</strong>，这样有2个好处：</p><ol><li>为线程预分配缓存需要进行1次系统调用，后续线程申请小内存时，从缓存分配，都是在用户态执行，没有系统调用，<strong>缩短了内存总体的分配和释放时间，这是快速分配内存的第二个层次</strong>。</li><li>多个线程同时申请小内存时，从各自的缓存分配，访问的是不同的地址空间，无需加锁，<strong>把内存并发访问的粒度进一步降低了，这是快速分配内存的第三个层次</strong>。</li></ol><h2 id="Go-GC（垃圾回收）"><a href="#Go-GC（垃圾回收）" class="headerlink" title="Go GC（垃圾回收）"></a>Go GC（垃圾回收）</h2><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>&emsp;&emsp;程序在创建引用类型实体时会在虚拟内存中分配给他们一块空间（堆），如果该内存空间不再被任何引用变量引用就称为需要被回收的垃圾。操作系统会记录一个进程运行时的所占用的内存、CPU和寄存器等资源，当进程结束后便由操作系统能够自动回收资源。但是对于一个运行较长时间的程序，如果使用完内存资源后没有及时释放就会造成内存泄漏甚至系统错误。<br>&emsp;&emsp;以不支持自动垃圾回收的 C++ 为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">128</span>];</span><br><span class="line">  <span class="comment">// 对指针的使用</span></span><br><span class="line">  <span class="keyword">delete</span>[] p; <span class="comment">// delete语句释放对象数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果由于一场或者其他原因导致 delete 语句没有正常执行，且该函数被频繁调用，那么很容易占用所有的内存从而导致程序崩溃，如果泄漏的时系统资源还会导致系统崩溃。另一方面如果我们在不该释放内存的时候释放内存，那么仍然在使用这块内存的指针就会变成野指针 <code>wild pointer</code>，使用该指针对内存进行读写是未定义的行为。</p><ol><li><p>垃圾回收过程<br>&emsp;&emsp;用户程序<code>Mutator</code>通过内存分配器<code>Allocator</code>在堆<code>Heap</code>上申请内存，垃圾回收器<code>Collector</code>会定时清理堆上的内存。<br><img lazyload src="/images/loading.svg" data-src="collector.jpg" alt="avatar"></p></li><li><p>自动垃圾回收与手动垃圾回收<br>&emsp;&emsp;<code>C</code>语言这种较为传统的语言通过<code>malloc</code>和<code>free</code>手动向操作系统申请和释放内存，这种自由管理内存的方式给予程序员极大的自由度，但是也相应地提高了对程序员的要求。<code>C</code>语言的内存分配和回收方式主要包括三种：</p></li></ol><ul><li>函数体内的局部变量：在栈上创建，函数作用域结束后自动释放内存</li><li>静态变量：在静态存储区域上分配内存，整个程序运行结束后释放（全局生命周期）</li><li>动态分配内存的变量：在堆上分配，通过<code>malloc</code>申请，<code>free</code>释放</li></ul><p>&emsp;&emsp;<code>C</code>、<code>C++</code>等较早的语言采用的是手动垃圾回收，需要程序员通过向操作系统申请和释放内存来手动管理内存，程序员极容易忘记释放自己申请的内存，对于一个长期运行的程序往往是一个致命的缺点。<code>Python</code>、<code>Java</code>和<code>Golang</code>等较新的语言采取的都是自动垃圾回收方式，程序员只需要负责申请内存，垃圾回收器会周期性释放结束生命周期的变量所占用的内存空间。</p><ol start="3"><li>垃圾回收目标<br>垃圾回收器主要包括三个目标：</li></ol><ul><li><strong>无内存泄漏</strong>：垃圾回收器最基本的目标就是减少防止程序员未及时释放导致的内存泄漏，垃圾回收器会识别并清理内存中的垃圾</li><li>自动<strong>回收无用内存</strong>：垃圾回收器作为独立的子任务，不需要程序员显式调用即可自动清理内存垃圾</li><li>内存整理：如果只是简单回收无用内存，那么堆上的内存空间会存在较多<strong>内存碎片</strong>而无法满足分配较大对象的需求，因此垃圾回收器需要重整内存空间，提高内存利用率</li></ul><h3 id="常见的垃圾回收方法"><a href="#常见的垃圾回收方法" class="headerlink" title="常见的垃圾回收方法"></a>常见的垃圾回收方法</h3><p>&emsp;&emsp;根据判断对象是否存活的方法，可以简单将<code>GC</code>算法分为“<strong>引用计数式</strong>”垃圾回收和“<strong>追踪回收式</strong>”垃圾回收。前者根据每个对象的引用计数器是否为<code>0</code>来判断该对象是否为未引用的垃圾对象，后者先判断哪些对象存活，然后将其余的所有对象作为垃圾进行回收。追踪回收本身包括标记-清除<code>Mark-Sweep</code>、标记-复制<code>Mark-Copy</code>和标记-整理<code>Mark-Compact</code>三种回收算法。</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>&emsp;&emsp;引用计数<code>Reference counting</code>会为每个对象维护一个计数器，当该对象被其他对象引用时加一，引用失效时减一，当引用次数归零后即可回收对象。使用这类<code>GC</code>方法的语言包括<code>python</code>、<code>php</code>、<code>objective-C</code>和<code>C++</code>标准库中的<code>std::shared_ptr</code>等。<br>优点：</p><ul><li>原理和实现都比较简单</li><li>回收的即时性：当对象的引用计数为<code>0</code>时立即回收，不像其他<code>GC</code>机制需要等待特定时机再回收，提高了内存的利用率</li><li>不需要暂停应用即可完成回收</li></ul><p>缺点：</p><ul><li>无法解决循环引用的回收问题：当<code>ObjA</code>引用了<code>ObjB</code>，<code>ObjB</code>也引用<code>ObjA</code>时，这两个对象的引用次数使用大于<code>0</code>，从而占用的内存无法被回收</li><li>时间和空间成本较高：一方面是因为每个对象需要额外的空间存储引用计数器变量，另一方面是在栈上的赋值时修改引用次数时间成本较高（原本只需要修改寄存器中的值，现在计数器需要不断更新因此不是只读的，需要额外的原子操作来保证线程安全）</li><li>引用计数是一种摊销算法，会将内存的回收分摊到整个程序的运行过程，但是当销毁一个很大的树形结构时无法保证响应时间</li></ul><h4 id="追踪回收式"><a href="#追踪回收式" class="headerlink" title="追踪回收式"></a>追踪回收式</h4><p>追踪基础：可达性分析算法<br>&emsp;&emsp;尽管前面提到的三种追踪式垃圾回收算法实现起来各不相同，但是第一步都是通过可达性分析算法标记<code>Mark</code>对象是否“可达”。一般可到达的对象主要包括两类：</p><ul><li><code>GC Root</code>对象：包括全局对象、栈上的对象（函数参数与内部变量）</li><li>与<code>GC Root</code>对象通过引用链<code>Reference Chain</code>相连的对象</li></ul><p>对于“不可达”的对象，我们可以认为该对象为垃圾对象并回收对应的内存空间。<br><img lazyload src="/images/loading.svg" data-src="reachable.jpg" alt="avatar"></p><p>同引用计数法相比，追踪式算法具有如下优点：</p><ul><li>解决了循环引用对象的回收问题</li><li>占用空间更少</li></ul><p>缺点包括：</p><ul><li>同引用计数相比无法立刻识别出垃圾对象，需要依赖<code>GC</code>线程(下文的算法)</li><li>算法在标记时必须暂停整个程序，即<code>Stop The World, STW</code>，否则其他线程的代码会修改对象状态从而回收不该回收的对象</li></ul><ol><li>标记-清除算法<br>标记-清除<code>Mark-Sweep</code>算法是最基础的追踪式算法，分为“标记”和“清除”两个步骤：</li></ol><ul><li>标记：记录需要回收的垃圾对象</li><li>清除：在标记完成后回收垃圾对象的内存空间</li></ul><p><img lazyload src="/images/loading.svg" data-src="mark-sweep.jpg" alt="avatar"><br>优点包括：</p><ul><li>算法吞吐量较高，即运行用户代码时间 / （运行用户代码时间 + 运行垃圾收集时间）较高</li><li>空间利用率高：同标记-复制相比不需要额外空间复制对象，也不需要像引用计数算法为每个对象设置引用计数器</li></ul><p>缺点：</p><ul><li>清除后会<strong>产生大量的内存碎片</strong>空间，导致程序在运行时可能没法为较大的对象分配内存空间，导致提前进行下一次垃圾回收</li></ul><ol start="2"><li>标记-复制算法<br>标记-复制<code>Mark-Copy</code>算法将内存分成大小相同的两块，当某一块的内存使用完了之后就将使用中的对象挨个复制到另一块内存中，最后将当前内存恢复未使用的状态。<br><img lazyload src="/images/loading.svg" data-src="mark-copy.jpg" alt="avatar"></li></ol><p>优点：</p><ul><li>标记-清除法需要在清除阶段对大量垃圾对象进行扫描，标记-复制则只需要从<code>GC Root</code>对象出发，将“可到达”的对象复制到另一块内存后直接清理当前这块的内存，因此提升了垃圾回收的效率</li><li>解决了内存碎片化的问题，防止分配较大连续空间时的提前<code>GC</code>问题</li></ul><p>缺点：</p><ul><li>同标记-清除法相比，在“可达”对象占比较高的情况下有复制对象的开销</li><li>内存利用率较低，相当于可利用的内存仅有一半</li></ul><ol start="3"><li>标记-整理算法<br>&emsp;&emsp;标记-整理<code>Mark-Compact</code>算法综合了标记-清除法和标记-复制法的优势，既不会产生内存碎片化的问题，也不会有一半内存空间浪费的问题。该方法首先标记出所有“可达”的对象，然后将存活的对象移动到内存空间的一端，最后清理掉端边界以外的内存。<br><img lazyload src="/images/loading.svg" data-src="mark-compact.jpg" alt="avatar"><br>优点包括：</li></ol><ul><li>避免了内存碎片化的问题</li><li>在对象存活率较高的情况下，标记-整理算法由于不需要复制对象效率更高，因此更加适合老年代算法</li></ul><p>缺点包括：</p><ul><li>整理过程较为复杂，需要多次遍历内存导致<code>STW</code>时间比标记-清除算法更长</li></ul><h3 id="Golang-的-GC-算法"><a href="#Golang-的-GC-算法" class="headerlink" title="Golang 的 GC 算法"></a>Golang 的 GC 算法</h3><h4 id="三色标记法（go-1-3）"><a href="#三色标记法（go-1-3）" class="headerlink" title="三色标记法（go 1.3）"></a>三色标记法（go 1.3）</h4><p>&emsp;&emsp;前面提到的“标记”类算法都有一个共同的瑕疵，即在进行垃圾回收的时候会暂停整个程序（<code>STW</code>问题）。三色标记法是对“标记”阶段的改进，在不暂停程序的情况下即可完成对象的可达性分析。<code>GC</code>线程将所有对象分为三类：</p><ul><li>白色：未搜索的对象，在回收周期开始时所有对象都是白色，在回收周期结束时所有的白色都是垃圾对象</li><li>灰色：正在搜索的对象，但是对象身上还有一个或多个引用没有扫描</li><li>黑色：已搜索完的对象，所有的引用已经被扫描完</li></ul><p>&emsp;&emsp;三色标记法属于增量式<code>GC</code>算法，回收器首先将所有的对象着色成白色，然后从<code>GC Root</code>出发，逐步把所有“可达”的对象变成灰色再到黑色，最终所有的白色对象即是“不可达”对象。</p><blockquote><p><code>GC Root</code> 对象包括：</p><ol><li>全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。</li><li>执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。</li><li> 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。</li></ol></blockquote><p>具体的实现如下：</p><ol><li>初始时所有对象都是白色对象</li><li>从<code>GC Root</code>对象出发，扫描所有可达对象并标记为灰色，放入待处理队列</li><li>从队列取出一个灰色对象并标记为黑色，将其引用对象标记为灰色放入队列</li><li>重复上一步骤，直到灰色对象队列为空</li><li>此时所有剩下的白色对象就是垃圾对象</li></ol><p><img lazyload src="/images/loading.svg" data-src="three_color.gif" alt="gif"></p><p>优点：不需要暂停整个程序进行垃圾回收<br>缺点：</p><ul><li>如果程序垃圾对象的产生速度大于垃圾对象的回收速度时，可能导致程序中的垃圾对象越来越多而无法及时收集</li><li>线程切换和上下文转换的消耗会使得垃圾回收的总体成本上升，从而降低系统吞吐量</li></ul><h4 id="屏障机制"><a href="#屏障机制" class="headerlink" title="屏障机制"></a>屏障机制</h4><ol><li><p>STW<br>&emsp;&emsp;STW 可以是Stop The World的缩写，也可以是Start The World的缩写。通常意义上指的是从Stop The World到Start The World这一段时间间隔。垃圾回收过程中为了保证准确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图以完成垃圾回收。STW时间越长，对用户代码造成的影响越大。</p></li><li><p>No STW 存在的问题<br>&emsp;&emsp;假设下面的场景，已经被标记为灰色的对象2，未被标记的对象3被对象2用指针p引用；此时已经被标记为黑色的对象4创建指针q 指向未被标记的对象3，同时对象2将指针p移除；对象4已经被标记为黑色，对象3未被引用，对象2删除与对象3的引用，导致最后对象3被误清除；<br><img lazyload src="/images/loading.svg" data-src="stw.png" alt="avatar"></p></li></ol><ul><li>垃圾回收的原则是不应出现对象的丢失，也不应错误的回收还不需要回收的对象。如果同时满足下面两个条件会破坏回收器的正确性：<ul><li>条件 1: 赋值器修改对象图，导致某一黑色对象引用白色对象；（通俗的说就是A突然持有了B的指针，而B在并发标记的过程中已经被判定为白色对象要被清理掉的）</li><li>条件 2: 从灰色对象出发，到达白色对象且未经访问过的路径被赋值器破坏；（通俗的说就是A持有B的指针，这个持有关系被释放）</li></ul></li></ul><blockquote><p>只要能够避免其中任何一个条件，则不会出现对象丢失的情况，因为：</p><ul><li>  如果条件 1被避免，则所有白色对象均被灰色对象引用，没有白色对象会被遗漏；<strong>强三色不变性</strong></li><li>  如果条件 2 被避免，即便白色对象的指针被写入到黑色对象中，但从灰色对象出发，总存在一条没有访问过的路径，从而找到到达白色对象的路径，白色对象最终不会被遗漏。<strong>弱三色不变性</strong></li></ul></blockquote><p><strong>可能的解决方法：</strong> 整个过程STW，浪费资源，且对用户程序影响较大，由此引入了<strong>屏障机制</strong>；</p><ol start="3"><li>屏障机制<br>&emsp;&emsp;把回收器视为对象，把赋值器视为影响回收器这一对象的实际行为（即影响 GC 周期的长短），从而引入赋值器的颜色：</li></ol><ul><li>黑色赋值器：已经由回收器扫描过，不会再次对其进行扫描。</li><li>灰色赋值器：尚未被回收器扫描过或尽管已经扫描过，但仍需要重新扫描。</li></ul><h5 id="Dijkstra插入写屏障（go-1-5）"><a href="#Dijkstra插入写屏障（go-1-5）" class="headerlink" title="Dijkstra插入写屏障（go 1.5）"></a>Dijkstra插入写屏障（go 1.5）</h5><p>&emsp;&emsp;<code>Dijkstra</code>插入写屏障避免了前面提到的条件1，即防止黑色对象指向白色对象。一个对象可以存储在内存中的“栈”或者“堆”，<strong>由于“栈”空间容量小且要求相应速度较高，因此“插入写屏障”不适合用于“栈”空间</strong>。在“插入写屏障”保护下的三色标记法执行例子如下：<br><img lazyload src="/images/loading.svg" data-src="step1.jpeg" alt="avatar"><br><img lazyload src="/images/loading.svg" data-src="step2.jpeg" alt="avatar"><br><img lazyload src="/images/loading.svg" data-src="step3.jpeg" alt="avatar"></p><p>&emsp;&emsp;尽管<code>Dijkstra</code>插入写屏障可以<strong>实现垃圾回收和用户程序的并发执行</strong>，但是它存在两个缺点。一方面它是一种比较保守的垃圾回收方法，<strong>把有可能存活的对象都标记成灰色了以满足“强三色不变性”</strong>。以下图为例，用户程序<code>Mutator</code>将对象A原本指向B对象的指针改成指向C对象，尽管在修改后B对象已经是一个垃圾对象，但是它在本轮垃圾回收过程中不会被回收。<br><img lazyload src="/images/loading.svg" data-src="dj.jpeg" alt="avatra"></p><h5 id="Yuasa删除屏障"><a href="#Yuasa删除屏障" class="headerlink" title="Yuasa删除屏障"></a>Yuasa删除屏障</h5><p>&emsp;&emsp;<code>Yuasa</code>删除写屏障避免了前面提到的条件2，防止丢失灰色对象到白色对象的可达路径。<strong>满足了弱三色不变性</strong><br><img lazyload src="/images/loading.svg" data-src="yuasa.jpeg" alt="avatar"></p><p>下图简单绘制了<code>Yuasa</code>删除写屏障是如何保证用户程序<code>Mutator</code>和垃圾回收器<code>Collector</code>的并发执行的：</p><ul><li>  第二步中<code>Mutator</code>将对象<code>A</code>原本指向对象<code>B</code>的指针指向<code>C</code>，由于对象<code>B</code>本身就是灰色的，因此不需要对它重新着色</li><li>  第三步中<code>Mutator</code>删除了对象<code>B</code>指向对象<code>C</code>的指针，删除写屏障将下游对象<code>C</code>标记为灰色<br><img lazyload src="/images/loading.svg" data-src="yuasa1.jpeg" alt="avatar"><br>&emsp;&emsp;<code>Yuasa</code>删除写屏障和<code>Dijkstra</code>插入写屏障相比优点在于不需要在一轮三色标记后对栈空间上的对象进行重新扫描，缺点在于<code>Collector</code>会悲观地认为所有被删除的对象都可能被黑色对象引用，比如上图中第三步<code>Mutator</code>删除了对象<code>B</code>指向对象<code>C</code>的指针，如果此时还有一个单独的对象<code>E</code>指向<code>C</code>，那么本该被删除的对象<code>E</code>却可以在本轮垃圾回收中存活。</li></ul><h5 id="混合写屏障（go-1-8）"><a href="#混合写屏障（go-1-8）" class="headerlink" title="混合写屏障（go 1.8）"></a>混合写屏障（go 1.8）</h5><blockquote><p><strong>混合写屏障也是仅在堆空间启动的，防止降低栈空间的运行效率</strong></p></blockquote><p>回顾一下之前提到的两种写屏障的劣势：</p><ul><li><code>Dijkstra</code>插入写屏障：一轮标记结束后需要<code>STW</code>重新扫描栈上对象</li><li><code>Yuasa</code>删除写屏障：回收精度低，在垃圾回收开始前使用<code>STW</code>扫描所有<code>GC Root</code>对象形成初始快照，用户程序<code>Mutator</code>从灰色/白色对象中删除白色指针时会将下游对象标记为灰色，相当于保护了所有初始快照中的白色对象不被删除</li></ul><h6 id="具体场景的实现"><a href="#具体场景的实现" class="headerlink" title="具体场景的实现"></a><strong>具体场景的实现</strong></h6><p><code>GC</code>开始阶段会将所有栈空间可达对象都标记为黑色：<br><img lazyload src="/images/loading.svg" data-src="s11.jpeg" alt="avatar"></p><p>场景一：某个对象从堆对象的下游变成栈对象的下游，这种情况下标记该对象为灰色，该对象就不会被错误地回收<br><img lazyload src="/images/loading.svg" data-src="s12.jpeg" alt="avatar"></p><p>场景二：某个对象从一个栈对象的下游变成另一个对象的下游，由于对象全都在栈空间对象的可达对象中，因此混合写屏障不会对这些对象着色。<br><img lazyload src="/images/loading.svg" data-src="s13.jpeg" alt="avatar"></p><p>场景三：某个对象从一个堆对象的下游变成另一个堆对象的下游，比如下图中对象G从F的下游移动到Y的下游，为了避免对象<code>G</code>被错误回收，我们需要将其标记为灰色<br><img lazyload src="/images/loading.svg" data-src="s14.jpeg" alt="avatar"></p><p>场景四：某个对象从栈对象的下游变成堆对象的下游，对于栈空间对象不触发写屏障，但是对于被删除的堆空间对象<code>G</code>需要标记成灰色以保护它和它的下游对象不被错误删除<br><img lazyload src="/images/loading.svg" data-src="s15.jpeg" alt="avatar"></p><ul><li>混合写屏障继承了插入写屏障的优点，起始无需 STW 打快照，直接并发扫描垃圾即可；</li><li>混合写屏障继承了删除写屏障的优点，赋值器是黑色赋值器，GC 期间，任何在栈上创建的新对象，均为黑色。扫描过一次就不需要扫描了，这样就消除了插入写屏障时期最后 STW 的重新扫描栈；</li><li>混合写屏障扫描精度继承了删除写屏障，比插入写屏障更低，随着带来的 是 GC 过程全程无 STW；</li><li>混合写屏障扫描栈虽然没有 STW，但是扫描某一个具体的栈的时候，还是 要停止这个 goroutine 赋值器的工作的</li></ul><h4 id="GC-触发时机"><a href="#GC-触发时机" class="headerlink" title="GC 触发时机"></a>GC 触发时机</h4><p>主动触发：调用 runtime.GC<br>被动触发： 使用系统监控，该触发条件由 runtime.forcegcperiod 变量控制，默认为 2 分钟。当超过两分钟没有产生任何 GC 时，强制触发 GC。 使用步调（Pacing）算法，其核心思想是控制内存增长的比例。如 Go 的 GC 是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC 存活堆大小成比例. 由 GOGC 控制, 默认 100, 即 2 倍的关系, 200 就是 3 倍, 当 Go 新创建的对象所占用的内存大小，除以上次 GC 结束后保留下来的对象占用内存大小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang-Map-的底层实现&quot;&gt;&lt;a href=&quot;#Golang-Map-的底层实现&quot; class=&quot;headerlink&quot; title=&quot;Golang Map 的底层实现&quot;&gt;&lt;/a&gt;Golang Map 的底层实现&lt;/h1&gt;&lt;h2 id=&quot;一般的-map-的</summary>
      
    
    
    
    <category term="go语言" scheme="http://jiahaohong1997.github.io/categories/go%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="golang" scheme="http://jiahaohong1997.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记（三）</title>
    <link href="http://jiahaohong1997.github.io/2022/01/18/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/01/18/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-01-18T07:35:00.000Z</published>
    <updated>2022-02-14T09:19:03.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String-类型的底层数据结构"><a href="#String-类型的底层数据结构" class="headerlink" title="String 类型的底层数据结构"></a>String 类型的底层数据结构</h1><h2 id="为什么-String-类型内存开销大"><a href="#为什么-String-类型内存开销大" class="headerlink" title="为什么 String 类型内存开销大"></a>为什么 String 类型内存开销大</h2><p>&emsp;&emsp;除了记录实际数据，string 类型还需要额外的内存空间记录数据长度、空间使用等信息，这些信息也叫作元数据。当实际保存的数据较小时，元数据的空间开销就显得比较大了。<br>&emsp;&emsp;string 类型是如何保存数据的呢？</p><ol><li>当保存 64 位有符号整数时，string 类型会把它保存为一个 8 字节的 Long 类型整数，这种保存方式通常也叫作 int 编码方式。</li><li>当保存的数据中包含字符时，String 类型就会用简单动态字符串（Simple Dynamic String，SDS）结构体来保存，如下图所示：</li></ol><p><img lazyload src="/images/loading.svg" data-src="redis43.jpg" alt="avatar"><br><strong>这里其实类似 Go 的 slice 类型的底层数据结构</strong><br>buf：字节数组，保存实际数据。为了表示字节数组的结束，Redis 会自动在数组最后加一个“\0”，这就会额外占用 1 个字节的开销。<br>len：占 4 个字节，表示 buf 的已用长度。<br>alloc：也占个 4 字节，表示 buf 的实际分配长度，一般大于 len。</p><p>&emsp;&emsp;可以看到，在 SDS 中，buf 保存实际数据，而 len 和 alloc 本身其实是 SDS 结构体的额外开销。另外，对于 String 类型来说，除了 SDS 的额外开销，还有一个来自于 RedisObject 结构体的开销。因为 Redis 的数据类型有很多，而且，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等），所以，Redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据。<br>&emsp;&emsp;一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在，例如指向 String 类型的 SDS 结构所在的内存地址，可以看一下下面的示意图。<br><img lazyload src="/images/loading.svg" data-src="redis44.jpg" alt="avatar"><br>&emsp;&emsp;为了节省内存空间，Redis 还对 Long 类型整数和 SDS 的内存布局做了专门的设计。</p><ul><li>一方面，当保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。</li><li>另一方面，当保存的是字符串数据，并且字符串小于等于 44 字节时，RedisObject 中的元 数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。这种布局方式也被 称为 embstr 编码方式。</li><li>当字符串大于 44 字节时，SDS 的数据量就开始变多了，Redis 就不再把 SDS 和RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。这种布局方式被称为 raw 编码模式。</li></ul><p>如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis45.jpg" alt="avatar"></p><p>举例说明一下：我们用 10 位数来表示图片 ID 和图片存储对象 ID，例如，图片 ID 为 1101000051，它在存储系统中对应的 ID 号是 3301000051。可以看到，图片 ID 和图片存储对象 ID 正好一一对应，是典型的“键 - 单值”模式。因为 10 位数的图片 ID 和图片存储对象 ID 是 Long 类型整数，所以可以直接用 int 编码的 RedisObject 保存。每个 int 编码的 RedisObject 元数据部分占 8 字节，指针部分被直接赋值为 8 字节的整数了。此时，每个 ID 会使用 16 字节，加起来一共是 32 字节。同时，Redis 会使用一个全局哈希表保存所有键值对，哈希表的每一项是一个 dictEntry 的结构体，用来指向一个键值对。dictEntry 结构中有三个 8 字节的指针， 分别指向 key、value 以及下一个 dictEntry，三个指针共 24 字节，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis46.jpg" alt="avatar"><br>&emsp;&emsp;此时，这三个指针占据了 24 字节，但是实际上会占用 32 字节，这就要提到 Redis 使用的内存分配库 jemalloc 了。jemalloc 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。如果你申请 24 字节空间，jemalloc 则会分配 32 字节。所以存储这样一个 “键 - 值”对要使用 64 个字节。<br>&emsp;&emsp;明明有效信息只有 16 字节，使用 String 类型保存时，却需要 64 字节的内存空间，有 48 字节都没有用于保存实际的数据。</p><h2 id="用什么数据结构可以节省内存？"><a href="#用什么数据结构可以节省内存？" class="headerlink" title="用什么数据结构可以节省内存？"></a>用什么数据结构可以节省内存？</h2><p>&emsp;&emsp;Redis 有一种底层数据结构，叫压缩列表（ziplist），这是一种非常节省内存的结构。我们先回顾下压缩列表的构成。表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量，以及列表中的 entry 个数。压缩列表尾还有一个 zlend，表示列表结束。<br><img lazyload src="/images/loading.svg" data-src="redis47.jpg" alt="avatar"><br>&emsp;&emsp;压缩列表之所以能够节省内存，是因为它是用一系列连续的 entry 保存数据。每个 entry 的元数据包括下面几部分。</p><ul><li>prev_len：表示前一个 entry 的长度。prev_len 有两种取值情况：1 字节或 5 字节。取值 1 字节时，表示上一个 entry 的长度小于 254 字节。虽然 1 字节的值能表示的数值范围是 0 到 255，但是压缩列表中 zlend 的取值默认是 255，因此，就默认用 255 表示整个压缩列表的结束，其他表示长度的地方就不能再用 255 这个值了。所以，当上一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节，否则，就取值为 5 字节；</li><li>len：表示自身长度，4 字节；</li><li>encoding：表示编码方式，1 字节；</li><li>content：保存实际数据。</li></ul><p>&emsp;&emsp;这些 entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。我们以保存图片存储对象 ID 为例，来分析一下压缩列表是如何节省内存空间的。每个 entry 保存一个图片存储对象 ID（8 字节），此时，每个 entry 的 prev_len 只需要 1 个字节就行，因为每个 entry 的前一个 entry 长度都只有 8 字节，小于 254 字节。这样一来，一个图片的存储对象 ID 所占用的内存大小是 14 字节（1+4+1+8=14），实际分配 16 字节。</p><p>&emsp;&emsp;我们以一个全局的视角去看使用 string 类型的存储形式，每张图片 ID 都会占用一个哈希桶位，这就增加了哈希冲突的概率。并且，元数据和指针会占用大量的空间。<br><img lazyload src="/images/loading.svg" data-src="redis48.png" alt="avatar"></p><p>&emsp;&emsp;若使用 Hash 类型来存储，可以采取二级编码方法。这里说的二级编码， 就是把一个单值的数据拆分成两部分，前一部分作为 Hash 集合的 key，后一部分作为 Hash 集合的 value，这样一来，我们就可以把单值数据保存到 Hash 集合中了。<br>&emsp;&emsp;以图片 ID 1101000060 和图片存储对象 ID 3302000080 为例，我们可以把图片 ID 的前 7 位（1101000）作为 Hash 类型的键，把图片 ID 的最后 3 位（060）和图片存储对象 ID 分别作为 Hash 类型值中的 key 和 value。<br>&emsp;&emsp;按照这种设计方法，在存储了大量的图片和对象的数据后，在 Redis 中插入了一组图片 ID 及其存储对象 ID 的记录，并且用 info 命令查看了内存开销，发现，增加一条记录后，内存占用只增加了 16 字节，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info memory </span><br><span class="line"><span class="comment"># Memory </span></span><br><span class="line">used_memory:1039120</span><br><span class="line">127.0.0.1:6379&gt; hset 1101000 060 3302000080 </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; info memory </span><br><span class="line"><span class="comment"># Memory </span></span><br><span class="line">used_memory:1039136</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是因为图片 ID 的前 7 位（1101000）作为 key 在之前已经存储过了，采用 以 压缩列表为底层数据结构的 hash 类型，就可以根据 key 的后三位 （060）存储在压缩列表中，增加的内存仅仅是压缩列表中一个 entry 的大小。而以 string 类型来存储“键 - 值”对，都要新分配一个哈希桶，开辟一个哈希桶下的新 entry 节点来存储。<br><img lazyload src="/images/loading.svg" data-src="redis49.png" alt="avatar"></p><p>&emsp;&emsp;最后，你可能也会有疑惑：“二级编码一定要把图片 ID 的前 7 位作为 Hash 类型的键，把最后 3 位作为 Hash 类型值中的 key 吗？”其实，二级编码方法中采用的 ID 长度是有讲究的。Redis Hash 类型的两种底层实现结构，分别是压缩列表和哈希表。Hash 类型设置了用压缩列表保存数据时的两个阈值，一旦超过了阈值，Hash 类型就会用哈希表来保存数据了。这两个阈值分别对应以下两个配置项：</p><ol><li>hash-max-ziplist-entries：表示用压缩列表保存时哈希集合中的最大元素个数。</li><li>hash-max-ziplist-value：表示用压缩列表保存时哈希集合中单个元素的最大长度。</li></ol><p>&emsp;&emsp;如果我们往 Hash 集合中写入的元素个数超过了 hash-max-ziplist-entries，或者写入的单个元素大小超过了 hash-max-ziplist-value，Redis 就会自动把 Hash 类型的实现结构由压缩列表转为哈希表。一旦从压缩列表转为了哈希表，Hash 类型就会一直用哈希表进行保存，而不会再转回压缩列表了。在节省内存空间方面，哈希表就没有压缩列表那么高效了。<strong>为了能充分使用压缩列表的精简内存布局，我们一般要控制保存在 Hash 集合中的元素个数</strong>。所以，在刚才的二级编码中，我们只用图片 ID 最后 3 位作为 Hash 集合的 key，也就 保证了 Hash 集合的元素个数不超过 1000，同时，我们把 hash-max-ziplist-entries 设置 为 1000，这样一来，Hash 集合就可以一直使用压缩列表来节省内存空间了。</p><h1 id="数据存储的业务场景"><a href="#数据存储的业务场景" class="headerlink" title="数据存储的业务场景"></a>数据存储的业务场景</h1><h2 id="聚合统计（Set）"><a href="#聚合统计（Set）" class="headerlink" title="聚合统计（Set）"></a>聚合统计（Set）</h2><p>&emsp;&emsp;所谓的聚合统计，就是指统计多个集合元素的聚合结果，包括：统计多个集合的共有元素（交集统计）；把两个集合相比，统计其中一个集合独有的元素（差集统计）；统计多个集合的所有元素（并集统计）。</p><h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><p>&emsp;&emsp;统计手机 App 每天的新增用户数和第二天的留存用户数。要完成这个统计任务，我们可以用一个集合记录所有登录过 App 的用户 ID，同时，用另一个集合记录每一天登录过 App 的用户 ID。然后，再对这两个集合做聚合统计。我们来看下具体的操作。</p><ol><li><p>记录所有登录过 App 的用户 ID，我们可以直接使用 Set 类型，把 key 设置为 user:id，表示记录的是用户 ID，value 就是一个 Set 集合，里面是所有登录过 App 的用户 ID，我们可以把这个 Set 叫作累计用户 Set，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis50.jpg" alt="avatar"></p></li><li><p>还需要把每一天登录的用户 ID，记录到一个新集合中，我们把这个集合叫作每 日用户 Set，它有两个特点：</p></li></ol><ul><li>key 是 user:id 以及当天日期，例如 user:id:20200803；</li><li>value 是 Set 集合，记录当天登录的用户 ID。<br><img lazyload src="/images/loading.svg" data-src="redis51.jpg" alt="avatar"></li></ul><h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><p>&emsp;&emsp;假设我们的手机 App 在 2020 年 8 月 3 日上线，那么，8 月 3 日前是没有用户的。此时，累计用户 Set 是空集，当天登录的用户 ID 会被记录到 key 为 user:id:20200803 的 Set 中。所以，user:id:20200803 这个 Set 中的用户就是当天的新增用户。然后，我们计算累计用户 Set 和 user:id:20200803 Set 的并集结果，结果保存在 user:id 这个累计用户 Set 中，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNIONSTORE  user:id  user:id  user:id:20200803</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时，user:id 这个累计用户 Set 中就有了 8 月 3 日的用户 ID。等到 8 月 4 日再统计时，我们把 8 月 4 日登录的用户 ID 记录到 user:id:20200804 的 Set 中。接下来，我们执行 SDIFFSTORE 命令计算累计用户 Set 和 user:id:20200804 Set 的差集，结果保存在 key 为 user:new 的 Set 中，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFFSTORE  user:new  user:id:20200804  user:id</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，这个差集中的用户 ID 在 user:id:20200804 的 Set 中存在，但是不在累计用户 Set 中。所以，user:new 这个 Set 中记录的就是 8 月 4 日的新增用户。</p><p>&emsp;&emsp;当要计算 8 月 4 日的留存用户时，我们只需要再计算 user:id:20200803 和 user:id:20200804 两个 Set 的交集，就可以得到同时在这两个集合中的用户 ID 了，这些就是在 8 月 3 日登录，并且在 8 月 4 日留存的用户。执行的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTERSTORE  user:id:rem  user:id:20200803  user:id:20200804</span><br></pre></td></tr></table></figure><h3 id="潜在风险及解决策略"><a href="#潜在风险及解决策略" class="headerlink" title="潜在风险及解决策略"></a>潜在风险及解决策略</h3><ul><li><p>潜在风险：Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。</p></li><li><p>解决策略：可以从主从集群中选择一个从库，让它专门负责聚合计算，或者是把数据读取到客户端，在客户端来完成聚合统计，这样就可以规避阻塞主库实例和其他从库实例的风险了。</p></li></ul><h2 id="排序统计（List、Sorted-Set）"><a href="#排序统计（List、Sorted-Set）" class="headerlink" title="排序统计（List、Sorted Set）"></a>排序统计（List、Sorted Set）</h2><p>&emsp;&emsp;最新评论列表包含了所有评论中的最新留言，<strong>这就要求集合类型能对元素保序</strong>，也就是说，集合中的元素可以按序排列，这种对元素保序的集合类型叫作有序集合。在 Redis 常用的 4 个集合类型中（List、Hash、Set、Sorted Set），List 和 Sorted Set 就属于有序集合。<br>&emsp;&emsp;List 是按照元素进入 List 的顺序进行排序的，而 Sorted Set 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p><h3 id="业务场景-1"><a href="#业务场景-1" class="headerlink" title="业务场景"></a>业务场景</h3><ol><li>List</li></ol><p>&emsp;&emsp;每个商品对应一个 List，这个 List 包含了对这个商品的所有评论，而且会按照评论时间保存这些评论，每来一个新评论，就用 LPUSH 命令把它插入 List 的队头。在只有一页评论的时候，我们可以很清晰地看到最新的评论，但是，在实际应用中，网站一般会分页显示最新的评论列表，一旦涉及到分页操作，List 就可能会出现问题了。</p><p>&emsp;&emsp;假设当前的评论 List 是{A, B, C, D, E, F}（其中，A 是最新的评论，以此类推，F 是最早的评论），在展示第一页的 3 个评论时，我们可以用下面的命令，得到最新的三条评论 A、B、C：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LRANGE product1 0 2</span><br><span class="line">1) <span class="string">&quot;A&quot;</span></span><br><span class="line">2) <span class="string">&quot;B&quot;</span></span><br><span class="line">3) <span class="string">&quot;C&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后，再用下面的命令获取第二页的 3 个评论，也就是 D、E、F。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LRANGE product1 3 5</span><br><span class="line">1) <span class="string">&quot;D&quot;</span></span><br><span class="line">2) <span class="string">&quot;E&quot;</span></span><br><span class="line">3) <span class="string">&quot;F&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是，如果在展示第二页前，又产生了一个新评论 G，评论 G 就会被 LPUSH 命令插入到评论 List 的队头，评论 List 就变成了{G, A, B, C, D, E, F}。此时，再用刚才的命令获取第二页评论时，就会发现，评论 C 又被展示出来了，也就是 C、D、E。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LRANGE product1 3 5</span><br><span class="line">1) <span class="string">&quot;C&quot;</span></span><br><span class="line">2) <span class="string">&quot;D&quot;</span></span><br><span class="line">3) <span class="string">&quot;E&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;之所以会这样，关键原因就在于，List 是通过元素在 List 中的位置来排序的，当有一个新元素插入时，原先的元素在 List 中的位置都后移了一位，比如说原来在第 1 位的元素现在排在了第 2 位。所以，对比新元素插入前后，List 相同位置上的元素就会发生变化，用 LRANGE 读取时，就会读到旧元素。</p><ol start="2"><li>Sorted Set<br>&emsp;&emsp;和 List 相比，Sorted Set 就不存在这个问题，因为它是根据元素的实际权重来排序和获取数据的。我们可以按评论时间的先后给每条评论设置一个权重值，然后再把评论保存到 Sorted Set 中。Sorted Set 的 ZRANGEBYSCORE 命令就可以按权重排序后返回元素。这样的话，即使集合中的元素频繁更新，Sorted Set 也能通过 ZRANGEBYSCORE 命令准确地获取到按序排列的数据。假设越新的评论权重越大，目前最新评论的权重是 N，我们执行下面的命令时，就可以获得最新的 10 条评论：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE comments N-9 N</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;所以，在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议优先考虑使用 Sorted Set。</p><h2 id="二值状态统计（Bitmap）"><a href="#二值状态统计（Bitmap）" class="headerlink" title="二值状态统计（Bitmap）"></a>二值状态统计（Bitmap）</h2><p>&emsp;&emsp;二值状态就是指集合元素的取 值就只有 0 和 1 两种。在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。</p><h3 id="业务场景-2"><a href="#业务场景-2" class="headerlink" title="业务场景"></a>业务场景</h3><p>&emsp;&emsp;在签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。这个时候，我们就可以选择 Bitmap。这是 Redis 提供的扩展数据类型。</p><h3 id="bitmap-的实现原理"><a href="#bitmap-的实现原理" class="headerlink" title="bitmap 的实现原理"></a>bitmap 的实现原理</h3><p>&emsp;&emsp;Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态。你可以把 Bitmap 看作是一个 bit 数组。<br>&emsp;&emsp;Bitmap 提供了 GETBIT/SETBIT 操作，使用一个偏移值 offset 对 bit 数组的某一个 bit 位进行读和写。不过，需要注意的是，Bitmap 的偏移量是从 0 开始算的，也就是说 offset 的最小值是 0。当使用 SETBIT 对一个 bit 位进行写操作时，这个 bit 位会被设置为 1。Bitmap 还提供了 BITCOUNT 操作，用来统计这个 bit 数组中所有“1”的个数。</p><h3 id="具体例子1"><a href="#具体例子1" class="headerlink" title="具体例子1"></a>具体例子1</h3><p>&emsp;&emsp;假设我们要统计 ID 3000 的用户在 2020 年 8 月份的签到情况，就可以按照下面的步骤进行操作。</p><ol><li><p>第一步，执行下面的命令，记录该用户 8 月 3 号已签到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT uid:sign:3000:202008 2 1</span><br></pre></td></tr></table></figure></li><li><p>第二步，检查该用户 8 月 3 日是否签到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT uid:sign:3000:202008 2</span><br></pre></td></tr></table></figure></li><li><p>第三步，统计该用户在 8 月份的签到次数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT uid:sign:3000:202008</span><br></pre></td></tr></table></figure></li></ol><h3 id="具体例子2"><a href="#具体例子2" class="headerlink" title="具体例子2"></a>具体例子2</h3><p>&emsp;&emsp;：如果记录了 1 亿个用户 10 天的签到情况，你有办法统计出这 10 天连续签到的用户总数吗？<br>&emsp;&emsp;Bitmap 支持用 BITOP 命令对多个 Bitmap 按位做“与”“或”“异或”的操作，操作的结果会保存到一个新的 Bitmap 中。我以按位“与”操作为例来具体解释一下。从下图中，可以看到，三个 Bitmap bm1、bm2 和 bm3，对应 bit 位做“与”操作，结果保存到了一个新的 Bitmap 中（示例中，这个结果 Bitmap 的 key 被设为“resmap”）。<br><img lazyload src="/images/loading.svg" data-src="redis52.jpg" alt="avatar"><br>&emsp;&emsp;在统计 1 亿个用户连续 10 天的签到情况时，你可以把每天的日期作为 key，每个 key 对应一个 1 亿位的 Bitmap，每一个 bit 对应一个用户当天的签到情况。接下来，我们对 10 个 Bitmap 做“与”操作，得到的结果也是一个 Bitmap。在这个 Bitmap 中，只有 10 天都签到的用户对应的 bit 位上的值才会是 1。最后，我们可以用 BITCOUNT 统计下 Bitmap 中的 1 的个数，这就是连续签到 10 天的用户总数了。<br>&emsp;&emsp;现在，我们可以计算一下记录了 10 天签到情况后的内存开销。每天使用 1 个 1 亿位的 Bitmap，大约占 12MB 的内存（10^8/8/1024/1024），10 天的 Bitmap 的内存开销约为 120MB，内存压力不算太大。不过，在实际应用时，最好对 Bitmap 设置过期时间，让 Redis 自动删除不再需要的签到记录，以节省内存开销。</p><p>&emsp;&emsp;所以，如果只需要统计数据的二值状态，例如商品有没有、用户在不在等，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0 或 1。在记录海量数据时，Bitmap 能够有效地节省内存空间。</p><h2 id="基数统计（HyperLogLog）"><a href="#基数统计（HyperLogLog）" class="headerlink" title="基数统计（HyperLogLog）"></a>基数统计（HyperLogLog）</h2><p>&emsp;&emsp;基数统计就是指统计一个集合中不重复的元素个数。</p><h3 id="业务场景-3"><a href="#业务场景-3" class="headerlink" title="业务场景"></a>业务场景</h3><p>&emsp;&emsp;网页 UV 的统计有个独特的地方，就是需要去重，一个用户一天内的多次访问只能算作一次。在 Redis 的集合类型中，Set 类型默认支持去重，所以看到有去重需求时，我们可能第一时间就会想到用 Set 类型。</p><p>我们来结合一个例子看一看用 Set 的情况。</p><ol><li>有一个用户 user1 访问 page1 时，你把这个信息加到 Set 中：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD page1:uv user1</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;用户 1 再来访问时，Set 的去重功能就保证了不会重复记录用户 1 的访问次数，这样，用 户 1 就算是一个独立访客。当你需要统计 UV 时，可以直接用 SCARD 命令，这个命令会返回一个集合中的元素个数。<br>&emsp;&emsp;但是，如果 page1 非常火爆，UV 达到了千万，这个时候，一个 Set 就要记录千万个用户 ID。对于一个搞大促的电商网站而言，这样的页面可能有成千上万个，如果每个页面都用这样的一个 Set，就会消耗很大的内存空间。</p><p>当然，你也可以用 Hash 类型记录 UV。<br>例如，你可以把用户 ID 作为 Hash 集合的 key，当用户访问页面时，就用 HSET 命令（用 于设置 Hash 集合元素的值），对这个用户 ID 记录一个值“1”，表示一个独立访客，用 户 1 访问 page1 后，我们就记录为 1 个独立访客，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET page1:uv user1 1</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;即使用户 1 多次访问页面，重复执行这个 HSET 命令，也只会把 user1 的值设置为 1，仍然只记为 1 个独立访客。当要统计 UV 时，我们可以用 HLEN 命令统计 Hash 集合中的所有元素个数。但是，和 Set 类型相似，当页面很多时，Hash 类型也会消耗很大的内存空间。那么，有什么办法既能完成统计，还能节省内存吗？</p><h3 id="使用-HyperLogLog"><a href="#使用-HyperLogLog" class="headerlink" title="使用 HyperLogLog"></a>使用 HyperLogLog</h3><p>&emsp;&emsp;HyperLogLog 是一种用于统计基数的数据集合类型，它的最大优势就在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小。在 Redis 中，每个 HyperLogLog 只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数。和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p><ol><li><p>在统计 UV 时，可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFADD page1:uv user1 user2 user3 user4 user5</span><br></pre></td></tr></table></figure></li><li><p>接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT page1:uv</span><br></pre></td></tr></table></figure></li></ol><h3 id="HyperLogLog-的精度局限性"><a href="#HyperLogLog-的精度局限性" class="headerlink" title="HyperLogLog 的精度局限性"></a>HyperLogLog 的精度局限性</h3><p>&emsp;&emsp;不过，有一点需要你注意一下，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。这也就意味着，你使用HyperLogLog 统计的 UV 是 100 万，但实际的 UV 可能是 101 万。虽然误差率不算大，但是，如果你需要精确统计结果的话，最好还是继续用 Set 或 Hash 类型。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;在本结中，我们结合统计用户新增数和留存数、最新评论列表、签到统计以及网页独立访问量这 4 种典型场景，讨论了 4 种统计模式，分别是聚合统计、排序统计、二值状态统计和基数统计。下表是这 4 种统计模式对应 Redis 类型的解决策略：<br><img lazyload src="/images/loading.svg" data-src="redis53.jpg" alt="avatar"><br>&emsp;&emsp;可以看到，Set 和 Sorted Set 都支持多种聚合统计，不过，对于差集计算来说，只有 Set 支持。Bitmap 也能做多个 Bitmap 间的聚合计算，包括与、或和异或操作。</p><p>&emsp;&emsp;当需要进行排序统计时，List 中的元素虽然有序，但是一旦有新元素插入，原来的元素在 List 中的位置就会移动，那么，按位置读取的排序结果可能就不准确了。而 Sorted Set 本身是按照集合元素的权重排序，可以准确地按序获取结果，所以建议优先使用它。</p><p>&emsp;&emsp;如果我们记录的数据只有 0 和 1 两个值的状态，Bitmap 会是一个很好的选择，这主要归功于 Bitmap 对于一个数据只用 1 个 bit 记录，可以节省内存。</p><p>&emsp;&emsp;对于基数统计来说，如果集合元素量达到亿级别而且不需要精确统计时，建议你使用 HyperLogLog。</p><h1 id="GEO-类型"><a href="#GEO-类型" class="headerlink" title="GEO 类型"></a>GEO 类型</h1><p>&emsp;&emsp;在日常生活中，我们越来越依赖搜索“附近的餐馆”、在打车软件上叫车，这些都离不开基于位置信息服务（Location-Based Service，LBS）的应用。LBS 应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS 服务的场景中，我们来看一下它的底层结构。</p><h2 id="GEO-的底层结构"><a href="#GEO-的底层结构" class="headerlink" title="GEO 的底层结构"></a>GEO 的底层结构</h2><h3 id="GEO-要处理的数据的特点"><a href="#GEO-要处理的数据的特点" class="headerlink" title="GEO 要处理的数据的特点"></a>GEO 要处理的数据的特点</h3><p>&emsp;&emsp;我以叫车服务为例，来分析下 LBS 应用中经纬度的存取特点。</p><ol><li>每一辆网约车都有一个编号（例如 33），网约车需要将自己的经度信息（例如116.034579）和纬度信息（例如 39.000452 ）发给叫车应用。</li><li>用户在叫车的时候，叫车应用会根据用户的经纬度位置（例如经度 116.054579，纬度39.030452），查找用户的附近车辆，并进行匹配。</li><li>等把位置相近的用户和车辆匹配上以后，叫车应用就会根据车辆的编号，获取车辆的信息，并返回给用户。</li></ol><p>&emsp;&emsp;可以看到，一辆车（或一个用户）对应一组经纬度，并且随着车（或用户）的位置移动，相应的经纬度也会变化。这种数据记录模式属于一个 key（例如车 ID）对应一个 value（一组经纬度）。当有很多车辆信息要保存时，就需要有一个集合来保存一系列的 key 和 value。Hash 集合类型可以快速存取一系列的 key 和 value，正好可以用来记录一系列车辆 ID 和经纬度的对应关系， 所以，我们可以把不同车辆的 ID 和它们对应的经纬度信息存在 Hash 集合中，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis54.jpg" alt="avatra"><br>&emsp;&emsp;同时，Hash 类型的 HSET 操作命令，会根据 key 来设置相应的 value 值，所以，我们可以用它来快速地更新车辆变化的经纬度信息。<br>&emsp;&emsp;到这里，Hash 类型看起来是一个不错的选择。但问题是，对于一个 LBS 应用来说，除了记录经纬度信息，还需要根据用户的经纬度信息在车辆的 Hash 集合中进行范围查询。一 旦涉及到范围查询，就意味着集合中的元素需要有序，（<strong>如果无序那么只能全局遍历搜索，其时间代价是不能够接受的</strong>），但 Hash 类型的元素是无序的，显然不能满足我们的要求。</p><p>&emsp;&emsp;我们再来看看使用 Sorted Set 类型是不是合适。Sorted Set 类型也支持一个 key 对应一个 value 的记录模式，其中，key 就是 Sorted Set 中的元素，而 value 则是元素的权重分数。更重要的是，Sorted Set 可以根据元素的 权重分数排序，支持范围查询。这就能满足 LBS 服务中查找相邻位置的需求了。实际上，GEO 类型的底层数据结构就是用 Sorted Set 来实现的。咱们还是借着叫车应用的例子来加深下理解。<br>&emsp;&emsp;用 Sorted Set 来保存车辆的经纬度信息时，Sorted Set 的元素是车辆 ID，元素的权重分数是经纬度信息，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis55.jpg" alt="avatar"><br>&emsp;&emsp;这时问题来了，Sorted Set 元素的权重分数是一个浮点数（float 类型），而一组经纬度包含的是经度和纬度两个值，是没法直接保存为一个浮点数的，那具体该怎么进行保存呢？这就要用到 GEO 类型中的 GeoHash 编码了。</p><h3 id="GeoHash-的编码方法"><a href="#GeoHash-的编码方法" class="headerlink" title="GeoHash 的编码方法"></a>GeoHash 的编码方法</h3><p>&emsp;&emsp;为了能高效地对经纬度进行比较，Redis 采用了业界广泛使用的 GeoHash 编码方法，这个方法的基本原理就是“二分区间，区间编码”。当我们要对一组经纬度进行 GeoHash 编码时，我们要先对经度和纬度分别编码，然后再把经纬度各自的编码组合成一个最终编码。</p><ol><li>下经度和纬度的单独编码过程:<br>&emsp;&emsp;对于一个地理位置信息来说，它的经度范围是[-180,180]。GeoHash 编码会把一个经度值编码成一个 N 位的二进制值，我们来对经度范围[-180,180]做 N 次的二分区操作，其中 N 可以自定义。<br>&emsp;&emsp;在进行第一次二分区时，经度范围[-180,180]会被分成两个子区间：[-180,0) 和[0,180] （左、右分区）。此时，我们可以查看一下要编码的经度值落在了左分区还是右分区。如果是落在左分区，我们就用 0 表示；如果落在右分区，就用 1 表示。这样一来，每做完一次二分区，我们就可以得到 1 位编码值。然后，我们再对经度值所属的分区再做一次二分区，同时再次查看经度值落在了二分区后的左分区还是右分区，按照刚才的规则再做 1 位编码。当做完 N 次的二分区后，经度值就可以用一个 N bit 的数来表示了。</li></ol><p>&emsp;&emsp;举个例子，假设我们要编码的经度值是 116.37，我们用 5 位编码值（也就是 N=5，做 5 次分区）。<br><img lazyload src="/images/loading.svg" data-src="redis56.jpg" alt="avatar"><br>对纬度的编码方式，和对经度的一样，只是纬度的范围是[-90，90]，下面这张表显示了对 纬度值 39.86 的编码过程。<br><img lazyload src="/images/loading.svg" data-src="redis57.jpg" alt="avatar"></p><ol start="2"><li>把它们的各自编码值组合在一起:<br>&emsp;&emsp;组合的规则是：最终编码值的偶数位上依次是经度的编码值，奇数位上依次是纬度的编码值，其中，偶数位从 0 开始，奇数位从 1 开始。我们刚刚计算的经纬度（116.37，39.86）的各自编码值是 11010 和 10111，组合之后，第 0 位是经度的第 0 位 1，第 1 位是纬度的第 0 位 1，第 2 位是经度的第 1 位 1，第 3 位是纬度的第 1 位 0，以此类推，就能得到最终编码值 1110011101，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis58.jpg" alt="avatar"><br>&emsp;&emsp;用了 GeoHash 编码后，原来无法用一个权重分数表示的一组经纬度（116.37，39.86）就可以用 1110011101 这一个值来表示，就可以保存为 Sorted Set 的权重分数了。当然，使用 GeoHash 编码后，我们相当于把整个地理空间划分成了一个个方格，每个方格对应了 GeoHash 中的一个分区。<br>&emsp;&emsp;举个例子。我们把经度区间[-180,180]做一次二分区，把纬度区间[-90,90]做一次二分区，就会得到 4 个分区。我们来看下它们的经度和纬度范围以及对应的 GeoHash 组合编码。</li></ol><ul><li>分区一：[-180,0) 和[-90,0)，编码 00；</li><li>分区二：[-180,0) 和[0,90]，编码 01；</li><li>分区三：[0,180]和[-90,0)，编码 10；</li><li>分区四：[0,180]和[0,90]，编码 11。</li></ul><p>&emsp;&emsp;这 4 个分区对应了 4 个方格，每个方格覆盖了一定范围内的经纬度值，分区越多，每个方格能覆盖到的地理空间就越小，也就越精准。我们把所有方格的编码值映射到一维空间时，相邻方格的 GeoHash 编码值基本也是接近的，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis59.jpg" alt="avatar"><br>&emsp;&emsp;所以，我们使用 Sorted Set 范围查询得到的相近编码值，在实际的地理空间上，也是相邻的方格，这就可以实现 LBS 应用“搜索附近的人或物”的功能了。不过，有的编码值虽然在大小上接近，但实际对应的方格却距离比较远。例如，我们用 4 位来做 GeoHash 编码，把经度区间[-180,180]和纬度区间[-90,90]各 分成了 4 个分区，一共 16 个分区，对应了 16 个方格。编码值为 0111 和 1000 的两个方格就离得比较远，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis60.jpg" alt="avatar"><br>&emsp;&emsp;所以，为了避免查询不准确问题，我们可以同时查询给定经纬度所在的方格周围的 4 个或 8 个方格。</p><h2 id="如何操作-GEO-类型"><a href="#如何操作-GEO-类型" class="headerlink" title="如何操作 GEO 类型"></a>如何操作 GEO 类型</h2><p>&emsp;&emsp;在使用 GEO 类型时，我们经常会用到两个命令，分别是 GEOADD 和 GEORADIUS。</p><ul><li>GEOADD 命令：用于把一组经纬度信息和相对应的一个 ID 记录到 GEO 类型集合中；</li><li>GEORADIUS 命令：会根据输入的经纬度位置，查找以这个经纬度为中心的一定范围内的其他元素。当然，我们可以自己定义这个范围。</li></ul><p>&emsp;&emsp;我还是以叫车应用的车辆匹配场景为例，介绍下具体如何使用这两个命令。假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。执行下面的这个命令，就可以 把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD cars:locations 116.034579 39.030452 33</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当用户想要寻找自己附近的网约车时，LBS 应用就可以使用 GEORADIUS 命令。例如，LBS 应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息 （116.054579，39.030452 ），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。当然，你可以修改“5”这个参数，来返回更大或更小范围内的车辆信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS cars:locations 116.054579 39.030452 5 km ASC COUNT 10</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;另外，我们还可以进一步限定返回的车辆信息。比如，我们可以使用 ASC 选项，让返回的车辆信息按照距离这个中心位置从近到远的方式来排序，以方便选择最近的车辆；还可以使用 COUNT 选项，指定返回的车辆信息的数量。毕竟，5 公里范围内的车辆可能有很多，如果返回全部信息，会占用比较多的数据带宽，这个选项可以帮助控制返回的数据量，节省带宽。</p><h1 id="自定义的数据类型"><a href="#自定义的数据类型" class="headerlink" title="自定义的数据类型"></a>自定义的数据类型</h1><h2 id="如何自定义数据类型"><a href="#如何自定义数据类型" class="headerlink" title="如何自定义数据类型"></a>如何自定义数据类型</h2><p>&emsp;&emsp;为了实现自定义数据类型，首先，我们需要了解 Redis 的基本对象结构 RedisObject，因 为 Redis 键值对中的每一个值都是用 RedisObject 保存的。RedisObject 包括元数据和指针。其中，元数据的一个功能就是用来区分不同的数据类型，指针用来指向具体的数据类型的值。所以，要想开发新数据类型，我们就先来了解下 RedisObject 的元数据和指针。</p><h2 id="Redis-的基本对象结构"><a href="#Redis-的基本对象结构" class="headerlink" title="Redis 的基本对象结构"></a>Redis 的基本对象结构</h2><p>&emsp;&emsp;RedisObject 的内部组成包括了 type,、encoding,、lru 和 refcount 4 个元数据，以及 1 个*ptr指针。</p><ul><li>type：表示值的类型，涵盖了我们前面学习的五大基本类型；</li><li>encoding：是值的编码方式，用来表示 Redis 中实现各个基本类型的底层数据结构，例如 SDS、压缩列表、哈希表、跳表等；</li><li>lru：记录了这个对象最后一次被访问的时间，用于淘汰过期的键值对；</li><li>refcount：记录了对象的引用计数；</li><li>*ptr：是指向数据的指针。</li></ul><p><img lazyload src="/images/loading.svg" data-src="redis61.jpg" alt="avatar"><br>&emsp;&emsp;RedisObject 结构借助*ptr指针，就可以指向不同的数据类型，例如，*ptr指向一个 SDS 或一个跳表，就表示键值对中的值是 String 类型或 Sorted Set 类型。所以，我们在定义了新的数据类型后，也只要在 RedisObject 中设置好新类型的 type 和 encoding，再 用*ptr指向新类型的实现，就行了。</p><h1 id="在-Redis-中保存时间序列数据"><a href="#在-Redis-中保存时间序列数据" class="headerlink" title="在 Redis 中保存时间序列数据"></a>在 Redis 中保存时间序列数据</h1><h2 id="需求概括"><a href="#需求概括" class="headerlink" title="需求概括"></a>需求概括</h2><p>&emsp;&emsp;我们现在做互联网产品的时候，都有这么一个需求：记录用户在网站或者 App 上的点击行为数据，来分析用户行为。这里的数据一般包括用户 ID、行为类型（例如浏览、登录、下单等）、行为发生的时间戳：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserID, Type, TimeStamp</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再比如做物联网项目，我们需要周期性地统计近万台设备的实时状态，包括设备 ID、压力、温度、湿度，以及对应的时间戳：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeviceID, Pressure, Temperature, Humidity, TimeStamp</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这些<strong>与发生时间相关</strong>的一组数据，就是时间序列数据。这些数据的特点是没有严格的关系模型，记录的信息可以表示成键和值的关系（例如，一个设备 ID 对应一条记录），所以，并不需要专门用关系型数据库（例如 MySQL）来保存。而 Redis 的键值数据模型，正好可以满足这里的数据存取需求。</p><h2 id="时间序列数据的读写特点"><a href="#时间序列数据的读写特点" class="headerlink" title="时间序列数据的读写特点"></a>时间序列数据的读写特点</h2><ul><li><p>写数据<br>&emsp;&emsp;在实际应用中，时间序列数据通常是持续高并发写入的，例如，需要连续记录数万个设备的实时状态值。同时，时间序列数据的写入主要就是插入新数据，而不是更新一个已存在的数据，也就是说，一个时间序列数据被记录后通常就不会变了，因为它就代表了一个设备在某个时刻的状态值（例如，一个设备在某个时刻的温度测量值，一旦记录下来，这个值本身就不会再变了）。所以，<strong>这种数据的写入特点很简单，就是插入数据快，这就要求我们选择的数据类型，在进行数据插入时，复杂度要低，尽量不要阻塞</strong>。</p></li><li><p>读数据<br>&emsp;&emsp;我们在查询时间序列数据时，既有对单条记录的查询（例如查询某个设备在某一个时刻的运行状态信息，对应的就是这个设备的一条记录），也有对某个时间范围内的数据的查询（例如每天早上 8 点到 10 点的所有设备的状态信息）。除此之外，还有一些更复杂的查询，比如对某个时间范围内的数据做聚合计算。这里的聚合计算，就是对符合查询条件的所有数据做计算，包括计算均值、最大 / 最小值、求和等。例如，我们要计算某个时间段内的设备压力的最大值，来判断是否有故障发生。那用一个词概括时间序列数据的“读”，就是<strong>查询模式多</strong>。</p></li></ul><p>&emsp;&emsp;Redis 提供 了保存时间序列数据的两种方案，分别可以基于 Hash 和 Sorted Set 实现，以及基于 RedisTimeSeries 模块实现。</p><h2 id="基于-Hash-和-Sorted-Set-保存时间序列数据"><a href="#基于-Hash-和-Sorted-Set-保存时间序列数据" class="headerlink" title="基于 Hash 和 Sorted Set 保存时间序列数据"></a>基于 Hash 和 Sorted Set 保存时间序列数据</h2><h3 id="为什么要同时使用这两种类型"><a href="#为什么要同时使用这两种类型" class="headerlink" title="为什么要同时使用这两种类型"></a>为什么要同时使用这两种类型</h3><p>&emsp;&emsp;关于 Hash 类型，我们都知道，它有一个特点是，可以实现对单键的快速查询。这就满足了时间序列数据的单键查询需求。我们可以把时间戳作为 Hash 集合的 key，把记录的设备状态值作为 Hash 集合的 value。<br>可以看下用 Hash 集合记录设备的温度值的示意图：<br><img lazyload src="/images/loading.svg" data-src="redis62.jpg" alt="avatar"><br>&emsp;&emsp;当我们想要查询某个时间点或者是多个时间点上的温度数据时，直接使用 HGET 命令或者 HMGET 命令，就可以分别获得 Hash 集合中的一个 key 和多个 key 的 value 值了。</p><p>&emsp;&emsp;举个例子。我们用 HGET 命令查询 202008030905 这个时刻的温度值，使用 HMGET 查询 202008030905、202008030907、202008030908 这三个时刻的温度值，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HGET device:temperature 202008030905 </span><br><span class="line"><span class="string">&quot;25.1&quot;</span></span><br><span class="line"></span><br><span class="line">HMGET device:temperature 202008030905 202008030907 202008030908</span><br><span class="line">1) <span class="string">&quot;25.1&quot;</span></span><br><span class="line">2) <span class="string">&quot;25.9&quot;</span></span><br><span class="line">3) <span class="string">&quot;24.9&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;用 Hash 类型来实现单键的查询很简单。但是，Hash 类型有个短板：<strong>它并不支持对数据进行范围查询</strong>。所以，如果要对 Hash 类型进行范围查询的话，就需要扫描 Hash 集合中的所有数据，再把这些数据取回到客户端进行排序，然后，才能在客户端得到所查询范围内的数据。显然，查询效率很低。</p><p>&emsp;&emsp;为了能同时支持按时间戳范围的查询，可以用 Sorted Set 来保存时间序列数据，因为它能够根据元素的权重分数来排序。我们可以把时间戳作为 Sorted Set 集合的元素分数，把时间点上记录的数据作为元素本身。<br><img lazyload src="/images/loading.svg" data-src="redis63.jpg" alt="avatar"></p><p>&emsp;&emsp;使用 Sorted Set 保存数据后，我们就可以使用 ZRANGEBYSCORE 命令，按照输入的最大时间戳和最小时间戳来查询这个时间范围内的温度值了。如下所示，我们来查询一下在 2020 年 8 月 3 日 9 点 7 分到 9 点 10 分间的所有温度值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE device:temperature 202008030907 202008030910</span><br><span class="line">1) <span class="string">&quot;25.9&quot;</span></span><br><span class="line">2) <span class="string">&quot;24.9&quot;</span></span><br><span class="line">3) <span class="string">&quot;25.3&quot;</span></span><br><span class="line">4) <span class="string">&quot;25.2&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们知道了，可以同时使用 Hash 和 Sorted Set，就能满足对单个时间点和一个时间范围内的数据查询需求。但是又会面临一个新的问题，也就是我们要解决的第二个问题：<strong>如何保证写入 Hash 和 Sorted Set 是一个原子性的操作呢</strong>？</p><h3 id="如何保证事务的原子性？"><a href="#如何保证事务的原子性？" class="headerlink" title="如何保证事务的原子性？"></a>如何保证事务的原子性？</h3><ul><li>MULTI 命令：表示一系列原子性操作的开始。收到这个命令后，Redis 就知道，接下来再收到的命令需要放到一个内部队列中，后续一起执行，保证原子性。</li><li>EXEC 命令：表示一系列原子性操作的结束。一旦 Redis 收到了这个命令，就表示所有要保证原子性的命令操作都已经发送完成了。此时，Redis 开始执行刚才放到内部队列中的所有命令操作。</li></ul><p><img lazyload src="/images/loading.svg" data-src="redis64.jpg" alt="avatar"><br>&emsp;&emsp;以保存设备状态信息的需求为例，我们执行下面的代码，把设备在 2020 年 8 月 3 日 9 时 5 分的温度，分别用 HSET 命令和 ZADD 命令写入 Hash 集合和 Sorted Set 集合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI </span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; HSET device:temperature 202008030911 26.8 </span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZADD device:temperature 202008030911 26.8 </span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先，Redis 收到了客户端执行的 MULTI 命令。然后，客户端再执行 HSET 和 ZADD 命令后，Redis 返回的结果为“QUEUED”，表示这两个命令暂时入队，先不执行；执行了 EXEC 命令后，HSET 命令和 ZADD 命令才真正执行，并返回成功结果（结果值为 1）。<br>&emsp;&emsp;到这里，我们就解决了时间序列数据的单点查询、范围查询问题，并使用 MUTLI 和 EXEC 命令保证了 Redis 能原子性地把数据保存到 Hash 和 Sorted Set 中。接下来，我们需要继续解决第三个问题：<strong>如何对时间序列数据进行聚合计算</strong>？</p><h3 id="如何实现聚合计算"><a href="#如何实现聚合计算" class="headerlink" title="如何实现聚合计算"></a>如何实现聚合计算</h3><p>&emsp;&emsp;因为 Sorted Set 只支持范围查询，无法直接进行聚合计算，所以，我们只能先把时间范围内的数据取回到客户端，然后在客户端自行完成聚合计算。这个方法虽然能完成聚合计算，但是会带来一定的潜在风险，也就是<strong>大量数据在 Redis 实例和客户端间频繁传输，这会和其他操作命令竞争网络资源，导致其他操作变慢</strong>。<br>&emsp;&emsp;在我们这个物联网项目中，就需要每 3 分钟统计一下各个设备的温度状态，一旦设备温度超出了设定的阈值，就要进行报警。这是一个典型的聚合计算场景，我们可以来看看这个过程中的数据体量。<br>&emsp;&emsp;假设我们需要每 3 分钟计算一次的所有设备各指标的最大值，每个设备每 15 秒记录一个指标值，1 分钟就会记录 4 个值，3 分钟就会有 12 个值。我们要统计的设备指标数量有 33 个，所以，单个设备每 3 分钟记录的指标数据有将近 400 个（33 * 12 = 396），而设备总数量有 1 万台，这样一来，每 3 分钟就有将近 400 万条（396 * 1 万 = 396 万）数据需要在客户端和 Redis 实例间进行传输。<br>&emsp;&emsp;为了避免客户端和 Redis 实例间频繁的大量数据传输，我们可以使用 RedisTimeSeries 来保存时间序列数据。RedisTimeSeries 支持直接在 Redis 实例上进行聚合计算。还是以刚才每 3 分钟算一次最大值为例。在 Redis 实例上直接聚合计算，那么，对于单个设备的一个指标值来说，每 3 分钟记录的 12 条数据可以聚合计算成一个值，单个设备每 3 分钟也就只有 33 个聚合值需要传输，1 万台设备也只有 33 万条数据。数据量大约是在客户端做聚合计算的十分之一，很显然，可以减少大量数据传输对 Redis 实例网络的性能影响。<br>&emsp;&emsp;所以，如果我们只需要进行单个时间点查询或是对某个时间范围查询的话，适合使用 Hash 和 Sorted Set 的组合，它们都是 Redis 的内在数据结构，性能好，稳定性高。但是，如果我们需要进行大量的聚合计算，同时网络带宽条件不是太好时，Hash 和 Sorted Set 的组合就不太适合了。此时，使用 RedisTimeSeries 就更加合适一些。</p><h2 id="基于-RedisTimeSeries-模块保存时间序列数据"><a href="#基于-RedisTimeSeries-模块保存时间序列数据" class="headerlink" title="基于 RedisTimeSeries 模块保存时间序列数据"></a>基于 RedisTimeSeries 模块保存时间序列数据</h2><ul><li><input disabled type="checkbox"> TODO</li></ul><h1 id="Redis-对于消息队列需求的解决方案"><a href="#Redis-对于消息队列需求的解决方案" class="headerlink" title="Redis 对于消息队列需求的解决方案"></a>Redis 对于消息队列需求的解决方案</h1><h2 id="消息队列的存取需求"><a href="#消息队列的存取需求" class="headerlink" title="消息队列的存取需求"></a>消息队列的存取需求</h2><p>&emsp;&emsp;消息队列的本质是为组件间或者说系统间提供解耦的服务，使组件间的服务可以异步完成。如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis65.jpg" alt="avatar"><br>&emsp;&emsp;我们一般把消息队列中发送消息的组件称为生产者（例子中的组件 1），把接收消息的组件称为消费者（例子中的组件 2），下图展示了一个通用的消息队列的架构模型：<br><img lazyload src="/images/loading.svg" data-src="redis66.jpg" alt="avatar"><br>&emsp;&emsp;在使用消息队列时，消费者可以异步读取生产者消息，然后再进行处理。这样一来，即使生产者发送消息的速度远远超过了消费者处理消息的速度，生产者已经发送的消息也可以缓存在消息队列中，避免阻塞生产者，这是消息队列作为分布式组件通信的一大优势。</p><p>&emsp;&emsp;不过，消息队列在存取消息时，必须要满足三个需求，分别是<strong>消息保序</strong>、<strong>处理重复的消息</strong>和<strong>保证消息可靠性</strong>。</p><h3 id="需求一：消息保存"><a href="#需求一：消息保存" class="headerlink" title="需求一：消息保存"></a>需求一：消息保存</h3><p>&emsp;&emsp;虽然消费者是异步处理消息，但是，消费者仍然需要按照生产者发送消息的顺序来处理消息，避免后发送的消息被先处理了。对于要求消息保序的场景来说，一旦出现这种消息被乱序处理的情况，就可能会导致业务逻辑被错误执行，从而给业务方造成损失。<br>&emsp;&emsp;我们来看一个更新商品库存的场景。假设生产者负责接收库存更新请求，消费者负责实际更新库存，现有库存量是 10。生产者先后发送了消息 1 和消息 2，消息 1 要把商品 X 的库存记录更新为 5，消息 2 是把商品 X 库存更新为 3。如果消息 1 和 2 在消息队列中无法保序，出现消息 2 早于消息 1 被处理的情况，那么，很显然，库存更新就出错了。这是业务应用无法接受的。面对这种情况，你可能会想到一种解决方案：<strong>不要把更新后的库存量作为生产者发送的消息，而是把库存扣除值作为消息的内容</strong>。这样一来，消息 1 是扣减库存量 5，消息 2 是扣减库存量 2。如果消息 1 和消息 2 之间没有库存查询请求的话，即使消费者先处理消息 2，再处理消息 1，这个方案也能够保证最终的库存量是正确的，也就是库存量为 3。但是，我们还需要考虑这样一种情况：假如消费者收到了这样三条消息：消息 1 是扣减库 存量 5，消息 2 是读取库存量，消息 3 是扣减库存量 2，此时，如果消费者先处理了消息 3（把库存量扣减 2），那么库存量就变成了 8。然后，消费者处理了消息 2，读取当前的库存量是 8，这就会出现库存量查询不正确的情况。从业务应用层面看，消息 1、2、3 应该是顺序执行的，所以，消息 2 查询到的应该是扣减了 5 以后的库存量，而不是扣减了 2 以后的库存量。所以，用库存扣除值作为消息的方案，<strong>在消息中同时包含读写操作的场景下，会带来数据读取错误的问题</strong>。而且，这个方案还会面临一个问题，那就是<strong>重复消息处理</strong>。</p><h3 id="需求二：重复消息处理"><a href="#需求二：重复消息处理" class="headerlink" title="需求二：重复消息处理"></a>需求二：重复消息处理</h3><p>&emsp;&emsp;消费者从消息队列读取消息时，有时会因为网络堵塞而出现消息重传的情况。此时，消费者可能会收到多条重复的消息。对于重复的消息，消费者如果多次处理的话，就可能造成一个业务逻辑被多次执行，如果业务逻辑正好是要修改数据，那就会出现数据被多次修改的问题了。还是以库存更新为例，假设消费者收到了一次消息 1，要扣减库存量 5，然后又收到了一次消息 1，那么，如果消费者无法识别这两条消息实际是一条相同消息的话，就会执行两次扣减库存量 5 的操作，此时，库存量就不对了。这当然也是无法接受的。</p><h3 id="需求三：消息可靠性保证"><a href="#需求三：消息可靠性保证" class="headerlink" title="需求三：消息可靠性保证"></a>需求三：消息可靠性保证</h3><p>&emsp;&emsp;另外，消费者在处理消息的时候，还可能出现因为故障或宕机导致消息没有处理完成的情况。此时，消息队列需要能提供消息可靠性的保证，也就是说，当消费者重启后，可以重新读取消息再次进行处理，否则，就会出现消息漏处理的问题了。</p><p>&emsp;&emsp;Redis 的 List 和 Streams 两种数据类型，就可以满足消息队列的这三个需求。我们先来了解下基于 List 的消息队列实现方法。</p><h2 id="基于-List-的消息队列解决方案"><a href="#基于-List-的消息队列解决方案" class="headerlink" title="基于 List 的消息队列解决方案"></a>基于 List 的消息队列解决方案</h2><h3 id="消息保存"><a href="#消息保存" class="headerlink" title="消息保存"></a>消息保存</h3><p>&emsp;&emsp;List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。具体来说，生产者可以使用 LPUSH 命令把要发送的消息依次写入 List，而消费者则可以使 用 RPOP 命令，从 List 的另一端按照消息的写入顺序，依次读取消息并进行处理。<br>&emsp;&emsp;如下图所示，生产者先用 LPUSH 写入了两条库存消息，分别是 5 和 3，表示要把库存更新为 5 和 3；消费者则用 RPOP 把两条消息依次读出，然后进行相应的处理。<br><img lazyload src="/images/loading.svg" data-src="redis67.jpg" alt="avatar"><br>&emsp;&emsp;不过，在消费者读取数据时，有一个潜在的性能风险点。在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，<strong>如果消费者想要及时处理消息，就需要在程序中不停地调用 RPOP 命令</strong>（比如使用一个 while(1) 循环）。如果有新消息写入，RPOP 命令就会返回结果，否则，RPOP 命令返回空值，再继续循环。所以，即使没有新消息写入 List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。<br>&emsp;&emsp;为了解决这个问题，Redis 提供了 BRPOP 命令。BRPOP 命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。和消费者程序自己不停地调用 RPOP 命令相比，这种方式能节省 CPU 开销。</p><h3 id="重复消息处理"><a href="#重复消息处理" class="headerlink" title="重复消息处理"></a>重复消息处理</h3><p>&emsp;&emsp;消息保序的问题解决了，接下来，我们还需要考虑解决重复消息处理的问题，这里其实有一个要求：消费者程序本身能对重复消息进行判断。<br>&emsp;&emsp;一方面，消息队列要能给每一个消息提供全局唯一的 ID 号；另一方面，消费者程序要把已经处理过的消息的 ID 号记录下来。(<strong>在扣款业务中也是如此，生成唯一的订单号就是服务端只扣款一次的保证</strong>)当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID， 来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。这种处理特性也称为<strong>幂等性</strong>，幂等性就是指，对于同一条消息，消费者收到一次的处理结果和收到多次的处理结果是一致的。不过，List 本身是不会为每个消息生成 ID 号的，所以，消息的全局唯一 ID 号就需要生产者程序在发送消息前自行生成。生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。例如，我们执行以下命令，就把一条全局 ID 为 101030001、库存量为 5 的消息插入了消息队列：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH mq <span class="string">&quot;101030001:stock:5&quot;</span> </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="保证消息可靠性"><a href="#保证消息可靠性" class="headerlink" title="保证消息可靠性"></a>保证消息可靠性</h3><p>&emsp;&emsp;当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了<strong>故障或宕机</strong>，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。<br>&emsp;&emsp;为了留存消息，List 类型提供了 BRPOPLPUSH 命令，这个命令的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。<br><img lazyload src="/images/loading.svg" data-src="redis68.jpg" alt="avatar"></p><p>&emsp;&emsp;但是，在用 List 做消息队列时，还可能遇到过一个问题：生产者消息发送很 快，而消费者处理消息的速度比较慢，这就导致 List 中的消息越积越多，给 Redis 的内存带来很大压力。这个时候，我们希望启动多个消费者程序组成一个消费组，一起分担处理 List 中的消息。 但是，List 类型并不支持消费组的实现。那么，还有没有更合适的解决方案呢？这就要说 到 Redis 从 5.0 版本开始提供的 Streams 数据类型了。</p><h2 id="基于-Streams-的消息队列解决方案"><a href="#基于-Streams-的消息队列解决方案" class="headerlink" title="基于 Streams 的消息队列解决方案"></a>基于 Streams 的消息队列解决方案</h2><p>&emsp;&emsp;Streams 是 Redis 专门为消息队列设计的数据类型，它提供了丰富的消息队列操作命令。</p><ol><li>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</li><li>XREAD：用于读取消息，可以按 ID 读取数据；</li><li>XREADGROUP：按消费组形式读取消息；</li><li>XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。</li></ol><ul><li><p>XADD<br>&emsp;&emsp;XADD 命令可以往消息队列中插入新消息，消息的格式是键 - 值对形式。对于插入的每一条消息，Streams 可以自动为其生成一个全局唯一的 ID。<br>&emsp;&emsp;比如说，我们执行下面的命令，就可以往名称为 mqstream 的消息队列中插入一条消息， 消息的键是 repo，值是 5。其中，消息队列名称后面的*，表示让 Redis 为插入的数据自动生成一个全局唯一的 ID，例如“1599203861727-0”。当然，我们也可以不用*，直接在消息队列名称后自行设定一个 ID 号，只要保证这个 ID 号是全局唯一的就行。不过，相比自行设定 ID 号，使用*会更加方便高效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XADD mqstream * repo 5</span><br><span class="line"><span class="string">&quot;1599203861727-0&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，消息的全局唯一 ID 由两部分组成，第一部分“1599203861727”是数据插入时，以毫秒为单位计算的当前服务器时间，第二部分表示插入消息在当前毫秒内的消息序号，这是从 0 开始编号的。例如，“1599203861727-0”就表示在“1599203861727”毫秒内的第 1 条消息。</p></li><li><p>XREAD<br>&emsp;&emsp;XREAD 在读取消息时，可以指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取。例如，我们可以执行下面的命令，从 ID 号为 1599203861727-0 的消息开始，读取后续的所有消息（示例中一共 3 条）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">XREAD BLOCK 100 STREAMS mqstream 1599203861727-0</span><br><span class="line">1) 1) <span class="string">&quot;mqstream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1599274912765-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">            2) <span class="string">&quot;3&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;1599274925823-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">    2) <span class="string">&quot;2&quot;</span></span><br><span class="line">      3) 1) <span class="string">&quot;1599274927910-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">            2) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;另外，消费者也可以在调用 XRAED 时设定 block 配置项，实现类似于 BRPOP 的阻塞读取操作。当消息队列中没有消息时，一旦设置了 block 配置项，XREAD 就会阻塞，阻塞的时长可以在 block 配置项进行设置。<br>&emsp;&emsp;举个例子，我们来看一下下面的命令，其中，命令最后的“$”符号表示读取最新的消息，同时，我们设置了 block 10000 的配置项，10000 的单位是毫秒，表明 XREAD 在读取最新消息时，如果没有消息到来，XREAD 将阻塞 10000 毫秒（即 10 秒），然后再返回。下面命令中的 XREAD 执行后，消息队列 mqstream 中一直没有消息，所以，XREAD 在10 秒后返回空值（nil）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XREAD block 10000 streams mqstream $ </span><br><span class="line">(nil) </span><br><span class="line">(10.00s)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;刚刚讲到的这些操作是 List 也支持的，接下来，我们再来学习下 Streams 特有的功能。<br>&emsp;&emsp;Streams 本身可以使用 XGROUP 创建消费组，创建消费组之后，Streams 可以使用 XREADGROUP 命令让消费组内的消费者读取消息，例如，我们执行下面的命令，创建一个名为 group1 的消费组，这个消费组消费的消息队列是 mqstream。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XGROUP create mqstream group1 0 </span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后，我们再执行一段命令，让 group1 消费组里的消费者 consumer1 从 mqstream 中读取所有消息，其中，命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取。 因为在 consumer1 读取消息前，group1 中没有其他消费者读取过消息，所以， consumer1 就得到 mqstream 消息队列中的所有消息了（一共 4 条）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP group group1 consumer1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mqstream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1599203861727-0&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">         2) <span class="string">&quot;5&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;1599274912765-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">            2) <span class="string">&quot;3&quot;</span></span><br><span class="line">      3) 1) <span class="string">&quot;1599274925823-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">            2) <span class="string">&quot;2&quot;</span></span><br><span class="line">      4) 1) <span class="string">&quot;1599274927910-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">            2) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要注意的是，消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了。比如说，我们执行完刚才的 XREADGROUP 命令后，再执行下面的命令，让 group1 内的 consumer2 读取消息时，consumer2 读到的就是空值，因为消息已经被 consumer1 读取完了，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP group group1 consumer2 streams mqstream 0</span><br><span class="line">1) 1) <span class="string">&quot;mqstream&quot;</span></span><br><span class="line">   2) (empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。例如，我们执行下列命令，让 group2 中的 consumer1、2、3 各自读取一条消息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP group group2 consumer1 count 1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mqstream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1599203861727-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">            2) <span class="string">&quot;5&quot;</span></span><br><span class="line">XREADGROUP group group2 consumer2 count 1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mqstream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1599274912765-0&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">         2) <span class="string">&quot;3&quot;</span></span><br><span class="line">XREADGROUP group group2 consumer3 count 1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mqstream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1599274925823-0&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">         2) <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息，Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams“消息已经处理完成”。如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。例如，我们来查看一下 group2 中各个消费者已读取、但尚未确认的消息个数。其中， XPENDING 返回结果的第二、三行分别表示 group2 中所有消费者读取的消息最小 ID 和 最大 ID。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">XPENDING mqstream group2</span><br><span class="line">1) (<span class="built_in">integer</span>) 3</span><br><span class="line">2) <span class="string">&quot;1599203861727-0&quot;</span></span><br><span class="line">3) <span class="string">&quot;1599274925823-0&quot;</span></span><br><span class="line">4) 1) 1) <span class="string">&quot;consumer1&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;consumer2&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;consumer3&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果我们还需要进一步查看某个消费者具体读取了哪些数据，可以执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XPENDING mqstream group2 - + 10 consumer2</span><br><span class="line">1) 1) <span class="string">&quot;1599274912765-0&quot;</span></span><br><span class="line">   2) <span class="string">&quot;consumer2&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 513336</span><br><span class="line">   4) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，consumer2 已读取的消息的 ID 是 1599274912765-0。一旦消息 1599274912765-0 被 consumer2 处理了，consumer2 就可以使用 XACK 命令通知 Streams，然后这条消息就会被删除。当我们再使用 XPENDING 命令查看时，就可以看到，consumer2 已经没有已读取、但尚未确认处理的消息了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XACK mqstream group2 1599274912765-0 </span><br><span class="line">(<span class="built_in">integer</span>) 1 </span><br><span class="line">XPENDING mqstream group2 - + 10 consumer2 </span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h1 id="异步机制：如何避免单线程模型的阻塞"><a href="#异步机制：如何避免单线程模型的阻塞" class="headerlink" title="异步机制：如何避免单线程模型的阻塞"></a>异步机制：如何避免单线程模型的阻塞</h1><p>&emsp;&emsp;Redis 的操作基本可以分为 4 类：</p><ol><li>服务客户端请求的键值对增删改查操作；</li><li>网络 IO；</li><li>保证可靠性的持久化操作；</li><li>进行主从复制时的数据同步操作。</li></ol><h2 id="Redis-实例有哪些阻塞点"><a href="#Redis-实例有哪些阻塞点" class="headerlink" title="Redis 实例有哪些阻塞点"></a>Redis 实例有哪些阻塞点</h2><p>&emsp;&emsp;Redis 实例在运行时，要和许多对象进行交互，这些不同的交互就会涉及不同的操作，下面我们来看看和 Redis 实例交互的对象，以及交互时会发生的操作。</p><ul><li>客户端：网络 IO，键值对增删改查操作，数据库操作；</li><li>磁盘：生成 RDB 快照，记录 AOF 日志，AOF 日志重写；</li><li>主从节点：主库生成、传输 RDB 文件，从库接收 RDB 文件、清空数据库、加载 RDB 文件；</li><li>切片集群实例：向其他实例传输哈希槽信息，数据迁移。<br>如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis69.jpg" alt="avatar"></li></ul><h3 id="和客户端交互时的阻塞点"><a href="#和客户端交互时的阻塞点" class="headerlink" title="和客户端交互时的阻塞点"></a>和客户端交互时的阻塞点</h3><p>&emsp;&emsp;网络 IO 有时候会比较慢，但是 Redis 使用了 IO 多路复用机制，避免了主线程一直处在等待网络连接或请求到来的状态，所以，网络 IO 不是导致 Redis 阻塞的因素。</p><ol><li><p>潜在阻塞点一：复杂度高的操作<br>&emsp;&emsp;键值对的增删改查操作是 Redis 和客户端交互的主要部分，也是 Redis 主线程执行的主要任务。所以，复杂度高的增删改查操作肯定会阻塞 Redis。<br>&emsp;&emsp;那么，怎么判断操作复杂度是不是高呢？这里有一个最基本的标准，就是看操作的复杂度是否为 O(N)。Redis 中涉及集合的操作复杂度通常为 O(N)，我们要在使用时重视起来。例如集合元素全量查询操作 HGETALL、SMEMBERS，以及集合的聚合统计操作，例如求交、并和差集。这些操作可以作为 Redis 的第一个阻塞点：<strong>集合全量查询</strong>和<strong>聚合操作</strong>。</p></li><li><p>潜在阻塞点二：bigkey 的删除<br>&emsp;&emsp;除此之外，集合自身的删除操作同样也有潜在的阻塞风险。你可能会认为，删除操作很简单，直接把数据删除就好了，为什么还会阻塞主线程呢？其实，删除操作的本质是要释放键值对占用的内存空间。你可不要小瞧内存的释放过程。 释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，<strong>操作系统需要把释放掉的内存块插入一个空闲内存块的链表</strong>，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会<strong>阻塞当前释放内存的应用程序</strong>，所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞。<br>&emsp;&emsp;那么，什么时候会释放大量内存呢？其实就是在删除大量键值对数据的时候，最典型的就是删除包含了大量元素的集合，也称为 bigkey 删除。测试了不同元素数量的集合在进行删除操作时所消耗的时间，如下表所示：<br><img lazyload src="/images/loading.svg" data-src="redis70.jpg" alt="avatar"></p></li><li><p>潜在阻塞点三：清空数据库<br>&emsp;&emsp;既然频繁删除键值对都是潜在的阻塞点了，那么，在 Redis 的数据库级别操作中，清空数 据库（例如 FLUSHDB 和 FLUSHALL 操作）必然也是一个潜在的阻塞风险，因为它涉及到 删除和释放所有的键值对。所以，这就是 Redis 的第三个阻塞点：清空数据库。</p></li></ol><h3 id="和磁盘交互的阻塞点"><a href="#和磁盘交互的阻塞点" class="headerlink" title="和磁盘交互的阻塞点"></a>和磁盘交互的阻塞点</h3><ol start="4"><li>潜在阻塞点四：AOF 日志同步写<br>&emsp;&emsp;Redis 开发者早已认识到磁盘 IO 会带来阻塞，所以就把 Redis 进一步设计为采用子进程的方式生成 RDB 快照文件，以及执行 AOF 日志重写操作。这样一来，这两个操作由子进程负责执行，慢速的磁盘 IO 就不会阻塞主线程了。但是，Redis 直接记录 AOF 日志时，会根据不同的写回策略对数据做落盘保存。一个同步写磁盘的操作的耗时大约是 1～2ms，如果有大量的写操作需要记录在 AOF 日志中，并同 步写回的话，就会阻塞主线程了。这就得到了 Redis 的第四个阻塞点了：AOF 日志同步写。</li></ol><h3 id="主从节点交互时的阻塞点"><a href="#主从节点交互时的阻塞点" class="headerlink" title="主从节点交互时的阻塞点"></a>主从节点交互时的阻塞点</h3><p>&emsp;&emsp;在主从集群中，主库需要生成 RDB 文件，并传输给从库。主库在复制的过程中，创建和传输 RDB 文件都是由子进程来完成的，不会阻塞主线程。但是，对于从库来说，它在接收了 RDB 文件后，需要使用 FLUSHDB 命令清空当前数据库，这就正好撞上了刚才我们分析的第三个阻塞点。</p><ol start="5"><li>潜在阻塞点五：从节点加载 RDB 文件<br>&emsp;&emsp;此外，从库在清空当前数据库后，还需要把 RDB 文件加载到内存，这个过程的快慢和 RDB 文件的大小密切相关，RDB 文件越大，加载过程越慢，所以，加载 RDB 文件就成为了 Redis 的第五个阻塞点。</li></ol><h3 id="切片集群实例交互时的阻塞点"><a href="#切片集群实例交互时的阻塞点" class="headerlink" title="切片集群实例交互时的阻塞点"></a>切片集群实例交互时的阻塞点</h3><p>&emsp;&emsp;最后，当我们部署 Redis 切片集群时，每个 Redis 实例上分配的哈希槽信息需要在不同实例间进行传递，同时，当需要进行负载均衡或者有实例增删时，数据会在不同的实例间进行迁移。不过，哈希槽的信息量不大，而数据迁移是渐进式执行的，所以，一般来说，这两类操作对 Redis 主线程的阻塞风险不大。不过，如果你使用了 Redis Cluster 方案，而且同时正好迁移的是 bigkey 的话，就会造成主线程的阻塞，因为 Redis Cluster 使用了同步迁移。当没有 bigkey 时，切片集群的各实例在进行交互时不会阻塞主线程。</p><p>&emsp;&emsp;总结一下五个阻塞点：</p><ol><li>集合全量查询和聚合操作；</li><li>bigkey 删除；</li><li>清空数据库；</li><li>AOF 日志同步写；</li><li>从库加载 RDB 文件。</li></ol><p>&emsp;&emsp;如果在主线程中执行这些操作，必然会导致主线程长时间无法服务其他请求。为了避免阻塞式操作，Redis 提供了异步线程机制。所谓的异步线程机制，就是指，Redis 会启动一些子线程，然后把一些任务交给这些子线程，让它们在后台完成，而不再由主线程来执行这些任务。使用异步线程机制执行操作，可以避免阻塞主线程。</p><h2 id="哪些阻塞点可以异步执行"><a href="#哪些阻塞点可以异步执行" class="headerlink" title="哪些阻塞点可以异步执行"></a>哪些阻塞点可以异步执行</h2><p>&emsp;&emsp;如果一个操作能被异步执行，就意味着，它并不是 Redis 主线程的关键路径上的操作。关键路径上的操作就是客户端把请求发送给 Redis 后，等着 Redis 返回数据结果的操作。</p><p><img lazyload src="/images/loading.svg" data-src="redis71.jpg" alt="avatar"><br>&emsp;&emsp;主线程接收到操作 1 后，因为操作 1 并不用给客户端返回具体的数据，所以，主线程可以把它交给后台子线程来完成，同时只要给客户端返回一个“OK”结果就行。在子线程执行操作 1 的时候，客户端又向 Redis 实例发送了操作 2，而此时，客户端是需要使用操作 2 返回的数据结果的，如果操作 2 不返回结果，那么，客户端将一直处于等待状态。</p><ol><li><p>集合全量查询和聚合操作<br>&emsp;&emsp;对于 Redis 来说，读操作是典型的关键路径操作，因为客户端发送了读操作之后，就会等待读取的数据返回，以便进行后续的数据处理。而 Redis 的第一个阻塞点“集合全量查询和聚合操作”都涉及到了读操作，所以，它们是不能进行异步操作了。</p></li><li><p>bigkey 删除 &amp; 清空数据库<br>&emsp;&emsp;我们再来看看删除操作。删除操作并不需要给客户端返回具体的数据结果，所以不算是关键路径操作。而我们刚才总结的第二个阻塞点“bigkey 删除”，和第三个阻塞点“清空数据库”，都是对数据做删除，并不在关键路径上。因此，我们可以使用后台子线程来异步执行删除操作。</p></li><li><p>AOF 日志同步<br>&emsp;&emsp;对于第四个阻塞点“AOF 日志同步写”来说，为了保证数据可靠性，Redis 实例需要保证 AOF 日志中的操作记录已经落盘，这个操作虽然需要实例等待，但它并不会返回具体的数据结果给实例。所以，我们也可以启动一个子线程来执行 AOF 日志的同步写，而不用让主线程等待 AOF 日志的写完成。</p></li><li><p>从库加载 RDB 文件<br>&emsp;&emsp;最后，我们再来看下“从库加载 RDB 文件”这个阻塞点。从库要想对客户端提供数据存取服务，就必须把 RDB 文件加载完成。所以，这个操作也属于关键路径上的操作，我们必须让从库的主线程来执行。</p></li></ol><p>&emsp;&emsp;对于 Redis 的五大阻塞点来说，除了“集合全量查询和聚合操作”和“从库加载 RDB 文件”，其他三个阻塞点涉及的操作都不在关键路径上，所以，我们可以使用 Redis 的异步子线程机制来实现 bigkey 删除，清空数据库，以及 AOF 日志同步写。</p><h2 id="Redis-的异步子线程机制"><a href="#Redis-的异步子线程机制" class="headerlink" title="Redis 的异步子线程机制"></a>Redis 的异步子线程机制</h2><p>&emsp;&emsp;Redis 主线程启动后，会<strong>使用操作系统提供的 pthread_create 函数创建 3 个子线程</strong>，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。</p><ol><li>键值对删除子线程<br>&emsp;&emsp;主线程通过一个链表形式的任务队列和子线程进行交互。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成。但实际上，这个时候删除还没有执行，等到后台子线程从任务队列中读取任务后，才开始实际删除键值对，并释放相应的内存空间。因此，我们把这种异步删除也称为惰性删除（lazy free）。此时，删除或清空操作不会阻塞主线程，这就避免了对主线程的性能影响。<br>&emsp;&emsp;异步的键值对删除和数据库清空操作是 Redis 4.0 后提供的功能，Redis 也提供了新的命令来执行这两个操作。</li></ol><ul><li>键值对删除：当集合类型中有大量元素（例如有百万级别或千万级别元素）需要删除时，建议使用 UNLINK 命令。</li><li>清空数据库：可以在 FLUSHDB 和 FLUSHALL 命令后加上 ASYNC 选项，这样就可以让后台子线程异步地清空数据库，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FLUSHDB ASYNC </span><br><span class="line">FLUSHALL ASYNC</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>AOF 日志同步<br>&emsp;&emsp;当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到任务队列中。后台子线程读取任务后，开始自行写入 AOF 日志，这样主线程就不用一直等待 AOF 日志写完了。</li></ol><p>&emsp;&emsp;下面这张图展示了 Redis 中的异步子线程执行机制:<br><img lazyload src="/images/loading.svg" data-src="redis72.jpg" alt="avatar"></p><h2 id="使用-scan-避免-keys-命令"><a href="#使用-scan-避免-keys-命令" class="headerlink" title="使用 scan 避免 keys 命令"></a>使用 scan 避免 keys 命令</h2><p>&emsp;&emsp;有时候需要从 Redis 实例成千上万的 key 中找出特定前缀的 key 列表来手动处理数据，可能是修改它的值，也可能是删除 key。这里就有一个问题，如何从海量的 key 中找出满足特定前缀的 key 列表来？Redis 提供了一个简单暴力的指令 keys 用来列出所有满足特定正则字符串规则的 key。这个指令使用非常简单，提供一个简单的正则字符串即可，但是有很明显的两个缺点。</p><ol><li>没有 offset、limit 参数，一次性吐出所有满足条件的 key，万一实例中有几百 w 个 key 满足条件，当你看到满屏的字符串刷的没有尽头时，你就知道难受了;</li><li>keys 算法是遍历算法，复杂度是 O(n)，如果实例中有千万级以上的 key，这个指令就会导致 Redis 服务卡顿，所有读写 Redis 的其它的指令都会被延后甚至会超时报错，因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续。</li></ol><p>&emsp;&emsp;因此在实际的生产环境中建议屏蔽掉 keys 命令。Redis 为了解决这个问题，它在 2.8 版本中加入了指令——scan。<br>&emsp;&emsp;scan 相比 keys 具备有以下特点：</p><ol><li>复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程；</li><li>提供 limit 参数，可以控制每次返回结果的最大条数，limit 只是对增量式迭代命令的一种提示(hint)，返回的结果可多可少；</li><li>同 keys 一样，它也提供模式匹配功能；</li><li>服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数；</li><li>返回的结果可能会有重复，需要客户端去重复，这点非常重要；</li><li>遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的；</li><li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零。</li></ol><h3 id="scan-基础使用"><a href="#scan-基础使用" class="headerlink" title="scan 基础使用"></a>scan 基础使用</h3><p><strong>SCAN cursor [MATCH pattern] [COUNT count]</strong><br>&emsp;&emsp;初始执行scan命令例如scan 0。SCAN命令是一个基于游标的迭代器。这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数，以此来延续之前的迭代过程。当SCAN命令的游标参数被设置为0时，服务器将开始一次新的迭代，而当redis服务器向用户返回值为0的游标时，表示迭代已结束，这是唯一迭代结束的判定方式，而不能通过返回结果集是否为空判断迭代结束。<br>&emsp;&emsp;scan 参数提供了三个参数，第一个是 cursor 整数值，第二个是 key 的正则模式，第三个是遍历的 limit hint。例如下面所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">scan 0 match key99* count 1000</span><br><span class="line">1) <span class="string">&quot;13912&quot;</span> </span><br><span class="line">2) 1) <span class="string">&quot;key997&quot;</span> </span><br><span class="line">   2) <span class="string">&quot;key9906&quot;</span> </span><br><span class="line">   3) <span class="string">&quot;key9957&quot;</span> </span><br><span class="line">   4) <span class="string">&quot;key9902&quot;</span> </span><br><span class="line">   5) <span class="string">&quot;key9971&quot;</span> </span><br><span class="line">   6) <span class="string">&quot;key9935&quot;</span> </span><br><span class="line">   7) <span class="string">&quot;key9958&quot;</span> </span><br><span class="line">   8) <span class="string">&quot;key9928&quot;</span> </span><br><span class="line">   9) <span class="string">&quot;key9931&quot;</span> </span><br><span class="line">   10) <span class="string">&quot;key9961&quot;</span> </span><br><span class="line">   11) <span class="string">&quot;key9948&quot;</span> </span><br><span class="line">   12) <span class="string">&quot;key9965&quot;</span> </span><br><span class="line">   13) <span class="string">&quot;key9937&quot;</span></span><br><span class="line">   </span><br><span class="line">scan 13912 match key99* count 1000</span><br><span class="line">1) <span class="string">&quot;5292&quot;</span> </span><br><span class="line">2) 1) <span class="string">&quot;key996&quot;</span> </span><br><span class="line">   2) <span class="string">&quot;key9960&quot;</span> </span><br><span class="line">   3) <span class="string">&quot;key9973&quot;</span> </span><br><span class="line">   4) <span class="string">&quot;key9978&quot;</span> </span><br><span class="line">   5) <span class="string">&quot;key9927&quot;</span></span><br><span class="line">   6) <span class="string">&quot;key995&quot;</span> </span><br><span class="line">   7) <span class="string">&quot;key9992&quot;</span> </span><br><span class="line">   8) <span class="string">&quot;key9993&quot;</span> </span><br><span class="line">   9) <span class="string">&quot;key9964&quot;</span> </span><br><span class="line">   10) <span class="string">&quot;key9934&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;返回结果分为两个部分：第一部分即 1) 就是下一次迭代游标，第二部分即 2) 就是本次迭代结果集。从上面的过程可以看到虽然提供的 limit 是 1000，但是返回的结果只有 10 个左右。因为这个 limit 不是限定返回结果的数量，而是限定服务器单次遍历的字典槽位数量(约等于)。如果将 limit 设置为 10，你会发现返回结果是空的，但是游标值不为零，意味着遍历还没结束。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scan 0 match key99* count 10</span><br><span class="line">1) <span class="string">&quot;15360&quot;</span> </span><br><span class="line">2) (empty list or <span class="built_in">set</span>)</span><br><span class="line">scan 15360 match key99* count 10</span><br><span class="line">1) <span class="string">&quot;2304&quot;</span> </span><br><span class="line">2) (empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h1 id="删除数据后为什么内存占用率还是很高？"><a href="#删除数据后为什么内存占用率还是很高？" class="headerlink" title="删除数据后为什么内存占用率还是很高？"></a>删除数据后为什么内存占用率还是很高？</h1><p>&emsp;&emsp;在使用 Redis 时，我们经常会遇到这样一个问题：明明做了数据删除，数据量已经不大 了，为什么使用 top 命令查看时，还会发现 Redis 占用了很多内存呢？首先要明白一个概念，那就是操作系统的内存碎片是什么。应用申请内存通常是一段连续的内存空间，以 64 位的系统为例，一个内存块的大小是 8 字节，当要保存一段 6 字节的数据时，会申请一块新的内存块，这样就会剩下 2 字节的内存没被占用并且也不会再被分配给其他的数据。这样就出现了 2 字节的内存碎片。<br><img lazyload src="/images/loading.svg" data-src="redis73.jpg" alt="avatar"></p><h2 id="出现内存碎片的原因"><a href="#出现内存碎片的原因" class="headerlink" title="出现内存碎片的原因"></a>出现内存碎片的原因</h2><h3 id="内因：内存分配器的分配策略"><a href="#内因：内存分配器的分配策略" class="headerlink" title="内因：内存分配器的分配策略"></a>内因：内存分配器的分配策略</h3><p>&emsp;&emsp;内存分配器的分配策略就决定了操作系统无法做到“按需分配”。这是因为，内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。<br>&emsp;&emsp;Redis 可以使用 libc、jemalloc、tcmalloc 多种内存分配器来分配内存，默认使用 jemalloc。接下来，就以 jemalloc 为例，来具体解释一下。其他分配器也存在类似的问题。<br>&emsp;&emsp;jemalloc 的分配策略之一，是按照一系列固定的大小划分内存空间，例如 8 字节、16 字节、32 字节、48 字节，…, 2KB、4KB、8KB 等。当程序申请的内存最接近某个固定值 ，jemalloc 会给它分配相应大小的空间。这样的分配方式本身是为了减少分配次数。例如，Redis 申请一个 20 字节的空间保存数据，jemalloc 就会分配 32 字节，此时，如果应用还要写入 10 字节的数据，Redis 就不用再向操作系统申请空间了，因为刚才分配的 32 字节已经够用了，这就避免了一次分配操作。但是，如果 Redis 每次向分配器申请的内存空间大小不一样，这种分配方式就会有形成碎片的风险，而这正好来源于 Redis 的外因了。</p><h3 id="外因：键值对大小不一样和删改操作"><a href="#外因：键值对大小不一样和删改操作" class="headerlink" title="外因：键值对大小不一样和删改操作"></a>外因：键值对大小不一样和删改操作</h3><p>&emsp;&emsp;Redis 通常作为共用的缓存系统或键值数据库对外提供服务，所以，不同业务应用的数据都可能保存在 Redis 中，这就会带来不同大小的键值对。这样一来，Redis 申请内存空间分配时，本身就会有大小不一的空间需求。这是第一个外因。<br>&emsp;&emsp;第二个外因是，这些键值对会被修改和删除，这会导致空间的扩容和释放。具体来说，一方面，如果修改后的键值对变大或变小了，就需要占用额外的空间或者释放不用的空间。另一方面，删除的键值对就不再需要内存空间了，此时，就会把空间释放出来，形成空闲空间。</p><h3 id="如何清理内存碎片？"><a href="#如何清理内存碎片？" class="headerlink" title="如何清理内存碎片？"></a>如何清理内存碎片？</h3><p>&emsp;&emsp;当 Redis 发生内存碎片后，一个“简单粗暴”的方法就是重启 Redis 实例。当然，这并不是一个“优雅”的方法，毕竟，重启 Redis 会带来两个后果：</p><ol><li>如果 Redis 中的数据没有持久化，那么，数据就会丢失；</li><li>即使 Redis 数据持久化了，我们还需要通过 AOF 或 RDB 进行恢复，恢复时长取决于 AOF 或 RDB 的大小，如果只有一个 Redis 实例，恢复阶段无法提供服务。</li></ol><p>清理过程如下：<br><img lazyload src="/images/loading.svg" data-src="redis74.jpg" alt="avatar"><br>&emsp;&emsp;不过，需要注意的是：碎片清理是有代价的，操作系统需要把多份数据拷贝到新位置，把原有空间释放出来，这会带来时间开销。因为 Redis 是单线程，在数据拷贝时，Redis 只能等着，这就导致 Redis 无法及时处理请求，性能就会降低。而且，有的时候，数据拷贝还需要注意顺序，就像刚刚说的清理内存碎片的例子，操作系统需要先拷贝 D，并释放 D 的空间后，才能拷贝 B。这种对顺序性的要求，会进一步增加 Redis 的等待时间，导致性能降低。那么，有什么办法可以尽量缓解这个问题吗？这就要提到，Redis 专门为自动内存碎片清理功机制设置的参数了。我们可以通过设置参数，来控制碎片清理的开始和结束时机，以及占用的 CPU 比例，从而减少碎片清理对 Redis 本身请求处理的性能影响。</p><p>&emsp;&emsp;首先，Redis 需要启用自动内存碎片清理，可以把 activedefrag 配置项设置为 yes，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> activedefrag yes</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;自动内存碎片清理机制在控制碎片清理启停的时机上，既考虑了碎片的空间占比、对 Redis 内存使用效率的影响，还考虑了清理机制本身的 CPU 时间占比、对 Redis 性能的影响。</p><h1 id="Redis-作为缓存的两种策略"><a href="#Redis-作为缓存的两种策略" class="headerlink" title="Redis 作为缓存的两种策略"></a>Redis 作为缓存的两种策略</h1><p>&emsp;&emsp;在商品大促的场景中，商品的库存信息会一直被修改。如果每次修改都需到数据库中处理，就会拖慢整个应用，此时，我们通常会选择读写缓存的模式。而在短视频 App 的场景中，虽然视频的属性有很多，但是，一般确定后，修改并不频繁，此时，在数据库中进行修改对缓存影响不大，所以只读缓存模式是一个合适的选择。</p><h2 id="只读缓存"><a href="#只读缓存" class="headerlink" title="只读缓存"></a>只读缓存</h2><p>&emsp;&emsp;当 Redis 用作只读缓存时，应用要读取数据的话，会先调用 Redis GET 接口，查询数据是否存在。而所有的数据写请求，会直接发往后端的数据库，在数据库中增删改。对于删 的数据来说，如果 Redis 已经缓存了相应的数据，应用需要把这些缓存的数据删除，Redis 中就没有这些数据了。当应用再次读取这些数据时，会发生缓存缺失，应用会把这些数据从数据库中读出来，并写到缓存中。这样一来，这些数据后续再被读取时，就可以直接从缓存中获取了，能起到加速访问的效果。举个例子。假设业务应用要修改数据 A，此时，数据 A 在 Redis 中也缓存了，那么，应用会先直接在数据库里修改 A，并把 Redis 中的 A 删除。等到应用需要读取数据 A 时，会发生缓存缺失，此时，应用从数据库中读取 A，并写入 Redis，以便后续请求从缓存中直接读取，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis75.jpg" alt="avatar"><br>&emsp;&emsp;只读缓存直接在数据库中更新数据的好处是，所有最新的数据都在数据库中，而数据库是提供数据可靠性保障的，这些数据不会有丢失的风险。当我们需要缓存图片、短视频这些用户只读的数据时，就可以使用只读缓存这个类型了。</p><h2 id="读写缓存"><a href="#读写缓存" class="headerlink" title="读写缓存"></a>读写缓存</h2><p>&emsp;&emsp;对于读写缓存来说，除了读请求会发送到缓存进行处理（直接在缓存中查询数据是否存在)，所有的写请求也会发送到缓存，在缓存中直接对数据进行增删改操作。此时，得益于 Redis 的高性能访问特性，数据的增删改操作可以在缓存中快速完成，处理结果也会快速返回给业务应用，这就可以提升业务应用的响应速度。但是，和只读缓存不一样的是，在使用读写缓存时，最新的数据是在 Redis 中，而 Redis 是内存数据库，一旦出现掉电或宕机，内存中的数据就会丢失。这也就是说，应用的最新数据可能会丢失，给应用业务带来风险。所以，根据业务应用对数据可靠性和缓存性能的不同要求，我们会有同步直写和异步写回两种策略。其中，同步直写策略优先保证数据可靠性，而异步写回策略优先提供快速响应。学习了解这两种策略，可以帮助我们根据业务需求，做出正确的设计选择。</p><p>&emsp;&emsp;关于是选择只读缓存，还是读写缓存，主要看我们对写请求是否有加速的需求。</p><ul><li>如果需要对写请求进行加速，我们选择读写缓存；</li><li>如果写请求很少，或者是只需要提升读请求的响应速度的话，我们选择只读缓存。</li></ul><h3 id="同步直写"><a href="#同步直写" class="headerlink" title="同步直写"></a>同步直写</h3><p>&emsp;&emsp;写请求发给缓存的同时，也会发给后端数据库进行处理，等到缓存和数据库都写完数据，才给客户端返回。这样，即使缓存宕机或发生故障，最新的数据仍然保存在数据库中，这就提供了数据可靠性保证。不过，同步直写会降低缓存的访问性能。这是因为缓存中处理写请求的速度是很快的，而数据库处理写请求的速度较慢。即使缓存很快地处理了写请求，也需要等待数据库处理完所有的写请求，才能给应用返回结果，这就增加了缓存的响应延迟。</p><h3 id="异步写回"><a href="#异步写回" class="headerlink" title="异步写回"></a>异步写回</h3><p>&emsp;&emsp;而异步写回策略，则是优先考虑了响应延迟。此时，所有写请求都先在缓存中处理。等到这些增改的数据要被从缓存中淘汰出来时，缓存将它们写回后端数据库。这样一来，处理这些数据的操作是在缓存中进行的，很快就能完成。只不过，如果发生了掉电，而它们还没有被写回数据库，就会有丢失的风险了。</p><h1 id="Redis-的缓存策略"><a href="#Redis-的缓存策略" class="headerlink" title="Redis 的缓存策略"></a>Redis 的缓存策略</h1><p><img lazyload src="/images/loading.svg" data-src="redis76.jpg" alt="avatar"></p><ol><li><p>noeviction<br>&emsp;&emsp;默认情况下，Redis 在使用的内存空间超过 maxmemory 值时，并不会淘汰数据，也就是设定的 noeviction 策略。对应到 Redis 缓存，也就是指，一旦缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误。Redis 用作缓存时，实际的数据集通常都是大于缓存容量的，总会有新的数据要写入缓存，这个策略本身不淘汰数据，也就不会腾出新的缓存空间，我们不把它用在 Redis 缓存中。</p></li><li><p>volatile：只在设置了过期时间的键值对中进行删除</p></li><li><ol><li>volatile-ttl 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除；</li></ol></li><li><ol start="2"><li>volatile-random 在设置了过期时间的键值对中，进行随机删除；</li></ol></li><li><ol start="3"><li>volatile-lru 使用 LRU 算法筛选设置了过期时间的键值对；</li></ol></li><li><ol start="4"><li>volatile-lfu 使用 LFU 算法选择设置了过期时间的键值对。</li></ol></li></ol><p>&emsp;&emsp;如果一个键值对被删除策略选中了，即使它的过期时间还没到，也需要被删 除。当然，如果它的过期时间到了但未被策略选中，同样也会被删除。</p><ol start="3"><li>allkeys：备选淘汰数据范围，扩大到了所有键值对，无论这些键值对是否设置了过期时间</li><li><ol><li>allkeys-random：从所有键值对中随机选择并删除数据；</li></ol></li><li><ol start="2"><li>allkeys-lru：使用 LRU 算法在所有数据中进行筛选；</li></ol></li><li><ol start="3"><li>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选。</li></ol></li></ol><h2 id="如何处理被淘汰的数据？"><a href="#如何处理被淘汰的数据？" class="headerlink" title="如何处理被淘汰的数据？"></a>如何处理被淘汰的数据？</h2><p>&emsp;&emsp;一般来说，一旦被淘汰的数据选定后，如果这个数据是干净数据，那么我们就直接删除；如果这个数据是脏数据，我们需要把它写回数据库，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis77.jpg" alt="avatar"><br>那怎么判断一个数据到底是干净的还是脏的呢？干净数据和脏数据的区别就在于，和最初从后端数据库里读取时的值相比，有没有被修改过。干净数据一直没有被修改，所以后端数据库里的数据也是最新值。在替换时，它可以被直接删除。而脏数据就是曾经被修改过的，已经和后端数据库中保存的数据不一致了。此时，如果不把脏数据写回到数据库中，这个数据的最新值就丢失了，就会影响应用的正常使用。</p><h1 id="缓存和数据库的数据一致问题"><a href="#缓存和数据库的数据一致问题" class="headerlink" title="缓存和数据库的数据一致问题"></a>缓存和数据库的数据一致问题</h1><h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><p>“一致性”包含了两种情况：</p><ol><li>缓存中有数据，那么，缓存的数据值需要和数据库中的值相同；</li><li>缓存中本身没有数据，那么，数据库中的值必须是最新值。</li></ol><h2 id="只读缓存的数据一致问题"><a href="#只读缓存的数据一致问题" class="headerlink" title="只读缓存的数据一致问题"></a>只读缓存的数据一致问题</h2><h3 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h3><p>&emsp;&emsp;如果是新增数据，数据会直接写到数据库中，不用对缓存做任何操作，此时，缓存中本身就没有新增数据，而数据库中是最新值，这种情况符合我们刚刚所说的一致性的第 2 种情况，所以，此时，缓存和数据库的数据是一致的。</p><h3 id="删改数据"><a href="#删改数据" class="headerlink" title="删改数据"></a>删改数据</h3><p>&emsp;&emsp;如果发生删改操作，应用既要更新数据库，也要在缓存中删除数据。这两个操作如果无法保证原子性，也就是说，要不都完成，要不都没完成，此时，就会出现数据不一致问题了。</p><ul><li><p>先删除缓存，再更新数据库<br>我们假设应用先删除缓存，再更新数据库，如果缓存删除成功，但是数据库更新失败，那么，应用再访问数据时，缓存中没有数据，就会发生缓存缺失。然后，应用再访问数据库，但是数据库中的值为旧值，应用就访问到旧值了。<br><img lazyload src="/images/loading.svg" data-src="redis78.jpg" alt="avatar"><br>&emsp;&emsp;应用要把数据 X 的值从 10 更新为 3，先在 Redis 缓存中删除了 X 的缓存值，但是更新数据库却失败了。如果此时有其他并发的请求访问 X，会发现 Redis 中缓存缺失，紧接着，请求就会访问数据库，读到的却是旧值 10。</p></li><li><p>先更新数据库，再删除缓存<br>&emsp;&emsp;如果应用先完成了数据库的更新，但是，在删除缓存时失败了，那么，数据库中的值是新值，而缓存中的是旧值，这肯定是不一致的。这个时候，如果有其他的并发请求来访问数据，按照正常的缓存访问流程，就会先在缓存中查询，但此时，就会读到旧值了。<br><img lazyload src="/images/loading.svg" data-src="redis79.jpg" alt="avatar"><br>&emsp;&emsp;应用要把数据 X 的值从 10 更新为 3，先成功更新了数据库，然后在 Redis 缓存中删除 X 的缓存，但是这个操作却失败了，这个时候，数据库中 X 的新值为 3，Redis 中的 X 的缓存值为 10，这肯定是不一致的。如果刚好此时有其他客户端也发送请求访问 X，会先在 Redis 中查询，该客户端会发现缓存命中，但是读到的却是旧值 10。</p></li></ul><p>&emsp;&emsp;我们可以看到，在更新数据库和删除缓存值的过程中，无论这两个操作的执行顺序谁先谁后，只要有一个操作失败了，就会导致客户端读取到旧值。下面这张表总结了刚刚所说的这两种情况。<br><img lazyload src="/images/loading.svg" data-src="redis80.jpg" alt="avatar"></p><h4 id="如何解决数据不一致问题？"><a href="#如何解决数据不一致问题？" class="headerlink" title="如何解决数据不一致问题？"></a>如何解决数据不一致问题？</h4><p><strong>重试机制</strong>：具体来说，可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用 Kafka 消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。<br>&emsp;&emsp;如果能够成功地删除或更新，我们就要把这些值从消息队列中去除，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了。否则的话，我们还需要再次进行重试。如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。<br><img lazyload src="/images/loading.svg" data-src="redis81.jpg" alt="avatar"></p><p><strong>并发情况下怎样解决</strong></p><ul><li>情况一：先删除缓存，再更新数据库<br>&emsp;&emsp;假设线程 A 删除缓存值后，还没有来得及更新数据库（比如说有网络延迟），线程 B 就开始读取数据了，那么这个时候，线程 B 会发现缓存缺失，就只能去数据库读取。这会带来两个问题：</li></ul><ol><li>线程 B 读取到了旧值；</li><li>线程 B 是在缓存缺失的情况下读取的数据库，所以，它还会把旧值写入缓存，这可能会导致其他线程从缓存中读到旧值。<br>&emsp;&emsp;等到线程 B 从数据库读取完数据、更新了缓存后，线程 A 才开始更新数据库，此时，缓存中的数据是旧值，而数据库中的是最新值，两者就不一致了。<br><img lazyload src="/images/loading.svg" data-src="redis82.jpg" alt="avatar"></li></ol><p><strong>解决方案</strong>：在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间，再进行一次缓存删除操作。<br>&emsp;&emsp;之所以要加上 sleep 的这段时间，就是为了让线程 B 能够先从数据库读取数据，再把缺失的数据写入缓存，然后，线程 A 再进行删除。所以，线程 A sleep 的时间，就需要大于线程 B 读取数据再写入缓存的时间。这个时间怎么确定呢？建议你在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，以此为基础来进行估算。这样一来，其它线程读取数据时，会发现缓存缺失，所以会从数据库中读取最新值。因为这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，所以我们也把它叫做“延迟双删”。下面的这段伪代码就是“延迟双删”方案的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis.delKey(X) // 先删除缓存</span><br><span class="line">db.update(X)// 再更新数据库</span><br><span class="line">Thread.sleep(N) // 睡眠一会儿</span><br><span class="line">redis.delKey(X) // 再删除一遍缓存，确保之后缓存中的数据是更新后的</span><br></pre></td></tr></table></figure><ul><li>情况二：先更新数据库值，再删除缓存值<br>&emsp;&emsp;如果线程 A 删除了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了，那么此时，线程 B 查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。不过，在这种情况下，如果其他线程并发读缓存的请求不多，那么，就不会有很多请求读取到旧值。而且，线程 A 一般也会很快删除缓存值，这样一来，其他线程再次读取时，就会发生缓存缺失，进而从数据库中读取最新值。所以，这种情况对业务的影响较小。<br><img lazyload src="/images/loading.svg" data-src="redis83.jpg" alt="avatar"></li></ul><p>&emsp;&emsp;总结一下上述的解决方案：</p><ol><li>删除缓存和更新数据库的“原子”操作：使用消息队列，当前一个事件完成后立即向消息队列中投递消息，只有当后续事件成功才消费掉这个消息，避免之后的事件因为失败而导致数据不一致；</li><li>如果采用先删除缓存，再更新数据库的策略，使用“延迟双删”方案：确保缓存中的数据最终一定和数据库一致。<br><img lazyload src="/images/loading.svg" data-src="redis84.jpg" alt="avatar"></li></ol><h2 id="读写缓存的数据一致问题"><a href="#读写缓存的数据一致问题" class="headerlink" title="读写缓存的数据一致问题"></a>读写缓存的数据一致问题</h2><p>&emsp;&emsp;这种情况删改操作同时操作数据库和缓存。</p><h3 id="新增数据-1"><a href="#新增数据-1" class="headerlink" title="新增数据"></a>新增数据</h3><p>&emsp;&emsp;同只读缓存</p><h3 id="删改数据-1"><a href="#删改数据-1" class="headerlink" title="删改数据"></a>删改数据</h3><ul><li><strong>重试机制</strong>：同只读缓存</li></ul><ol><li>先更新数据库，再更新缓存：如果更新数据库成功，但缓存更新失败，此时数据库中是最新值，但缓存中是旧值，后续的读请求会直接命中缓存，得到的是旧值。  </li><li>先更新缓存，再更新数据库：如果更新缓存成功，但数据库更新失败，此时缓存中是最新值，数据库中是旧值，后续读请求会直接命中缓存，但得到的是最新值，短期对业务影响不大。但是，一旦缓存过期或者满容后被淘汰，读请求就会从数据库中重新加载旧值到缓存中，之后的读请求会从缓存中得到旧值，对业务产生影响。  </li></ol><p>&emsp;&emsp;同样地，针对这种其中一个操作可能失败的情况，也可以使用重试机制解决，把第二步操作放入到消息队列中，消费者从消息队列取出消息，再更新缓存或数据库，成功后把消息从消息队列删除，否则进行重试，以此达到数据库和缓存的最终一致。</p><p><strong>并发情况下怎样解决</strong></p><ol><li><p>先更新数据库，再更新缓存，写+读并发：线程A先更新数据库，之后线程B读取数据，此时线程B会命中缓存，读取到旧值，之后线程A更新缓存成功，后续的读请求会命中缓存得到最新值。这种场景下，线程A未更新完缓存之前，在这期间的读请求会短暂读到旧值，对业务短暂影响。</p></li><li><p>先更新缓存，再更新数据库，写+读并发：线程A先更新缓存成功，之后线程B读取数据，此时线程B命中缓存，读取到最新值后返回，之后线程A更新数据库成功。这种场景下，虽然线程A还未更新完数据库，数据库会与缓存存在短暂不一致，但在这之前进来的读请求都能直接命中缓存，获取到最新值，所以对业务没影响。</p></li><li><p>先更新数据库，再更新缓存，写+写并发：线程A和线程B同时更新同一条数据，假如更新数据库的顺序是先A后B，但更新缓存时顺序是先B后A，这会导致数据库和缓存的不一致。</p></li><li><p>先更新缓存，再更新数据库，写+写并发：与场景3类似，线程A和线程B同时更新同一条数据，假如更新缓存的顺序是先A后B，但是更新数据库的顺序是先B后A，这也会导致数据库和缓存的不一致。</p></li></ol><p>总结：场景1和2对业务影响较小，场景3和4会造成数据库和缓存不一致，影响较大。也就是说，在读写缓存模式下，写+读并发对业务的影响较小，而写+写并发时，会造成数据库和缓存的不一致。针对场景3和4的解决方案是，对于写请求，需要配合分布式锁使用。写请求进来时，针对同一个资源的修改操作，先加分布式锁，这样同一时间只允许一个线程去更新数据库和缓存，没有拿到锁的线程把操作放入到队列中，延时处理。用这种方式保证多个线程操作同一资源的顺序性，以此保证一致性。综上，使用读写缓存同时操作数据库和缓存时，因为其中一个操作失败导致不一致的问题，同样可以通过<strong>消息队列</strong>重试来解决。而在并发的场景下，读+写并发对业务没有影响或者影响较小，而<strong>写+写并发时需要配合分布式锁</strong>的使用，才能保证缓存和数据库的一致性。</p><p>&emsp;&emsp;另外，读写缓存模式由于会同时更新数据库和缓存，优点是，缓存中一直会有数据，如果更新操作后会立即再次访问，可以直接命中缓存，能够降低读请求对于数据库的压力（没有了只读缓存的删除缓存导致缓存缺失和再加载的过程）。缺点是，如果更新后的数据，之后很少再被访问到，会导致缓存中保留的不是最热的数据，缓存利用率不高（只读缓存中保留的都是热数据），所以读写缓存比较适合用于读写相当的业务场景。</p><h1 id="如何解决缓存雪崩、击穿、穿透难题？"><a href="#如何解决缓存雪崩、击穿、穿透难题？" class="headerlink" title="如何解决缓存雪崩、击穿、穿透难题？"></a>如何解决缓存雪崩、击穿、穿透难题？</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>&emsp;&emsp;缓存雪崩是指大量的应用请求无法在 Redis 缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。缓存雪崩一般是由两个原因导致的，应对方案也有所不同，我们一个个来看。</p><ol><li>第一个原因是：缓存中有大量数据同时过期，导致大量请求无法得到处理。</li></ol><p><strong>如何避免</strong>：首先，我们可以避免给大量的数据设置相同的过期时间。如果业务层的确要求有些数据同时失效，你可以在用 EXPIRE 命令给每个数据设置过期时间时，给这些数据的过期时间增加一个较小的随机数（例如，随机增加 1~3 分钟），这样一来，不同数据的过期时间有所差别，但差别又不会太大，既避免了大量数据同时过期，同时也保证了这些数据基本在相近的时间失效，仍然能满足业务需求。除了微调过期时间，我们还可以通过<strong>服务降级</strong>，来应对缓存雪崩。所谓的服务降级，是指发生缓存雪崩时，针对不同的数据采取不同的处理方式。当业务应用访问的是非核心数据（例如电商商品属性）时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息；当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存 缺失，也可以继续通过数据库读取。<br>&emsp;&emsp;这样一来，只有部分过期数据的请求会发送到数据库，数据库的压力就没有那么大了。下面这张图显示的是服务降级时数据请求的执行情况：<br><img lazyload src="/images/loading.svg" data-src="redis85.jpg" alt="avatar"><br>2. Redis 缓存实例发生故障宕机了，无法处理请求，这就会导致大量请求一下子积压到数据库层，从而发生缓存雪崩。<br><strong>如何避免</strong>：<strong>在业务系统中实现服务熔断或请求限流机制</strong>，所谓的服务熔断，是指在发生缓存雪崩时，为了防止引发连锁的数据库雪崩，甚至是整个系统的崩溃，我们暂停业务应用对缓存系统的接口访问。再具体点说，就是业务应用调用缓存接口时，缓存客户端并不把请求发给 Redis 缓存实例，而是直接返回，等到 Redis 缓存实例重新恢复服务后，再允许应用请求发送到缓存系统。<br>&emsp;&emsp;服务熔断虽然可以保证数据库的正常运行，但是暂停了整个缓存系统的访问，对业务应用的影响范围大。为了尽可能减少这种影响，我们也可以进行请求限流。这里说的请求限流，就是指，我们在业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库。<br>&emsp;&emsp;<strong>事前预防</strong>： 通过主从节点的方式构建 Redis 缓存高可靠集群。如果 Redis 缓存的主节点故障宕机了，从节点还可以切换成为主节点，继续提供缓存服务，避免了由于缓存实例宕机而导致的缓存雪崩问题。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>&emsp;&emsp;缓存击穿是指，针对某个访问非常频繁的热点数据的请求，无法在缓存中进行处理，紧接着，访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力激增，会影响数据库处理其他请求。缓存击穿的情况，经常发生在热点数据过期失效时，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis86.jpg" alt="avatar"><br><strong>如何避免</strong>：为了避免缓存击穿给数据库带来的激增压力，我们的解决方法也比较直接，对于访问特别频繁的热点数据，我们就不设置过期时间了。这样一来，对热点数据的访问请求，都可以在缓存中进行处理，而 Redis 数万级别的高吞吐量可以很好地应对大量的并发请求访问。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>&emsp;&emsp;缓存穿透是指要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。此时，应用也无法从数据库中读取数据再写入缓存，来服务后续请求，这样一来，缓存也就成了“摆设”，如果应用持续有大量请求访问数据，就会同时给缓存和数据库带来巨大压力，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis87.jpg" alt="avatar"><br>&emsp;&emsp;缓存穿透会发生在什么时候呢？一般来说，有两种情况。</p><ol><li>业务层误操作：缓存中的数据和数据库中的数据被误删除了，所以缓存和数据库中都没 有数据；</li><li>恶意攻击：专门访问数据库中没有的数据。</li></ol><p><strong>如何避免</strong>：</p><ol><li><strong>缓存空值或缺省值</strong>：一旦发生缓存穿透，我们就可以针对查询的数据，在 Redis 中缓存一个空值或是和业务层协商确定的缺省值（例如，库存的缺省值可以设为 0）。紧接着，应用发送的后续请求再进行查询时，就可以直接从 Redis 中读取空值或缺省值，返回给业务应用了，避免了把大量请求发送给数据库处理，保持了数据库的正常运行。</li><li>使用<strong>布隆过滤器</strong>快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。布隆过滤器由一个初值都为 0 的 bit 数组和 N 个哈希函数组成，可以用来快速判断某个数据是否存在。当我们想标记某个数据存在时（例如，数据已被写入数据库），布隆过滤器会通过三个操作完成标记：首先，使用 N 个哈希函数，分别计算这个数据的哈希值，得到 N 个哈希值；然后，我们把这 N 个哈希值对 bit 数组的长度取模，得到每个哈希值在数组中的对应位置；最后，我们把对应位置的 bit 位设置为 1，这就完成了在布隆过滤器中标记数据的操作。当需要查询某个数据时，我们就执行刚刚说的计算过程，先得到这个数据在 bit 数组中对应的 N 个位置。紧接着，我们查看 bit 数组中这 N 个位置上的 bit 值。只要这 N 个 bit 值 有一个不为 1，这就表明布隆过滤器没有对该数据做过标记，所以，查询的数据一定没有 在数据库中保存。<br><img lazyload src="/images/loading.svg" data-src="redis88.jpg" alt="avatar"><br>&emsp;&emsp;图中布隆过滤器是一个包含 10 个 bit 位的数组，使用了 3 个哈希函数，当在布隆过滤器中标记数据 X 时，X 会被计算 3 次哈希值，并对 10 取模，取模结果分别是 1、3、7。所 以，bit 数组的第 1、3、7 位被设置为 1。当应用想要查询 X 时，只要查看数组的第 1、 3、7 位是否为 1，只要有一个为 0，那么，X 就肯定不在数据库中。<br>&emsp;&emsp;正是基于布隆过滤器的快速检测特性，我们可以在把数据写入数据库时，使用布隆过滤器做个标记。当缓存缺失后，应用查询数据库时，可以通过查询布隆过滤器快速判断数据是否存在。如果不存在，就不用再去数据库中查询了。这样一来，即使发生缓存穿透了，大量请求只会查询 Redis 和布隆过滤器，而不会积压到数据库，也就不会影响数据库的正常 运行。布隆过滤器可以使用 Redis 实现，本身就能承担较大的并发访问压力。<strong>判断数据不在布隆过滤器中，一定不在数据库中，直接返回。判断在布隆过滤器中，可能误判，不一定在数据库中，若不在数据库中仍然发生缓存穿透，然后缓存空值或缺省值</strong>。</li><li>最后一种方案是，<strong>在请求入口的前端进行请求检测</strong>。缓存穿透的一个原因是有大量的恶意请求访问不存在的数据，所以，一个有效的应对方案是在请求入口前端，对业务系统接收到的请求进行合法性检测，把恶意的请求（例如请求参数不合理、请求参数是非法值、请 求字段不存在）直接过滤掉，不让它们访问后端缓存和数据库。这样一来，也就不会出现缓存穿透问题了。</li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img lazyload src="/images/loading.svg" data-src="redis89.jpg" alt="avatar"><br>&emsp;&emsp;，服务熔断、服务降级、请求限流这些方法都是属于“有损”方案，在保证数据库和整体系统稳定的同时，会对业务应用带来负面影响。例如使用服务降级时，有部分数据的请求就只能得到错误返回信息，无法正常处理。如果使用了服务熔断，那么，整个缓存系统的服务都被暂停了，影响的业务范围更大。而使用了请求限流机制后，整个业务系统的吞吐率会降低，能并发处理的用户请求会减少，会影响到用户体验。所以建议尽量使用尽量使用预防式方案：</p><ol><li>针对缓存雪崩，合理地设置数据过期时间，以及搭建高可靠缓存集群；</li><li>针对缓存击穿，在缓存访问非常频繁的热点数据时，不要设置过期时间；</li><li>针对缓存穿透，提前在入口前端实现恶意请求检测，或者规范数据库的数据删除操作，避免误删除。</li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>&emsp;&emsp;在提到缓存雪崩时，可以采用服务熔断、服务降级、请求限流的方式来应对。这三个机制可以用来应对混存穿透问题吗？还有没有其他策略来解决这一问题？</p><blockquote><p> 服务熔断、服务降级、请求限流这三个机制不适合来处理缓存穿透的场景。 三个机制都是在服务不可用时来减少影响的，缓存穿透的场景下，本质上服务是可用的， 如果使用上述三个机制会影响其他正常的请求。可以记录ip和穿透访问的次数，频率超过阈值的ip直接拉黑</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;String-类型的底层数据结构&quot;&gt;&lt;a href=&quot;#String-类型的底层数据结构&quot; class=&quot;headerlink&quot; title=&quot;String 类型的底层数据结构&quot;&gt;&lt;/a&gt;String 类型的底层数据结构&lt;/h1&gt;&lt;h2 id=&quot;为什么-Strin</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiahaohong1997.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Redis" scheme="http://jiahaohong1997.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SQL学习笔记</title>
    <link href="http://jiahaohong1997.github.io/2022/01/05/SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://jiahaohong1997.github.io/2022/01/05/SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-05T12:31:00.000Z</published>
    <updated>2022-01-05T12:45:59.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL中的SQL是如何执行的"><a href="#MySQL中的SQL是如何执行的" class="headerlink" title="MySQL中的SQL是如何执行的"></a>MySQL中的SQL是如何执行的</h1><p>&emsp;&emsp;MySQL是典型的 Client/Server 架构，服务器端程序使用的是 mysqld。整体的 MySQL 流程如下图所示：<br><img lazyload src="/images/loading.svg" data-src="mysql1.jpg" alt="avatar"><br>&emsp;&emsp;可以看到的MySQL三层：</p><ol><li>==连接层==：客户端和服务端建立连接（例如tcp），客户端发送 SQL 至服务端；</li><li>==SQL 层==：对 SQL 语句进行查询处理；</li><li>==存储引擎层==：与数据库文件打交道，负责数据的存储和读取。</li></ol><h2 id="SQL-层"><a href="#SQL-层" class="headerlink" title="SQL 层"></a>SQL 层</h2><p>其中 SQL 层与数据库文件的存储方式无关，我们来看下 SQL 层的结构：<br><img lazyload src="/images/loading.svg" data-src="mysql2.jpg" alt="avatar"><br>&emsp;&emsp;其流程总结如下：</p><ol><li>==查询缓存==：服务端接收到客户端的 SQL 语句后，先在缓存中查询该语句，有结果命中缓存就直接返回给客户端；如果没有就进入到解析器阶段；</li><li>==解析器==：在解析器中对 SQL 语句进行语法分析、语义分析；</li><li>==优化器==：在优化器中会确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引来检索等；</li><li>==执行器==：在执行之前需要判断该用户是否具备权限，如果具备权限就执行 SQL 查询并返回结果。如果设置了查询缓存，这时会将查询结果进行缓存。</li></ol><p>SQL 语句→缓 存查询→解析器→优化器→执行器</p><h2 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h2><p>&emsp;&emsp;MySQL 的存储引擎采用了插件的形 式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎。</p><ol><li>==InnoDB 存储引擎==：MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。</li><li>==MyISAM 存储引擎==：MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。</li><li>Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。</li><li>NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</li><li>Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL中的SQL是如何执行的&quot;&gt;&lt;a href=&quot;#MySQL中的SQL是如何执行的&quot; class=&quot;headerlink&quot; title=&quot;MySQL中的SQL是如何执行的&quot;&gt;&lt;/a&gt;MySQL中的SQL是如何执行的&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;My</summary>
      
    
    
    
    <category term="SQL" scheme="http://jiahaohong1997.github.io/categories/SQL/"/>
    
    
    <category term="MySQL" scheme="http://jiahaohong1997.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记（二）</title>
    <link href="http://jiahaohong1997.github.io/2022/01/05/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/01/05/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-01-05T03:10:00.000Z</published>
    <updated>2022-02-17T13:28:31.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两大纬度，三大主线"><a href="#两大纬度，三大主线" class="headerlink" title="两大纬度，三大主线"></a>两大纬度，三大主线</h1><p><img lazyload src="/images/loading.svg" data-src="redis1.jpg" alt="avatar"></p><ul><li><p>两大维度</p></li><li><p><input disabled type="checkbox">  应用纬度</p></li><li><p><input disabled type="checkbox">  系统纬度</p></li><li><p>三大主线</p></li><li><p><input disabled type="checkbox">  ==高性能主线==，包括线程模型、数据结构、持久化、网络框架</p></li><li><p><input disabled type="checkbox">  ==高可靠主线==，包括主从复制、哨兵机制</p></li><li><p><input disabled type="checkbox">  ==高可扩展主线==，包括数据分片、负载均衡</p></li></ul><h2 id="Redis的组件和功能"><a href="#Redis的组件和功能" class="headerlink" title="Redis的组件和功能"></a>Redis的组件和功能</h2><p><img lazyload src="/images/loading.svg" data-src="redis2.jpg" alt="avatar"></p><ol><li>Redis 主要通过网络框架进行访问，而不再是动态库了，这也使得 Redis 可以作为一个基础性的网络服务进行访问，扩大了 Redis 的应用范围。</li><li>Redis 数据模型中的 value 类型很丰富，因此也带来了更多的操作接口，例如面向列表的 LPUSH/LPOP，面向集合的 SADD/SREM 等。</li><li>Redis 的持久化模块能支持两种方式：日志（AOF）和快照（RDB），这两种持久化方式具有不同的优劣势，影响到 Redis 的访问性能和可靠性。</li><li>Redis 支持高可靠集群和高可扩展集群</li></ol><h1 id="快速的Redis有哪些慢操作"><a href="#快速的Redis有哪些慢操作" class="headerlink" title="快速的Redis有哪些慢操作"></a>快速的Redis有哪些慢操作</h1><h2 id="Redis快在哪儿"><a href="#Redis快在哪儿" class="headerlink" title="Redis快在哪儿"></a>Redis快在哪儿</h2><ul><li>Redis是内存数据库， 所有操作都在内存上完成，内存的访问速度本身就很快。</li><li>归功于它的数据结构。键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 Redis 快速处理数据的基础。</li></ul><h2 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>&emsp;&emsp;底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。它们和数据类型的对应关系如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis3.jpg" alt="avatar"><br>&emsp;&emsp;可以看到，String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型，它们的特点是<strong>一个键对应了一个集合的数据</strong>。</p><h3 id="键和值用什么数据结构组织"><a href="#键和值用什么数据结构组织" class="headerlink" title="键和值用什么数据结构组织"></a>键和值用什么数据结构组织</h3><p>&emsp;&emsp;为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一 个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。<br>&emsp;&emsp;在下图中，可以看到，哈希桶中的 entry 元素中保存了 key 和 value 指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过 value 指针被查找到。</p><p><img lazyload src="/images/loading.svg" data-src="redis4.jpg" alt="avatar"></p><p>&emsp;&emsp;因为这个哈希表保存了所有的键值对，所以，我也把它称为==全局哈希表==。哈希表的最大好处很明显，就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。<br>&emsp;&emsp;查找过程主要依赖于哈希计算，和数据量的多少并没有直接关系。也就是说， 不管哈希表里有 10 万个键还是 100 万个键，我们只需要一次计算就能找到相应的键。但是，当你往 Redis 中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在的风险点，那就是哈希表的冲突问题和 rehash 可能带来的操作阻塞。</p><h3 id="为什么哈希表操作变慢了"><a href="#为什么哈希表操作变慢了" class="headerlink" title="为什么哈希表操作变慢了"></a>为什么哈希表操作变慢了</h3><p>&emsp;&emsp;当你往哈希表中写入更多数据时，哈希冲突是不可避免的问题。这里的哈希冲突，也就是指，两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。毕竟，哈希桶的个数通常要少于 key 的数量，这也就是说，难免会有一些 key的哈希值对 应到了同一个哈希桶中。Redis 解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。如下图所示：entry1、entry2 和 entry3 都需要保存在哈希桶 3 中，导致了哈希冲突。此时，entry1 元素会通过一个<em>next指针指向 entry2，同样，entry2 也会通过</em>next指针指向 entry3。这样一来，即使哈希桶 3 中的元素有 100 个，我们也可以通过 entry 元素中的指针，把它们连起来。这就形成了一个链表，也叫作哈希冲突链。<br><img lazyload src="/images/loading.svg" data-src="redis5.jpg" alt="avatar"></p><p>&emsp;&emsp;但是，这里依然存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。对于追求“快”的 Redis 来说，这是不太能接受的。所以，Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。那具体怎么做呢？<br>&emsp;&emsp;为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p><ol><li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li><li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li><li>释放哈希表 1 的空间。</li></ol><p>&emsp;&emsp;这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了渐进式 rehash。简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis6.jpg" alt="avatar"><br>&emsp;&emsp;这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操 作，保证了数据的快速访问。</p><h3 id="集合类数据的操作效率"><a href="#集合类数据的操作效率" class="headerlink" title="集合类数据的操作效率"></a>集合类数据的操作效率</h3><p>&emsp;&emsp;和 String 类型不同，一个集合类型的值，==第一步是通过全局哈希表找到对应的哈希桶位置==，==第二步是在集合中再增删改查==。那么，集合的操作效率和哪些因素相关呢？首先，与集合的底层数据结构有关。例如，使用哈希表实现的集合，要比使用链表实现的 集合访问效率更高。其次，操作效率和这些操作本身的执行特点有关，比如读写一个元素 的操作要比读写所有元素的效率高。</p><h4 id="集合类数据的底层数据结构"><a href="#集合类数据的底层数据结构" class="headerlink" title="集合类数据的底层数据结构"></a>集合类数据的底层数据结构</h4><p>&emsp;&emsp;集合类型的底层数据结构主要有 5 种：整数数组、双向链表、哈希表、压缩列表和跳表。<br>&emsp;&emsp;压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。<br><img lazyload src="/images/loading.svg" data-src="redis7.jpg" alt="avatar"><br>&emsp;&emsp;在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。</p><p>我们再来看下跳表。</p><p>&emsp;&emsp;有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。具体来说，跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis8.jpg" alt="avatar"></p><p>&emsp;&emsp;如果我们要在链表中查找 33 这个元素，只能从头开始遍历链表，查找 6 次，直到找到 33 为止。此时，复杂度是 O(N)，查找效率很低。<br>&emsp;&emsp;为了提高查找速度，我们来增加一级索引：从第一个元素开始，每两个元素选一个出来作为索引。这些索引再通过指针指向原始的链表。例如，从前两个元素中抽取元素 1 作为一级索引，从第三、四个元素中抽取元素 11 作为一级索引。此时，我们只需要 4 次查找就 能定位到元素 33 了。<br>&emsp;&emsp;如果我们还想再快，可以再增加二级索引：从一级索引中，再抽取部分元素作为二级索引。例如，从一级索引中抽取 1、27、100 作为二级索引，二级索引指向一级索引。这样，我们只需要 3 次查找，就能定位到元素 33 了。<br>&emsp;&emsp;可以看到，这个查找过程就是在多级索引上跳来跳去，最后定位到元素。这也正好符合“跳”表的叫法。当数据量很大时，跳表的查找复杂度就是 O(logN)。<br><img lazyload src="/images/loading.svg" data-src="redis9.jpg" alt="avatar"></p><h2 id="不同操作的复杂度"><a href="#不同操作的复杂度" class="headerlink" title="不同操作的复杂度"></a>不同操作的复杂度</h2><ol><li>==单元素操作==，是指每一种集合类型对单个数据实现的增删改查操作。例如，Hash 类型的 HGET、HSET 和 HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)；Set 类型用哈希表作为底层数据结构时，它的 SADD、 SREM、SRANDMEMBER 复杂度也是 O(1)。集合类型支持同时对多个元素进行增删改查，例如 Hash 类型的 HMGET 和 HMSET，Set 类型的 SADD 也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了。</li><li>==范围操作==，<strong>是指集合类型中的遍历操作，可以返回集合中的所有数据</strong>，比如 Hash 类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List 类型的 LRANGE 和 ZSet 类型的 ZRANGE。<strong>这类操作的复杂度一般是 O(N)，比较耗时， 我们应该尽量避免</strong>。不过，Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了<strong>渐进式遍历</strong>，每次只返回有限数量的数据。这样一来，相比于 HGETALL、SMEMBERS 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞。</li><li>==统计操作==，是指<strong>集合类型对集合中所有元素个数的记录</strong>，例如 LLEN 和 SCARD。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。</li><li>==例外情况==，是指某些数据结构的特殊记录，例如<strong>压缩列表和双向链表都会记录表头和表尾的偏移量</strong>。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。</li></ol><h2 id="Redis选择不同数据结构的考量"><a href="#Redis选择不同数据结构的考量" class="headerlink" title="Redis选择不同数据结构的考量"></a>Redis选择不同数据结构的考量</h2><p>&emsp;&emsp;Redis 之所以能快速操作键值对，一方面是因为 O(1) 复杂度的哈希表被广泛使用，包括 String、Hash 和 Set，它们的操作复杂度基本由哈希表决定，另一方面，Sorted Set 也采用了 O(logN) 复杂度的跳表。不过，集合类型的范围操作，因为要遍历底层数据结构，复 杂度通常是 O(N)。这里，我的建议是：用其他命令来替代，例如可以用 SCAN 来代替， 避免在 Redis 内部产生费时的全集合遍历操作。<br>&emsp;&emsp;当然，我们不能忘了复杂度较高的 List 类型，它的两种底层实现结构：双向链表和压缩列表的操作复杂度都是 O(N)。但是它的 POP/PUSH 效率很高，那么就将它主要用于 FIFO 队列场景，而不是作为一个可以随机读写的集合。<strong>另外，List底层使用压缩列表本质上是将所有元素紧挨着存储，所以分配的是一块连续的内存空间，虽然数据结构本身没有时间复杂度的优势，但是这样节省空间而且也能避免一 些内存碎片，它比链表占用的内存要更少。 Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。</strong></p><h1 id="高性能-IO-模型"><a href="#高性能-IO-模型" class="headerlink" title="高性能 IO 模型"></a>高性能 IO 模型</h1><p>&emsp;&emsp;首先要厘清一个事实，说 Redis 是单线程模型，主要是指 <strong>Redis 的网络 IO 和键值对的读写是由一个线程来完成的</strong>，这也是 Redis 对外提供键值存储服务的主要流程。 但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p><h2 id="为什么使用单线程"><a href="#为什么使用单线程" class="headerlink" title="为什么使用单线程"></a>为什么使用单线程</h2><ol><li>==为什么不使用多线程==：并发访问控制一直是多线程开发中的一个难点问题，如果没有精细的设计，比如说，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。而且，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。为了避免这些问题，Redis 直接采用了单线程模式。</li><li>==单线程 Redis 为什么快==：一方面，Redis 的大部分操作在内存上完成，再加上它使用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。另一方面，就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</li></ol><h2 id="基本-IO-模型与阻塞点"><a href="#基本-IO-模型与阻塞点" class="headerlink" title="基本 IO 模型与阻塞点"></a>基本 IO 模型与阻塞点</h2><p>&emsp;&emsp;Redis 处理一个客户端发来的 Get 请求，要经过以下步骤：要监听客户端请求 （bind/listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。<br>&emsp;&emsp;下图显示了这一过程，其中，bind/listen、accept、recv、parse 和 send 属于网络 IO 处理，而 get 属于键值数据操作。既然 Redis 是单线程，那么，最基本的一种实现是在一个线程中依次执行上面说的这些操作。<br><img lazyload src="/images/loading.svg" data-src="redis10.jpg" alt="avatar"><br>&emsp;&emsp;但是，在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听到一个客户端有连接请求，但一直==未能成功建立起连接==时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果==数据一直没有到达==，Redis 也会一直阻塞在 recv()。这就导致 Redis 整个线程阻塞，无法处理其他客户端请求，效率很低。不过，幸运的是， socket 网络模型本身支持非阻塞模式。</p><h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>&emsp;&emsp;在 socket 模型中，不同操作调用后会返回不同的套接字类型。socket() 方法会返回主动套接字，然后调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字。<br><img lazyload src="/images/loading.svg" data-src="redis11.jpg" alt="avatar"><br>&emsp;&emsp;针对监听套接字，我们可以设置非阻塞模式：当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但是，要注意的是，调用 accept() 时，已经存在监听套接字了。<br>&emsp;&emsp;虽然 Redis 线程可以不用继续等待，但是总得有机制继续在监听套接字上等待后续连接请求，并在有请求时通知 Redis。类似的，我们也可以针对已连接套接字设置非阻塞模式：Redis 调用 recv() 后，如果已连 接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作。我们也需要有机 制继续监听该已连接套接字，并在有数据达到时通知 Redis。这样才能保证 Redis 线程，既不会像基本 IO 模型中一直在阻塞点等待，也不会导致 Redis 无法处理实际到达的连接请求或数据。</p><p>到此，Linux 中的 IO 多路复用机制就要登场了。</p><h3 id="基于多路复用的高性能-I-O-模型"><a href="#基于多路复用的高性能-I-O-模型" class="headerlink" title="基于多路复用的高性能 I/O 模型"></a>基于多路复用的高性能 I/O 模型</h3><p>&emsp;&emsp;Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，<strong>同时存在多个监听套接字和已连接套接字</strong>。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。<br>&emsp;&emsp;下图就是基于多路复用的 Redis IO 模型。图中的多个 FD 就是刚才所说的多个套接字。 Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理 上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。<br><img lazyload src="/images/loading.svg" data-src="redis12.jpg" alt="avatar"><br>&emsp;&emsp;为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来， Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时， Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。<br>&emsp;&emsp;以连接请求和读数据请求为例，具体解释一下:<br>&emsp;&emsp;这两个请求分别对应 Accept 事件和 Read 事件，Redis 分别对这两个事件注册 accept 和 get 回调函数。当 Linux 内核监听到有连接请求或读数据请求时，就会触发 Accept 事件 和 Read 事件，此时，内核就会回调 Redis 相应的 accept 和 get 函数进行处理。</p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>&emsp;&emsp;随着硬件性能提升，Redis 的性能瓶颈可能出现网络 IO 的读写，也就是：单个线程处理网络读写的速度跟不上底层网络硬件的速度。读写网络的 <code>read/write</code> 系统调用占用了Redis 执行期间大部分CPU 时间，瓶颈主要在于网络的 IO 消耗。所以，Redis6.0版本 采用多个 IO 线程来处理网络请求，提高网络请求处理的并行度。<strong>需要注意的是，Redis 多 IO 线程模型只用来处理网络读写请求，对于 Redis 的读写命令，依然是单线程处理</strong>。这是因为，网络处理经常是瓶颈，通过多线程并行处理可提高性能。<br>架构图如下：<br><img lazyload src="/images/loading.svg" data-src="redis13.jpg" alt="avatar"><br>主线程与 IO 多线程是如何实现协作呢？<br><img lazyload src="/images/loading.svg" data-src="redis14.jpg" alt="avatar"><br>主要流程：</p><ol><li>主线程负责接收建立连接请求，获取 <code>socket</code> 放入全局等待读处理队列；</li><li>主线程通过轮询将可读 <code>socket</code> 分配给 IO 线程；</li><li>主线程阻塞等待 IO 线程读取 <code>socket</code> 完成；</li><li>主线程执行 IO 线程读取和解析出来的 Redis 请求命令；</li><li>主线程阻塞等待 IO 线程将指令执行结果回写回 <code>socket</code>完毕；</li><li>主线程清空全局队列，等待客户端后续的请求。</li></ol><p>思路：<strong>将主线程 IO 读写任务拆分出来给一组独立的线程处理，使得多个 socket 读写可以并行化，但是 Redis 命令还是主线程串行执行。</strong></p><p>模型缺陷:<br>&emsp;&emsp;Redis 的多线程网络模型实际上并不是一个标准的 <code>Multi-Reactors/Master-Workers</code> 模型。Redis 的多线程方案中，I/O 线程任务仅仅是通过 socket 读取客户端请求命令并解析，却没有真正去执行命令。所有客户端命令最后还需要回到主线程去执行，因此对多核的利用率并不算高，而且每次主线程都必须在分配完任务之后忙轮询等待所有 I/O 线程完成任务之后才能继续执行其他逻辑。</p><h1 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a>AOF 日志</h1><h2 id="AOF-日志是如何实现的"><a href="#AOF-日志是如何实现的" class="headerlink" title="AOF 日志是如何实现的"></a>AOF 日志是如何实现的</h2><p>&emsp;&emsp;对于SQL这类的数据库，基本都是写前日志（Write Ahead Log, WAL），也就是在实际写数据前，先将数据记录在日志中，以便故障时恢复。AOF 正好相反，它是写后日志，也就是说先执行 Redis 命令写入数据，再记录日志。如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis15.jpg" alt="avatar"></p><p>&emsp;&emsp;传统的数据库日志，记录的是修改后的数据，而 AOF 记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存下来的。我们以 Redis 收到“set testkey testvalue”命令后记录的日志为例，看看 AOF 日志的内容。其中，“*3”表示当前命令有三个部分，每部分都是由“$+数字”开头，后面紧跟着 具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节。例 如，“$3 set”表示这部分有 3 个字节，也就是“set”命令。<br><img lazyload src="/images/loading.svg" data-src="redis16.jpg" alt="avatar"></p><p>&emsp;&emsp;AOF 采用写后日志的方式有两个好处：第一，不需要消耗额外的资源检查命令是否正确，只需要在成功写入之后更新日志即可；第二，因为是在写入后更新日志，不必担心被阻塞当前的写操作。<br>&emsp;&emsp;但是这种方式也有天然的缺点，第一，如果在一条命令成功执行后服务器突然宕机，此时还没来得及在 AOF 日志中保存下这条命令，那么再重启服务后这条命令的写入/更新操作就不会被执行；第二，虽然不会阻塞当前的写操作，但是写日志也是在主进程中执行的，如果磁盘的IO压力很大导致写日志很慢，那么之后的 Redis 命令就会被阻塞。<br>&emsp;&emsp;这两个风险都是和 AOF 写回磁盘的时机相关的。这也就意味着，如果我们能够控制一个写命令执行完后 AOF 日志写回磁盘的时机，这两个风险就解除了。</p><h2 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h2><ul><li>Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</li><li>Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li><li>No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li></ul><p>三种写回策略的比较：<br><img lazyload src="/images/loading.svg" data-src="redis17.jpg" alt="avatar"><br>&emsp;&emsp;这时我们就要根据我们的系统的需求来进行 trade-off 了，如果想要保证高可靠，那么就采取 Always 的策略；如果追求的是高性能，那么久采用 no 策略，将控制写回的时机完全交给操作系统；如果想要兼顾两者，那就选择 everysec 策略。</p><h2 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h2><p>&emsp;&emsp;随着时间的推移，Redis 的 AOF 日志文件会越来越大，此时可能有三种因素共同制约日志文件的大小：</p><ol><li>操作系统对每个文件的大小上限有限制；</li><li>日志文件过大，每次要打开文件往里面写入，对性能的损耗就越大；</li><li>当使用 AOF 日志恢复数据时，由于 AOF 日志过大，整个恢复过程就会很慢。</li></ol><p>&emsp;&emsp;这个时候，AOF 重写机制就登场了。AOF 会根据日志的现状重新创建一个日志文件，对一个键值对的修改可能是经过很多条 Redis 命令后形成的最终的结果，此时只需要一条命令就能替换掉之前所有的命令。这样一来，一个键值对在重写日志中只用一条命令就行了，在日志恢复时，只用执行这条命令，就可以直接完成这个键值对的写入了。</p><p>下面这张图就是一个例子：<br><img lazyload src="/images/loading.svg" data-src="redis18.jpg" alt="avatar"></p><p>&emsp;&emsp;重写机制虽然能够大大缩减日志文件的大小，但是可以想见，这必定是一个非常消耗资源的操作，那么 AOF 重写会阻塞主线程吗？为避免 AOF 重写阻塞主线程，重写过程会在后台起一个线程来完成。可以总结为一句话：“<strong>一个拷贝，两处日志</strong>”。</p><ul><li><strong>一个拷贝</strong>：主线程 fork 一个线程来重写 AOF 日志时，会将主线程内存拷贝一份给子线程，这里面包含了数据库的最新数据，子线程就可以在不影响主线程的前提下逐一把拷贝的数据写成操作存入重写日志。</li><li><strong>两处日志</strong>：如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这 个 AOF 日志的操作仍然是齐全的，可以用于恢复；而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这 样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日 志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我 们就可以用新的 AOF 文件替代旧文件了。<br><img lazyload src="/images/loading.svg" data-src="redis19.jpg" alt="avatar"><br>&emsp;&emsp; 总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个 日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>AOF 日志重写的时候，是由 bgrewriteaof 子进程来完成的，不用主线程参与，我们今天说的非阻塞也是指子进程的执行不阻塞主线程。但是，你觉得，这个重写过程有没有其他潜在的阻塞风险呢？如果有的话，会在哪里阻塞？<br>答：fork子进程，fork这个瞬间一定是会阻塞主线程的（注意，fork时并不会一次性拷贝所有内存数据给子进程），fork采用操作系统提供的写实复制(Copy On Write)机制，就是为了避免一次性拷贝大量内存数据给子进程造成的长时间阻塞问题，但<strong>fork子进程需要拷贝进程必要的数据结构，其中有一项就是拷贝内存页表</strong>（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，实例越大，内存页表越大，fork阻塞时间越久。拷贝内存页表完成后，子进程与父进程指向相同的内存地址空间，也就是说此时虽然产生了子进程，但是并没有申请与父进程相同的内存大小。那什么时候父子进程才会真正内存分离呢？“写实复制”顾名思义，就是在写发生时，才真正拷贝内存真正的数据，这个过程中，父进程也可能会产生阻塞的风险，就是下面介绍的场景。</li></ol><p>fork出的子进程指向与父进程相同的内存地址空间，此时子进程就可以执行AOF重写，把内存中的所有数据写入到AOF文件中。但是此时父进程依旧是会有流量写入的，如果父进程操作的是一个已经存在的key，那么这个时候父进程就会真正拷贝这个key对应的内存数据，申请新的内存空间，这样逐渐地，父子进程内存数据开始分离，父子进程逐渐拥有各自独立的内存空间。因为内存分配是以页为单位进行分配的，默认4k，如果父进程此时操作的是一个bigkey，重新申请大块内存耗时会变长，可能会产阻塞风险。另外，如果操作系统开启了内存大页机制(Huge Page，页面大小2M)，那么父进程申请内存时阻塞的概率将会大大提高，所以在Redis机器上需要关闭Huge Page机制。Redis每次fork生成RDB或AOF重写完成后，都可以在Redis log中看到父进程重新申请了多大的内存空间。</p><ol start="2"><li>AOF 重写也有一个重写日志，为什么它不共享使用 AOF 本身的日志呢？<br>答：一个原因是父子进程写同一个文件必然会产生竞争问题，控制竞争就意味着会影响父进程的性能。二是如果AOF重写过程中失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用。所以Redis AOF重写一个新文件，重写失败的话，直接删除这个文件就好了，不会对原先的AOF文件产生影响。等重写完成之后，直接替换旧文件即可。</li></ol><h1 id="RDB-内存快照"><a href="#RDB-内存快照" class="headerlink" title="RDB 内存快照"></a>RDB 内存快照</h1><p>&emsp;&emsp;上一节说到 AOF 日志将 Redis 的写命令逐一记录下来，在服务重启时再逐一执行恢复数据。如果 AOF 日志文件过大，这一过程通常是很缓慢的。这一节将讨论另一种持久化方式：内存快照。所谓内存快照，就是指内存中的数据在某一个时刻的状态记录。这就类似于照片，当你给朋友拍照时，一张照片就能把朋友一瞬间的形象完全记下来。对 Redis 来说，它实现类似照片记录效果的方式，就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 RDB 文件，其中，RDB 就是 Redis DataBase 的缩写。和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，我 们可以直接把 RDB 文件读入内存，很快地完成恢复。听起来好像很不错，但内存快照也并不是最优选项。为什么这么说呢？有另个问题要考虑：</p><ol><li>我们应该对那些数据做快照？这关系到快照的执行效率问题；</li><li>做快照时，数据还能被增删改吗？这关系到 Redis 是否被阻塞，能否同时正常处理请求。</li></ol><p>拿拍照片来举例子。我们在拍照时，通常要关注两个问题：</p><ol><li>如何取景？也就是说，我们打算把哪些人、哪些物拍到照片中；</li><li>在按快门前，要记着提醒朋友不要乱动，否则拍出来的照片就模糊了。</li></ol><h2 id="给哪些数据做快照"><a href="#给哪些数据做快照" class="headerlink" title="给哪些数据做快照?"></a>给哪些数据做快照?</h2><p>&emsp;&emsp;Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是<strong>全量快照</strong>，也就是说，把内存中的所有数据都记录到磁盘中，这就类似于给 100 个人拍合影，把每一个人都拍进照片里。这样做的好处是，一次性记录了所有数据，一个都不少。同样，给内存的全量数据做快照， 把它们全部写入磁盘也会花费很多时间。而且，全量数据越多，RDB 文件就越大，往磁盘上写数据的时间开销就越大。对于 Redis 而言，它的单线程模型就决定了，我们要尽量避免所有会阻塞主线程的操作， 所以，针对任何操作，我们都会提一个灵魂之问：“它会阻塞主线程吗?”。RDB 文件的生成是否会阻塞主线程，这就关系到是否会降低 Redis 的性能。</p><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。</p><ul><li>save：在主线程中执行，会导致阻塞；</li><li>bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。</li></ul><p>&emsp;&emsp;我们就可以通过 bgsave 命令来执行全量快照，这既提供了数据的可靠性保证，也避免了对 Redis 的性能影响。</p><p>&emsp;&emsp;接下来，我们要关注的问题就是，在对内存数据做快照时，这些数据还能“动”吗? 也就是说，这些数据还能被修改吗？ 这个问题非常重要，这是因为，如果数据能被修改，那就意味着 Redis 还能正常处理写操作。否则，所有写操作都得等到快照完了才能执行，性能一下子就降低了。</p><h2 id="快照时数据能修改吗"><a href="#快照时数据能修改吗" class="headerlink" title="快照时数据能修改吗?"></a>快照时数据能修改吗?</h2><p>&emsp;&emsp;当我们采用 bgsave 方式来生成快照时，其实是 fork 了一个子进程。根据 Linux 中 fork 系统调用的规则，子进程在创建后并不会将父进程所有的内存数据都单独拷贝一份，而是拷贝一份页表，背后指向和父进程一样的物理地址。当有新的 Redis 写入命令时，原来的键值对发生了修改，那么就会启用 copy-on-write 思想，子进程会在内存中复制一份该键值对，并通过页表指向该新创建的地址，这就做到了在进行快照时，数据发生了修改，子进程仍然可以把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。<br><img lazyload src="/images/loading.svg" data-src="redis20.jpg" alt="avatar"><br>&emsp;&emsp;这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影 响。到这里，我们就解决了对“哪些数据做快照”以及“做快照时数据能否修改”这两大问 题：Redis 会使用 bgsave 对当前内存中的所有数据做快照，这个操作是子进程在后台完 成的，这就允许主线程同时可以修改数据。</p><p>&emsp;&emsp;现在，我们再来看另一个问题：多久做一次快照？我们在拍照的时候，还有项技术叫“连 拍”，可以记录人或物连续多个瞬间的状态。那么，快照也适合“连拍”吗？</p><h2 id="可以每秒做一次快照吗？"><a href="#可以每秒做一次快照吗？" class="headerlink" title="可以每秒做一次快照吗？"></a>可以每秒做一次快照吗？</h2><p>&emsp;&emsp;对于快照来说，所谓“连拍”就是指连续地做快照。这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。但是，这其中的快照间隔时间就很关键了。<br>&emsp;&emsp;如下图所示，我们先在 T0 时刻做了一次快照，然后又在 T0+t 时刻做了一次快照，在这期间，数据块 5 和 9 被修改了。如果在 t 这段时间内，机器宕机了，那么，只能按照 T0 时刻的快照进行恢复。此时，数据块 5 和 9 的修改值因为没有快照记录，就无法恢复了。<br><img lazyload src="/images/loading.svg" data-src="redis21.jpg" alt="avatar"><br>&emsp;&emsp;所以，要想尽可能恢复数据，t 值就要尽可能小，t 越小，就越像“连拍”。那么，t 值可以小到什么程度呢，比如说是不是可以每秒做一次快照？毕竟，每次快照都是由 bgsave 子进程在后台执行，也不会阻塞主线程。这种想法其实是错误的。虽然 <strong>bgsave 执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销</strong>。</p><ol><li>一方面，对于<strong>磁盘</strong>而言，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</li><li>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后 不会再阻塞主线程，但是，<strong>fork 这个创建过程本身会阻塞主线程</strong>，而且主线程的内存越 大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。</li></ol><p>&emsp;&emsp;此时，我们可以做<strong>增量快照</strong>，所谓增量快照，就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。</p><p>&emsp;&emsp;在第一次做完全量快照后，T1 和 T2 时刻如果再做快照，我们只需要将被修改的数据写入快照文件就行。但是，这么做的前提是，我们需要<strong>记住哪些数据被修改了</strong>。你可不要小瞧 这个“记住”功能，它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis22.jpg" alt="avatar"><br>&emsp;&emsp;如果我们对每一个键值对的修改，都做个记录，那么，如果有 1 万个被修改的键值对，我们就需要有 1 万条额外的记录。而且，有的时候，键值对非常小，比如只有 32 字节，而记录它被修改的元数据信息，可能就需要 8 字节，这样的画，为了“记住”修改，引入的额外空间开销比较大。这对于内存资源宝贵的 Redis 来说，有些得不偿失。</p><p>&emsp;&emsp;到这里，你可以发现，虽然跟 AOF 相比，快照的恢复速度快，但是，快照的频率不好把握，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销，那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？我们再仔细想一想，使用 AOF 日志不是能很好的记录修改吗。</p><h2 id="混合使用-AOF-日志和内存快照"><a href="#混合使用-AOF-日志和内存快照" class="headerlink" title="混合使用 AOF 日志和内存快照"></a>混合使用 AOF 日志和内存快照</h2><p>&emsp;&emsp;简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。<br><img lazyload src="/images/loading.svg" data-src="redis23.jpg" alt="avatar"><br>&emsp;&emsp;这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势。</p><h1 id="主从库同步"><a href="#主从库同步" class="headerlink" title="主从库同步"></a>主从库同步</h1><p>&emsp;&emsp;当启动多个 Redis 实例的时候，它们之间就可以通过 replicaof （Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。例如，现在有实例 1（ip：172.16.19.3）和实例 2（ip：172.16.19.5），我们在实例 2 上执行以下这个命令后，实例 2 就变成了实例 1 的从库，并从实例 1 上复制数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof 172.16.19.3 6379</span><br></pre></td></tr></table></figure><h2 id="主从库第一次同步"><a href="#主从库第一次同步" class="headerlink" title="主从库第一次同步"></a>主从库第一次同步</h2><p>三个阶段：<br><img lazyload src="/images/loading.svg" data-src="redis24.jpg" alt="avatar"></p><ul><li><p>阶段一：<br>&emsp;&emsp;主从库建立连接，协商同步，主要是为全量复制做准备。具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。<br>runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设 为“？”。<br>offset，此时设为 -1，表示第一次复制。</p></li><li><p>第二阶段<br>&emsp;&emsp;主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。<strong>FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库主库执行 bgsave 命令，把当前所有的数据都复制给从库</strong>。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。</p></li><li><p>第三阶段<br>&emsp;&emsp;在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p></li></ul><h2 id="主从级联分担全量复制时主库的压力"><a href="#主从级联分担全量复制时主库的压力" class="headerlink" title="主从级联分担全量复制时主库的压力"></a>主从级联分担全量复制时主库的压力</h2><p>&emsp;&emsp;对于主库来说，完成第一次主从同步，即一次全量复制，有两个耗时的操作：生成 RDB 文件和传输 RDB 文件。如果从库过多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步。fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。此外，传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。可以使用“主-从-从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。<br><img lazyload src="/images/loading.svg" data-src="redis25.jpg" alt="avatar"></p><h2 id="主从库间的网络断了怎么办？"><a href="#主从库间的网络断了怎么办？" class="headerlink" title="主从库间的网络断了怎么办？"></a>主从库间的网络断了怎么办？</h2><p>&emsp;&emsp;在 Redis 2.8 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步。听名字大概就可以猜到它和全量复制的不同：全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库。那么，增量复制时，主从库之间具体是怎么保持同步的呢？这里的奥妙就在于 repl_backlog_buffer 这个缓冲区。我们先来看下它是如何用于增量命令的同步的。<br>&emsp;&emsp;当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。repl_backlog_buffer 是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己 已经读到的位置。刚开始的时候，主库和从库的写读位置在一起，这算是它们的起始位置。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，我们通常用偏移量来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是 master_repl_offset。主库接收的新写操作越多，这个值就会越大。同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量 slave_repl_offset 也在不断增加。正常情况下，这两个偏移量基本相等。<br><img lazyload src="/images/loading.svg" data-src="redis26.jpg" alt="avatar"><br><img lazyload src="/images/loading.svg" data-src="redis27.jpg" alt="avatar"><br>&emsp;&emsp;，因为 repl_backlog_buffer 是一个环形缓冲区，所以在 缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。针对这种情况，一方面，可以根据 Redis 所在服务器的内存资源再适当增加 repl_backlog_size 值，比如说设置成缓冲空间大小的 4 倍，另一方面，可以考虑使用切片集群来分担单个主库的请求压力。</p><h2 id="为什么使用-RDB-文件进行主从复制，而不是用-AOF？"><a href="#为什么使用-RDB-文件进行主从复制，而不是用-AOF？" class="headerlink" title="为什么使用 RDB 文件进行主从复制，而不是用 AOF？"></a>为什么使用 RDB 文件进行主从复制，而不是用 AOF？</h2><ol><li>相同数据下，AOF 文件比 RDB 更大，因此需要的网络带宽更多；</li><li>在恢复数据时，使用RDB更快。RDB 是数据库的快照文件，记录的是某一时刻数据库中所有键值对的状态，而 AOF 文件记录的是所有的写 Redis 命令，在做全量复制的时候会需要大量的时间；</li><li>如果使用AOF文件来同步相对来说丢的数据更少，但是不表示不丢数据。即也需要第三 个阶段来保证数据的一致性。因此相对来说使用RDB开销更小些。</li></ol><h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><p>&emsp;&emsp;在主从模式下。如果从库挂了，那么客户端的请求会被其他正常工作的从库接收。但如果是主库挂了，那么客户端的写请求将不再能够被处理，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis28.jpg" alt="avatar"><br>&emsp;&emsp;无论是写服务中断，还是从库无法同步数据，都是不可接受的。所以，如果主库挂了，我们就需要运行一个新的主库，比如手将一个从库切换为主库。这就涉及三个问题：</p><ol><li>主库真的挂了吗？</li><li>该选择哪个从库作为主库？</li><li>怎么把新主库的相关信息通知给从库和客户端呢？</li></ol><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>&emsp;&emsp;哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。</p><ul><li><p>监控<br>&emsp;&emsp;监控是指哨兵进程在运行时，周期性地给所有主从库发送 PING 命令，检测它们是否仍然在线。如果从库没有在规定时间内相应哨兵的 PING 命令，哨兵就会将它标记为“下线状态“；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下限，然后开始自动切换主库的流程。</p></li><li><p>选主<br>&emsp;&emsp;主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。这一步完成后，现在的集群里就有了新主库。</p></li><li><p>通知<br>&emsp;&emsp;在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。</p></li></ul><p><img lazyload src="/images/loading.svg" data-src="redis29.jpg" alt="avatar"></p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><ul><li>主观下线<br>&emsp;&emsp;哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么哨兵会将它标记为“主观下线”。</li></ul><p>&emsp;&emsp;首先，我们要知道啥叫误判。很简单，就是主库实际并没有下线，但是哨兵误以为它下线了。误判一般会发生在集群网络压力较大、网络拥塞，或者是主库本身压力较大的情况下。哨兵机制<strong>通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群</strong>来减少误判。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。在判断主库是否下线时，不能由一个哨兵说了算，只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“客观下线”，这个叫法也是表明主库下线成为一个客观事实了。这个判断原则就是：少数服从多数。同时，这会进一步触发哨兵开始主从切换流程。<br><img lazyload src="/images/loading.svg" data-src="redis30.jpg" alt="avatar"></p><ul><li>客观下线<br>&emsp;&emsp;简单来说，“客观下线”的标准就是，当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”。这样一来，就可以减少误判 的概率，也能避免误判带来的无谓的主从库切换。（当然，有多少个实例做出“主观下线”的判断才可以，可以由 Redis 管理员自行设定）。</li></ul><h2 id="选主"><a href="#选主" class="headerlink" title="选主"></a>选主</h2><p>&emsp;&emsp;我们在多个从库中，先按照<strong>一定的筛选条件</strong>，把不符合条件的从库去掉。然后，我们再按照<strong>一定的规则</strong>，给剩下的从库逐个打分，将得分最高的从库选为新主库，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis31.jpg" alt="avatar"></p><ul><li><p>一定的筛选条件<br>&emsp;&emsp;在选主时，<strong>除了要检查从库的当前在线状态，还要判断它之前的网络连接状态</strong>。如果从库总是和主库断连，而且断连次数超出了一定的阈值，我们就有理由相信，这个从库的网络状况并不是太好，就可以把这个从库筛掉了。</p></li><li><p>一定的规则<br>&emsp;&emsp;我们可以分别按照三个规则依次进行三轮打分，这三个规则分别是从库优先级、从库复制进度以及从库 ID 号。只要在某一轮中，有从库得分最高，那么它就是主库了，选主过程到此结束。如果没有出现得分最高的从库，那么就继续进行下一轮。</p></li></ul><ol><li><p>第一轮：优先级最高的从库得分高。<br>&emsp;&esmsp;用户可以通过 slave-priority 配置项，给不同的从库设置不同优先级。比如，你有两个从库，它们的内存大小不一样，你可以手动给内存大的实例设置一个高优先级。在选主时，哨兵会给优先级高的从库打高分，如果有一个从库优先级最高，那么它就是新主库了。如果从库的优先级都一样，那么哨兵开始第二轮打分。</p></li><li><p>第二轮：和旧主库同步程度最接近的从库得分高。<br>&emsp;&emsp;这个规则的依据是，如果选择和旧主库同步最接近的那个从库作为主库，那么，这个新主库上就有最新的数据。主从库同步时有个命令传播的过程。在这个过程中，主库会用 master_repl_offset 记录当前的最新写操作在 repl_backlog_buffer 中的位置，而从库会用 slave_repl_offset 这个值记录当前的复制进度。此时，我们想要找的从库，它的 slave_repl_offset 需要最接近 master_repl_offset。如果在所有从库中，有从库的 slave_repl_offset 最接近 master_repl_offset，那么它的得分就最高，可以作为新主库。就像下图所示，旧主库的 master_repl_offset 是 1000，从库 1、2 和 3 的 slave_repl_offset 分别是 950、990 和 900，那么，从库 2 就应该被选为新主库。<br><img lazyload src="/images/loading.svg" data-src="redis32.jpg" alt="avatar"><br>当然，如果有两个从库的 slave_repl_offset 值大小是一样的（例如，从库 1 和从库 2 的 slave_repl_offset 值都是 990），我们就需要给它们进行第三轮打分了。</p></li><li><p>第三轮：ID 号小的从库得分高。</p></li></ol><h2 id="哨兵集群的原理"><a href="#哨兵集群的原理" class="headerlink" title="哨兵集群的原理"></a>哨兵集群的原理</h2><p>&emsp;&emsp;我们通常通过使用哨兵集群来对主从库的状态进行监控并在主库挂掉时选出新的主库。那么哨兵出现故障呢？实际上，一旦多个实例组成哨兵集群，即使一个实例挂掉，剩下的哨兵依然会继续履行原始的职能，通过哨兵集群的配置项（如下所示），我们可以发现，哨兵在建立的一开始对彼此是没有感知的，它们各自知道的只有 Redis 主库的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在配置哨兵的信息时，我们只需要用到下面的这个配置项，设置主库的 IP 和端口，并没有配置其他哨兵的连接信息。</p><h3 id="基于-Pub-Sub-机制的哨兵集群的相互感知"><a href="#基于-Pub-Sub-机制的哨兵集群的相互感知" class="headerlink" title="基于 Pub/Sub 机制的哨兵集群的相互感知"></a>基于 Pub/Sub 机制的哨兵集群的相互感知</h3><p>&emsp;&emsp;哨兵之间能够相互发现，要归功于 Redis 的pub/sub 机制，即发布/订阅机制。哨兵只要和主库建立了连接，就可以在主库上发布消息了，比如说发布它自己的连接信 息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。<br>&emsp;&emsp;除了哨兵实例，我们自己编写的应用程序也可以通过 Redis 进行消息的发布和订阅。所以，为了区分不同应用的消息，Redis 会以频道的形式，对这些消息进行分门别类的管理。所谓的频道，实际上就是消息的类别。当消息类别相同时，它们就属于同一个频道。 反之，就属于不同的频道。只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换。<br>&emsp;&emsp;在主从集群中，主库上有一个名为“__sentinel__:hello”的频道，不同哨兵就是通过它来相互发现，实现互相通信的。<br>&emsp;&emsp;举个例子，具体说明一下。在下图中，哨兵 1 把自己的 IP（172.16.19.3）和端口 （26579）发布到“__sentinel__:hello”频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。然后，哨兵 2、3 可以和哨兵 1 建立网络连接。通过这个方式，哨兵 2 和 3 也可以建立网络连接，这样一来，哨兵集群就形成了。它们相互间可以通过网络连接进行通信，比如说对主库有没有下线这件事儿进行判断和协商。<br><img lazyload src="/images/loading.svg" data-src="redis33.jpg" alt="avatar"><br>&emsp;&emsp;哨兵除了彼此之间建立起连接形成集群外，还需要和从库建立连接。这是因为，在哨兵的监控任务中，它需要对主从库都进行心跳判断，而且在主从库切换完成后，它还需要通知从库，让它们和新主库进行同步。</p><h3 id="哨兵如何何知道从库的-IP-地址和端口"><a href="#哨兵如何何知道从库的-IP-地址和端口" class="headerlink" title="哨兵如何何知道从库的 IP 地址和端口"></a>哨兵如何何知道从库的 IP 地址和端口</h3><p>&emsp;&emsp;哨兵向主库发送 INFO 命令来完成的。就像下图所示，哨兵 2 给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。哨兵 1 和 3 可以通过相同的方法和从库建立连接。<br><img lazyload src="/images/loading.svg" data-src="redis34.jpg" alt="avatar"><br>&emsp;&emsp;通过 pub/sub 机制，哨兵之间可以组成集群，同时，哨兵又通过 INFO 命令，获得了从库连接信息，也能和从库建立连接，并进行监控了。</p><h3 id="基于-pub-sub-机制的客户端事件通知"><a href="#基于-pub-sub-机制的客户端事件通知" class="headerlink" title="基于 pub/sub 机制的客户端事件通知"></a>基于 pub/sub 机制的客户端事件通知</h3><p>&emsp;&emsp;哨兵不能只和主、从库连接。因为，主从库切换后，客户端也需要知道新主库的连接信息，才能向新主库发送请求操作。所以，哨兵还需要完成把新主库的信息告诉客户端这个任务。而且，在实际使用哨兵时，我们有时会遇到这样的问题：如何在客户端通过监控了解哨兵进行主从切换的过程呢？比如说，主从切换进行到哪一步了？这其实就是要求，客户端能够获取到哨兵集群在监控、选主、切换这个过程中发生的各种事件。<br>&emsp;&emsp;从本质上说，哨兵就是一个运行在特定模式下的 Redis 实例，只不过它并不服务请求操作，只是完成监控、选主和通知的任务。所以，每个哨兵实例也提供 pub/sub 机制，客户端可以从哨兵订阅消息。哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。<br><img lazyload src="/images/loading.svg" data-src="redis35.jpg" alt="avatar"><br>&emsp;&emsp;知道了这些频道之后，你就可以让客户端从哨兵这里订阅消息了。具体的操作步骤是，客户端读取哨兵的配置文件后，可以获得哨兵的地址和端口，和哨兵建立网络连接。然后，我们可以在客户端执行订阅命令，来获取不同的事件消息。</p><p>举个例子，你可以执行如下命令，来订阅“所有实例进入客观下线状态的事件”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE +odown</span><br></pre></td></tr></table></figure><p>当然，你也可以执行如下命令，订阅所有的事件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSUBSCRIBE *</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当哨兵把新主库选择出来后，客户端就会看到下面的 switch-master 事件。这个事件表示主库已经切换了，新主库的 IP 地址和端口信息已经有了。这个时候，客户端就可以用这里面的新主库地址和端口进行通信了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch-master &lt;master name&gt; &lt;oldip&gt; &lt;oldport&gt; &lt;newip&gt; &lt;newport&gt;</span><br></pre></td></tr></table></figure><h3 id="由哪个哨兵执行主从切换"><a href="#由哪个哨兵执行主从切换" class="headerlink" title="由哪个哨兵执行主从切换?"></a>由哪个哨兵执行主从切换?</h3><p>&emsp;&emsp;实际上，<strong>选主和执行主从切换这两个流程是分裂的，并不是由发现主库下线的哨兵直接执行，而也是通过“投票”的方式选出执行的哨兵</strong>。哨兵集群要判定主库“客观下线”，需要有一定数量的实例都认为该主库已经“主观下线”了。任何一个实例只要自身判断主库“主观下线”后，就会给其他实例发送 is-master-downby-addr 命令。接着，其他实例会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相 当于赞成票，N 相当于反对票。<br><img lazyload src="/images/loading.svg" data-src="redis36.jpg" alt="avatar"></p><p>&emsp;&emsp;一个哨兵获得了仲裁所需的赞成票数后，就可以标记主库为“客观下线”。这个所需的赞成票数是通过哨兵配置文件中的 quorum 配置项设定的。例如，现在有 5 个哨兵，quorum 配置的是 3，那么，一个哨兵需要 3 张赞成票，就可以标记主库为“客观下线”了。这 3 张赞成票包括哨兵自己的一张赞成票和另外两个哨兵的赞成票。<br>&emsp;&emsp;此时，这个哨兵就可以再给其他哨兵发送命令，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。这个投票过程称为“Leader 选举”。因为最终执行主从切换的哨兵 称为 Leader，投票过程就是确定 Leader。在投票过程中，任何一个想成为 Leader 的哨兵，要满足两个条件：第一，拿到半数以上的赞成票；第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。以 3 个哨兵为例，假设此时的 quorum 设置为 2，那么，任何一个想成为 Leader 的哨兵只要拿到 2 张赞成票，就可以了。</p><p>下面展示一下 3 个哨兵、quorum 为 2 的选举过程。<br><img lazyload src="/images/loading.svg" data-src="redis37.jpg" alt="avatar"><br>&emsp;&emsp;如果 S3 没有拿到 2 票 Y，那么这轮投票就不会产生 Leader。哨兵集群会等待一段时间（也就是哨兵故障转移超时时间的 2 倍），再重新选举。这是因为，哨兵集群能够进行成功投票，很大程度上依赖于选举命令的正常网络传播。如果网络压力较大或有短时堵塞， 就可能导致没有一个哨兵能拿到半数以上的赞成票。所以，等到网络拥塞好转之后，再进行投票选举，成功的概率就会增加。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>&emsp;&emsp;假设有一个 Redis 集群，是“一主四从”，同时配置了包含 5 个哨兵实例的集群，quorum 值设为 2。在运行过程中，如果有 3 个哨兵实例都发生故障了，此时，Redis 主库如果有故障，还能正确地判断主库“客观下线”吗？如果可以的话，还能进行主从库自动切换吗？<br>答：1、可以正确的判断主库“客观下线”，以为其中一个哨兵已经获得了“客观下线”所需要 的投票数；2、不能进行自动的主从切换，因为在主从切换的时候，必须选择出一个主哨兵，但是选择 主哨兵有2个条件：2.1、获得半数以上的票数；2.2、票数大于等于 quorum 值。在已经有3个哨兵挂掉的情况下不可能获得超过半数的票。</p><h1 id="Redis-切片集群"><a href="#Redis-切片集群" class="headerlink" title="Redis 切片集群"></a>Redis 切片集群</h1><p>&emsp;&emsp;我们先设想一个场景，如果要存储一个很大规模的数据，例如要用 Redis 保存 5000 万个键值对，每个键值对大约是 512B，粗略地计算了一下，这些键值对所占的内存空间大约是 25GB（5000 万 *512B）。选择一台 32 GB 内存的主机来部署 Redis，32GB 的内存能保存所有数据，而且还留有 7GB，可以保证系统的正常运行。同时采用 RDB 对数据做持久化，以确保 Redis 实例故障后，还能从 RDB 恢复数据。但是，在实际的使用场景中，这种方式可能会导致 Redis 的响应相当慢，这跟 Redis 的持久化机制有关系。在使用 RDB 进行持久化时，Redis 会 fork 子进程来完成，fork 操作的用时和 Redis 的数据量是正相关的，而 fork 在执行时会阻塞主线程。数据量越大，fork 操作造成的主线程阻塞的时间越长。所以，在使用 RDB 对 25GB 的数据进行持久化时，数据量较大，后台运行的子进程在 fork 创建时阻塞了主线程，于是就导致 Redis 响应变慢了。<br>&emsp;&emsp;这样看来，光是通过扩容内存来解决数据量大的问题会引入新的问题。这时我们可以考虑 Redis 的切片集群，它可以保存大量数据，而且对 Redis 主线程的阻塞影响较小。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>&emsp;&emsp;切片集群，也叫分片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。回到我们刚刚的场景中，如果把 25GB 的数据平均分成 5 份（当然，也可以不做均分），使用 5 个实例来保存，每个实例只需要保存 5GB 数据。如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis38.jpg" alt="avatar"><br>&emsp;&emsp;那么，在切片集群中，实例在为 5GB 数据生成 RDB 时，数据量就小了很多，fork 子进程一般不会给主线程带来较长时间的阻塞。采用多个实例保存数据切片后，我们既能保存25GB 数据，又避免了 fork 子进程阻塞主线程而导致的响应突然变慢。</p><h2 id="如何保存更多数据"><a href="#如何保存更多数据" class="headerlink" title="如何保存更多数据"></a>如何保存更多数据</h2><p>&emsp;&emsp;为了保存大量数据，我们可以使用大内存云主机和切片集群两种方法。实际上，这两种方法分别对应着 Redis 应对数据量增多的两种方案：纵向扩展（scale up）和横向扩展（scale out）。</p><ul><li>纵向扩展：升级单个 Redis 实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU。就像下图中，原来的实例内存是 8GB，硬盘是 50GB，纵向扩展后， 内存增加到 24GB，磁盘增加到 150GB。</li><li>横向扩展：横向增加当前 Redis 实例的个数，就像下图中，原来使用 1 个 8GB 内存、 50GB 磁盘的实例，现在使用三个相同配置的实例。<br><img lazyload src="/images/loading.svg" data-src="redis39.jpg" alt="avatar"></li></ul><h2 id="数据切片和实例的对应分布关系"><a href="#数据切片和实例的对应分布关系" class="headerlink" title="数据切片和实例的对应分布关系"></a>数据切片和实例的对应分布关系</h2><p>&emsp;&emsp;在切片集群中，数据需要分布在不同实例上，那么，数据和实例之间如何对应呢？这就和接下来我要讲的 Redis Cluster 方案有关了。不过，我们要先弄明白切片集群和 Redis Cluster 的联系与区别。实际上，切片集群是一种保存大量数据的通用机制，这个机制可以有不同的实现方案。在 Redis 3.0 之前，官方并没有针对切片集群提供具体的方案。从 3.0 开始，官方提供了一个名为 Redis Cluster 的方案，用于实现切片集群。Redis Cluster 方案中就规定了数据和实例的对应规则。<br>&emsp;&emsp;Redis Cluster 方案采用哈希槽来处理数据与实例的映射关系。一个 Redis 切片集群共有 16384 个哈希槽，，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。<br>&emsp;&emsp;具体的映射分为两步：</p><ol><li>根据键值对的 key 计算出一个哈希值，匹配到某一个哈希槽上</li><li>将具体的哈希槽与 Redis 切片实例关联上</li></ol><p>&emsp;&emsp;我们在部署 Redis Cluster 方案时，可以使用 cluster create 命令创建集群，此时，Redis 会自动把这些槽平均分布在集群实例上。例如，如果集群中有 N 个实例，那么，每个实例上的槽个数为 16384/N 个。我们也可以使用 cluster meet 命令手动建立实例间的连接，形成集群，再使用 cluster addslots 命令，指定每个实例上的哈希槽个数。假设集群中不同 Redis 实例的内存大小配置不一，如果把哈希槽均分在各个实例上，在保存相同数量的键值对时，和内存大的实例相比，内存小的实例就会有更大的容量压力。遇到这种情况时，你可以根据不同实例的资源配置情况，使用 cluster addslots 命令手动分配哈希槽。<br>&emsp;&emsp;数据、哈希槽、实例这三者的映射分布情况如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis40.jpg" alt="avatar"><br>&emsp;&emsp;示意图中的切片集群一共有 3 个实例，同时假设有 5 个哈希槽，我们首先可以通过下面的命令手动分配哈希槽：实例 1 保存哈希槽 0 和 1，实例 2 保存哈希槽 2 和 3，实例 3 保存哈希槽 4。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 172.16.19.3 –p 6379 cluster addslots 0,1 </span><br><span class="line">redis-cli -h 172.16.19.4 –p 6379 cluster addslots 2,3 </span><br><span class="line">redis-cli -h 172.16.19.5 –p 6379 cluster addslots 4</span><br></pre></td></tr></table></figure><h2 id="客户端如何定位数据"><a href="#客户端如何定位数据" class="headerlink" title="客户端如何定位数据"></a>客户端如何定位数据</h2><p>&emsp;&emsp;一般来说，客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端。但是，在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，是不知道其他实例拥有的哈希槽信息的。那么，客户端为什么可以在访问任何一个实例时，都能获得所有的哈希槽信息呢？这是因为，Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。<br>&emsp;&emsp;但是，在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：</p><ol><li>在集群中，实例有新增或删除，Redis 需要重新分配哈希槽；</li><li>为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。</li></ol><p>&emsp;&emsp;此时，实例之间还可以通过相互传递消息，获得最新的哈希槽分配信息，但是，客户端是无法主动感知这些变化的。这就会导致，它缓存的分配信息和最新的分配信息就不一致了。Redis Cluster 方案提供了一种重定向机制，所谓的“重定向”，就是指，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令。那客户端又是怎么知道重定向时的新实例的访问地址呢？当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回下面的 MOVED 命令响应结果，这个结果中就包含了新实例的访问地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET hello:key (error) MOVED 13320 172.16.19.5:6379</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，MOVED 命令表示，客户端请求的键值对所在的哈希槽 13320，实际是在 172.16.19.5 这个实例上。通过返回的 MOVED 命令，就相当于把哈希槽所在的新实例的信息告诉给客户端了。这样一来，客户端就可以直接和 172.16.19.5 连接，并发送操作请求了。</p><p>&emsp;&emsp;如下图所示，由于负载均衡， Slot 2 中的数据已经从实例 2 迁移到了实例 3，但是，客户端缓存仍然记录着“Slot 2 在实例 2”的信息，所以会给实例 2 发送命令。实例 2 给客户端返回一条 MOVED 命令，把 Slot 2 的最新位置（也就是在实例 3 上），返回给客户端，客户端就会再次向实例 3 发送请求，同时还会更新本地缓存，把 Slot 2 与实例的对应关系更新过来。<br><img lazyload src="/images/loading.svg" data-src="redis41.jpg" alt="avatar"></p><p>&emsp;&emsp;在实际的使用过程中还会出现一种情况，客户端向实例 2 发送请求，但此时，Slot 2 中的数据只有一部分迁移到了实例 3，还有部分数据没有迁移。在这种迁移部分完成的情况下，客户端就会收到一条 ASK 报错信息，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET hello:key </span><br><span class="line">(error) ASK 13320 172.16.19.5:6379</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个结果中的 ASK 命令就表示，客户端请求的键值对所在的哈希槽 13320，在 172.16.19.5 这个实例上，但是这个哈希槽正在迁移。此时，客户端需要先给 172.16.19.5 这个实例发送一个 ASKING 命令。这个命令的意思是，让这个实例允许执行客户端接下来发送的命令。然后，客户端再向这个实例发送 GET 命令，以读取数据。<br><img lazyload src="/images/loading.svg" data-src="redis42.jpg" alt="avatar"></p><p>&emsp;&emsp;和 MOVED 命令不同，ASK 命令并不会更新客户端缓存的哈希槽分配信息。所以，在上图中，如果客户端再次请求 Slot 2 中的数据，它还是会给实例 2 发送请求。这也就是说，ASK 命令的作用只是让客户端能给新实例发送一次请求，而不像 MOVED 命令那样，会更改本地缓存，让后续所有命令都发往新实例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;两大纬度，三大主线&quot;&gt;&lt;a href=&quot;#两大纬度，三大主线&quot; class=&quot;headerlink&quot; title=&quot;两大纬度，三大主线&quot;&gt;&lt;/a&gt;两大纬度，三大主线&lt;/h1&gt;&lt;p&gt;&lt;img lazyload src=&quot;/images/loading.svg&quot; da</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiahaohong1997.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Redis" scheme="http://jiahaohong1997.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>微服务可用性设计</title>
    <link href="http://jiahaohong1997.github.io/2021/12/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/"/>
    <id>http://jiahaohong1997.github.io/2021/12/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-12-29T07:00:00.000Z</published>
    <updated>2022-01-02T10:06:50.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h1><p>&emsp;&emsp;本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。</p><ul><li>服务隔离</li></ul><ol><li><p>动静隔离</p><p> 小到 CPU 的 cacheline <a class="link" href="https://www.cnblogs.com/cyfonly/p/5800758.html">false sharing<i class="fas fa-external-link-alt"></i></a>、数据库 mysql 表设计中避免 bufferpool 频繁过期，隔离动静表，大到架构设计中的图片、静态资源等缓存加速。本质上都体现的一样的思路，即加速/缓存访问变换频次小的。<br> 案例一： CDN 场景中，将静态资源和动态 API 分离，也是体现了隔离的思路:<br><img lazyload src="/images/loading.svg" data-src="CDN.png" alt="avatar"></p><p> *. 降低了应用服务器的负载，静态文件访问负载全部通过CDN；<br> *. 对象存储费用最低；<br> *. 海量存储空间，无需考虑存储架构的升级；<br> *. 静态CDN带宽加速，延迟低。</p><p>案例二：用户创作稿件库<br> archive: 稿件表，存储稿件的名称、作者、分类、tag、状态等信息，表示稿件的基本信息。在一个投稿流程中，一旦稿件创建改动的频率比较低。<br> archive_stat: 稿件统计表，表示稿件的播放、点赞、收藏、投币数量，比较高频的更新。随着稿件获取流量，稿件被用户所消费，各类计数信息更新比较频繁。<br><img lazyload src="/images/loading.svg" data-src="archive.png" alt="avatar"><br> MySQL BufferPool 是用于缓存 DataPage 的，DataPage 可以理解为缓存了表的行，那么如果频繁更新 DataPage 不断会置换，会导致命中率下降的问题，所以我们在表设计中，仍然可以沿用类似的思路，其主表基本更新，在上游 Cache 未命中，透穿到 MySQL，仍然有 BufferPool 的缓存。</p></li><li><p>读写分离：主从、Replicaset、CQRS</p></li></ol><ul><li>轻重隔离</li></ul><ol><li><p>核心隔离</p><p> 业务按照 Level 进行资源池划分（L0/L1/L2）<br><img lazyload src="/images/loading.svg" data-src="level.png" alt="avatar"><br> 核心/非核心的故障域的差异性隔离（机器资源、依赖资源）<br> 多集群，通过冗余资源来提升吞吐和容灾能力。</p></li><li><p>快慢隔离<br>&emsp;&emsp;我们可以把服务的吞吐想象为一个池，当突然洪流进来时，池子需要一定时间才能排放完，这时候其他支流在池子里待的时间取决于前面的排放能力，耗时就会增高，对小请求产生影响。</p></li></ol><p>日志传输体系的架构设计中，整个流都会投放到一个 kafka topic 中（早期设计目的: 更好的顺序 IO），流内会区分不同的 logid，logid 会有不同的 sink 端，它们之前会出现差速，比如 HDFS 抖动吞吐下降，ES 正常水位，全局数据就会整体反压。<br><img lazyload src="/images/loading.svg" data-src="kafka.png" alt="avatar"><br>按照各种纬度隔离：sink、部门、业务、logid、重要性（S/A/B/C）。<br>业务日志也属于某个 logid，日志等级就可以作为隔离通道。</p><ol start="3"><li>热点隔离(也是解决缓存击穿的策略)</li></ol><p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行缓存。比如：<br>小表广播（单起一个goroutine，采用copy-on-write的方式更新localcache）: 从 remotecache 提升为 localcache，app 定时更新，甚至可以让运营平台支持广播刷新 localcache。<a class="link" href="https://pkg.go.dev/sync/atomic">atomic.Value<i class="fas fa-external-link-alt"></i></a><br><img lazyload src="/images/loading.svg" data-src="atomic.png" alt="avatar"><br>主动预热（旁路监控方式，类似地震前30秒的预警，提前一段时间将缓存中的热点数据变成localcache 存储）: 比如直播房间页高在线情况下 bypass 监控主动防御。<br><img lazyload src="/images/loading.svg" data-src="monitor.png" alt="avatar"></p><ul><li>物理隔离</li></ul><ol><li><p>线程隔离<br>&emsp;&emsp;主要通过线程池进行隔离，也是实现服务隔离的基础。把业务进行分类并交给不同的线程池进行处理，当某个线程池处理一种业务请求发生问题时，不会讲故障扩散和影响到其他线程池，保证服务可用。<br>对于 Go 来说，所有 IO 都是 Nonblocking，且托管给了 Runtime，只会阻塞 Goroutine，不阻塞 M，我们只需要考虑 Goroutine 总量的控制，不需要线程模型语言的线程隔离。<br><img lazyload src="/images/loading.svg" data-src="java.png" alt="avatar"></p></li><li><p>进程隔离<br>&emsp;&emsp;容器化（docker），容器编排引擎（k8s）。我们15年在 KVM 上部署服务；16年使用 Docker Swarm；17年迁移到 Kubernetes，到年底在线应用就全托管了，之后很快在线应用弹性公有云上线；20年离线 Yarn 和 在线 K8s 做了在离线混部（错峰使用），之后计划弹性公有云配合自建 IDC 做到离线的混合云架构。</p></li><li><p>集群隔离<br>&emsp;&emsp;过多集群方案，即逻辑上是一个应用，物理上部署多套应用，通过 cluster 区分。</p></li></ol><h2 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h2><ol><li>转码集群被超大视频攻击，导致转码大量延迟。</li></ol><p>&emsp;&emsp;针对大视频、较大视频、重要视频分别设置转码集群，当再遭遇转码攻击，只会影响部分的服务器，还能维持整体的可用。</p><ol start="2"><li>缩略图服务，被大图实时缩略吃完所有 CPU，导致正常的小图缩略被丢弃，大量503。</li></ol><p>&emsp;&emsp;对于请求的图像，不会专门针对所有设备都预设好图片的尺寸，会根据用户的设备大小进行实时的缩略。如果请求了大量的 gif，那么对 gif的每一帧都要进行实时缩略，耗时比图像要久很多。把 gif 和正常图像分为两个集群来处理，将全剧故障化解为局部故障。</p><ol start="3"><li><p> 数据库实例 cgroup 未隔离，导致大 SQL 引起的集体故障。</p></li><li><p> INFO 日志量过大，导致异常 ERROR 日志采集延迟。</p></li></ol><h1 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h1><p>&emsp;&emsp;超时控制，我们的组件能够快速失效（fail fast），因为我们不希望等到断开的实例直到超时。没有什么比挂起的请求和无响应的界面更令人失望。这不仅浪费资源，而且还会让用户体验变得更差。我们的服务是互相调用的，所以在这些延迟叠加前，应该特别注意防止那些超时的操作。<br><img lazyload src="/images/loading.svg" data-src="timeout.png" alt="avatar"></p><ul><li>网路传递具有不确定性。</li><li>客户端和服务端不一致的超时策略导致资源浪费。</li><li>默认值”策略。(不建议使用“永不超时”默认值)</li><li>高延迟服务导致 client 浪费资源等待，使用超时传递: 进程间传递 + 跨进程传递。</li></ul><p>&emsp;&emsp;超时控制是微服务可用性的第一道关，良好的超时策略，可以尽可能让服务不堆积请求，尽快清空高延迟的请求，释放 Goroutine。</p><h2 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h2><p>&emsp;&emsp;实际业务开发中，我们依赖的微服务的超时策略并不清楚，或者随着业务迭代耗时超生了变化，意外的导致依赖者出现了超时。<br>处理策略：</p><ul><li> 服务提供者定义好 latency SLO，更新到 gRPC Proto 定义中，服务后续迭代，都应保证 SLO。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> google.example.library.v1;</span><br><span class="line"></span><br><span class="line">service LibraryService &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Lagency SLO: 95th in 100ms, 99th in 150ms.</span></span><br><span class="line"></span><br><span class="line"> rpc CreateBook(CreateBookRequest) returns (Book);</span><br><span class="line"></span><br><span class="line"> rpc GetBook(GetBookRequest) returns Book);</span><br><span class="line"></span><br><span class="line"> rpc ListBooks(ListBooksRequest) returns (ListBooksResponse);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免出现意外的默认超时策略，或者意外的配置超时策略。</p><ul><li>kit 基础库兜底默认超时，比如 100ms，进行配置防御保护，避免出现类似 60s 之类的超大超时策略。</li><li>配置中心公共模版，对于未配置的服务使用公共配置。</li></ul><h3 id="超时传递"><a href="#超时传递" class="headerlink" title="超时传递"></a>超时传递</h3><p> &emsp;&emsp;超时传递: 当上游服务已经超时返回 504，但下游服务仍然在执行，会导致浪费资源做无用功。超时传递指的是把当前服务的剩余 Quota 传递到下游服务中，继承超时策略，控制请求级别的全局超时控制。<br> <img lazyload src="/images/loading.svg" data-src="timetransfer.png" alt="avatar"><br> 取配置的超时控制策略与剩余时间的最小值。</p><ul><li><p>进程内超时控制<br>&emsp;&emsp;一个请求在每个阶段(网络请求)开始前，就要检查是否还有足够的剩余来处理请求，以及继承他的超时策略，使用 Go 标准库的 <a class="link" href="https://pkg.go.dev/context">context.WithTimeout<i class="fas fa-external-link-alt"></i></a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *asiiConn)</span> <span class="title">Get</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="params">(result \*Item, err error)</span></span> &#123;</span><br><span class="line">c.conn.SetWriteDeadline(shrinkDeadline(ctx, c.writeTimeout))</span><br><span class="line"><span class="keyword">if</span> _, err = fmt.Fprintf(c.rw, <span class="string">&quot;gets %s\r\n&quot;</span>, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多进程的超时控制<br><img lazyload src="/images/loading.svg" data-src="processcontrol.png" alt="avatar"></p></li></ul><ol><li>A gRPC 请求 B，1s超时。</li><li>B 使用了300ms 处理请求，再转发请求 C。</li><li>C 配置了600ms 超时，但是实际只用了500ms。</li><li>到其他的下游，发现余量不足，取消传递。</li></ol><p>在需要强制执行时，下游的服务可以覆盖上游的超时传递和配额。<br>在 gRPC 框架中，会依赖 gRPC Metadata Exchange，基于 HTTP2 的 Headers 传递 grpc-timeout 字段，自动传递到下游，构建带 timeout 的 context。</p><p><img lazyload src="/images/loading.svg" data-src="Bimodel.png" alt="avatar"></p><ul><li>双峰分布: 95%的请求耗时在100ms内，5%的请求可能永远不会完成（长超时）。</li><li>对于监控不要只看 mean，可以看看耗时分布统计，比如 95th，99th。</li><li>设置合理的超时，拒绝超长请求，或者当Server 不可用要主动失败。</li></ul><p><strong>超时决定着服务线程耗尽。</strong></p><h2 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h2><ul><li>SLB 入口 Nginx 没配置超时导致连锁故障。</li><li>服务依赖的 DB 连接池漏配超时，导致请求阻塞，最终服务集体 OOM。</li><li>下游服务发版耗时增加，而上游服务配置超时过短，导致上游请求失败。</li></ul><h1 id="过载保护和限流"><a href="#过载保护和限流" class="headerlink" title="过载保护和限流"></a>过载保护和限流</h1><h2 id="过载保护"><a href="#过载保护" class="headerlink" title="过载保护"></a>过载保护</h2><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>   一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：</p><ul><li>假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。</li><li>桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝。</li><li>当一个 n 个字节大小的数据包到达，将从桶中删除n 个令牌，接着数据包被发送到网络上。</li><li>如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。</li></ul><p><img lazyload src="/images/loading.svg" data-src="token-bucket.png" alt="avatar"><br>token-bucket rate limit algorithm: <a class="link" href="https://pkg.go.dev/golang.org/x/time/rate">/x/time/rate<i class="fas fa-external-link-alt"></i></a></p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>作为计量工具（The Leaky Bucket Algorithm as a Meter）时，可以用于流量整形（Traffic Shaping）和流量控制（TrafficPolicing），漏桶算法的描述如下：</p><ul><li> 一个固定容量的漏桶，按照常量固定速率流出水滴。</li><li>如果桶是空的，则不需流出水滴。</li><li>可以以任意速率流入水滴到漏桶。</li><li>如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。<br><img lazyload src="/images/loading.svg" data-src="leaky-bucket.png" alt="avatar"><br>leaky-bucket rate limit algorithm: <a class="link" href="https://pkg.go.dev/go.uber.org/ratelimit">/go.uber.org/ratelimit<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="令牌桶和漏桶算法的弊端"><a href="#令牌桶和漏桶算法的弊端" class="headerlink" title="令牌桶和漏桶算法的弊端"></a>令牌桶和漏桶算法的弊端</h3><p>&emsp;&emsp;漏斗桶/令牌桶确实能够保护系统不被拖垮, 但不管漏斗桶还是令牌桶, 其防护思路都是设定一个指标, 当超过该指标后就阻止或减少流量的继续进入，当系统负载降低到某一水平后则恢复流量的进入。但其通常都是被动的，其实际效果取决于限流阈值设置是否合理，但往往设置合理不是一件容易的事情。</p><ul><li>集群增加机器或者减少机器限流阈值是否要重新设置?</li><li>设置限流阈值的依据是什么?</li><li>人力运维成本是否过高?</li><li>当调用方反馈429时, 这个时候重新设置限流, 其实流量高峰已经过了重新评估限流是否有意义?</li></ul><p>&emsp;&emsp;这些其实都是采用漏斗桶/令牌桶的缺点, 总体来说就是太被动, 不能快速适应流量变化。因此我们需要一种自适应的限流算法，即: 过载保护，根据系统当前的负载自动丢弃流量。</p><h3 id="根据系统负载做过载保护"><a href="#根据系统负载做过载保护" class="headerlink" title="根据系统负载做过载保护"></a>根据系统负载做过载保护</h3><p>&emsp;&emsp;计算系统临近过载时的峰值吞吐作为限流的阈值来进行流量控制，达到系统保护。</p><ul><li>服务器临近过载时，主动抛弃一定量的负载，目标是自保。</li><li>在系统稳定的前提下，保持系统的吞吐量。</li></ul><p>常见做法：利特尔法则<br><img lazyload src="/images/loading.svg" data-src="lierte.png" alt="avatar"></p><ul><li>CPU、内存作为信号量进行节流。</li><li>队列管理: 队列长度、LIFO。</li><li>可控延迟算法: <a class="link" href="https://blog.csdn.net/dog250/article/details/72849893">Co<i class="fas fa-external-link-alt"></i></a><a class="link" href="https://blog.csdn.net/dog250/article/details/72849893">D<i class="fas fa-external-link-alt"></i></a><a class="link" href="https://blog.csdn.net/dog250/article/details/72849893">el<i class="fas fa-external-link-alt"></i></a>。</li></ul><p>如何计算接近峰值时的系统吞吐？</p><ul><li><p>CPU: 使用一个独立的线程采样，每隔 250ms 触发一次。在计算均值时，使用了简单滑动平均去除峰值的影响。<br><img lazyload src="/images/loading.svg" data-src="cpu.png" alt="avatar"></p></li><li><p>Inflight: 当前服务中正在进行的请求的数量。</p></li><li><p>Pass&amp;RT: 最近5s，pass 为每100ms采样窗口内成功请求的数量，rt 为单个采样窗口中平均响应时间。<br><img lazyload src="/images/loading.svg" data-src="slide.png" alt="avatar"></p></li><li><p>使用 CPU 的滑动均值（CPU &gt; 800）作为启发阈值，一旦触发进入到过载保护阶段，算法为：(pass* rt) &lt; inflight</p></li><li><p>限流效果生效后，CPU 会在临界值（800）附近抖动，如果不使用冷却时间，那么一个短时间的 CPU 下降就可能导致大量请求被放行，严重时会打满 CPU。</p></li><li><p>在冷却时间后，重新判断阈值（CPU &gt; 800 ），是否持续进入过载保护。</p></li></ul><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>&amp;emsp&emsp;在一段时间内，定义某个客户或应用可以接收或处理多少个请求的技术。例如，通过限流，你可以过滤掉产生流量峰值的客户和微服务，或者可以确保你的应用程序在自动扩展（Auto Scaling）失效前都不会出现过载的情况。</p><ul><li>令牌桶、漏桶 针对单个节点，无法分布式限流。</li><li>QPS 限流<ul><li>不同的请求可能需要数量迥异的资源来处理。</li><li>某种静态 QPS 限流不是特别准。</li></ul></li><li>给每个用户设置限制<ul><li>全局过载发生时候，针对某些“异常”进行控制。</li><li>一定程度的“超卖”配额。</li></ul></li><li>按照优先级丢弃。</li><li>拒绝请求也需要成本。<br><img lazyload src="/images/loading.svg" data-src="rateLimitEnabled.png" alt="avatar"></li></ul><h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p>&emsp;&emsp; 分布式限流，是为了控制某个应用全局的流量，而非真对单个节点纬度。</p><ul><li>单个大流量的接口，使用 redis 容易产生热点。</li><li>pre-request 模式对性能有一定影响，高频的网络往返。  </li></ul><p><img lazyload src="/images/loading.svg" data-src="distributed.png" alt="avatar"></p><p>思考：<br>&emsp;&emsp;从获取单个 quota 升级成批量 quota。quota: 表示速率，获取后使用令牌桶算法来限制。</p><ul><li>每次心跳后，异步批量获取 quota，可以大大减少请求 redis 的频次，获取完以后本地消费，基于令牌桶拦截</li><li>每次申请的配额需要手动设定静态值略欠灵活，比如每次要20，还是50</li></ul><p><img lazyload src="/images/loading.svg" data-src="redis.png" alt="avatar"></p><p>如何基于单个节点按需申请，并且避免出现不公平的现象？<br>初次使用默认值，一旦有过去历史窗口的数据，可以基于历史窗口数据进行 quota 请求。</p><p>思考：<br>我们经常面临给一组用户划分稀有资源的问题，他们都享有等价的权利来获取资源，但是其中一些用户实际上只需要比其他用户少的资源。那么我们如何来分配资源呢？一种在实际中广泛使用的分享技术称作“最大最小公平分享”（Max-Min Fairness）。<br><img lazyload src="/images/loading.svg" data-src="max-min.png" alt="avatar"></p><p>直观上，公平分享分配给每个用户想要的可以满足的最小需求，然后将没有使用的资源均匀的分配给需要‘大资源’的用户。</p><p>最大最小公平分配算法的形式化定义如下：<br>•资源按照需求递增的顺序进行分配。<br>•不存在用户得到的资源超过自己的需求。<br>•未得到满足的用户等价的分享资源。</p><p><img lazyload src="/images/loading.svg" data-src="compare.png" alt="avatar"></p><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>&emsp;&emsp;每个接口配置阈值，运营工作繁重，最简单的我们配置服务级别 quota，更细粒度的，我们可以根据不同重要性设定 quota，我们引入了重要性（criticality）:</p><p>•最重要 CRITICAL_PLUS，为最终的要求预留的类型，拒绝这些请求会造成非常严重的用户可见的问题。<br>•重要 CRITICAL，生产任务发出的默认请求类型。拒绝这些请求也会造成用户可见的问题。但是可能没那么严重。<br>•可丢弃的 SHEDDABLE_PLUS 这些流量可以容忍某种程度的不可用性。这是批量任务发出的请求的默认值。这些请求通常可以过几分钟、几小时后重试。<br>•可丢弃的 SHEDDABLE 这些流量可能会经常遇到部分不可用情况，偶尔会完全不可用。</p><p>&emsp;&emsp;gRPC 系统之间，需要自动传递重要性信息。如果后端接受到请求 A，在处理过程中发出了请求 B 和 C 给其他后端，请求 B 和 C 会使用与 A 相同的重要性属性。</p><p>•全局配额不足时，优先拒绝低优先级的。<br>•全局配额，可以按照重要性分别设置。<br>•过载保护时，低优先级的请求先被拒绝。</p><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>&emsp;&emsp;断路器（Circuit Breakers）: 为了限制操作的持续时间，我们可以使用超时，超时可以防止挂起操作并保证系统可以响应。因为我们处于高度动态的环境中，几乎不可能确定在每种情况下都能正常工作的准确的时间限制。断路器以现实世界的电子元件命名，因为它们的行为是都是相同的。断路器在分布式系统中非常有用，因为重复的故障可能会导致雪球效应，并使整个系统崩溃。</p><ul><li>服务依赖的资源出现大量错误。</li><li>某个用户超过资源配额时，后端任务会快速拒绝请求，返回“配额不足”的错误，但是拒绝回复仍然会消耗一定资源。有可能后端忙着不停发送拒绝请求，导致过载。<br><img lazyload src="/images/loading.svg" data-src="rongduan.png" alt="avatar"></li></ul><p>Google SRE<br>max(0, (requests - K*accepts) / (requests + 1))<br><img lazyload src="/images/loading.svg" data-src="google.png" alt="avatar"><br><img lazyload src="/images/loading.svg" data-src="google1.png" alt="avatar"></p><h3 id="Gutter"><a href="#Gutter" class="headerlink" title="Gutter"></a>Gutter</h3><p>&emsp;&emsp;基于熔断的 gutter kafka ，用于接管自动修复系统运行过程中的负载，这样只需要付出10%的资源就能解决部分系统可用性问题。我们经常使用 failover 的思路，但是完整的 failover 需要翻倍的机器资源，平常不接受流量时，资源浪费。高负载情况下接管流量又不一定完整能接住。所以这里核心利用熔断的思路，是把抛弃的流量转移到 gutter 集群，如果 gutter 也接受不住的流量，重新回抛到主集群，最大力度来接受。<br><img lazyload src="/images/loading.svg" data-src="gutter.png" alt="avatar"></p><h3 id="客户端流控"><a href="#客户端流控" class="headerlink" title="客户端流控"></a>客户端流控</h3><p>positive feedback: 用户总是积极重试，访问一个不可达的服务。<br>•客户端需要限制请求频次，retry backoff 做一定的请求退让。<br><img lazyload src="/images/loading.svg" data-src="backoff.png" alt="avatar"><br>•可以通过接口级别的 error_details，挂载到每个 API 返回的响应里。<br><img lazyload src="/images/loading.svg" data-src="error.png" alt="avatar"></p><h3 id="Case-1"><a href="#Case-1" class="headerlink" title="Case"></a>Case</h3><ol><li>二层缓存穿透、大量回源导致的核心服务（例如Mysql）故障。</li></ol><p>通过限流策略，控制到达Mysql的请求速率，让Mysql的缓存逐步建立，避免被海量的请求直接打死。</p><ol start="2"><li>异常客户端引起的服务故障（query of death）</li></ol><ul><li>请求放大。</li><li>资源数放大</li></ul><p>针对相应的用户做专门的限制，比如最多只放行 k 个请求。</p><ol start="3"><li>用户重试导致的大面积故障。</li></ol><p>在客户端限制用户的请求频次。</p><h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><p>&emsp;&emsp;通过降级回复来减少工作量，或者丢弃不重要的请求。而且需要了解哪些流量可以降级，并且有能力区分不同的请求。我们通常提供降低回复的质量来答复减少所需的计算量或者时间。我们自动降级通常需要考虑几个点：<br>•确定具体采用哪个指标作为流量评估和优雅降级的决定性指标（如，CPU、延迟、队列长度、线程数量、错误等）。<br>•当服务进入降级模式时，需要执行什么动作？<br>•流量抛弃或者优雅降级应该在服务的哪一层实现？是否需要在整个服务的每一层都实现，还是可以选择某个高层面的关键节点来实现？</p><p>同时我们要考虑一下几点：<br>•优雅降级不应该被经常触发 - 通常触发条件现实了容量规划的失误，或者是意外的负载。<br>•演练，代码平时不会触发和使用，需要定期针对一小部分的流量进行演练，保证模式的正常。<br>•应该足够简单。</p><h2 id="降级本质为-提供有损服务。"><a href="#降级本质为-提供有损服务。" class="headerlink" title="降级本质为: 提供有损服务。"></a>降级本质为: 提供有损服务。</h2><ol><li><p>UI 模块化，非核心模块降级。</p><ul><li>BFF 层聚合 API，模块降级。<br><img lazyload src="/images/loading.svg" data-src="bilibili.png" alt="avatar"></li></ul></li><li><p>页面上一次缓存副本。</p></li><li><p>默认值、热门推荐等。</p></li><li><p>流量拦截 + 定期数据缓存(过期副本策略)。</p></li></ol><p>处理策略<br>•页面降级、延迟服务、写/读降级、缓存降级<br>•抛异常、返回约定协议、Mock 数据、Fallback 处理<br><img lazyload src="/images/loading.svg" data-src="fallback.png" alt="avatar"></p><h2 id="Case-2"><a href="#Case-2" class="headerlink" title="Case"></a>Case</h2><ol><li>客户端解析协议失败，app 奔溃。</li></ol><p>要返回的默认降级数据（空数组、nil）一定要和客户端的开发人员进行沟通，否则会导致客户端解析失败而闪退。</p><ol start="2"><li>客户端部分协议不兼容，导致页面失败。</li><li> local cache 数据源缓存，发版失效 + 依赖接口故障，引起的白屏。</li></ol><p>解决方案：在远程remote cache 中再保存一份。</p><h1 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h1><p>&emsp;&emsp;当请求返回错误（例: 配额不足、超时、内部错误等），对于 backend 部分节点过载的情况下，倾向于立刻重试，但是需要留意重试带来的流量放大:</p><p>•限制重试次数和基于重试分布的策略（重试比率: 10%）。<br>•随机化、指数型递增的重试周期: exponential ackoff + jitter。<br>•client 测记录重试次数直方图，传递到 server，进行分布判定，交由 server 判定拒绝。<br>•只应该在失败的这层进行重试，当重试仍然失败，全局约定错误码“过载，无须重试”，避免级联重试。</p><h2 id="Case-3"><a href="#Case-3" class="headerlink" title="Case"></a>Case</h2><ol><li>Nginx upstream retry 过大，导致服务雪崩。</li></ol><ol start="2"><li><p>业务不幂等，导致的重试，数据重复。<br>•全局唯一 ID: 根据业务生成一个全局唯一 ID，在调用接口时会传入该 ID，接口提供方会从相应的存储系统比如 redis 中去检索这个全局 ID 是否存在，如果存在则说明该操作已经执行过了，将拒绝本次服务请求；否则将相应该服务请求并将全局 ID 存入存储系统中,之后包含相同业务 ID 参数的请求将被拒绝。<br>•去重表: 这种方法适用于在业务中有唯一标识的插入场景。比如在支付场景中，一个订单只会支付一次，可以建立一张去重表,将订单 ID 作为唯一索引。把支付并且写入支付单据到去重表放入一个事务中了，这样当出现重复支付时，数据库就会抛出唯一约束异常,操作就会回滚。这样保证了订单只会被支付一次。<br>•多版本并发控制: 适合对更新请求作幂等性控制,比如要更新商品的名字，这是就可以在更新的接口中增加一个版本号来做幂等性控制。</p></li><li><p>多层级重试传递，放大流量引起雪崩。</p></li></ol><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="数据中心内部的负载均衡"><a href="#数据中心内部的负载均衡" class="headerlink" title="数据中心内部的负载均衡"></a>数据中心内部的负载均衡</h2><p>&emsp;&emsp;在理想情况下，某个服务的负载会完全均匀地分发给所有的后端任务。在任何时刻，最忙和最不忙的节点永远消耗同样数量的CPU。<br>目标：<br>•均衡的流量分发。<br>•可靠的识别异常节点。<br>•scale-out，增加同质节点扩容。<br>•减少错误，提高可用性。<br><img lazyload src="/images/loading.svg" data-src="SLB.png" alt="avatar"></p><p>   在 backend 之间的 load 差异比较大：</p><ul><li>每个请求的处理成本不同。</li><li>物理机环境的差异:<ul><li>服务器很难强同质性。</li><li>存在共享资源争用（内存缓存、带宽、IO等）。</li></ul></li><li>性能因素:<ul><li>FullGC。</li><li>JVM JIT。<br><img lazyload src="/images/loading.svg" data-src="load.png" alt="avatar"></li></ul></li></ul><p>参考JSQ（最闲轮训）负载均衡算法带来的问题，缺乏的是服务端全局视图，因此我们目标需要综合考虑：负载+可用性。<br><img lazyload src="/images/loading.svg" data-src="LB.png" alt="avatar"></p><p><img lazyload src="/images/loading.svg" data-src="S.png" alt="avatar"></p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ul><li>变更管理:<ul><li>70％的问题是由变更引起的，恢复可用代码并不总是坏事。</li></ul></li><li>避免过载:<ul><li>过载保护、流量调度等。</li></ul></li><li>依赖管理:<ul><li>任何依赖都可能故障，做 chaos monkey testing，注入故障测试。</li></ul></li><li>优雅降级:<ul><li>有损服务，避免核心链路依赖故障。</li></ul></li><li>重试退避:<ul><li>退让算法，冻结时间，API retry detail 控制策略。</li></ul></li><li>超时控制:<ul><li>进程内 + 服务间 超时控制。</li></ul></li><li>极限压测 + 故障演练。</li><li>扩容 + 重启 + 消除有害流量。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;隔离&quot;&gt;&lt;a href=&quot;#隔离&quot; class=&quot;headerlink&quot; title=&quot;隔离&quot;&gt;&lt;/a&gt;隔离&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，</summary>
      
    
    
    
    <category term="微服务" scheme="http://jiahaohong1997.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="开发" scheme="http://jiahaohong1997.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>gin开发中踩过的坑</title>
    <link href="http://jiahaohong1997.github.io/2021/12/13/gin%E5%BC%80%E5%8F%91%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    <id>http://jiahaohong1997.github.io/2021/12/13/gin%E5%BC%80%E5%8F%91%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</id>
    <published>2021-12-13T04:46:00.000Z</published>
    <updated>2021-12-12T16:48:21.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gin框架操作Cookie"><a href="#gin框架操作Cookie" class="headerlink" title="gin框架操作Cookie"></a>gin框架操作Cookie</h1><p>坑：c.SetCookie 中的的 domain 定义成什么就要用什么访问 cookie 才会生效，例如，定义的 127.0.0.1，浏览器访问时也必须输入 127.0.0.1 才行，localhost 都不行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line">    router.GET(<span class="string">&quot;/cookie&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        cookie, err := c.Cookie(<span class="string">&quot;gin_cookie&quot;</span>) <span class="comment">// 获取Cookie</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            cookie = <span class="string">&quot;NotSet&quot;</span></span><br><span class="line">            <span class="comment">// 给客户端设置Cookie,maxAge：3600秒后过期，</span></span><br><span class="line">            <span class="comment">// path：cookie/为Cookie所在目录，</span></span><br><span class="line">            <span class="comment">// domain stinrg：域名</span></span><br><span class="line">            <span class="comment">// secure：是否只能通过https访问</span></span><br><span class="line">            <span class="comment">// httpOnly bool：是否允许别人通过js获取自己的cookie</span></span><br><span class="line">            c.SetCookie(<span class="string">&quot;gin_cookie&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="number">3600</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Cookie value: %s \n&quot;</span>, cookie)</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;gin框架操作Cookie&quot;&gt;&lt;a href=&quot;#gin框架操作Cookie&quot; class=&quot;headerlink&quot; title=&quot;gin框架操作Cookie&quot;&gt;&lt;/a&gt;gin框架操作Cookie&lt;/h1&gt;&lt;p&gt;坑：c.SetCookie 中的的 domain 定</summary>
      
    
    
    
    <category term="web开发" scheme="http://jiahaohong1997.github.io/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="踩坑" scheme="http://jiahaohong1997.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>使用Gin如何优雅的停止监听</title>
    <link href="http://jiahaohong1997.github.io/2021/12/08/%E4%BD%BF%E7%94%A8Gin%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%81%9C%E6%AD%A2%E7%9B%91%E5%90%AC/"/>
    <id>http://jiahaohong1997.github.io/2021/12/08/%E4%BD%BF%E7%94%A8Gin%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%81%9C%E6%AD%A2%E7%9B%91%E5%90%AC/</id>
    <published>2021-12-08T11:34:00.000Z</published>
    <updated>2021-12-08T11:39:05.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="暴力停止"><a href="#暴力停止" class="headerlink" title="暴力停止"></a>暴力停止</h1><p>&emsp;&emsp;我们在 go run main.go 后，若需要停止监听，需要使用 <code>ctrl+c</code> 终止监听。该方案会立即终止服务器监听，同时结束正在处理的请求，也就是说若存在未处理完毕的请求，是不能继续处理的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run() <span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优雅停止"><a href="#优雅停止" class="headerlink" title="优雅停止"></a>优雅停止</h1><p>&emsp;&emsp;代替示例代码中 <code>router.Run()</code> 方法，我们可以使用 <code>http.Server</code> 内置的 <a class="link" href="https://golang.org/pkg/net/http/#Server.Shutdown">Shutdown()<i class="fas fa-external-link-alt"></i></a> 方法优雅地停止。所谓优雅，指的是可以将正在处理的请求处理完毕后再关闭服务器。示例代码如下 main.go ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 常规的初始化路由</span></span><br><span class="line">    router := gin.Default()</span><br><span class="line">    router.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">        c.String(http.StatusOK, <span class="string">&quot;Welcome Gin Server&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 定义服务器</span></span><br><span class="line">    srv := &amp;http.Server&#123;</span><br><span class="line">        Addr:    <span class="string">&quot;:8080&quot;</span>,</span><br><span class="line">        Handler: router,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用 goroutine 启动监听</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// srv.ListenAndServe() 监听</span></span><br><span class="line">        <span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;</span><br><span class="line">            log.Fatalf(<span class="string">&quot;listen: %s\n&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待中断信号以优雅地关闭服务器（设置 5 秒的超时时间）</span></span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(quit, os.Interrupt)</span><br><span class="line">    <span class="comment">// quit 信道是同步信道，若没有信号进来，处于阻塞状态</span></span><br><span class="line">    <span class="comment">// 反之，则执行后续代码</span></span><br><span class="line">    &lt;-quit</span><br><span class="line">    log.Println(<span class="string">&quot;Shutdown Server ...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    <span class="comment">// 调用 srv.Shutdown() 完成优雅停止</span></span><br><span class="line">    <span class="comment">// 调用时传递了一个上下文对象，对象中定义了超时时间</span></span><br><span class="line">    <span class="keyword">if</span> err := srv.Shutdown(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;Server Shutdown:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;Server exiting&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试以上代码，结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running <span class="keyword">in</span> <span class="string">&quot;debug&quot;</span> mode. Switch to <span class="string">&quot;release&quot;</span> mode <span class="keyword">in</span> production.</span><br><span class="line"> - using env:   <span class="built_in">export</span> GIN_MODE=release</span><br><span class="line"> - using code:  gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /                         --&gt; main.main.func1 (3 handlers)</span><br><span class="line">2019/11/05 22:49:04 Shutdown Server ...</span><br><span class="line">[GIN] 2019/11/05 - 22:49:07 | 200 |    5.0000438s |             ::1 | GET      /</span><br><span class="line">2019/11/05 22:49:08 Server exiting</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;暴力停止&quot;&gt;&lt;a href=&quot;#暴力停止&quot; class=&quot;headerlink&quot; title=&quot;暴力停止&quot;&gt;&lt;/a&gt;暴力停止&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;我们在 go run main.go 后，若需要停止监听，需要使用 &lt;code&gt;ctrl+c&lt;/co</summary>
      
    
    
    
    <category term="Go框架" scheme="http://jiahaohong1997.github.io/categories/Go%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="web框架" scheme="http://jiahaohong1997.github.io/tags/web%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Go语言的错误处理</title>
    <link href="http://jiahaohong1997.github.io/2021/12/05/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>http://jiahaohong1997.github.io/2021/12/05/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</id>
    <published>2021-12-04T17:56:00.000Z</published>
    <updated>2022-03-31T21:46:40.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Error-vs-Exception"><a href="#Error-vs-Exception" class="headerlink" title="Error vs Exception"></a>Error vs Exception</h1><p>先看下面一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a named type for our new error type</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement the error interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New creates interface values of type error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> errorString(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrNamedType = New(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> ErrStructType = errors.New(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ErrNamedType == New(<span class="string">&quot;EOF&quot;</span>) &#123;  <span class="comment">// true</span></span><br><span class="line">fmt. Println(<span class="string">&quot;Named Type Error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ErrStructType == errors.New(<span class="string">&quot;EOF&quot;</span>) &#123; <span class="comment">// false</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Struct Type Error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>ErrNamedType</code> 是我们自己定义的<code>Error</code> 方法，它是一个<code>string</code> 类型的变量(错误描述)，只要错误描述相同，那么两个<code>Error</code>是一样的。<code>ErrStructType</code>是通过<code>go</code>标准库定义的<code>Error</code> 类型，它是指向<code>string</code> 类型的错误描述的指针，即使错误描述一样，也会因为指向其地址的指针不同而不同。</p><h2 id="各语言的演进历史"><a href="#各语言的演进历史" class="headerlink" title="各语言的演进历史"></a>各语言的演进历史</h2><ul><li>C</li></ul><p>&emsp;&emsp;单返回值，一般通过传递指针作为入参，返回值为 int 表示成功还是失败。</p><ul><li>C++</li></ul><p>&emsp;&emsp;引入了exception，但是无法知道被调用方会城出什么异常。</p><ul><li>Java</li></ul><p>&emsp;&emsp;引入了checked exception，方法的所有者必须申明，调用者必须处理。在启动时拋出大量的异常是司空见惯的事情，并在它们的调用堆栈中尽职地记录下来。Java 异常不再是异常，而是变得司空见惯了。它们从良性到灾难性都有使用，异常的严重性由两数的调用者来区分。</p><ul><li>Go</li></ul><p>&emsp;&emsp;Go 的处理异常逻辑是不引入 exception，支持多参数返回，所以很容易的在函数签名中带上实现了 error interface 的对象，交由调用者来判定。如果一个西数返回了(value,error)，你不<strong>能对这个 value 做任何假设，必须先判定 error</strong>。唯一可以忽路error 的是，如果你连 value 也不关心。Go 中有 panic 的机制，如果你认为和其他语言的 exception 一样，那你就错了。当我们拋出异常的时候，相当于你把 exception 扔给了调用者来处理。比如，你在C++ 中，把string 转为 int， 如果转换失败，拋出异常。或者在 java 中转换 string 为 date 失败时，拋出异常。Go panic 意味着 fatal error（就是挂了）。不能假设调用者来解决 panic，意味着代码不能继续运行。</p><p>&emsp;&emsp;使用多个返回值和一个简单的约定，Go解决了让程序员知道什么时候出了问题，并为真正的异常情况保留了 panic。可以更好的分别什么时候是良性异常，什么时候是真正的错误。通过 panic + recover 还可以为代码兜底，放弃掉这个<code>request</code> 进而保证别的<code>request</code> 的正常处理。</p><p>&emsp;&emsp;对于真正意外的情况，那些表示不可恢复的程序错误，例如索引l越界、不可恢复的环境问题、栈溢出，我们才使用 panic。对于其他的错误情况，我们应该是期望使用 error 来进行判定。下面是Go使用这种机制的理由：</p><ol><li>简单</li><li>考虑失败，而不是成功(plan for failure, not success)</li><li>没有隐藏的控制流</li><li>完全交给你来控制 Error</li><li>Error are values</li></ol><h1 id="Sentinel-Error"><a href="#Sentinel-Error" class="headerlink" title="Sentinel Error"></a>Sentinel Error</h1><p>&emsp;&emsp;预定义的特定错误，我们叫做 <code>sentinel error</code>，这个名字来源于计算机编程中使用一个特定的值来表示不可能进行进一步处理的做法。所以对于Go，我们使用特定的值来表示错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err == ErrSomething &#123;...&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Error)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="keyword">string</span>(e) &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用 <code>sentinel</code>值是最不灵活的错误处理策略，因为调用方法必须使用 == 将结果与预先声明的值进行比较。当你想要提供更多的上下文，这就出现了一个问题，因为返回一个不通的错误将破坏相等性检查。</p><p>&emsp;&emsp;甚至是一些有意义的 <code>fmt.Errof</code>携带一些上下文，也会破坏调用者的 ==，将调用者被迫查看error.Error()方法的输出，一查看它是否与特定的字符串匹配。</p><ul><li>不依赖 error.Error() 的输出</li></ul><p>&emsp;&emsp;不应该依赖检测 error.Error() 的输出，Error 方法存在于 error 接口主要用于方便程序员使用而不是程序（编写测试可能会依赖这个返回）。这个输出的字符串用于记录日志、输出到 stdout。</p><ul><li>Sentinel errors 成为你 API 公共部分</li></ul><p>&emsp;&emsp;如果你的公共函数或方法返回一个特定的错误，那么该值必须是公共的，当然要有文档记录，这会增加API的表面积。</p><p>&emsp;&emsp;如果 API 定义了一个返回特定错误的 interface，则该接口的所有实现豆浆杯限制为仅返回该错误，即使它们可以提供更具描述性的错误。</p><p>&emsp;&emsp;比如 io.Reader。像 io.Copy 这类函数需要 reader 的实现者返回 io.EOF 来告诉调用者没有更多的数据了，但这又不是错误。</p><ul><li>Sentinel errors 在两个包之间创建了依赖</li></ul><p>&emsp;&emsp;sentinel errors最糟糕的问题是它在两个包之间床架了源代码依赖关系。例如，检查错误是否等于 io.EOF，你的代码必须导入 io 包。这个特定的例子听起来并不是十分糟糕，因为它非常常见，但是想想一下，当项目中的许多包到处错误值时，存在耦合，项目中的其他包必须注入这些错误值才能检查特定的错误条件。</p><ul><li>结论：尽可能避免 Sentinel errors</li></ul><p>&emsp;&emsp;避免在编写代码时使用 Sentinel errors。在标准库中有一些使用它们的情况，但这不是好的模仿对象。 </p><h1 id="Error-Types"><a href="#Error-Types" class="headerlink" title="Error Types"></a>Error Types</h1><p>Error type 是实现了 error 接口的自定义类型。例如 MyError 类型记录了文件和行号以展示发生了什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Msg<span class="keyword">string</span></span><br><span class="line">    File<span class="keyword">string</span></span><br><span class="line">    Line<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s:%d: %s&quot;</span>, e.File, e.Line, e.Msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;<span class="string">&quot;Something happened&quot;</span>, <span class="string">&quot;server.go&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := test()</span><br><span class="line">    <span class="keyword">switch</span> err := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="comment">// call succeeded, nothing to do</span></span><br><span class="line">        <span class="keyword">case</span> *MyError:</span><br><span class="line">        fmt.Println(<span class="string">&quot;error occurred on line&quot;</span>, err.Line)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// unknown error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;与错误值相比，错误类型的一大改进是它们能够包装底层错误以提供更多上下文。一个不错的例子就是 os.PathError 它提供了底层执行了什么操作、那个路径出了什么问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op<span class="keyword">string</span></span><br><span class="line">    Path<span class="keyword">string</span></span><br><span class="line">    Errerror</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;调用者要使用类型断言和类型 switch，就要让自定义的 error 变为 public。这种模型会导致和调用者产生强耦合，从而导致 API 变得脆弱。</p><p>&emsp;&emsp;结论是尽量避免使用 error types，虽然错误类型比 sentinel errors 更好，因为它们可以捕获关于错误的更多上下文，但是 error types 共享 error values 许多相同的问题。因此，建议避免错误类型，或者至少避免它们成为公共 API 的一部分。</p><h1 id="Opaque-errors"><a href="#Opaque-errors" class="headerlink" title="Opaque errors"></a>Opaque errors</h1><p>&emsp;&emsp;这是一种最灵活的错误处理策略，因为它要求代码和调用者之间的耦合最少。我们将这种风格成为不透明的错误处理，因为虽然知道发生了错误，但没有能力看到错误的内部。作为调用者，关于操作的结果，你所知道的就是它起作用了，或者没有起作用（成功还是失败）。</p><p>&emsp;&emsp;这就是不透明错误处理的全部功能-只需返回错误而不假设其内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/quux/bar&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">x, err := bar. Foo</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> f</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Assert errors for behaviour, not type</li></ul><p>&emsp;&emsp;在少数情況下，这种二分错误处理方法是不够的。例如，与进程外的世界进行交互（如网络活动），需要调用方调查错误的性质，以确定重试该操作是否合理。在这种情況下，我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值。考虑这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> temporary <span class="keyword">interface</span> &#123;</span><br><span class="line">    Temporary()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsTemporary returns true if err is temporary</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsTemporary</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    te, ok := err.(temporary)</span><br><span class="line">    <span class="keyword">return</span> ok &amp;&amp; te.Temporary()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的关键是，这个逻辑可以在不导入定义错误的包或者实际上不了解 err 的底层类型的情况下实现——只对它的行为感兴趣。</p><h1 id="Handling-Error"><a href="#Handling-Error" class="headerlink" title="Handling Error"></a>Handling Error</h1><p>&emsp;&emsp;无错误的正常流程代码，将成为一条直线，而不是缩紧的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do stuff</span></span><br><span class="line"></span><br><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// handle error</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们看一下net/http 标准包里对 WriteResponse 的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">Key, Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">Code<span class="keyword">int</span></span><br><span class="line">Reason<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, st Status, headers []Header, body o.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">-, err := fmt.Fprintf(w,<span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, st.Code, st.Reason)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">        _, err := fmt.Fprintf(w, <span class="string">&quot;%s: %s\r\n&quot;</span>, h.Key, h.Value)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> _, err := fmt.Fprint(w <span class="string">&quot;\r\n&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _, err = io.Copy(w, body)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式写了大量的 <code>if err != nil</code>，如果采用下面这种方式，可以避免出现大量的重复代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">io.Writer</span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errWriter)</span> <span class="title">Write</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, e.err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">    n, e.err = e.Writer.Write(buf)</span><br><span class="line">    <span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(wio.Writer, st Status, headers []Header, body io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ew := &amp;errWriter&#123;Writer: w&#125;</span><br><span class="line">    fmt.Fprintf(ew, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, st.Code, st.Reason)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">        fmt.Fprintf(ew, <span class="string">&quot;%s: %s\r\n&quot;</span>, h.Key, h.Value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Fprint(ew, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">    io.Copy(ew, body)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ew.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实际上在封装的 errWriter 中处理掉了</p><h1 id="Wrap-erros"><a href="#Wrap-erros" class="headerlink" title="Wrap erros"></a>Wrap erros</h1><p>&emsp;&emsp;没有生成错误的 file:line 信息。没有导致错误的调用堆栈的堆栈跟踪。这段代码的作者将被迫进行长时间的代码分割，以发现是哪个代码路径触发了文件未找到错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span> <span class="params">(r *Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := authenticate(r.User)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;authenticate failed: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是正如我们前面看到的，这种模式与 sentinel errors 或 type assertions 的使用不兼容，因为将错误值转换为字符串，将其与另一个字符串合并，然后将其转换回 fmt.Errorf 破坏了原始的错误，导致等值判定失败。</p><p>&emsp;&emsp;You should only handle errors once. Handling an error means inspecting the error value and making a single decision.</p><p>我们经常发现类似的代码，在错误处理中，带了两个任务：记录日志井且再次返回错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w i0.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    -, err : = w.Write(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;unable to write:&quot;</span>, err)<span class="comment">// annotated error goes to log file</span></span><br><span class="line">        <span class="keyword">return</span> err<span class="comment">// unannotated error returned to caller</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在下面这个例子中，如果在 w.Write 过程中发生了一个错误，那么一行代码将被写入日志文件中，记录错误发生的文件和行，并且错误也会返回给调用者，调用者可能会记录并返回它，一直返回到程序的顶部。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">buf, err := json.Marshal(conf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log. Printf(<span class="string">&quot;could not marshal config: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;could not write config: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Go 中的错误处理契约规定，在出现错误的情况下，不能对其他返回值的内容做出任何假设。由于 JSON 序列化失败，buf 的内容是未知的，可能它不包含任何内容，但更糟糕的是，他可能包含一个半写的 JSON 片段。</p><p>&emsp;&emsp;由于程序员在检查并记录错误后忘记 return，损坏的缓冲区将被传递给 WriteAll，这可能会成功，因此配置文件将被错误地写入。但是，该函数返回的结果是正确的。</p><p>&emsp;&emsp;日志记录与错误无关且对调试没有帮助的信息应被视为噪音，应予以质疑。记录的原因是因为某些东西失败了，而日志包含了答案。</p><ul><li>错误要被日志记录。</li><li>应用程序处理错误，保证100%完整性。</li><li>之后不再报告当前错误。</li></ul><h2 id="使用-github-com-pkg-errors-库"><a href="#使用-github-com-pkg-errors-库" class="headerlink" title="使用 github.com/pkg/errors 库"></a>使用 github.com/pkg/errors 库</h2><p><img lazyload src="/images/loading.svg" data-src="graphAlph1.jpg" alt="avatar"></p><p><img lazyload src="/images/loading.svg" data-src="graphAlph2.jpg" alt="avatar"></p><p>&emsp;&emsp;通过使用 pkg/errors 包，可以想错误值添加上下文，这种方式既可以由人也可以由机器检查。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := w.Write(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// annotated error goes to log file</span></span><br><span class="line">        log.Println(<span class="string">&quot;unable to write:&quot;</span>, err)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// unannotated error returned to caller</span></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方式既打印了日志，还抛出了错误，违背了只处理一次的行为，使用下面的代码可以完美解决。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := w.Write(buf)</span><br><span class="line">    <span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;write failed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在你的业务代码中，使用 errors.New 或者 errors.Errorf 返回错误，它们同errors.Wrap 一样，都会返回错误的堆栈信息。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseArgs</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.Errorf(<span class="string">&quot;not enough arguments, expected at least 3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果调用其他包内的函数，通常简单的直接返回</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果和其他库进行协作，考虑使用 errors.Wrap 或者 errors.Wrapf 保存堆栈信息。同样适用于和标准库协作的时候。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;failed to open %q&quot;</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接返回错误，而不是每个错误产生的地方到处打印日志</li><li>在程序的顶部或者是工作的 goroutine 顶部（请求入口），使用 %+v 把堆栈详情记录</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := app.Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;FATAL: %+v\n&quot;</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 errors.Cause 获取root error， 在进行和 sentinel error 判定。还可以对其进行断言。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> err := errors.Cause(err).(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *MyError:</span><br><span class="line">        <span class="comment">// handle specifically</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// unknown error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>Packages that are reusable across many projects only return root error values.</li></ul><p>选择 wrap error 是只有 applications 可以选择应用的策略。具有最高可重用性的包只能返回根错误值。此机制与 Go 标准库中使用的相同。</p><ul><li>If the error is not going to be handled, wrap and return up the call stack.</li></ul><p>这是关于函数/方法调用返回的每个错误的基本问题。如果函数/方法不打算处理错误，那么用足够的上下文 wrap errors 并将其返回到调用堆栈中。例如，额外的上下文可以是使用的输入参数或失败的查询语句。确定您记录的上下文是足够多还是大多的一个好方法是检查日志并验证它们在开发期间是否为您工作。</p><ul><li>Once an error is handled, it is not allowed to be passed up the call stack any longer.</li></ul><p>一旦确定函数/方法将处理错误，错误就不再是错误。如果函数/方法仍然需要发出返回，则它不能返<br>错误值。它应该只返回零（比如降级处理中，你返回了降级数据，然后需要 return nil）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Error-vs-Exception&quot;&gt;&lt;a href=&quot;#Error-vs-Exception&quot; class=&quot;headerlink&quot; title=&quot;Error vs Exception&quot;&gt;&lt;/a&gt;Error vs Exception&lt;/h1&gt;&lt;p&gt;先看下面一段</summary>
      
    
    
    
    <category term="Error机制" scheme="http://jiahaohong1997.github.io/categories/Error%E6%9C%BA%E5%88%B6/"/>
    
    
    <category term="Error" scheme="http://jiahaohong1997.github.io/tags/Error/"/>
    
  </entry>
  
  <entry>
    <title>微服务概览与设计</title>
    <link href="http://jiahaohong1997.github.io/2021/11/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <id>http://jiahaohong1997.github.io/2021/11/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-11-28T07:45:00.000Z</published>
    <updated>2022-01-05T03:08:36.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微服务概念"><a href="#微服务概念" class="headerlink" title="微服务概念"></a>微服务概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现<strong>服务组件化</strong>，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活：</p><ul><li>原子服务：关注单一业务场景</li><li>独立进程：能够独立部署和交付</li><li>隔离部署：减小某一物理机crash对全局的影响</li><li>去中心化服务治理：服务之间的通讯rpc直连，减少集中的负载均衡</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>基础设施的建设、复杂度高</li><li>微服务应用是分布式系统，由此会带来固有的复杂性。开发者不得不使用RPC或者消息传递，来实现进程间的通信；此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题</li><li>分区的数据库架构，同时更新多个业务主体的事务很普遍。这种事务对于单体应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务锁使用的不同数据库，从而对开发者提出了更高的要求和挑战</li><li>测试一个基于微服务架构的应用是很复杂的任务</li><li>服务模块间的依赖，应用的升级有可能会涉及多个服务模块的修改</li><li>对运维的基础设施的挑战比较大</li></ul><h2 id="组件服务化"><a href="#组件服务化" class="headerlink" title="组件服务化"></a>组件服务化</h2><p>&emsp;&emsp;传统实现组件的方式是通过库(library)，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。我们用 Go 实施一个微服务：</p><ul><li>kit：一个微服务的基础库（框架）</li><li>service：业务代码＋ hit 依赖＋ 第三方依赖组成的业务微服务</li><li>RPC + message queue: 轻量级通讯</li></ul><p>&emsp;&emsp;<strong>本质上等同于，多个微服务组合(compose)完成了一个完整的用户场景(usecase)。</strong></p><h2 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h2><p>&emsp;&emsp;每个服务面临的业务场景不同，可以针对性的选择合适的技术解决方案。但也需要避免过度多样化，结合团队实际情况来选择取舍，要是每个服务都用不同的语言的技术栈来实现，想想维护成本真够高的。</p><ul><li>数据去中心化：每个服务独享自身的数据存储设施(缓存，数据库等)</li><li>治理去中心化：避免集中式做流量分发和负载均衡</li><li>技术去中心化：不绑定某一特定语言</li></ul><p>&emsp;&emsp;<strong>每个服务独享自身的数据存储设施(缓存，数据库等)，不像传统应用共享一个缓存和数据库，这样有利于服务的独立性，隔旁相关干扰。</strong></p><h2 id="基础设施自动化"><a href="#基础设施自动化" class="headerlink" title="基础设施自动化"></a>基础设施自动化</h2><p>&emsp;&emsp;无自动化不微服务，自动化包括测试和部署。单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、监控和部署的复杂度都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。</p><ul><li>CICD: Gitlab + Gitlab Hooks + kubernetes</li><li>Testing：测试环境、单元测试、API 自动化测试</li><li>在线运行时: kubernetes, 以及一系列Prometheus, ELK, Conrtol Panle</li></ul><h2 id="可用性-amp-兼容性设计"><a href="#可用性-amp-兼容性设计" class="headerlink" title="可用性 &amp; 兼容性设计"></a>可用性 &amp; 兼容性设计</h2><p>&emsp;&emsp;微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的新问题，如网络延迟、消息格式、负载均衡和容错，忽略其中任何一点都属于对“分布式计算的误解”。</p><ul><li>隔离</li><li>超时控制</li><li>负载保护</li><li>限流</li><li>降级</li><li>重试</li><li>负载均衡</li></ul><p>&emsp;&emsp;一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻蓮记保持服务契约（接口）的兼容性。发送时要保守，接收时要开放。按照伯斯塔次法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。</p><h1 id="微服务设计"><a href="#微服务设计" class="headerlink" title="微服务设计"></a>微服务设计</h1><h2 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h2><ol><li>按照垂直功能进行拆分，对外暴露了一批微服务，但是因为缺乏统一的出口面临不少问题：</li></ol><p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/1.png" alt="avatar"></p><ul><li>客户端到微服务直接通信，强耦合：不利于服务的更新迭代，要始终保留过往版本的接口</li><li>需要多次请求，客户端聚合数据，工作量巨大，延迟高</li><li>协议不利于统一，各个部门间有差异，需要端来兼容</li><li>面向“端”（不同终端）的API适配，耦合到了内部服务</li><li>多终端兼容逻辑复杂，每个服务都需要处理</li><li>统一逻辑无法收敛，比如安全认证、限流</li></ul><ol start="2"><li>新增一个app-interface 用于统一的协议出口，在服务哪进行大量的 dataset join（各种微服务数据的聚合），按照业务的场景来设计粗粒度的 API，给后续业务演进带来很多优势：</li></ol><p><img lazyload src="/images/loading.svg" data-src="2.png" alt="avatar"></p><ul><li>轻量交互：协议精简、聚合</li><li>差异服务：数据裁剪以及聚合、针对终端定制化API</li><li>动态升级：原有系统兼容升级，更新服务而非协议</li><li>沟通效率提升，协作模式演进为移动业务+网关小组</li></ul><p>BFF 可以认为是一种适配服务，将后端的微服务进行适配（主要包括聚合裁剪和格式适配等逻辑），向无线端设备暴露友好和统一的API，方便无线设备接入访问后端服务。</p><p>最致命的一个问题是整个 app-interface 属于单点故障，严重代码缺陷或流量洪峰可能引发集群宕机。</p><p><img lazyload src="/images/loading.svg" data-src="3.png" alt="avatar"></p><ul><li>但各模块也会导致后续业务集成复杂度高，根据康威法则，单块的无线BFF和多团队之间就出现不匹配问题，团队之间沟通协调成本高，交付效率低下</li><li>很多跨横切面逻辑，比如安全认证，日志监控，限流熔断。随着时间推移，代码变得越来越复杂，技术栈越来越多</li></ul><ol start="3"><li>跨横切面(Cross-Cutting Concerns)的功能, 需要协调更新框架升级发版(路由、认证、限流、安<br>全），因此全部上沉，引入了 API Gateway，把业务集成度高的 BFF 层和通用功能服务层 API<br>Gateway 进行了分层处理。</li></ol><p><img lazyload src="/images/loading.svg" data-src="4.png" alt="avatar"></p><p>在新的架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器。在网关的配合下，单块 BFF<br>实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提开。另外，把跨横切面逻<br>辑从 BFF 剥离到网关上去以后，BFF 的开发人员可以更加专法业务逻辑交付，实现了架构上的关注分离<br>(Separation of Concerns).</p><p>业务流量实所为：<br>移动端 -&gt; API Gateway -&gt; BFF -&gt; Mircoservice, 在 FE Web业务中，BFF 可以是nodejs 来做服务端渲染<br>(SSR, Server-Side Rendering), 注意这里忽略了上游的 CDN、4/7层负载均衡(ELB)。</p><h2 id="Mircoservice划分"><a href="#Mircoservice划分" class="headerlink" title="Mircoservice划分"></a>Mircoservice划分</h2><p>&emsp;&emsp;微服务架构时遇到的第一个问题就是如何划分服务的边界。在实际项目中通常会采用两种不同的方式划分服务便捷，即通过业务职能（Business Capbility）或是DDD的限界上下文（Bounded Context）。</p><ul><li>Business Capbility</li></ul><p>&emsp;&emsp;由公司内部不同的部门提供的职能。例如客户服务部门提供客户服务职能，财务部门提供财务相关的职能。</p><ul><li>Bounded Context</li></ul><p>&emsp;&emsp;限界上下文DDD中用来划分不同业务边界的元素，这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案域，为了解决某种类型的业务问题，贴近领域知识，也就是业务。</p><p>这本质上也促进了组织结构的演进：Service per team</p><p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/5.png" alt="avatar"></p><ul><li><p>CQRS</p><p>将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新。(其实就是读写分离)</p></li></ul><p>在稿件服务演进过程中，围绕着创作稿件、审核稿件、最终发布稿件有大量的逻辑揉在一块，其中稿件本身的状态也有非常多种，但是最终前台用户只关注稿件能否查看，依赖稿件数据库 binlog 以及订阅binlog 的中间 canal， 将稿件结果发布到消息队列katka 中，最终消费数据独立组建一个稿件查阅结果数据库，并对外提供一个独立查询服务，来板分复杂架构和业务。<br><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/6.jpg" alt="avatar"></p><p>将稿件审核并写入数据库(archive-result-database)的服务(稿件job)和外部用户查看稿件审核结果的服务(稿件结果)分离开来。</p><h2 id="Mircoservice安全"><a href="#Mircoservice安全" class="headerlink" title="Mircoservice安全"></a>Mircoservice安全</h2><p>&emsp;&emsp;对于外网的请求来说，我们通常在 API Gateway进行统一的认证拦截，一旦认证成功，我们会使用 Header 方式通过 RPC 元数据传递的方式带到 BFF 层，BFF 获取后把身份信息注入到应用的 Context 中，BFF 到其他下层的微服务，建议是直接在 RPC Request 中带入用户身份信息(UserID)请求服务。</p><ul><li><p>API Gateway -&gt; BFF -&gt; Service</p></li><li><p>Biz Auth -&gt; UID -&gt; Request Args</p></li></ul><p>对于服务内部，一般要区分身份认证和授权。</p><ul><li>Full Trust</li><li>Half Trust</li><li>Zero Trust </li></ul><h1 id="gRPC和服务发现"><a href="#gRPC和服务发现" class="headerlink" title="gRPC和服务发现"></a>gRPC和服务发现</h1><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/7.jpg" alt="avatar"></p><ul><li><p>多语言：语言中立，支持多种语言。</p></li><li><p>轻量级、高性能序列化支持 PB（Protocol Buffer）和 JSON，PB 是一种语言无关的高性能系列化框架</p></li><li><p>可插拔。</p></li><li><p>IDL：基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端口以及客户端 Stub。</p></li><li><p>移动端：基于标准的 HTTP/2 设计，支持双向流、消息头压缩、单TCP的多路复用、服务端推送等特性。这些特性是的 gRPC 在移动端设备上更加省电和节省网络流量。</p></li><li><p>服务而非对象、消息而非引用：促进微服务的系统间粗粒度消息交互设计理念。</p></li><li><p>负载无关的：不同的服务需要使用不同的消息类型和编码, 例如 protocol buffers, JSON, XML 和 Thrift。</p></li><li><p>流: Streaming APl。</p></li><li><p>阻塞式和非阻塞式：支持异步和同步处理在客户端和服务端间交互的消息序列。</p></li><li><p>元数据交换：常见的横切关注点，如认证或跟踪，依赖数据交换。</p></li><li><p>标准化状态码：客户端通常以有限的方式响应 API 调用返回的错误。</p></li></ul><h2 id="gRPC-HealthCheck"><a href="#gRPC-HealthCheck" class="headerlink" title="gRPC - HealthCheck"></a>gRPC - HealthCheck</h2><p>gRPC 有一个标准的健康检测协议，在 gRPC 的所有语言实现中基本都提供了生成代码和用于设置运行状态的功能。</p><p>主动健康检查 health check，，可以在服务提供者服务不稳定时，被消费者所感知，份时从负载均衡中摘除，减少错误请求。当服务提供者重新稳定后，health check 成功，重新加入到消费者的负载均衡，恢复请求。health check  同样也被用于外挂方式的容器健康检测，或者流量检测(K8sliveness &amp; readiness)。</p><p><img lazyload src="/images/loading.svg" data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/8.jpg" alt="avatar"></p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><h3 id="客户端发现"><a href="#客户端发现" class="headerlink" title="客户端发现"></a>客户端发现</h3><p>&emsp;&emsp;一个服务实例被启动时，它的网络地址会被写到注册表上；当服务实例终止时，再从注册表中删除；这个服务实例的注册表通过心跳机制动态刷新；客户端使用一个负载均衡算法，去选择一个可用的服务实例，来响应这个请求。</p><h3 id="服务端发现"><a href="#服务端发现" class="headerlink" title="服务端发现"></a>服务端发现</h3><p>&emsp;&emsp;客户端通过负载均衡器向一个服务发送请求，这个负载均衡器会查询服务注册表，并将请求路由到可用的服务实例上。服务实例在服务注册表上被注册和注销(Consul Template+Nginx, kubernetesteted)。</p><p><img lazyload src="/images/loading.svg" data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/9.jpg" alt="avatar"></p><p>微服务的核心是去中心化，使用客户端发现模式。</p><p><img lazyload src="/images/loading.svg" data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/10.jpg" alt="avatar"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微服务概念&quot;&gt;&lt;a href=&quot;#微服务概念&quot; class=&quot;headerlink&quot; title=&quot;微服务概念&quot;&gt;&lt;/a&gt;微服务概念&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定</summary>
      
    
    
    
    <category term="微服务" scheme="http://jiahaohong1997.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="开发" scheme="http://jiahaohong1997.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常见问题补充</title>
    <link href="http://jiahaohong1997.github.io/2021/11/20/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85/"/>
    <id>http://jiahaohong1997.github.io/2021/11/20/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85/</id>
    <published>2021-11-19T16:21:00.000Z</published>
    <updated>2022-03-31T21:46:36.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据表的类型"><a href="#数据表的类型" class="headerlink" title="数据表的类型"></a>数据表的类型</h1><table><thead><tr><th align="center"></th><th align="center">MYISM</th><th align="center">INNODB</th></tr></thead><tbody><tr><td align="center">事务支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">数据行锁定</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">外键约束</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">全文索引</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">表空间的大小</td><td align="center">较小</td><td align="center">较大，约为MYSIM2倍</td></tr></tbody></table><ul><li>MYSIM：节约空间，速度较快</li><li>INNODB：安全性高，支持事务处理，多表多用户操作</li></ul><h1 id="DROP、TRUNCATE和DELETE的区别"><a href="#DROP、TRUNCATE和DELETE的区别" class="headerlink" title="DROP、TRUNCATE和DELETE的区别"></a>DROP、TRUNCATE和DELETE的区别</h1><ul><li><p>TRUNCATE和DELETE的相同点：都能删除数据面都不会删除表结构</p></li><li><p>区别：</p><ul><li>DROP table 【表名】<ul><li><strong>删除内容和定义</strong>，并释放空间。执行drop语句，<strong>将使此表的结构</strong>一起删除。</li></ul></li><li>TRUNCATE <ul><li><strong>删除内容、释放空间但不删除定义</strong>(也就是保留表的数据结构)。与drop不同的是,只是<strong>清空表数据</strong>而已。</li><li>重新设置，自增列计数器会归零</li><li>不会影响事务</li></ul></li><li>DELETE from 【表名】(where 【列名】= 值)<ul><li><strong>只删除内容、释放空间但不删除定义</strong>；但是delete即<strong>可以对行数据进行删除</strong>，也可以对整表数据进行删除。</li><li>自增列计数器保持原来的值</li></ul></li></ul></li><li><p>注意</p><ul><li>delete语句执行删除的过程是<strong>每次从表中删除一行</strong>，并且同时将该行的删除操作作为事务<strong>记录在日志</strong>中保存，以便进行进行回滚操作。</li><li><strong>执行速度</strong>一般来说：drop&gt;truncate&gt;delete</li><li>delete语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，<strong>事务提交之后才生效</strong>；如果有相应的 trigger，执行的时候将被触发。truncate、drop 是数据库定义语言(ddl)<strong>，操作立即生效</strong>，原数据不放到 rollback segment 中，不能回滚，操作不触发trigger。</li><li> truncate语句执行以后，<strong>id标识列还是按顺序排列</strong>，保持连续；而delete语句执行后，<strong>ID标识列不连续</strong></li></ul></li></ul><h1 id="为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？"><a href="#为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？" class="headerlink" title="为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？"></a>为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？</h1><p>分解关联查询的方式重构查询的优势有：</p><blockquote><ul><li><p><strong>让缓存的效率更高</strong>。我们知道执行一条sql的时候，会先去查询缓存中查找。那么许多应用程序可以方便地缓存单表查询对应的结果对象。如果关联查询，那么关联中的某个表发生了变化，那么就无法使用查询缓存，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。<br>将查询拆分后，执行单个查询可以减少锁的竞争。</p></li><li><p>在应用层做关联，可以更容易对数据库进行拆分，在现如今分库分表普遍使用的情景下，更容易做到高性能和可扩展。</p></li><li><p>查询本身效率也可能会有所提升。比如：让某些查询用IN()代替关联查询，可以让Mysql按照ID顺序进行查询，着可能比随机的关联要更高效。</p></li><li><p>可以减少冗余记录的查询。在应用层做关联，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能徐娅重复地访问一部分数据。从这方面看，这样的重构还可能会减少网络和内存的消耗。</p></li><li><p>分解关联查询，相当于在应用中实现了哈希关联，而不是使用Mysql的类似嵌套循环关联。某些场景哈希关联的效率更高效</p></li></ul></blockquote><p><img lazyload src="/images/loading.svg" data-src="overviewMySql.png" alt="avatar"></p><h1 id="MySQL索引原理"><a href="#MySQL索引原理" class="headerlink" title="MySQL索引原理"></a>MySQL索引原理</h1><h2 id="索引的目的"><a href="#索引的目的" class="headerlink" title="索引的目的"></a>索引的目的</h2><p>&emsp;&emsp;索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。</p><h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><p>&emsp;&emsp;除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。</p><p>&emsp;&emsp;数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？我们会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p><p>&emsp;&emsp;考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>&emsp;&emsp;前面讲了生活中索引的例子，索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。</p><p><img lazyload src="/images/loading.svg" data-src="graphAlph2.jpg" alt="avatar"></p><p>&emsp;&emsp;如上图，是一颗b+树，关于b+树的定义可以参见<a class="link" href="http://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B+树<i class="fas fa-external-link-alt"></i></a>，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p><ul><li>b+树的查找过程</li></ul><p>&emsp;&emsp;如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p><ul><li>b+树的性质</li></ul><ol><li><p>通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即<strong>索引字段要尽量的小</strong>，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</p></li><li><p>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的<strong>最左匹配特性</strong>。</p></li></ol><h2 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h2><h3 id="建索引的几大原则"><a href="#建索引的几大原则" class="headerlink" title="建索引的几大原则"></a>建索引的几大原则</h3><ol><li><strong>最左前缀匹配原则</strong>，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li><strong>=和in可以乱序</strong>，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</li><li><strong>尽量选择区分度高的列作为索引</strong>，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</li><li><strong>索引列不能参与计算</strong>，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</li><li><strong>尽量的扩展索引，不要新建索引</strong>。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li></ol><h3 id="慢查询优化的基本步骤"><a href="#慢查询优化的基本步骤" class="headerlink" title="慢查询优化的基本步骤"></a>慢查询优化的基本步骤</h3><ol start="0"><li>先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li><li>where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看看那个字段的区分度最高</li><li>expalin查看执行计划，是否与预期一致（从锁定记录较少的表开始查）</li><li>order by limit 形式的sql语句让排序的表优先查</li><li>了解业务方使用场景</li><li>加索引时参照建立索引的几大原则</li><li>观察结果，不符合预期的继续从0分析</li></ol><h3 id="几个慢查询案例"><a href="#几个慢查询案例" class="headerlink" title="几个慢查询案例"></a>几个慢查询案例</h3><ul><li>案例一</li></ul><p>很多情况下，我们写SQL只是为了实现功能，这只是第一步，不同的语句书写方式对于效率往往有本质的差别，这要求我们对mysql的执行计划和索引原则有非常清楚的认识，请看下面的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   <span class="keyword">distinct</span> cert.emp_id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   (</span><br><span class="line">      <span class="keyword">select</span></span><br><span class="line">         emp.id <span class="keyword">as</span> emp_id,</span><br><span class="line">         emp_cert.id <span class="keyword">as</span> cert_id </span><br><span class="line">      <span class="keyword">from</span></span><br><span class="line">         employee emp </span><br><span class="line">      <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">         emp_certificate emp_cert </span><br><span class="line">            <span class="keyword">on</span> emp.id <span class="operator">=</span> emp_cert.emp_id </span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">         emp.is_deleted<span class="operator">=</span><span class="number">0</span></span><br><span class="line">   ) cert </span><br><span class="line">      <span class="keyword">on</span> (</span><br><span class="line">         cl.ref_table<span class="operator">=</span><span class="string">&#x27;Employee&#x27;</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid<span class="operator">=</span> cert.emp_id</span><br><span class="line">      ) </span><br><span class="line">      <span class="keyword">or</span> (</span><br><span class="line">         cl.ref_table<span class="operator">=</span><span class="string">&#x27;EmpCertificate&#x27;</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid<span class="operator">=</span> cert.cert_id</span><br><span class="line">      ) </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date <span class="operator">&gt;=</span><span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date<span class="operator">&lt;=</span><span class="string">&#x27;2013-11-08 16:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="0"><li>先运行一下，53条记录 1.87秒，又没有用聚合语句，比较慢</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">53</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">1.87</span> sec)</span><br></pre></td></tr></table></figure><ol><li>explain</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type  <span class="operator">|</span> possible_keys                   <span class="operator">|</span> key                   <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>               <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> Extra                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> cl         <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> cm_log_cls_id,idx_last_upd_date <span class="operator">|</span> idx_last_upd_date     <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>   <span class="number">379</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> temporary   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>                            <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span> <span class="number">63727</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> emp        <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>                            <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span> <span class="number">13317</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> emp_cert   <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> emp_certificate_empid           <span class="operator">|</span> emp_certificate_empid <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.emp.id <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> index                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;简述一下执行计划，首先mysql根据idx_last_upd_date索引扫描cm_log表获得379条记录；然后查表扫描了63727条记录，分为两部分，derived表示构造表，也就是不存在的表，可以简单理解成是一个语句形成的结果集，后面的数字表示语句的ID。derived2表示的是ID = 2的查询构造了虚拟表，并且返回了63727条记录。我们再来看看ID = 2的语句究竟做了写什么返回了这么大量的数据，首先全表扫描employee表13317条记录，然后根据索引emp_certificate_empid关联emp_certificate表，rows = 1表示，每个关联都只锁定了一条记录，效率比较高。获得后，再和cm_log的379条记录根据规则关联。从执行过程上可以看出返回了太多的数据，返回的数据绝大部分cm_log都用不到，因为cm_log只锁定了379条记录。</p><p>&emsp;&emsp;如何优化呢？可以看到我们在运行完后还是要和cm_log做join,那么我们能不能之前和cm_log做join呢？仔细分析语句不难发现，其基本思想是如果cm_log的ref_table是EmpCertificate就关联emp_certificate表，如果ref_table是Employee就关联employee表，我们完全可以拆成两部分，并用union连接起来，注意这里用union，而不用union all是因为原语句有“distinct”来得到唯一的记录，而union恰好具备了这种功能。如果原语句中没有distinct不需要去重，我们就可以直接使用union all了，因为使用union需要去重的动作，会影响SQL性能。</p><p>优化过的语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   emp.id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   employee emp </span><br><span class="line">      <span class="keyword">on</span> cl.ref_table <span class="operator">=</span> <span class="string">&#x27;Employee&#x27;</span> </span><br><span class="line">      <span class="keyword">and</span> cl.ref_oid <span class="operator">=</span> emp.id  </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date <span class="operator">&gt;=</span><span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date<span class="operator">&lt;=</span><span class="string">&#x27;2013-11-08 16:00:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> emp.is_deleted <span class="operator">=</span> <span class="number">0</span>  </span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">   emp.id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   emp_certificate ec </span><br><span class="line">      <span class="keyword">on</span> cl.ref_table <span class="operator">=</span> <span class="string">&#x27;EmpCertificate&#x27;</span> </span><br><span class="line">      <span class="keyword">and</span> cl.ref_oid <span class="operator">=</span> ec.id  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   employee emp </span><br><span class="line">      <span class="keyword">on</span> emp.id <span class="operator">=</span> ec.emp_id  </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date <span class="operator">&gt;=</span><span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date<span class="operator">&lt;=</span><span class="string">&#x27;2013-11-08 16:00:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> emp.is_deleted <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>不需要了解业务场景，只需要改造的语句和改造之前的语句保持结果一致</p></li><li><p>现有索引可以满足，不需要建索引</p></li><li><p>用改造后的语句实验一下，只需要10ms 降低了近200倍！</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type   <span class="operator">|</span> possible_keys                   <span class="operator">|</span> key               <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> cl         <span class="operator">|</span> <span class="keyword">range</span>  <span class="operator">|</span> cm_log_cls_id,idx_last_upd_date <span class="operator">|</span> idx_last_upd_date <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span>  <span class="number">379</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> emp        <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>                         <span class="operator">|</span> <span class="keyword">PRIMARY</span>           <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.cl.ref_oid <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> cl         <span class="operator">|</span> <span class="keyword">range</span>  <span class="operator">|</span> cm_log_cls_id,idx_last_upd_date <span class="operator">|</span> idx_last_upd_date <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span>  <span class="number">379</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> ec         <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>,emp_certificate_empid   <span class="operator">|</span> <span class="keyword">PRIMARY</span>           <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.cl.ref_oid <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> emp        <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>                         <span class="operator">|</span> <span class="keyword">PRIMARY</span>           <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.ec.emp_id  <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                            <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span></span><br><span class="line"><span class="number">53</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><ul><li>案例二</li></ul><p>举这个例子的目的在于颠覆我们对列的区分度的认知，一般上我们认为区分度越高的列，越容易锁定更少的记录，但在一些特殊的情况下，这种理论是有局限性的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   stage_poi sp </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   sp.accurate_result<span class="operator">=</span><span class="number">1</span> </span><br><span class="line">   <span class="keyword">and</span> (</span><br><span class="line">      sp.sync_status<span class="operator">=</span><span class="number">0</span> </span><br><span class="line">      <span class="keyword">or</span> sp.sync_status<span class="operator">=</span><span class="number">2</span> </span><br><span class="line">      <span class="keyword">or</span> sp.sync_status<span class="operator">=</span><span class="number">4</span></span><br><span class="line">   );</span><br></pre></td></tr></table></figure><ol start="0"><li>先看看运行多长时间,951条数据6.22秒，真的很慢。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">951</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">6.22</span> sec)</span><br></pre></td></tr></table></figure><ol><li>先explain，rows达到了361万，type = ALL表明是全表扫描。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>    <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> sp    <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">3613155</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>所有字段都应用查询返回记录数，因为是单表查询 0已经做过了951条。</p></li><li><p>让explain的rows 尽量逼近951。</p></li></ol><p>看一下accurate_result = 1的记录数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),accurate_result <span class="keyword">from</span> stage_poi  <span class="keyword">group</span> <span class="keyword">by</span> accurate_result;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span> accurate_result <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">1023</span> <span class="operator">|</span>              <span class="number">-1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2114655</span> <span class="operator">|</span>               <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">972815</span> <span class="operator">|</span>               <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们看到accurate_result这个字段的区分度非常低，整个表只有-1,0,1三个值，加上索引也无法锁定特别少量的数据。</p><p>再看一下sync_status字段的情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),sync_status <span class="keyword">from</span> stage_poi  <span class="keyword">group</span> <span class="keyword">by</span> sync_status;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span> sync_status <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">3080</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3085413</span> <span class="operator">|</span>           <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+</span></span><br></pre></td></tr></table></figure><p>同样的区分度也很低，根据理论，也不适合建立索引。</p><p>&emsp;&emsp;问题分析到这，好像得出了这个表无法优化的结论，两个列的区分度都很低，即便加上索引也只能适应这种情况，很难做普遍性的优化，比如当sync_status 0、3分布的很平均，那么锁ß定记录也是百万级别的。</p><ol start="4"><li><p>找业务方去沟通，看看使用场景。业务方是这么来使用这个SQL语句的，每隔五分钟会扫描符合条件的数据，处理完成后把sync_status这个字段变成1,五分钟符合条件的记录数并不会太多，1000个左右。了解了业务方的使用场景后，优化这个SQL就变得简单了，因为业务方保证了数据的不平衡，如果加上索引可以过滤掉绝大部分不需要的数据。</p></li><li><p>根据建立索引规则，使用如下语句建立索引</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stage_poi <span class="keyword">add</span> index idx_acc_status(accurate_result,sync_status);</span><br></pre></td></tr></table></figure><ol start="6"><li>观察预期结果,发现只需要200ms，快了30多倍。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">952</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.20</span> sec)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们再来回顾一下分析问题的过程，单表查询相对来说比较好优化，大部分时候只需要把where条件里面的字段依照规则加上索引就好，如果只是这种“无脑”优化的话，显然一些区分度非常低的列，不应该加索引的列也会被加上索引，这样会对插入、更新性能造成严重的影响，同时也有可能影响其它的查询语句。所以我们第4步调差SQL的使用场景非常关键，我们只有知道这个业务场景，才能更好地辅助我们更好的分析和优化查询语句。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据表的类型&quot;&gt;&lt;a href=&quot;#数据表的类型&quot; class=&quot;headerlink&quot; title=&quot;数据表的类型&quot;&gt;&lt;/a&gt;数据表的类型&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;th align=&quot;</summary>
      
    
    
    
    <category term="SQL" scheme="http://jiahaohong1997.github.io/categories/SQL/"/>
    
    
    <category term="MySQL" scheme="http://jiahaohong1997.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
