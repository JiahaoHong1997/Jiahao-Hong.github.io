<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洪笳淏的个人博客</title>
  
  
  <link href="http://jiahaohong1997.github.io/atom.xml" rel="self"/>
  
  <link href="http://jiahaohong1997.github.io/"/>
  <updated>2022-01-05T12:45:59.362Z</updated>
  <id>http://jiahaohong1997.github.io/</id>
  
  <author>
    <name>洪笳淏</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL学习笔记</title>
    <link href="http://jiahaohong1997.github.io/2022/01/05/SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://jiahaohong1997.github.io/2022/01/05/SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-05T12:31:00.000Z</published>
    <updated>2022-01-05T12:45:59.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL中的SQL是如何执行的"><a href="#MySQL中的SQL是如何执行的" class="headerlink" title="MySQL中的SQL是如何执行的"></a>MySQL中的SQL是如何执行的</h1><p>&emsp;&emsp;MySQL是典型的 Client/Server 架构，服务器端程序使用的是 mysqld。整体的 MySQL 流程如下图所示：<br><img lazyload src="/images/loading.svg" data-src="mysql1.jpg" alt="avatar"><br>&emsp;&emsp;可以看到的MySQL三层：</p><ol><li>==连接层==：客户端和服务端建立连接（例如tcp），客户端发送 SQL 至服务端；</li><li>==SQL 层==：对 SQL 语句进行查询处理；</li><li>==存储引擎层==：与数据库文件打交道，负责数据的存储和读取。</li></ol><h2 id="SQL-层"><a href="#SQL-层" class="headerlink" title="SQL 层"></a>SQL 层</h2><p>其中 SQL 层与数据库文件的存储方式无关，我们来看下 SQL 层的结构：<br><img lazyload src="/images/loading.svg" data-src="mysql2.jpg" alt="avatar"><br>&emsp;&emsp;其流程总结如下：</p><ol><li>==查询缓存==：服务端接收到客户端的 SQL 语句后，先在缓存中查询该语句，有结果命中缓存就直接返回给客户端；如果没有就进入到解析器阶段；</li><li>==解析器==：在解析器中对 SQL 语句进行语法分析、语义分析；</li><li>==优化器==：在优化器中会确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引来检索等；</li><li>==执行器==：在执行之前需要判断该用户是否具备权限，如果具备权限就执行 SQL 查询并返回结果。如果设置了查询缓存，这时会将查询结果进行缓存。</li></ol><p>SQL 语句→缓 存查询→解析器→优化器→执行器</p><h2 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h2><p>&emsp;&emsp;MySQL 的存储引擎采用了插件的形 式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎。</p><ol><li>==InnoDB 存储引擎==：MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。</li><li>==MyISAM 存储引擎==：MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。</li><li>Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。</li><li>NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</li><li>Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL中的SQL是如何执行的&quot;&gt;&lt;a href=&quot;#MySQL中的SQL是如何执行的&quot; class=&quot;headerlink&quot; title=&quot;MySQL中的SQL是如何执行的&quot;&gt;&lt;/a&gt;MySQL中的SQL是如何执行的&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;My</summary>
      
    
    
    
    <category term="SQL" scheme="http://jiahaohong1997.github.io/categories/SQL/"/>
    
    
    <category term="MySQL" scheme="http://jiahaohong1997.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记（二）</title>
    <link href="http://jiahaohong1997.github.io/2022/01/05/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://jiahaohong1997.github.io/2022/01/05/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-01-05T03:10:00.000Z</published>
    <updated>2022-01-08T09:49:43.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两大纬度，三大主线"><a href="#两大纬度，三大主线" class="headerlink" title="两大纬度，三大主线"></a>两大纬度，三大主线</h1><p><img lazyload src="/images/loading.svg" data-src="redis1.jpg" alt="avatar"></p><ul><li><p>两大维度</p></li><li><p><input disabled type="checkbox">  应用纬度</p></li><li><p><input disabled type="checkbox">  系统纬度</p></li><li><p>三大主线</p></li><li><p><input disabled type="checkbox">  ==高性能主线==，包括线程模型、数据结构、持久化、网络框架</p></li><li><p><input disabled type="checkbox">  ==高可靠主线==，包括主从复制、哨兵机制</p></li><li><p><input disabled type="checkbox">  ==高可扩展主线==，包括数据分片、负载均衡</p></li></ul><h2 id="Redis的组件和功能"><a href="#Redis的组件和功能" class="headerlink" title="Redis的组件和功能"></a>Redis的组件和功能</h2><p><img lazyload src="/images/loading.svg" data-src="redis2.jpg" alt="avatar"></p><ol><li>Redis 主要通过网络框架进行访问，而不再是动态库了，这也使得 Redis 可以作为一个基础性的网络服务进行访问，扩大了 Redis 的应用范围。</li><li>Redis 数据模型中的 value 类型很丰富，因此也带来了更多的操作接口，例如面向列表的 LPUSH/LPOP，面向集合的 SADD/SREM 等。</li><li>Redis 的持久化模块能支持两种方式：日志（AOF）和快照（RDB），这两种持久化方式具有不同的优劣势，影响到 Redis 的访问性能和可靠性。</li><li>Redis 支持高可靠集群和高可扩展集群</li></ol><h1 id="快速的Redis有哪些慢操作"><a href="#快速的Redis有哪些慢操作" class="headerlink" title="快速的Redis有哪些慢操作"></a>快速的Redis有哪些慢操作</h1><h2 id="Redis快在哪儿"><a href="#Redis快在哪儿" class="headerlink" title="Redis快在哪儿"></a>Redis快在哪儿</h2><ul><li>Redis是内存数据库， 所有操作都在内存上完成，内存的访问速度本身就很快。</li><li>归功于它的数据结构。键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 Redis 快速处理数据的基础。</li></ul><h2 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>&emsp;&emsp;底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。它们和数据类型的对应关系如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis3.jpg" alt="avatar"><br>&emsp;&emsp;可以看到，String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型，它们的特点是<strong>一个键对应了一个集合的数据</strong>。</p><h3 id="键和值用什么数据结构组织"><a href="#键和值用什么数据结构组织" class="headerlink" title="键和值用什么数据结构组织"></a>键和值用什么数据结构组织</h3><p>&emsp;&emsp;为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一 个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。<br>&emsp;&emsp;在下图中，可以看到，哈希桶中的 entry 元素中保存了<em>key和</em>value指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过*value指针被查找到。</p><p><img lazyload src="/images/loading.svg" data-src="redis4.jpg" alt="avatar"></p><p>&emsp;&emsp;因为这个哈希表保存了所有的键值对，所以，我也把它称为==全局哈希表==。哈希表的最大好处很明显，就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。<br>&emsp;&emsp;查找过程主要依赖于哈希计算，和数据量的多少并没有直接关系。也就是说， 不管哈希表里有 10 万个键还是 100 万个键，我们只需要一次计算就能找到相应的键。但是，当你往 Redis 中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在的风险点，那就是哈希表的冲突问题和 rehash 可能带来的操作阻塞。</p><h3 id="为什么哈希表操作变慢了"><a href="#为什么哈希表操作变慢了" class="headerlink" title="为什么哈希表操作变慢了"></a>为什么哈希表操作变慢了</h3><p>&emsp;&emsp;当你往哈希表中写入更多数据时，哈希冲突是不可避免的问题。这里的哈希冲突，也就是指，两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。毕竟，哈希桶的个数通常要少于 key 的数量，这也就是说，难免会有一些 key的哈希值对 应到了同一个哈希桶中。Redis 解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。如下图所示：entry1、entry2 和 entry3 都需要保存在哈希桶 3 中，导致了哈希冲突。此时，entry1 元素会通过一个<em>next指针指向 entry2，同样，entry2 也会通过</em>next指针指向 entry3。这样一来，即使哈希桶 3 中的元素有 100 个，我们也可以通过 entry 元素中的指针，把它们连起来。这就形成了一个链表，也叫作哈希冲突链。<br><img lazyload src="/images/loading.svg" data-src="redis5.jpg" alt="avatar"></p><p>&emsp;&emsp;但是，这里依然存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。对于追求“快”的 Redis 来说，这是不太能接受的。所以，Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。那具体怎么做呢？<br>&emsp;&emsp;为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p><ol><li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li><li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li><li>释放哈希表 1 的空间。</li></ol><p>&emsp;&emsp;这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了渐进式 rehash。简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis6.jpg" alt="avatar"><br>&emsp;&emsp;这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操 作，保证了数据的快速访问。</p><h3 id="集合类数据的操作效率"><a href="#集合类数据的操作效率" class="headerlink" title="集合类数据的操作效率"></a>集合类数据的操作效率</h3><p>&emsp;&emsp;和 String 类型不同，一个集合类型的值，==第一步是通过全局哈希表找到对应的哈希桶位置==，==第二步是在集合中再增删改查==。那么，集合的操作效率和哪些因素相关呢？首先，与集合的底层数据结构有关。例如，使用哈希表实现的集合，要比使用链表实现的 集合访问效率更高。其次，操作效率和这些操作本身的执行特点有关，比如读写一个元素 的操作要比读写所有元素的效率高。</p><h4 id="集合类数据的底层数据结构"><a href="#集合类数据的底层数据结构" class="headerlink" title="集合类数据的底层数据结构"></a>集合类数据的底层数据结构</h4><p>&emsp;&emsp;集合类型的底层数据结构主要有 5 种：整数数组、双向链表、哈希表、压缩列表和跳表。<br>&emsp;&emsp;压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。<br><img lazyload src="/images/loading.svg" data-src="redis7.jpg" alt="avatar"><br>&emsp;&emsp;在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。</p><p>我们再来看下跳表。</p><p>&emsp;&emsp;有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。具体来说，跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis8.jpg" alt="avatar"></p><p>&emsp;&emsp;如果我们要在链表中查找 33 这个元素，只能从头开始遍历链表，查找 6 次，直到找到 33 为止。此时，复杂度是 O(N)，查找效率很低。<br>&emsp;&emsp;为了提高查找速度，我们来增加一级索引：从第一个元素开始，每两个元素选一个出来作为索引。这些索引再通过指针指向原始的链表。例如，从前两个元素中抽取元素 1 作为一级索引，从第三、四个元素中抽取元素 11 作为一级索引。此时，我们只需要 4 次查找就 能定位到元素 33 了。<br>&emsp;&emsp;如果我们还想再快，可以再增加二级索引：从一级索引中，再抽取部分元素作为二级索引。例如，从一级索引中抽取 1、27、100 作为二级索引，二级索引指向一级索引。这样，我们只需要 3 次查找，就能定位到元素 33 了。<br>&emsp;&emsp;可以看到，这个查找过程就是在多级索引上跳来跳去，最后定位到元素。这也正好符合“跳”表的叫法。当数据量很大时，跳表的查找复杂度就是 O(logN)。<br><img lazyload src="/images/loading.svg" data-src="redis9.jpg" alt="avatar"></p><h2 id="不同操作的复杂度"><a href="#不同操作的复杂度" class="headerlink" title="不同操作的复杂度"></a>不同操作的复杂度</h2><ol><li>==单元素操作==，是指每一种集合类型对单个数据实现的增删改查操作。例如，Hash 类型的 HGET、HSET 和 HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)；Set 类型用哈希表作为底层数据结构时，它的 SADD、 SREM、SRANDMEMBER 复杂度也是 O(1)。集合类型支持同时对多个元素进行增删改查，例如 Hash 类型的 HMGET 和 HMSET，Set 类型的 SADD 也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了。</li><li>==范围操作==，<strong>是指集合类型中的遍历操作，可以返回集合中的所有数据</strong>，比如 Hash 类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List 类型的 LRANGE 和 ZSet 类型的 ZRANGE。<strong>这类操作的复杂度一般是 O(N)，比较耗时， 我们应该尽量避免</strong>。不过，Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了<strong>渐进式遍历</strong>，每次只返回有限数量的数据。这样一来，相比于 HGETALL、SMEMBERS 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞。</li><li>==统计操作==，是指<strong>集合类型对集合中所有元素个数的记录</strong>，例如 LLEN 和 SCARD。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。</li><li>==例外情况==，是指某些数据结构的特殊记录，例如<strong>压缩列表和双向链表都会记录表头 和表尾的偏移量</strong>。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂 度也只有 O(1)，可以实现快速操作。</li></ol><h2 id="Redis选择不同数据结构的考量"><a href="#Redis选择不同数据结构的考量" class="headerlink" title="Redis选择不同数据结构的考量"></a>Redis选择不同数据结构的考量</h2><p>&emsp;&emsp;Redis 之所以能快速操作键值对，一方面是因为 O(1) 复杂度的哈希表被广泛使用，包括 String、Hash 和 Set，它们的操作复杂度基本由哈希表决定，另一方面，Sorted Set 也采用了 O(logN) 复杂度的跳表。不过，集合类型的范围操作，因为要遍历底层数据结构，复 杂度通常是 O(N)。这里，我的建议是：用其他命令来替代，例如可以用 SCAN 来代替， 避免在 Redis 内部产生费时的全集合遍历操作。<br>&emsp;&emsp;当然，我们不能忘了复杂度较高的 List 类型，它的两种底层实现结构：双向链表和压缩列表的操作复杂度都是 O(N)。但是它的 POP/PUSH 效率很高，那么就将它主要用于 FIFO 队列场景，而不是作为一个可以随机读写的集合。<strong>另外，List底层使用压缩列表本质上是将所有元素紧挨着存储，所以分配的是一块连续的内存空间，虽然数据结构本身没有时间复杂度的优势，但是这样节省空间而且也能避免一 些内存碎片，它比链表占用的内存要更少。 Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。</strong></p><h1 id="高性能-IO-模型"><a href="#高性能-IO-模型" class="headerlink" title="高性能 IO 模型"></a>高性能 IO 模型</h1><p>&emsp;&emsp;首先要厘清一个事实，说 Redis 是单线程模型，主要是指 <strong>Redis 的网络 IO 和键值对的读写是由一个线程来完成的</strong>，这也是 Redis 对外提供键值存储服务的主要流程。 但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p><h2 id="为什么使用单线程"><a href="#为什么使用单线程" class="headerlink" title="为什么使用单线程"></a>为什么使用单线程</h2><ol><li>==为什么不使用多线程==：并发访问控制一直是多线程开发中的一个难点问题，如果没有精细的设计，比如说，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。而且，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。为了避免这些问题，Redis 直接采用了单线程模式。</li><li>==单线程 Redis 为什么快==：一方面，Redis 的大部分操作在内存上完成，再加上它使用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。另一方面，就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</li></ol><h2 id="基本-IO-模型与阻塞点"><a href="#基本-IO-模型与阻塞点" class="headerlink" title="基本 IO 模型与阻塞点"></a>基本 IO 模型与阻塞点</h2><p>&emsp;&emsp;Redis 处理一个客户端发来的 Get 请求，要经过以下步骤：要监听客户端请求 （bind/listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。<br>&emsp;&emsp;下图显示了这一过程，其中，bind/listen、accept、recv、parse 和 send 属于网络 IO 处理，而 get 属于键值数据操作。既然 Redis 是单线程，那么，最基本的一种实现是在一个线程中依次执行上面说的这些操作。<br><img lazyload src="/images/loading.svg" data-src="redis10.jpg" alt="avatar"><br>&emsp;&emsp;但是，在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听到一个客户端有连接请求，但一直==未能成功建立起连接==时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果==数据一直没有到达==，Redis 也会一直阻塞在 recv()。这就导致 Redis 整个线程阻塞，无法处理其他客户端请求，效率很低。不过，幸运的是， socket 网络模型本身支持非阻塞模式。</p><h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>&emsp;&emsp;在 socket 模型中，不同操作调用后会返回不同的套接字类型。socket() 方法会返回主动套接字，然后调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字。<br><img lazyload src="/images/loading.svg" data-src="redis11.jpg" alt="avatar"><br>&emsp;&emsp;针对监听套接字，我们可以设置非阻塞模式：当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但是，要注意的是，调用 accept() 时，已经存在监听套接字了。<br>&emsp;&emsp;虽然 Redis 线程可以不用继续等待，但是总得有机制继续在监听套接字上等待后续连接请求，并在有请求时通知 Redis。类似的，我们也可以针对已连接套接字设置非阻塞模式：Redis 调用 recv() 后，如果已连 接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作。我们也需要有机 制继续监听该已连接套接字，并在有数据达到时通知 Redis。这样才能保证 Redis 线程，既不会像基本 IO 模型中一直在阻塞点等待，也不会导致 Redis 无法处理实际到达的连接请求或数据。</p><p>到此，Linux 中的 IO 多路复用机制就要登场了。</p><h3 id="基于多路复用的高性能-I-O-模型"><a href="#基于多路复用的高性能-I-O-模型" class="headerlink" title="基于多路复用的高性能 I/O 模型"></a>基于多路复用的高性能 I/O 模型</h3><p>&emsp;&emsp;Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，<strong>同时存在多个监听套接字和已连接套接字</strong>。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。<br>&emsp;&emsp;下图就是基于多路复用的 Redis IO 模型。图中的多个 FD 就是刚才所说的多个套接字。 Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理 上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。<br><img lazyload src="/images/loading.svg" data-src="redis12.jpg" alt="avatar"><br>&emsp;&emsp;为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来， Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时， Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。<br>&emsp;&emsp;以连接请求和读数据请求为例，具体解释一下:<br>&emsp;&emsp;这两个请求分别对应 Accept 事件和 Read 事件，Redis 分别对这两个事件注册 accept 和 get 回调函数。当 Linux 内核监听到有连接请求或读数据请求时，就会触发 Accept 事件 和 Read 事件，此时，内核就会回调 Redis 相应的 accept 和 get 函数进行处理。</p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>&emsp;&emsp;随着硬件性能提升，Redis 的性能瓶颈可能出现网络 IO 的读写，也就是：单个线程处理网络读写的速度跟不上底层网络硬件的速度。读写网络的 <code>read/write</code> 系统调用占用了Redis 执行期间大部分CPU 时间，瓶颈主要在于网络的 IO 消耗。所以，Redis6.0版本 采用多个 IO 线程来处理网络请求，提高网络请求处理的并行度。<strong>需要注意的是，Redis 多 IO 线程模型只用来处理网络读写请求，对于 Redis 的读写命令，依然是单线程处理</strong>。这是因为，网络处理经常是瓶颈，通过多线程并行处理可提高性能。<br>架构图如下：<br><img lazyload src="/images/loading.svg" data-src="redis13.jpg" alt="avatar"><br>主线程与 IO 多线程是如何实现协作呢？<br><img lazyload src="/images/loading.svg" data-src="redis14.jpg" alt="avatar"><br>主要流程：</p><ol><li>主线程负责接收建立连接请求，获取 <code>socket</code> 放入全局等待读处理队列；</li><li>主线程通过轮询将可读 <code>socket</code> 分配给 IO 线程；</li><li>主线程阻塞等待 IO 线程读取 <code>socket</code> 完成；</li><li>主线程执行 IO 线程读取和解析出来的 Redis 请求命令；</li><li>主线程阻塞等待 IO 线程将指令执行结果回写回 <code>socket</code>完毕；</li><li>主线程清空全局队列，等待客户端后续的请求。</li></ol><p>思路：<strong>将主线程 IO 读写任务拆分出来给一组独立的线程处理，使得多个 socket 读写可以并行化，但是 Redis 命令还是主线程串行执行。</strong></p><p>模型缺陷:<br>&emsp;&emsp;Redis 的多线程网络模型实际上并不是一个标准的 <code>Multi-Reactors/Master-Workers</code> 模型。Redis 的多线程方案中，I/O 线程任务仅仅是通过 socket 读取客户端请求命令并解析，却没有真正去执行命令。所有客户端命令最后还需要回到主线程去执行，因此对多核的利用率并不算高，而且每次主线程都必须在分配完任务之后忙轮询等待所有 I/O 线程完成任务之后才能继续执行其他逻辑。</p><h1 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a>AOF 日志</h1><h2 id="AOF-日志是如何实现的"><a href="#AOF-日志是如何实现的" class="headerlink" title="AOF 日志是如何实现的"></a>AOF 日志是如何实现的</h2><p>&emsp;&emsp;对于SQL这类的数据库，基本都是写前日志（Write Ahead Log, WAL），也就是在实际写数据前，先将数据记录在日志中，以便故障时恢复。AOF 正好相反，它是写后日志，也就是说先执行 Redis 命令写入数据，再记录日志。如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis15.jpg" alt="avatar"></p><p>&emsp;&emsp;传统的数据库日志，记录的是修改后的数据，而 AOF 记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存下来的。我们以 Redis 收到“set testkey testvalue”命令后记录的日志为例，看看 AOF 日志的内容。其中，“*3”表示当前命令有三个部分，每部分都是由“$+数字”开头，后面紧跟着 具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节。例 如，“$3 set”表示这部分有 3 个字节，也就是“set”命令。<br><img lazyload src="/images/loading.svg" data-src="redis16.jpg" alt="avatar"></p><p>&emsp;&emsp;AOF 采用写后日志的方式有两个好处：第一，不需要消耗额外的资源检查命令是否正确，只需要在成功写入之后更新日志即可；第二，因为是在写入后更新日志，不必担心被阻塞当前的写操作。<br>&emsp;&emsp;但是这种方式也有天然的缺点，第一，如果在一条命令成功执行后服务器突然宕机，此时还没来得及在 AOF 日志中保存下这条命令，那么再重启服务后这条命令的写入/更新操作就不会被执行；第二，虽然不会阻塞当前的写操作，但是写日志也是在主进程中执行的，如果磁盘的IO压力很大导致写日志很慢，那么之后的 Redis 命令就会被阻塞。<br>&emsp;&emsp;这两个风险都是和 AOF 写回磁盘的时机相关的。这也就意味着，如果我们能够控制一个写命令执行完后 AOF 日志写回磁盘的时机，这两个风险就解除了。</p><h2 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h2><ul><li>Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</li><li>Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li><li>No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li></ul><p>三种写回策略的比较：<br><img lazyload src="/images/loading.svg" data-src="redis17.jpg" alt="avatar"><br>&emsp;&emsp;这时我们就要根据我们的系统的需求来进行 trade-off 了，如果想要保证高可靠，那么就采取 Always 的策略；如果追求的是高性能，那么久采用 no 策略，将控制写回的时机完全交给操作系统；如果想要兼顾两者，那就选择 everysec 策略。</p><h2 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h2><p>&emsp;&emsp;随着时间的推移，Redis 的AOF 日志文件会越来越大，此时可能有三种因素共同制约日志文件的大小：</p><ol><li>操作系统对每个文件的大小上限有限制；</li><li>日志文件过大，每次要打开文件往里面写入，对性能的损耗就越大；</li><li>当使用 AOF 日志恢复数据时，由于 AOF 日志过大，整个恢复过程就会很慢。</li></ol><p>&emsp;&emsp;这个时候，AOF 重写机制就登场了。AOF 会根据日志的现状重新创建一个日志文件，对一个键值对的修改可能是经过很多条 Redis 命令后形成的最终的结果，此时只需要一条命令就能替换掉之前所有的命令。这样一来，一个键值对在重写日志中只用一条命令就行了，在日志恢复时，只用执行这条命令，就可以直接完成这个键值对的写入了。</p><p>下面这张图就是一个例子：<br><img lazyload src="/images/loading.svg" data-src="redis18.jpg" alt="avatar"></p><p>&emsp;&emsp;重写机制虽然能够大大缩减日志文件的大小，但是可以想见，这必定是一个非常消耗资源的操作，那么 AOF 重写会阻塞主线程吗？为避免 AOF 重写阻塞主线程，重写过程会在后台起一个线程来完成。可以总结为一句话：“<strong>一个拷贝，两处日志</strong>”。</p><ul><li><strong>一个拷贝</strong>：主线程 fork 一个线程来重写 AOF 日志时，会将主线程内存拷贝一份给子线程，这里面包含了数据库的最新数据，自线程就可以在不影响主线程的前提下逐一把拷贝的数据写成操作存入重写日志。</li><li><strong>两处日志</strong>：如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这 个 AOF 日志的操作仍然是齐全的，可以用于恢复；而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这 样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日 志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我 们就可以用新的 AOF 文件替代旧文件了。<br><img lazyload src="/images/loading.svg" data-src="redis19.jpg" alt="avatar"><br>&emsp;&emsp; 总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个 日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>AOF 日志重写的时候，是由 bgrewriteaof 子进程来完成的，不用主线程参与，我们今天说的非阻塞也是指子进程的执行不阻塞主线程。但是，你觉得，这个重写过程有没有其他潜在的阻塞风险呢？如果有的话，会在哪里阻塞？<br>答：fork子进程，fork这个瞬间一定是会阻塞主线程的（注意，fork时并不会一次性拷贝所有内存数据给子进程），fork采用操作系统提供的写实复制(Copy On Write)机制，就是为了避免一次性拷贝大量内存数据给子进程造成的长时间阻塞问题，但<strong>fork子进程需要拷贝进程必要的数据结构，其中有一项就是拷贝内存页表</strong>（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，实例越大，内存页表越大，fork阻塞时间越久。拷贝内存页表完成后，子进程与父进程指向相同的内存地址空间，也就是说此时虽然产生了子进程，但是并没有申请与父进程相同的内存大小。那什么时候父子进程才会真正内存分离呢？“写实复制”顾名思义，就是在写发生时，才真正拷贝内存真正的数据，这个过程中，父进程也可能会产生阻塞的风险，就是下面介绍的场景。</li></ol><p>fork出的子进程指向与父进程相同的内存地址空间，此时子进程就可以执行AOF重写，把内存中的所有数据写入到AOF文件中。但是此时父进程依旧是会有流量写入的，如果父进程操作的是一个已经存在的key，那么这个时候父进程就会真正拷贝这个key对应的内存数据，申请新的内存空间，这样逐渐地，父子进程内存数据开始分离，父子进程逐渐拥有各自独立的内存空间。因为内存分配是以页为单位进行分配的，默认4k，如果父进程此时操作的是一个bigkey，重新申请大块内存耗时会变长，可能会产阻塞风险。另外，如果操作系统开启了内存大页机制(Huge Page，页面大小2M)，那么父进程申请内存时阻塞的概率将会大大提高，所以在Redis机器上需要关闭Huge Page机制。Redis每次fork生成RDB或AOF重写完成后，都可以在Redis log中看到父进程重新申请了多大的内存空间。</p><ol start="2"><li>AOF 重写也有一个重写日志，为什么它不共享使用 AOF 本身的日志呢？<br>答：一个原因是父子进程写同一个文件必然会产生竞争问题，控制竞争就意味着会影响父进程的性能。二是如果AOF重写过程中失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用。所以Redis AOF重写一个新文件，重写失败的话，直接删除这个文件就好了，不会对原先的AOF文件产生影响。等重写完成之后，直接替换旧文件即可。</li></ol><h1 id="RDB-内存快照"><a href="#RDB-内存快照" class="headerlink" title="RDB 内存快照"></a>RDB 内存快照</h1><p>&emsp;&emsp;上一节说到 AOF 日志将 Redis 的写命令逐一记录下来，在服务重启时再逐一执行恢复数据。如果 AOF 日志文件过大，这一过程通常是很缓慢的。这一节将讨论另一种持久化方式：内存快照。所谓内存快照，就是指内存中的数据在某一个时刻的状态记录。这就类似于照片，当你给朋友拍照时，一张照片就能把朋友一瞬间的形象完全记下来。对 Redis 来说，它实现类似照片记录效果的方式，就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 RDB 文件，其中，RDB 就是 Redis DataBase 的缩写。和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，我 们可以直接把 RDB 文件读入内存，很快地完成恢复。听起来好像很不错，但内存快照也并不是最优选项。为什么这么说呢？有另个问题要考虑：</p><ol><li>我们应该对那些数据做快照？这关系到快照的执行效率问题；</li><li>做快照时，数据还能被增删改吗？这关系到 Redis 是否被阻塞，能否同时正常处理请求。</li></ol><p>拿拍照片来举例子。我们在拍照时，通常要关注两个问题：</p><ol><li>如何取景？也就是说，我们打算把哪些人、哪些物拍到照片中；</li><li>在按快门前，要记着提醒朋友不要乱动，否则拍出来的照片就模糊了。</li></ol><h2 id="给哪些数据做快照"><a href="#给哪些数据做快照" class="headerlink" title="给哪些数据做快照?"></a>给哪些数据做快照?</h2><p>&emsp;&emsp;Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是<strong>全量快照</strong>，也就是说，把内存中的所有数据都记录到磁盘中，这就类似于给 100 个人拍合影，把每一个人都拍进照片里。这样做的好处是，一次性记录了所有数据，一个都不少。同样，给内存的全量数据做快照， 把它们全部写入磁盘也会花费很多时间。而且，全量数据越多，RDB 文件就越大，往磁盘上写数据的时间开销就越大。对于 Redis 而言，它的单线程模型就决定了，我们要尽量避免所有会阻塞主线程的操作， 所以，针对任何操作，我们都会提一个灵魂之问：“它会阻塞主线程吗?”。RDB 文件的生成是否会阻塞主线程，这就关系到是否会降低 Redis 的性能。</p><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。</p><ul><li>save：在主线程中执行，会导致阻塞；</li><li>bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。</li></ul><p>&emsp;&emsp;我们就可以通过 bgsave 命令来执行全量快照，这既提供了数据的可靠性保证，也避免了对 Redis 的性能影响。</p><p>&emsp;&emsp;接下来，我们要关注的问题就是，在对内存数据做快照时，这些数据还能“动”吗? 也就是说，这些数据还能被修改吗？ 这个问题非常重要，这是因为，如果数据能被修改，那就意味着 Redis 还能正常处理写操作。否则，所有写操作都得等到快照完了才能执行，性能一下子就降低了。</p><h2 id="快照时数据能修改吗"><a href="#快照时数据能修改吗" class="headerlink" title="快照时数据能修改吗?"></a>快照时数据能修改吗?</h2><p>&emsp;&emsp;当我们采用 bgsave 方式来生成快照时，其实是 fork 了一个子进程。根据 Linux 中 fork 系统调用的规则，子进程在创建后并不会将父进程所有的内存数据都单独拷贝一份，而是拷贝一份页表，背后指向和父进程一样的物理地址。当有新的 Redis 写入命令时，原来的键值对发生了修改，那么就会启用 copy-on-write 思想，子进程会在内存中复制一份该键值对，并通过页表指向该新创建的地址，这就做到了在进行快照时，数据发生了修改，子进程仍然可以把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。<br><img lazyload src="/images/loading.svg" data-src="redis20.jpg" alt="avatar"><br>&emsp;&emsp;这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影 响。到这里，我们就解决了对“哪些数据做快照”以及“做快照时数据能否修改”这两大问 题：Redis 会使用 bgsave 对当前内存中的所有数据做快照，这个操作是子进程在后台完 成的，这就允许主线程同时可以修改数据。</p><p>&emsp;&emsp;现在，我们再来看另一个问题：多久做一次快照？我们在拍照的时候，还有项技术叫“连 拍”，可以记录人或物连续多个瞬间的状态。那么，快照也适合“连拍”吗？</p><h2 id="可以每秒做一次快照吗？"><a href="#可以每秒做一次快照吗？" class="headerlink" title="可以每秒做一次快照吗？"></a>可以每秒做一次快照吗？</h2><p>&emsp;&emsp;对于快照来说，所谓“连拍”就是指连续地做快照。这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。但是，这其中的快照间隔时间就很关键了。<br>&emsp;&emsp;如下图所示，我们先在 T0 时刻做了一次快照，然后又在 T0+t 时刻做了一次快照，在这期间，数据块 5 和 9 被修改了。如果在 t 这段时间内，机器宕机了，那么，只能按照 T0 时刻的快照进行恢复。此时，数据块 5 和 9 的修改值因为没有快照记录，就无法恢复了。<br><img lazyload src="/images/loading.svg" data-src="redis21.jpg" alt="avatar"><br>&emsp;&emsp;所以，要想尽可能恢复数据，t 值就要尽可能小，t 越小，就越像“连拍”。那么，t 值可以小到什么程度呢，比如说是不是可以每秒做一次快照？毕竟，每次快照都是由 bgsave 子进程在后台执行，也不会阻塞主线程。这种想法其实是错误的。虽然 <strong>bgsave 执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销</strong>。</p><ol><li>一方面，对于<strong>磁盘</strong>而言，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</li><li>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后 不会再阻塞主线程，但是，<strong>fork 这个创建过程本身会阻塞主线程</strong>，而且主线程的内存越 大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。</li></ol><p>&emsp;&emsp;此时，我们可以做<strong>增量快照</strong>，所谓增量快照，就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。</p><p>&emsp;&emsp;在第一次做完全量快照后，T1 和 T2 时刻如果再做快照，我们只需要将被修改的数据写入快照文件就行。但是，这么做的前提是，我们需要<strong>记住哪些数据被修改了</strong>。你可不要小瞧 这个“记住”功能，它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis22.jpg" alt="avatar"><br>&emsp;&emsp;如果我们对每一个键值对的修改，都做个记录，那么，如果有 1 万个被修改的键值对，我们就需要有 1 万条额外的记录。而且，有的时候，键值对非常小，比如只有 32 字节，而记录它被修改的元数据信息，可能就需要 8 字节，这样的画，为了“记住”修改，引入的额外空间开销比较大。这对于内存资源宝贵的 Redis 来说，有些得不偿失。</p><p>&emsp;&emsp;到这里，你可以发现，虽然跟 AOF 相比，快照的恢复速度快，但是，快照的频率不好把握，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销，那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？我们再仔细想一想，使用 AOF 日志不是能很好的记录修改吗。</p><h2 id="混合使用-AOF-日志和内存快照"><a href="#混合使用-AOF-日志和内存快照" class="headerlink" title="混合使用 AOF 日志和内存快照"></a>混合使用 AOF 日志和内存快照</h2><p>&emsp;&emsp;简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。<br><img lazyload src="/images/loading.svg" data-src="redis23.jpg" alt="avatar"><br>&emsp;&emsp;这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;两大纬度，三大主线&quot;&gt;&lt;a href=&quot;#两大纬度，三大主线&quot; class=&quot;headerlink&quot; title=&quot;两大纬度，三大主线&quot;&gt;&lt;/a&gt;两大纬度，三大主线&lt;/h1&gt;&lt;p&gt;&lt;img lazyload src=&quot;/images/loading.svg&quot; da</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiahaohong1997.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Redis" scheme="http://jiahaohong1997.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://jiahaohong1997.github.io/2021/12/30/overtime.png/"/>
    <id>http://jiahaohong1997.github.io/2021/12/30/overtime.png/</id>
    <published>2021-12-30T07:50:08.392Z</published>
    <updated>2021-12-30T07:50:08.392Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>微服务可用性设计</title>
    <link href="http://jiahaohong1997.github.io/2021/12/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/"/>
    <id>http://jiahaohong1997.github.io/2021/12/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-12-29T07:00:00.000Z</published>
    <updated>2022-01-02T10:06:50.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h1><p>&emsp;&emsp;本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。</p><ul><li>服务隔离</li></ul><ol><li><p>动静隔离</p><p> 小到 CPU 的 cacheline <a class="link" href="https://www.cnblogs.com/cyfonly/p/5800758.html">false sharing<i class="fas fa-external-link-alt"></i></a>、数据库 mysql 表设计中避免 bufferpool 频繁过期，隔离动静表，大到架构设计中的图片、静态资源等缓存加速。本质上都体现的一样的思路，即加速/缓存访问变换频次小的。<br> 案例一： CDN 场景中，将静态资源和动态 API 分离，也是体现了隔离的思路:<br><img lazyload src="/images/loading.svg" data-src="CDN.png" alt="avatar"></p><p> *. 降低了应用服务器的负载，静态文件访问负载全部通过CDN；<br> *. 对象存储费用最低；<br> *. 海量存储空间，无需考虑存储架构的升级；<br> *. 静态CDN带宽加速，延迟低。</p><p>案例二：用户创作稿件库<br> archive: 稿件表，存储稿件的名称、作者、分类、tag、状态等信息，表示稿件的基本信息。在一个投稿流程中，一旦稿件创建改动的频率比较低。<br> archive_stat: 稿件统计表，表示稿件的播放、点赞、收藏、投币数量，比较高频的更新。随着稿件获取流量，稿件被用户所消费，各类计数信息更新比较频繁。<br><img lazyload src="/images/loading.svg" data-src="archive.png" alt="avatar"><br> MySQL BufferPool 是用于缓存 DataPage 的，DataPage 可以理解为缓存了表的行，那么如果频繁更新 DataPage 不断会置换，会导致命中率下降的问题，所以我们在表设计中，仍然可以沿用类似的思路，其主表基本更新，在上游 Cache 未命中，透穿到 MySQL，仍然有 BufferPool 的缓存。</p></li><li><p>读写分离：主从、Replicaset、CQRS</p></li></ol><ul><li>轻重隔离</li></ul><ol><li><p>核心隔离</p><p> 业务按照 Level 进行资源池划分（L0/L1/L2）<br><img lazyload src="/images/loading.svg" data-src="level.png" alt="avatar"><br> 核心/非核心的故障域的差异性隔离（机器资源、依赖资源）<br> 多集群，通过冗余资源来提升吞吐和容灾能力。</p></li><li><p>快慢隔离<br>&emsp;&emsp;我们可以把服务的吞吐想象为一个池，当突然洪流进来时，池子需要一定时间才能排放完，这时候其他支流在池子里待的时间取决于前面的排放能力，耗时就会增高，对小请求产生影响。</p></li></ol><p>日志传输体系的架构设计中，整个流都会投放到一个 kafka topic 中（早期设计目的: 更好的顺序 IO），流内会区分不同的 logid，logid 会有不同的 sink 端，它们之前会出现差速，比如 HDFS 抖动吞吐下降，ES 正常水位，全局数据就会整体反压。<br><img lazyload src="/images/loading.svg" data-src="kafka.png" alt="avatar"><br>按照各种纬度隔离：sink、部门、业务、logid、重要性（S/A/B/C）。<br>业务日志也属于某个 logid，日志等级就可以作为隔离通道。</p><ol start="3"><li>热点隔离(也是解决缓存击穿的策略)</li></ol><p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行缓存。比如：<br>小表广播（单起一个goroutine，采用copy-on-write的方式更新localcache）: 从 remotecache 提升为 localcache，app 定时更新，甚至可以让运营平台支持广播刷新 localcache。<a class="link" href="https://pkg.go.dev/sync/atomic">atomic.Value<i class="fas fa-external-link-alt"></i></a><br><img lazyload src="/images/loading.svg" data-src="atomic.png" alt="avatar"><br>主动预热（旁路监控方式，类似地震前30秒的预警，提前一段时间将缓存中的热点数据变成localcache 存储）: 比如直播房间页高在线情况下 bypass 监控主动防御。<br><img lazyload src="/images/loading.svg" data-src="monitor.png" alt="avatar"></p><ul><li>物理隔离</li></ul><ol><li><p>线程隔离<br>&emsp;&emsp;主要通过线程池进行隔离，也是实现服务隔离的基础。把业务进行分类并交给不同的线程池进行处理，当某个线程池处理一种业务请求发生问题时，不会讲故障扩散和影响到其他线程池，保证服务可用。<br>对于 Go 来说，所有 IO 都是 Nonblocking，且托管给了 Runtime，只会阻塞 Goroutine，不阻塞 M，我们只需要考虑 Goroutine 总量的控制，不需要线程模型语言的线程隔离。<br><img lazyload src="/images/loading.svg" data-src="java.png" alt="avatar"></p></li><li><p>进程隔离<br>&emsp;&emsp;容器化（docker），容器编排引擎（k8s）。我们15年在 KVM 上部署服务；16年使用 Docker Swarm；17年迁移到 Kubernetes，到年底在线应用就全托管了，之后很快在线应用弹性公有云上线；20年离线 Yarn 和 在线 K8s 做了在离线混部（错峰使用），之后计划弹性公有云配合自建 IDC 做到离线的混合云架构。</p></li><li><p>集群隔离<br>&emsp;&emsp;过多集群方案，即逻辑上是一个应用，物理上部署多套应用，通过 cluster 区分。</p></li></ol><h2 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h2><ol><li>转码集群被超大视频攻击，导致转码大量延迟。</li></ol><p>&emsp;&emsp;针对大视频、较大视频、重要视频分别设置转码集群，当再遭遇转码攻击，只会影响部分的服务器，还能维持整体的可用。</p><ol start="2"><li>缩略图服务，被大图实时缩略吃完所有 CPU，导致正常的小图缩略被丢弃，大量503。</li></ol><p>&emsp;&emsp;对于请求的图像，不会专门针对所有设备都预设好图片的尺寸，会根据用户的设备大小进行实时的缩略。如果请求了大量的 gif，那么对 gif的每一帧都要进行实时缩略，耗时比图像要久很多。把 gif 和正常图像分为两个集群来处理，将全剧故障化解为局部故障。</p><ol start="3"><li><p> 数据库实例 cgroup 未隔离，导致大 SQL 引起的集体故障。</p></li><li><p> INFO 日志量过大，导致异常 ERROR 日志采集延迟。</p></li></ol><h1 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h1><p>&emsp;&emsp;超时控制，我们的组件能够快速失效（fail fast），因为我们不希望等到断开的实例直到超时。没有什么比挂起的请求和无响应的界面更令人失望。这不仅浪费资源，而且还会让用户体验变得更差。我们的服务是互相调用的，所以在这些延迟叠加前，应该特别注意防止那些超时的操作。<br><img lazyload src="/images/loading.svg" data-src="timeout.png" alt="avatar"></p><ul><li>网路传递具有不确定性。</li><li>客户端和服务端不一致的超时策略导致资源浪费。</li><li>默认值”策略。(不建议使用“永不超时”默认值)</li><li>高延迟服务导致 client 浪费资源等待，使用超时传递: 进程间传递 + 跨进程传递。</li></ul><p>&emsp;&emsp;超时控制是微服务可用性的第一道关，良好的超时策略，可以尽可能让服务不堆积请求，尽快清空高延迟的请求，释放 Goroutine。</p><h2 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h2><p>&emsp;&emsp;实际业务开发中，我们依赖的微服务的超时策略并不清楚，或者随着业务迭代耗时超生了变化，意外的导致依赖者出现了超时。<br>处理策略：</p><ul><li> 服务提供者定义好 latency SLO，更新到 gRPC Proto 定义中，服务后续迭代，都应保证 SLO。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> google.example.library.v1;</span><br><span class="line"></span><br><span class="line">service LibraryService &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Lagency SLO: 95th in 100ms, 99th in 150ms.</span></span><br><span class="line"></span><br><span class="line"> rpc CreateBook(CreateBookRequest) returns (Book);</span><br><span class="line"></span><br><span class="line"> rpc GetBook(GetBookRequest) returns Book);</span><br><span class="line"></span><br><span class="line"> rpc ListBooks(ListBooksRequest) returns (ListBooksResponse);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免出现意外的默认超时策略，或者意外的配置超时策略。</p><ul><li>kit 基础库兜底默认超时，比如 100ms，进行配置防御保护，避免出现类似 60s 之类的超大超时策略。</li><li>配置中心公共模版，对于未配置的服务使用公共配置。</li></ul><h3 id="超时传递"><a href="#超时传递" class="headerlink" title="超时传递"></a>超时传递</h3><p> &emsp;&emsp;超时传递: 当上游服务已经超时返回 504，但下游服务仍然在执行，会导致浪费资源做无用功。超时传递指的是把当前服务的剩余 Quota 传递到下游服务中，继承超时策略，控制请求级别的全局超时控制。<br> <img lazyload src="/images/loading.svg" data-src="timetransfer.png" alt="avatar"><br> 取配置的超时控制策略与剩余时间的最小值。</p><ul><li><p>进程内超时控制<br>&emsp;&emsp;一个请求在每个阶段(网络请求)开始前，就要检查是否还有足够的剩余来处理请求，以及继承他的超时策略，使用 Go 标准库的 <a class="link" href="https://pkg.go.dev/context">context.WithTimeout<i class="fas fa-external-link-alt"></i></a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *asiiConn)</span> <span class="title">Get</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="params">(result \*Item, err error)</span></span> &#123;</span><br><span class="line">c.conn.SetWriteDeadline(shrinkDeadline(ctx, c.writeTimeout))</span><br><span class="line"><span class="keyword">if</span> _, err = fmt.Fprintf(c.rw, <span class="string">&quot;gets %s\r\n&quot;</span>, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多进程的超时控制<br><img lazyload src="/images/loading.svg" data-src="processcontrol.png" alt="avatar"></p></li></ul><ol><li>A gRPC 请求 B，1s超时。</li><li>B 使用了300ms 处理请求，再转发请求 C。</li><li>C 配置了600ms 超时，但是实际只用了500ms。</li><li>到其他的下游，发现余量不足，取消传递。</li></ol><p>在需要强制执行时，下游的服务可以覆盖上游的超时传递和配额。<br>在 gRPC 框架中，会依赖 gRPC Metadata Exchange，基于 HTTP2 的 Headers 传递 grpc-timeout 字段，自动传递到下游，构建带 timeout 的 context。</p><p><img lazyload src="/images/loading.svg" data-src="Bimodel.png" alt="avatar"></p><ul><li>双峰分布: 95%的请求耗时在100ms内，5%的请求可能永远不会完成（长超时）。</li><li>对于监控不要只看 mean，可以看看耗时分布统计，比如 95th，99th。</li><li>设置合理的超时，拒绝超长请求，或者当Server 不可用要主动失败。</li></ul><p><strong>超时决定着服务线程耗尽。</strong></p><h2 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h2><ul><li>SLB 入口 Nginx 没配置超时导致连锁故障。</li><li>服务依赖的 DB 连接池漏配超时，导致请求阻塞，最终服务集体 OOM。</li><li>下游服务发版耗时增加，而上游服务配置超时过短，导致上游请求失败。</li></ul><h1 id="过载保护和限流"><a href="#过载保护和限流" class="headerlink" title="过载保护和限流"></a>过载保护和限流</h1><h2 id="过载保护"><a href="#过载保护" class="headerlink" title="过载保护"></a>过载保护</h2><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>   一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：</p><ul><li>假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。</li><li>桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝。</li><li>当一个 n 个字节大小的数据包到达，将从桶中删除n 个令牌，接着数据包被发送到网络上。</li><li>如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。</li></ul><p><img lazyload src="/images/loading.svg" data-src="token-bucket.png" alt="avatar"><br>token-bucket rate limit algorithm: <a class="link" href="https://pkg.go.dev/golang.org/x/time/rate">/x/time/rate<i class="fas fa-external-link-alt"></i></a></p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>作为计量工具（The Leaky Bucket Algorithm as a Meter）时，可以用于流量整形（Traffic Shaping）和流量控制（TrafficPolicing），漏桶算法的描述如下：</p><ul><li> 一个固定容量的漏桶，按照常量固定速率流出水滴。</li><li>如果桶是空的，则不需流出水滴。</li><li>可以以任意速率流入水滴到漏桶。</li><li>如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。<br><img lazyload src="/images/loading.svg" data-src="leaky-bucket.png" alt="avatar"><br>leaky-bucket rate limit algorithm: <a class="link" href="https://pkg.go.dev/go.uber.org/ratelimit">/go.uber.org/ratelimit<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="令牌桶和漏桶算法的弊端"><a href="#令牌桶和漏桶算法的弊端" class="headerlink" title="令牌桶和漏桶算法的弊端"></a>令牌桶和漏桶算法的弊端</h3><p>&emsp;&emsp;漏斗桶/令牌桶确实能够保护系统不被拖垮, 但不管漏斗桶还是令牌桶, 其防护思路都是设定一个指标, 当超过该指标后就阻止或减少流量的继续进入，当系统负载降低到某一水平后则恢复流量的进入。但其通常都是被动的，其实际效果取决于限流阈值设置是否合理，但往往设置合理不是一件容易的事情。</p><ul><li>集群增加机器或者减少机器限流阈值是否要重新设置?</li><li>设置限流阈值的依据是什么?</li><li>人力运维成本是否过高?</li><li>当调用方反馈429时, 这个时候重新设置限流, 其实流量高峰已经过了重新评估限流是否有意义?</li></ul><p>&emsp;&emsp;这些其实都是采用漏斗桶/令牌桶的缺点, 总体来说就是太被动, 不能快速适应流量变化。因此我们需要一种自适应的限流算法，即: 过载保护，根据系统当前的负载自动丢弃流量。</p><h3 id="根据系统负载做过载保护"><a href="#根据系统负载做过载保护" class="headerlink" title="根据系统负载做过载保护"></a>根据系统负载做过载保护</h3><p>&emsp;&emsp;计算系统临近过载时的峰值吞吐作为限流的阈值来进行流量控制，达到系统保护。</p><ul><li>服务器临近过载时，主动抛弃一定量的负载，目标是自保。</li><li>在系统稳定的前提下，保持系统的吞吐量。</li></ul><p>常见做法：利特尔法则<br><img lazyload src="/images/loading.svg" data-src="lierte.png" alt="avatar"></p><ul><li>CPU、内存作为信号量进行节流。</li><li>队列管理: 队列长度、LIFO。</li><li>可控延迟算法: <a class="link" href="https://blog.csdn.net/dog250/article/details/72849893">Co<i class="fas fa-external-link-alt"></i></a><a class="link" href="https://blog.csdn.net/dog250/article/details/72849893">D<i class="fas fa-external-link-alt"></i></a><a class="link" href="https://blog.csdn.net/dog250/article/details/72849893">el<i class="fas fa-external-link-alt"></i></a>。</li></ul><p>如何计算接近峰值时的系统吞吐？</p><ul><li><p>CPU: 使用一个独立的线程采样，每隔 250ms 触发一次。在计算均值时，使用了简单滑动平均去除峰值的影响。<br><img lazyload src="/images/loading.svg" data-src="cpu.png" alt="avatar"></p></li><li><p>Inflight: 当前服务中正在进行的请求的数量。</p></li><li><p>Pass&amp;RT: 最近5s，pass 为每100ms采样窗口内成功请求的数量，rt 为单个采样窗口中平均响应时间。<br><img lazyload src="/images/loading.svg" data-src="slide.png" alt="avatar"></p></li><li><p>使用 CPU 的滑动均值（CPU &gt; 800）作为启发阈值，一旦触发进入到过载保护阶段，算法为：(pass* rt) &lt; inflight</p></li><li><p>限流效果生效后，CPU 会在临界值（800）附近抖动，如果不使用冷却时间，那么一个短时间的 CPU 下降就可能导致大量请求被放行，严重时会打满 CPU。</p></li><li><p>在冷却时间后，重新判断阈值（CPU &gt; 800 ），是否持续进入过载保护。</p></li></ul><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>&amp;emsp&emsp;在一段时间内，定义某个客户或应用可以接收或处理多少个请求的技术。例如，通过限流，你可以过滤掉产生流量峰值的客户和微服务，或者可以确保你的应用程序在自动扩展（Auto Scaling）失效前都不会出现过载的情况。</p><ul><li>令牌桶、漏桶 针对单个节点，无法分布式限流。</li><li>QPS 限流<ul><li>不同的请求可能需要数量迥异的资源来处理。</li><li>某种静态 QPS 限流不是特别准。</li></ul></li><li>给每个用户设置限制<ul><li>全局过载发生时候，针对某些“异常”进行控制。</li><li>一定程度的“超卖”配额。</li></ul></li><li>按照优先级丢弃。</li><li>拒绝请求也需要成本。<br><img lazyload src="/images/loading.svg" data-src="rateLimitEnabled.png" alt="avatar"></li></ul><h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p>&emsp;&emsp; 分布式限流，是为了控制某个应用全局的流量，而非真对单个节点纬度。</p><ul><li>单个大流量的接口，使用 redis 容易产生热点。</li><li>pre-request 模式对性能有一定影响，高频的网络往返。  </li></ul><p><img lazyload src="/images/loading.svg" data-src="distributed.png" alt="avatar"></p><p>思考：<br>&emsp;&emsp;从获取单个 quota 升级成批量 quota。quota: 表示速率，获取后使用令牌桶算法来限制。</p><ul><li>每次心跳后，异步批量获取 quota，可以大大减少请求 redis 的频次，获取完以后本地消费，基于令牌桶拦截</li><li>每次申请的配额需要手动设定静态值略欠灵活，比如每次要20，还是50</li></ul><p><img lazyload src="/images/loading.svg" data-src="redis.png" alt="avatar"></p><p>如何基于单个节点按需申请，并且避免出现不公平的现象？<br>初次使用默认值，一旦有过去历史窗口的数据，可以基于历史窗口数据进行 quota 请求。</p><p>思考：<br>我们经常面临给一组用户划分稀有资源的问题，他们都享有等价的权利来获取资源，但是其中一些用户实际上只需要比其他用户少的资源。那么我们如何来分配资源呢？一种在实际中广泛使用的分享技术称作“最大最小公平分享”（Max-Min Fairness）。<br><img lazyload src="/images/loading.svg" data-src="max-min.png" alt="avatar"></p><p>直观上，公平分享分配给每个用户想要的可以满足的最小需求，然后将没有使用的资源均匀的分配给需要‘大资源’的用户。</p><p>最大最小公平分配算法的形式化定义如下：<br>•资源按照需求递增的顺序进行分配。<br>•不存在用户得到的资源超过自己的需求。<br>•未得到满足的用户等价的分享资源。</p><p><img lazyload src="/images/loading.svg" data-src="compare.png" alt="avatar"></p><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>&emsp;&emsp;每个接口配置阈值，运营工作繁重，最简单的我们配置服务级别 quota，更细粒度的，我们可以根据不同重要性设定 quota，我们引入了重要性（criticality）:</p><p>•最重要 CRITICAL_PLUS，为最终的要求预留的类型，拒绝这些请求会造成非常严重的用户可见的问题。<br>•重要 CRITICAL，生产任务发出的默认请求类型。拒绝这些请求也会造成用户可见的问题。但是可能没那么严重。<br>•可丢弃的 SHEDDABLE_PLUS 这些流量可以容忍某种程度的不可用性。这是批量任务发出的请求的默认值。这些请求通常可以过几分钟、几小时后重试。<br>•可丢弃的 SHEDDABLE 这些流量可能会经常遇到部分不可用情况，偶尔会完全不可用。</p><p>&emsp;&emsp;gRPC 系统之间，需要自动传递重要性信息。如果后端接受到请求 A，在处理过程中发出了请求 B 和 C 给其他后端，请求 B 和 C 会使用与 A 相同的重要性属性。</p><p>•全局配额不足时，优先拒绝低优先级的。<br>•全局配额，可以按照重要性分别设置。<br>•过载保护时，低优先级的请求先被拒绝。</p><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>&emsp;&emsp;断路器（Circuit Breakers）: 为了限制操作的持续时间，我们可以使用超时，超时可以防止挂起操作并保证系统可以响应。因为我们处于高度动态的环境中，几乎不可能确定在每种情况下都能正常工作的准确的时间限制。断路器以现实世界的电子元件命名，因为它们的行为是都是相同的。断路器在分布式系统中非常有用，因为重复的故障可能会导致雪球效应，并使整个系统崩溃。</p><ul><li>服务依赖的资源出现大量错误。</li><li>某个用户超过资源配额时，后端任务会快速拒绝请求，返回“配额不足”的错误，但是拒绝回复仍然会消耗一定资源。有可能后端忙着不停发送拒绝请求，导致过载。<br><img lazyload src="/images/loading.svg" data-src="rongduan.png" alt="avatar"></li></ul><p>Google SRE<br>max(0, (requests - K*accepts) / (requests + 1))<br><img lazyload src="/images/loading.svg" data-src="google.png" alt="avatar"><br><img lazyload src="/images/loading.svg" data-src="google1.png" alt="avatar"></p><h3 id="Gutter"><a href="#Gutter" class="headerlink" title="Gutter"></a>Gutter</h3><p>&emsp;&emsp;基于熔断的 gutter kafka ，用于接管自动修复系统运行过程中的负载，这样只需要付出10%的资源就能解决部分系统可用性问题。我们经常使用 failover 的思路，但是完整的 failover 需要翻倍的机器资源，平常不接受流量时，资源浪费。高负载情况下接管流量又不一定完整能接住。所以这里核心利用熔断的思路，是把抛弃的流量转移到 gutter 集群，如果 gutter 也接受不住的流量，重新回抛到主集群，最大力度来接受。<br><img lazyload src="/images/loading.svg" data-src="gutter.png" alt="avatar"></p><h3 id="客户端流控"><a href="#客户端流控" class="headerlink" title="客户端流控"></a>客户端流控</h3><p>positive feedback: 用户总是积极重试，访问一个不可达的服务。<br>•客户端需要限制请求频次，retry backoff 做一定的请求退让。<br><img lazyload src="/images/loading.svg" data-src="backoff.png" alt="avatar"><br>•可以通过接口级别的 error_details，挂载到每个 API 返回的响应里。<br><img lazyload src="/images/loading.svg" data-src="error.png" alt="avatar"></p><h3 id="Case-1"><a href="#Case-1" class="headerlink" title="Case"></a>Case</h3><ol><li>二层缓存穿透、大量回源导致的核心服务（例如Mysql）故障。</li></ol><p>通过限流策略，控制到达Mysql的请求速率，让Mysql的缓存逐步建立，避免被海量的请求直接打死。</p><ol start="2"><li>异常客户端引起的服务故障（query of death）</li></ol><ul><li>请求放大。</li><li>资源数放大</li></ul><p>针对相应的用户做专门的限制，比如最多只放行 k 个请求。</p><ol start="3"><li>用户重试导致的大面积故障。</li></ol><p>在客户端限制用户的请求频次。</p><h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><p>&emsp;&emsp;通过降级回复来减少工作量，或者丢弃不重要的请求。而且需要了解哪些流量可以降级，并且有能力区分不同的请求。我们通常提供降低回复的质量来答复减少所需的计算量或者时间。我们自动降级通常需要考虑几个点：<br>•确定具体采用哪个指标作为流量评估和优雅降级的决定性指标（如，CPU、延迟、队列长度、线程数量、错误等）。<br>•当服务进入降级模式时，需要执行什么动作？<br>•流量抛弃或者优雅降级应该在服务的哪一层实现？是否需要在整个服务的每一层都实现，还是可以选择某个高层面的关键节点来实现？</p><p>同时我们要考虑一下几点：<br>•优雅降级不应该被经常触发 - 通常触发条件现实了容量规划的失误，或者是意外的负载。<br>•演练，代码平时不会触发和使用，需要定期针对一小部分的流量进行演练，保证模式的正常。<br>•应该足够简单。</p><h2 id="降级本质为-提供有损服务。"><a href="#降级本质为-提供有损服务。" class="headerlink" title="降级本质为: 提供有损服务。"></a>降级本质为: 提供有损服务。</h2><ol><li><p>UI 模块化，非核心模块降级。</p><ul><li>BFF 层聚合 API，模块降级。<br><img lazyload src="/images/loading.svg" data-src="bilibili.png" alt="avatar"></li></ul></li><li><p>页面上一次缓存副本。</p></li><li><p>默认值、热门推荐等。</p></li><li><p>流量拦截 + 定期数据缓存(过期副本策略)。</p></li></ol><p>处理策略<br>•页面降级、延迟服务、写/读降级、缓存降级<br>•抛异常、返回约定协议、Mock 数据、Fallback 处理<br><img lazyload src="/images/loading.svg" data-src="fallback.png" alt="avatar"></p><h2 id="Case-2"><a href="#Case-2" class="headerlink" title="Case"></a>Case</h2><ol><li>客户端解析协议失败，app 奔溃。</li></ol><p>要返回的默认降级数据（空数组、nil）一定要和客户端的开发人员进行沟通，否则会导致客户端解析失败而闪退。</p><ol start="2"><li>客户端部分协议不兼容，导致页面失败。</li><li> local cache 数据源缓存，发版失效 + 依赖接口故障，引起的白屏。</li></ol><p>解决方案：在远程remote cache 中再保存一份。</p><h1 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h1><p>&emsp;&emsp;当请求返回错误（例: 配额不足、超时、内部错误等），对于 backend 部分节点过载的情况下，倾向于立刻重试，但是需要留意重试带来的流量放大:</p><p>•限制重试次数和基于重试分布的策略（重试比率: 10%）。<br>•随机化、指数型递增的重试周期: exponential ackoff + jitter。<br>•client 测记录重试次数直方图，传递到 server，进行分布判定，交由 server 判定拒绝。<br>•只应该在失败的这层进行重试，当重试仍然失败，全局约定错误码“过载，无须重试”，避免级联重试。</p><h2 id="Case-3"><a href="#Case-3" class="headerlink" title="Case"></a>Case</h2><ol><li>Nginx upstream retry 过大，导致服务雪崩。</li></ol><ol start="2"><li><p>业务不幂等，导致的重试，数据重复。<br>•全局唯一 ID: 根据业务生成一个全局唯一 ID，在调用接口时会传入该 ID，接口提供方会从相应的存储系统比如 redis 中去检索这个全局 ID 是否存在，如果存在则说明该操作已经执行过了，将拒绝本次服务请求；否则将相应该服务请求并将全局 ID 存入存储系统中,之后包含相同业务 ID 参数的请求将被拒绝。<br>•去重表: 这种方法适用于在业务中有唯一标识的插入场景。比如在支付场景中，一个订单只会支付一次，可以建立一张去重表,将订单 ID 作为唯一索引。把支付并且写入支付单据到去重表放入一个事务中了，这样当出现重复支付时，数据库就会抛出唯一约束异常,操作就会回滚。这样保证了订单只会被支付一次。<br>•多版本并发控制: 适合对更新请求作幂等性控制,比如要更新商品的名字，这是就可以在更新的接口中增加一个版本号来做幂等性控制。</p></li><li><p>多层级重试传递，放大流量引起雪崩。</p></li></ol><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="数据中心内部的负载均衡"><a href="#数据中心内部的负载均衡" class="headerlink" title="数据中心内部的负载均衡"></a>数据中心内部的负载均衡</h2><p>&emsp;&emsp;在理想情况下，某个服务的负载会完全均匀地分发给所有的后端任务。在任何时刻，最忙和最不忙的节点永远消耗同样数量的CPU。<br>目标：<br>•均衡的流量分发。<br>•可靠的识别异常节点。<br>•scale-out，增加同质节点扩容。<br>•减少错误，提高可用性。<br><img lazyload src="/images/loading.svg" data-src="SLB.png" alt="avatar"></p><p>   在 backend 之间的 load 差异比较大：</p><ul><li>每个请求的处理成本不同。</li><li>物理机环境的差异:<ul><li>服务器很难强同质性。</li><li>存在共享资源争用（内存缓存、带宽、IO等）。</li></ul></li><li>性能因素:<ul><li>FullGC。</li><li>JVM JIT。<br><img lazyload src="/images/loading.svg" data-src="load.png" alt="avatar"></li></ul></li></ul><p>参考JSQ（最闲轮训）负载均衡算法带来的问题，缺乏的是服务端全局视图，因此我们目标需要综合考虑：负载+可用性。<br><img lazyload src="/images/loading.svg" data-src="LB.png" alt="avatar"></p><p><img lazyload src="/images/loading.svg" data-src="S.png" alt="avatar"></p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ul><li>变更管理:<ul><li>70％的问题是由变更引起的，恢复可用代码并不总是坏事。</li></ul></li><li>避免过载:<ul><li>过载保护、流量调度等。</li></ul></li><li>依赖管理:<ul><li>任何依赖都可能故障，做 chaos monkey testing，注入故障测试。</li></ul></li><li>优雅降级:<ul><li>有损服务，避免核心链路依赖故障。</li></ul></li><li>重试退避:<ul><li>退让算法，冻结时间，API retry detail 控制策略。</li></ul></li><li>超时控制:<ul><li>进程内 + 服务间 超时控制。</li></ul></li><li>极限压测 + 故障演练。</li><li>扩容 + 重启 + 消除有害流量。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;隔离&quot;&gt;&lt;a href=&quot;#隔离&quot; class=&quot;headerlink&quot; title=&quot;隔离&quot;&gt;&lt;/a&gt;隔离&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，</summary>
      
    
    
    
    <category term="微服务" scheme="http://jiahaohong1997.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="开发" scheme="http://jiahaohong1997.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://jiahaohong1997.github.io/2021/12/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://jiahaohong1997.github.io/2021/12/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-12-28T08:39:47.908Z</published>
    <updated>2021-12-28T08:39:47.908Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://jiahaohong1997.github.io/2021/12/28/pathsumii2.jpg/"/>
    <id>http://jiahaohong1997.github.io/2021/12/28/pathsumii2.jpg/</id>
    <published>2021-12-28T08:39:31.007Z</published>
    <updated>2021-12-28T08:39:31.007Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>gin开发中踩过的坑</title>
    <link href="http://jiahaohong1997.github.io/2021/12/13/gin%E5%BC%80%E5%8F%91%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    <id>http://jiahaohong1997.github.io/2021/12/13/gin%E5%BC%80%E5%8F%91%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</id>
    <published>2021-12-13T04:46:00.000Z</published>
    <updated>2021-12-12T16:48:21.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gin框架操作Cookie"><a href="#gin框架操作Cookie" class="headerlink" title="gin框架操作Cookie"></a>gin框架操作Cookie</h1><p>坑：c.SetCookie 中的的 domain 定义成什么就要用什么访问 cookie 才会生效，例如，定义的 127.0.0.1，浏览器访问时也必须输入 127.0.0.1 才行，localhost 都不行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line">    router.GET(<span class="string">&quot;/cookie&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        cookie, err := c.Cookie(<span class="string">&quot;gin_cookie&quot;</span>) <span class="comment">// 获取Cookie</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            cookie = <span class="string">&quot;NotSet&quot;</span></span><br><span class="line">            <span class="comment">// 给客户端设置Cookie,maxAge：3600秒后过期，</span></span><br><span class="line">            <span class="comment">// path：cookie/为Cookie所在目录，</span></span><br><span class="line">            <span class="comment">// domain stinrg：域名</span></span><br><span class="line">            <span class="comment">// secure：是否只能通过https访问</span></span><br><span class="line">            <span class="comment">// httpOnly bool：是否允许别人通过js获取自己的cookie</span></span><br><span class="line">            c.SetCookie(<span class="string">&quot;gin_cookie&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="number">3600</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Cookie value: %s \n&quot;</span>, cookie)</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;gin框架操作Cookie&quot;&gt;&lt;a href=&quot;#gin框架操作Cookie&quot; class=&quot;headerlink&quot; title=&quot;gin框架操作Cookie&quot;&gt;&lt;/a&gt;gin框架操作Cookie&lt;/h1&gt;&lt;p&gt;坑：c.SetCookie 中的的 domain 定</summary>
      
    
    
    
    <category term="web开发" scheme="http://jiahaohong1997.github.io/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="踩坑" scheme="http://jiahaohong1997.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>使用Gin如何优雅的停止监听</title>
    <link href="http://jiahaohong1997.github.io/2021/12/08/%E4%BD%BF%E7%94%A8Gin%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%81%9C%E6%AD%A2%E7%9B%91%E5%90%AC/"/>
    <id>http://jiahaohong1997.github.io/2021/12/08/%E4%BD%BF%E7%94%A8Gin%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%81%9C%E6%AD%A2%E7%9B%91%E5%90%AC/</id>
    <published>2021-12-08T11:34:00.000Z</published>
    <updated>2021-12-08T11:39:05.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="暴力停止"><a href="#暴力停止" class="headerlink" title="暴力停止"></a>暴力停止</h1><p>&emsp;&emsp;我们在 go run main.go 后，若需要停止监听，需要使用 <code>ctrl+c</code> 终止监听。该方案会立即终止服务器监听，同时结束正在处理的请求，也就是说若存在未处理完毕的请求，是不能继续处理的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run() <span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优雅停止"><a href="#优雅停止" class="headerlink" title="优雅停止"></a>优雅停止</h1><p>&emsp;&emsp;代替示例代码中 <code>router.Run()</code> 方法，我们可以使用 <code>http.Server</code> 内置的 <a class="link" href="https://golang.org/pkg/net/http/#Server.Shutdown">Shutdown()<i class="fas fa-external-link-alt"></i></a> 方法优雅地停止。所谓优雅，指的是可以将正在处理的请求处理完毕后再关闭服务器。示例代码如下 main.go ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 常规的初始化路由</span></span><br><span class="line">    router := gin.Default()</span><br><span class="line">    router.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">        c.String(http.StatusOK, <span class="string">&quot;Welcome Gin Server&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 定义服务器</span></span><br><span class="line">    srv := &amp;http.Server&#123;</span><br><span class="line">        Addr:    <span class="string">&quot;:8080&quot;</span>,</span><br><span class="line">        Handler: router,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用 goroutine 启动监听</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// srv.ListenAndServe() 监听</span></span><br><span class="line">        <span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;</span><br><span class="line">            log.Fatalf(<span class="string">&quot;listen: %s\n&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待中断信号以优雅地关闭服务器（设置 5 秒的超时时间）</span></span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(quit, os.Interrupt)</span><br><span class="line">    <span class="comment">// quit 信道是同步信道，若没有信号进来，处于阻塞状态</span></span><br><span class="line">    <span class="comment">// 反之，则执行后续代码</span></span><br><span class="line">    &lt;-quit</span><br><span class="line">    log.Println(<span class="string">&quot;Shutdown Server ...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    <span class="comment">// 调用 srv.Shutdown() 完成优雅停止</span></span><br><span class="line">    <span class="comment">// 调用时传递了一个上下文对象，对象中定义了超时时间</span></span><br><span class="line">    <span class="keyword">if</span> err := srv.Shutdown(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;Server Shutdown:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;Server exiting&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试以上代码，结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running <span class="keyword">in</span> <span class="string">&quot;debug&quot;</span> mode. Switch to <span class="string">&quot;release&quot;</span> mode <span class="keyword">in</span> production.</span><br><span class="line"> - using env:   <span class="built_in">export</span> GIN_MODE=release</span><br><span class="line"> - using code:  gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /                         --&gt; main.main.func1 (3 handlers)</span><br><span class="line">2019/11/05 22:49:04 Shutdown Server ...</span><br><span class="line">[GIN] 2019/11/05 - 22:49:07 | 200 |    5.0000438s |             ::1 | GET      /</span><br><span class="line">2019/11/05 22:49:08 Server exiting</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;暴力停止&quot;&gt;&lt;a href=&quot;#暴力停止&quot; class=&quot;headerlink&quot; title=&quot;暴力停止&quot;&gt;&lt;/a&gt;暴力停止&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;我们在 go run main.go 后，若需要停止监听，需要使用 &lt;code&gt;ctrl+c&lt;/co</summary>
      
    
    
    
    <category term="Go框架" scheme="http://jiahaohong1997.github.io/categories/Go%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="web框架" scheme="http://jiahaohong1997.github.io/tags/web%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Go语言的错误处理</title>
    <link href="http://jiahaohong1997.github.io/2021/12/05/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>http://jiahaohong1997.github.io/2021/12/05/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</id>
    <published>2021-12-04T17:56:00.000Z</published>
    <updated>2022-01-05T03:08:35.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Error-vs-Exception"><a href="#Error-vs-Exception" class="headerlink" title="Error vs Exception"></a>Error vs Exception</h1><p>先看下面一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a named type for our new error type</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement the error interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New creates interface values of type error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> errorString(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrNamedType = New(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> ErrStructType = errors.New(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ErrNamedType == New(<span class="string">&quot;EOF&quot;</span>) &#123;  <span class="comment">// true</span></span><br><span class="line">fmt. Println(<span class="string">&quot;Named Type Error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ErrStructType == errors.New(<span class="string">&quot;EOF&quot;</span>) &#123; <span class="comment">// false</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Struct Type Error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>ErrNamedType</code> 是我们自己定义的<code>Error</code> 方法，它是一个<code>string</code> 类型的变量(错误描述)，只要错误描述相同，那么两个<code>Error</code>是一样的。<code>ErrStructType</code>是通过<code>go</code>标准库定义的<code>Error</code> 类型，它是指向<code>string</code> 类型的错误描述的指针，即使错误描述一样，也会因为指向其地址的指针不同而不同。</p><h2 id="各语言的演进历史"><a href="#各语言的演进历史" class="headerlink" title="各语言的演进历史"></a>各语言的演进历史</h2><ul><li>C</li></ul><p>&emsp;&emsp;单返回值，一般通过传递指针作为入参，返回值为 int 表示成功还是失败。</p><ul><li>C++</li></ul><p>&emsp;&emsp;引入了exception，但是无法知道被调用方会城出什么异常。</p><ul><li>Java</li></ul><p>&emsp;&emsp;引入了checked exception，方法的所有者必须申明，调用者必须处理。在启动时拋出大量的异常是司空见惯的事情，并在它们的调用堆栈中尽职地记录下来。Java 异常不再是异常，而是变得司空见惯了。它们从良性到灾难性都有使用，异常的严重性由两数的调用者来区分。</p><ul><li>Go</li></ul><p>&emsp;&emsp;Go 的处理异常逻辑是不引入 exception，支持多参数返回，所以很容易的在函数签名中带上实现了 error interface 的对象，交由调用者来判定。如果一个西数返回了(value,error)，你不<strong>能对这个 value 做任何假设，必须先判定 error</strong>。唯一可以忽路error 的是，如果你连 value 也不关心。Go 中有 panic 的机制，如果你认为和其他语言的 exception 一样，那你就错了。当我们拋出异常的时候，相当于你把 exception 扔给了调用者来处理。比如，你在C++ 中，把string 转为 int， 如果转换失败，拋出异常。或者在 java 中转换 string 为 date 失败时，拋出异常。Go panic 意味着 fatal error（就是挂了）。不能假设调用者来解决 panic，意味着代码不能继续运行。</p><p>&emsp;&emsp;使用多个返回值和一个简单的约定，Go解决了让程序员知道什么时候出了问题，并为真正的异常情况保留了 panic。可以更好的分别什么时候是良性异常，什么时候是真正的错误。通过 panic + recover 还可以为代码兜底，放弃掉这个<code>request</code> 进而保证别的<code>request</code> 的正常处理。</p><p>&emsp;&emsp;对于真正意外的情况，那些表示不可恢复的程序错误，例如索引l越界、不可恢复的环境问题、栈溢出，我们才使用 panic。对于其他的错误情况，我们应该是期望使用 error 来进行判定。下面是Go使用这种机制的理由：</p><ol><li>简单</li><li>考虑失败，而不是成功(plan for failure, not success)</li><li>没有隐藏的控制流</li><li>完全交给你来控制 Error</li><li>Error are values</li></ol><h1 id="Sentinel-Error"><a href="#Sentinel-Error" class="headerlink" title="Sentinel Error"></a>Sentinel Error</h1><p>&emsp;&emsp;预定义的特定错误，我们叫做 <code>sentinel error</code>，这个名字来源于计算机编程中使用一个特定的值来表示不可能进行进一步处理的做法。所以对于Go，我们使用特定的值来表示错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err == ErrSomething &#123;...&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Error)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="keyword">string</span>(e) &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用 <code>sentinel</code>值是最不灵活的错误处理策略，因为调用方法必须使用 == 将结果与预先声明的值进行比较。当你想要提供更多的上下文，这就出现了一个问题，因为返回一个不通的错误将破坏相等性检查。</p><p>&emsp;&emsp;甚至是一些有意义的 <code>fmt.Errof</code>携带一些上下文，也会破坏调用者的 ==，将调用者被迫查看error.Error()方法的输出，一查看它是否与特定的字符串匹配。</p><ul><li>不依赖 error.Error() 的输出</li></ul><p>&emsp;&emsp;不应该依赖检测 error.Error() 的输出，Error 方法存在于 error 接口主要用于方便程序员使用而不是程序（编写测试可能会依赖这个返回）。这个输出的字符串用于记录日志、输出到 stdout。</p><ul><li>Sentinel errors 成为你 API 公共部分</li></ul><p>&emsp;&emsp;如果你的公共函数或方法返回一个特定的错误，那么该值必须是公共的，当然要有文档记录，这会增加API的表面积。</p><p>&emsp;&emsp;如果 API 定义了一个返回特定错误的 interface，则该接口的所有实现豆浆杯限制为仅返回该错误，即使它们可以提供更具描述性的错误。</p><p>&emsp;&emsp;比如 io.Reader。像 io.Copy 这类函数需要 reader 的实现者返回 io.EOF 来告诉调用者没有更多的数据了，但这又不是错误。</p><ul><li>Sentinel errors 在两个包之间创建了依赖</li></ul><p>&emsp;&emsp;sentinel errors最糟糕的问题是它在两个包之间床架了源代码依赖关系。例如，检查错误是否等于 io.EOF，你的代码必须导入 io 包。这个特定的例子听起来并不是十分糟糕，因为它非常常见，但是想想一下，当项目中的许多包到处错误值时，存在耦合，项目中的其他包必须注入这些错误值才能检查特定的错误条件。</p><ul><li>结论：尽可能避免 Sentinel errors</li></ul><p>&emsp;&emsp;避免在编写代码时使用 Sentinel errors。在标准库中有一些使用它们的情况，但这不是好的模仿对象。 </p><h1 id="Error-Types"><a href="#Error-Types" class="headerlink" title="Error Types"></a>Error Types</h1><p>Error type 是实现了 error 接口的自定义类型。例如 MyError 类型记录了文件和行号以展示发生了什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Msg<span class="keyword">string</span></span><br><span class="line">    File<span class="keyword">string</span></span><br><span class="line">    Line<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s:%d: %s&quot;</span>, e.File, e.Line, e.Msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;<span class="string">&quot;Something happened&quot;</span>, <span class="string">&quot;server.go&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := test()</span><br><span class="line">    <span class="keyword">switch</span> err := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="comment">// call succeeded, nothing to do</span></span><br><span class="line">        <span class="keyword">case</span> *MyError:</span><br><span class="line">        fmt.Println(<span class="string">&quot;error occurred on line&quot;</span>, err.Line)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// unknown error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;与错误值相比，错误类型的一大改进是它们能够包装底层错误以提供更多上下文。一个不错的例子就是 os.PathError 它提供了底层执行了什么操作、那个路径出了什么问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op<span class="keyword">string</span></span><br><span class="line">    Path<span class="keyword">string</span></span><br><span class="line">    Errerror</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;调用者要使用类型断言和类型 switch，就要让自定义的 error 变为 public。这种模型会导致和调用者产生强耦合，从而导致 API 变得脆弱。</p><p>&emsp;&emsp;结论是尽量避免使用 error types，虽然错误类型比 sentinel errors 更好，因为它们可以捕获关于错误的更多上下文，但是 error types 共享 error values 许多相同的问题。因此，建议避免错误类型，或者至少避免它们成为公共 API 的一部分。</p><h1 id="Opaque-errors"><a href="#Opaque-errors" class="headerlink" title="Opaque errors"></a>Opaque errors</h1><p>&emsp;&emsp;这是一种最灵活的错误处理策略，因为它要求代码和调用者之间的耦合最少。我们将这种风格成为不透明的错误处理，因为虽然知道发生了错误，但没有能力看到错误的内部。作为调用者，关于操作的结果，你所知道的就是它起作用了，或者没有起作用（成功还是失败）。</p><p>&emsp;&emsp;这就是不透明错误处理的全部功能-只需返回错误而不假设其内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/quux/bar&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">x, err := bar. Foo</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> f</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Assert errors for behaviour, not type</li></ul><p>&emsp;&emsp;在少数情況下，这种二分错误处理方法是不够的。例如，与进程外的世界进行交互（如网络活动），需要调用方调查错误的性质，以确定重试该操作是否合理。在这种情況下，我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值。考虑这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> temporary <span class="keyword">interface</span> &#123;</span><br><span class="line">    Temporary()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsTemporary returns true if err is temporary</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsTemporary</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    te, ok := err.(temporary)</span><br><span class="line">    <span class="keyword">return</span> ok &amp;&amp; te.Temporary()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的关键是，这个逻辑可以在不导入定义错误的包或者实际上不了解 err 的底层类型的情况下实现——只对它的行为感兴趣。</p><h1 id="Handling-Error"><a href="#Handling-Error" class="headerlink" title="Handling Error"></a>Handling Error</h1><p>&emsp;&emsp;无错误的正常流程代码，将成为一条直线，而不是缩紧的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do stuff</span></span><br><span class="line"></span><br><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// handle error</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们看一下net/http 标准包里对 WriteResponse 的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">Key, Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">Code<span class="keyword">int</span></span><br><span class="line">Reason<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, st Status, headers []Header, body o.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">-, err := fmt.Fprintf(w,<span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, st.Code, st.Reason)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">        _, err := fmt.Fprintf(w, <span class="string">&quot;%s: %s\r\n&quot;</span>, h.Key, h.Value)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> _, err := fmt.Fprint(w <span class="string">&quot;\r\n&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _, err = io.Copy(w, body)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式写了大量的 <code>if err != nil</code>，如果采用下面这种方式，可以避免出现大量的重复代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">io.Writer</span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errWriter)</span> <span class="title">Write</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, e.err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">    n, e.err = e.Writer.Write(buf)</span><br><span class="line">    <span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(wio.Writer, st Status, headers []Header, body io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ew := &amp;errWriter&#123;Writer: w&#125;</span><br><span class="line">    fmt.Fprintf(ew, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, st.Code, st.Reason)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">        fmt.Fprintf(ew, <span class="string">&quot;%s: %s\r\n&quot;</span>, h.Key, h.Value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Fprint(ew, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">    io.Copy(ew, body)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ew.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实际上在封装的 errWriter 中处理掉了</p><h1 id="Wrap-erros"><a href="#Wrap-erros" class="headerlink" title="Wrap erros"></a>Wrap erros</h1><p>&emsp;&emsp;没有生成错误的 file:line 信息。没有导致错误的调用堆栈的堆栈跟踪。这段代码的作者将被迫进行长时间的代码分割，以发现是哪个代码路径触发了文件未找到错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span> <span class="params">(r *Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := authenticate(r.User)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;authenticate failed: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是正如我们前面看到的，这种模式与 sentinel errors 或 type assertions 的使用不兼容，因为将错误值转换为字符串，将其与另一个字符串合并，然后将其转换回 fmt.Errorf 破坏了原始的错误，导致等值判定失败。</p><p>&emsp;&emsp;You should only handle errors once. Handling an error means inspecting the error value and making a single decision.</p><p>我们经常发现类似的代码，在错误处理中，带了两个任务：记录日志井且再次返回错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w i0.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    -, err : = w.Write(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;unable to write:&quot;</span>, err)<span class="comment">// annotated error goes to log file</span></span><br><span class="line">        <span class="keyword">return</span> err<span class="comment">// unannotated error returned to caller</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在下面这个例子中，如果在 w.Write 过程中发生了一个错误，那么一行代码将被写入日志文件中，记录错误发生的文件和行，并且错误也会返回给调用者，调用者可能会记录并返回它，一直返回到程序的顶部。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">buf, err := json.Marshal(conf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log. Printf(<span class="string">&quot;could not marshal config: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;could not write config: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Go 中的错误处理契约规定，在出现错误的情况下，不能对其他返回值的内容做出任何假设。由于 JSON 序列化失败，buf 的内容是未知的，可能它不包含任何内容，但更糟糕的是，他可能包含一个半写的 JSON 片段。</p><p>&emsp;&emsp;由于程序员在检查并记录错误后忘记 return，损坏的缓冲区将被传递给 WriteAll，这可能会成功，因此配置文件将被错误地写入。但是，该函数返回的结果是正确的。</p><p>&emsp;&emsp;日志记录与错误无关且对调试没有帮助的信息应被视为噪音，应予以质疑。记录的原因是因为某些东西失败了，而日志包含了答案。</p><ul><li>错误要被日志记录。</li><li>应用程序处理错误，保证100%完整性。</li><li>之后不再报告当前错误。</li></ul><h2 id="使用-github-com-pkg-errors-库"><a href="#使用-github-com-pkg-errors-库" class="headerlink" title="使用 github.com/pkg/errors 库"></a>使用 github.com/pkg/errors 库</h2><p><img lazyload src="/images/loading.svg" data-src="%E5%9B%BE%E7%AE%97%E6%B3%95/1.jpg" alt="avatar"></p><p><img lazyload src="/images/loading.svg" data-src="%E5%9B%BE%E7%AE%97%E6%B3%95/2.jpg" alt="avatar"></p><p>&emsp;&emsp;通过使用 pkg/errors 包，可以想错误值添加上下文，这种方式既可以由人也可以由机器检查。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := w.Write(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// annotated error goes to log file</span></span><br><span class="line">        log.Println(<span class="string">&quot;unable to write:&quot;</span>, err)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// unannotated error returned to caller</span></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方式既打印了日志，还抛出了错误，违背了只处理一次的行为，使用下面的代码可以完美解决。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := w.Write(buf)</span><br><span class="line">    <span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;write failed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在你的业务代码中，使用 errors.New 或者 errors.Errorf 返回错误，它们同errors.Wrap 一样，都会返回错误的堆栈信息。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseArgs</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.Errorf(<span class="string">&quot;not enough arguments, expected at least 3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果调用其他包内的函数，通常简单的直接返回</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果和其他库进行协作，考虑使用 errors.Wrap 或者 errors.Wrapf 保存堆栈信息。同样适用于和标准库协作的时候。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;failed to open %q&quot;</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接返回错误，而不是每个错误产生的地方到处打印日志</li><li>在程序的顶部或者是工作的 goroutine 顶部（请求入口），使用 %+v 把堆栈详情记录</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := app.Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;FATAL: %+v\n&quot;</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 errors.Cause 获取root error， 在进行和 sentinel error 判定。还可以对其进行断言。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> err := errors.Cause(err).(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *MyError:</span><br><span class="line">        <span class="comment">// handle specifically</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// unknown error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>Packages that are reusable across many projects only return root error values.</li></ul><p>选择 wrap error 是只有 applications 可以选择应用的策略。具有最高可重用性的包只能返回根错误值。此机制与 Go 标准库中使用的相同。</p><ul><li>If the error is not going to be handled, wrap and return up the call stack.</li></ul><p>这是关于函数/方法调用返回的每个错误的基本问题。如果函数/方法不打算处理错误，那么用足够的上下文 wrap errors 并将其返回到调用堆栈中。例如，额外的上下文可以是使用的输入参数或失败的查询语句。确定您记录的上下文是足够多还是大多的一个好方法是检查日志并验证它们在开发期间是否为您工作。</p><ul><li>Once an error is handled, it is not allowed to be passed up the call stack any longer.</li></ul><p>一旦确定函数/方法将处理错误，错误就不再是错误。如果函数/方法仍然需要发出返回，则它不能返<br>错误值。它应该只返回零（比如降级处理中，你返回了降级数据，然后需要 return nil）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Error-vs-Exception&quot;&gt;&lt;a href=&quot;#Error-vs-Exception&quot; class=&quot;headerlink&quot; title=&quot;Error vs Exception&quot;&gt;&lt;/a&gt;Error vs Exception&lt;/h1&gt;&lt;p&gt;先看下面一段</summary>
      
    
    
    
    <category term="Error机制" scheme="http://jiahaohong1997.github.io/categories/Error%E6%9C%BA%E5%88%B6/"/>
    
    
    <category term="Error" scheme="http://jiahaohong1997.github.io/tags/Error/"/>
    
  </entry>
  
  <entry>
    <title>微服务概览与设计</title>
    <link href="http://jiahaohong1997.github.io/2021/11/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <id>http://jiahaohong1997.github.io/2021/11/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-11-28T07:45:00.000Z</published>
    <updated>2022-01-05T03:08:36.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微服务概念"><a href="#微服务概念" class="headerlink" title="微服务概念"></a>微服务概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现<strong>服务组件化</strong>，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活：</p><ul><li>原子服务：关注单一业务场景</li><li>独立进程：能够独立部署和交付</li><li>隔离部署：减小某一物理机crash对全局的影响</li><li>去中心化服务治理：服务之间的通讯rpc直连，减少集中的负载均衡</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>基础设施的建设、复杂度高</li><li>微服务应用是分布式系统，由此会带来固有的复杂性。开发者不得不使用RPC或者消息传递，来实现进程间的通信；此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题</li><li>分区的数据库架构，同时更新多个业务主体的事务很普遍。这种事务对于单体应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务锁使用的不同数据库，从而对开发者提出了更高的要求和挑战</li><li>测试一个基于微服务架构的应用是很复杂的任务</li><li>服务模块间的依赖，应用的升级有可能会涉及多个服务模块的修改</li><li>对运维的基础设施的挑战比较大</li></ul><h2 id="组件服务化"><a href="#组件服务化" class="headerlink" title="组件服务化"></a>组件服务化</h2><p>&emsp;&emsp;传统实现组件的方式是通过库(library)，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。我们用 Go 实施一个微服务：</p><ul><li>kit：一个微服务的基础库（框架）</li><li>service：业务代码＋ hit 依赖＋ 第三方依赖组成的业务微服务</li><li>RPC + message queue: 轻量级通讯</li></ul><p>&emsp;&emsp;<strong>本质上等同于，多个微服务组合(compose)完成了一个完整的用户场景(usecase)。</strong></p><h2 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h2><p>&emsp;&emsp;每个服务面临的业务场景不同，可以针对性的选择合适的技术解决方案。但也需要避免过度多样化，结合团队实际情况来选择取舍，要是每个服务都用不同的语言的技术栈来实现，想想维护成本真够高的。</p><ul><li>数据去中心化：每个服务独享自身的数据存储设施(缓存，数据库等)</li><li>治理去中心化：避免集中式做流量分发和负载均衡</li><li>技术去中心化：不绑定某一特定语言</li></ul><p>&emsp;&emsp;<strong>每个服务独享自身的数据存储设施(缓存，数据库等)，不像传统应用共享一个缓存和数据库，这样有利于服务的独立性，隔旁相关干扰。</strong></p><h2 id="基础设施自动化"><a href="#基础设施自动化" class="headerlink" title="基础设施自动化"></a>基础设施自动化</h2><p>&emsp;&emsp;无自动化不微服务，自动化包括测试和部署。单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、监控和部署的复杂度都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。</p><ul><li>CICD: Gitlab + Gitlab Hooks + kubernetes</li><li>Testing：测试环境、单元测试、API 自动化测试</li><li>在线运行时: kubernetes, 以及一系列Prometheus, ELK, Conrtol Panle</li></ul><h2 id="可用性-amp-兼容性设计"><a href="#可用性-amp-兼容性设计" class="headerlink" title="可用性 &amp; 兼容性设计"></a>可用性 &amp; 兼容性设计</h2><p>&emsp;&emsp;微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的新问题，如网络延迟、消息格式、负载均衡和容错，忽略其中任何一点都属于对“分布式计算的误解”。</p><ul><li>隔离</li><li>超时控制</li><li>负载保护</li><li>限流</li><li>降级</li><li>重试</li><li>负载均衡</li></ul><p>&emsp;&emsp;一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻蓮记保持服务契约（接口）的兼容性。发送时要保守，接收时要开放。按照伯斯塔次法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。</p><h1 id="微服务设计"><a href="#微服务设计" class="headerlink" title="微服务设计"></a>微服务设计</h1><h2 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h2><ol><li>按照垂直功能进行拆分，对外暴露了一批微服务，但是因为缺乏统一的出口面临不少问题：</li></ol><p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/1.png" alt="avatar"></p><ul><li>客户端到微服务直接通信，强耦合：不利于服务的更新迭代，要始终保留过往版本的接口</li><li>需要多次请求，客户端聚合数据，工作量巨大，延迟高</li><li>协议不利于统一，各个部门间有差异，需要端来兼容</li><li>面向“端”（不同终端）的API适配，耦合到了内部服务</li><li>多终端兼容逻辑复杂，每个服务都需要处理</li><li>统一逻辑无法收敛，比如安全认证、限流</li></ul><ol start="2"><li>新增一个app-interface 用于统一的协议出口，在服务哪进行大量的 dataset join（各种微服务数据的聚合），按照业务的场景来设计粗粒度的 API，给后续业务演进带来很多优势：</li></ol><p><img lazyload src="/images/loading.svg" data-src="2.png" alt="avatar"></p><ul><li>轻量交互：协议精简、聚合</li><li>差异服务：数据裁剪以及聚合、针对终端定制化API</li><li>动态升级：原有系统兼容升级，更新服务而非协议</li><li>沟通效率提升，协作模式演进为移动业务+网关小组</li></ul><p>BFF 可以认为是一种适配服务，将后端的微服务进行适配（主要包括聚合裁剪和格式适配等逻辑），向无线端设备暴露友好和统一的API，方便无线设备接入访问后端服务。</p><p>最致命的一个问题是整个 app-interface 属于单点故障，严重代码缺陷或流量洪峰可能引发集群宕机。</p><p><img lazyload src="/images/loading.svg" data-src="3.png" alt="avatar"></p><ul><li>但各模块也会导致后续业务集成复杂度高，根据康威法则，单块的无线BFF和多团队之间就出现不匹配问题，团队之间沟通协调成本高，交付效率低下</li><li>很多跨横切面逻辑，比如安全认证，日志监控，限流熔断。随着时间推移，代码变得越来越复杂，技术栈越来越多</li></ul><ol start="3"><li>跨横切面(Cross-Cutting Concerns)的功能, 需要协调更新框架升级发版(路由、认证、限流、安<br>全），因此全部上沉，引入了 API Gateway，把业务集成度高的 BFF 层和通用功能服务层 API<br>Gateway 进行了分层处理。</li></ol><p><img lazyload src="/images/loading.svg" data-src="4.png" alt="avatar"></p><p>在新的架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器。在网关的配合下，单块 BFF<br>实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提开。另外，把跨横切面逻<br>辑从 BFF 剥离到网关上去以后，BFF 的开发人员可以更加专法业务逻辑交付，实现了架构上的关注分离<br>(Separation of Concerns).</p><p>业务流量实所为：<br>移动端 -&gt; API Gateway -&gt; BFF -&gt; Mircoservice, 在 FE Web业务中，BFF 可以是nodejs 来做服务端渲染<br>(SSR, Server-Side Rendering), 注意这里忽略了上游的 CDN、4/7层负载均衡(ELB)。</p><h2 id="Mircoservice划分"><a href="#Mircoservice划分" class="headerlink" title="Mircoservice划分"></a>Mircoservice划分</h2><p>&emsp;&emsp;微服务架构时遇到的第一个问题就是如何划分服务的边界。在实际项目中通常会采用两种不同的方式划分服务便捷，即通过业务职能（Business Capbility）或是DDD的限界上下文（Bounded Context）。</p><ul><li>Business Capbility</li></ul><p>&emsp;&emsp;由公司内部不同的部门提供的职能。例如客户服务部门提供客户服务职能，财务部门提供财务相关的职能。</p><ul><li>Bounded Context</li></ul><p>&emsp;&emsp;限界上下文DDD中用来划分不同业务边界的元素，这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案域，为了解决某种类型的业务问题，贴近领域知识，也就是业务。</p><p>这本质上也促进了组织结构的演进：Service per team</p><p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/5.png" alt="avatar"></p><ul><li><p>CQRS</p><p>将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新。(其实就是读写分离)</p></li></ul><p>在稿件服务演进过程中，围绕着创作稿件、审核稿件、最终发布稿件有大量的逻辑揉在一块，其中稿件本身的状态也有非常多种，但是最终前台用户只关注稿件能否查看，依赖稿件数据库 binlog 以及订阅binlog 的中间 canal， 将稿件结果发布到消息队列katka 中，最终消费数据独立组建一个稿件查阅结果数据库，并对外提供一个独立查询服务，来板分复杂架构和业务。<br><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/6.jpg" alt="avatar"></p><p>将稿件审核并写入数据库(archive-result-database)的服务(稿件job)和外部用户查看稿件审核结果的服务(稿件结果)分离开来。</p><h2 id="Mircoservice安全"><a href="#Mircoservice安全" class="headerlink" title="Mircoservice安全"></a>Mircoservice安全</h2><p>&emsp;&emsp;对于外网的请求来说，我们通常在 API Gateway进行统一的认证拦截，一旦认证成功，我们会使用 Header 方式通过 RPC 元数据传递的方式带到 BFF 层，BFF 获取后把身份信息注入到应用的 Context 中，BFF 到其他下层的微服务，建议是直接在 RPC Request 中带入用户身份信息(UserID)请求服务。</p><ul><li><p>API Gateway -&gt; BFF -&gt; Service</p></li><li><p>Biz Auth -&gt; UID -&gt; Request Args</p></li></ul><p>对于服务内部，一般要区分身份认证和授权。</p><ul><li>Full Trust</li><li>Half Trust</li><li>Zero Trust </li></ul><h1 id="gRPC和服务发现"><a href="#gRPC和服务发现" class="headerlink" title="gRPC和服务发现"></a>gRPC和服务发现</h1><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/7.jpg" alt="avatar"></p><ul><li><p>多语言：语言中立，支持多种语言。</p></li><li><p>轻量级、高性能序列化支持 PB（Protocol Buffer）和 JSON，PB 是一种语言无关的高性能系列化框架</p></li><li><p>可插拔。</p></li><li><p>IDL：基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端口以及客户端 Stub。</p></li><li><p>移动端：基于标准的 HTTP/2 设计，支持双向流、消息头压缩、单TCP的多路复用、服务端推送等特性。这些特性是的 gRPC 在移动端设备上更加省电和节省网络流量。</p></li><li><p>服务而非对象、消息而非引用：促进微服务的系统间粗粒度消息交互设计理念。</p></li><li><p>负载无关的：不同的服务需要使用不同的消息类型和编码, 例如 protocol buffers, JSON, XML 和 Thrift。</p></li><li><p>流: Streaming APl。</p></li><li><p>阻塞式和非阻塞式：支持异步和同步处理在客户端和服务端间交互的消息序列。</p></li><li><p>元数据交换：常见的横切关注点，如认证或跟踪，依赖数据交换。</p></li><li><p>标准化状态码：客户端通常以有限的方式响应 API 调用返回的错误。</p></li></ul><h2 id="gRPC-HealthCheck"><a href="#gRPC-HealthCheck" class="headerlink" title="gRPC - HealthCheck"></a>gRPC - HealthCheck</h2><p>gRPC 有一个标准的健康检测协议，在 gRPC 的所有语言实现中基本都提供了生成代码和用于设置运行状态的功能。</p><p>主动健康检查 health check，，可以在服务提供者服务不稳定时，被消费者所感知，份时从负载均衡中摘除，减少错误请求。当服务提供者重新稳定后，health check 成功，重新加入到消费者的负载均衡，恢复请求。health check  同样也被用于外挂方式的容器健康检测，或者流量检测(K8sliveness &amp; readiness)。</p><p><img lazyload src="/images/loading.svg" data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/8.jpg" alt="avatar"></p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><h3 id="客户端发现"><a href="#客户端发现" class="headerlink" title="客户端发现"></a>客户端发现</h3><p>&emsp;&emsp;一个服务实例被启动时，它的网络地址会被写到注册表上；当服务实例终止时，再从注册表中删除；这个服务实例的注册表通过心跳机制动态刷新；客户端使用一个负载均衡算法，去选择一个可用的服务实例，来响应这个请求。</p><h3 id="服务端发现"><a href="#服务端发现" class="headerlink" title="服务端发现"></a>服务端发现</h3><p>&emsp;&emsp;客户端通过负载均衡器向一个服务发送请求，这个负载均衡器会查询服务注册表，并将请求路由到可用的服务实例上。服务实例在服务注册表上被注册和注销(Consul Template+Nginx, kubernetesteted)。</p><p><img lazyload src="/images/loading.svg" data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/9.jpg" alt="avatar"></p><p>微服务的核心是去中心化，使用客户端发现模式。</p><p><img lazyload src="/images/loading.svg" data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/10.jpg" alt="avatar"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微服务概念&quot;&gt;&lt;a href=&quot;#微服务概念&quot; class=&quot;headerlink&quot; title=&quot;微服务概念&quot;&gt;&lt;/a&gt;微服务概念&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定</summary>
      
    
    
    
    <category term="微服务" scheme="http://jiahaohong1997.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="开发" scheme="http://jiahaohong1997.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常见问题补充</title>
    <link href="http://jiahaohong1997.github.io/2021/11/20/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85/"/>
    <id>http://jiahaohong1997.github.io/2021/11/20/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85/</id>
    <published>2021-11-19T16:21:00.000Z</published>
    <updated>2022-01-05T12:31:00.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据表的类型"><a href="#数据表的类型" class="headerlink" title="数据表的类型"></a>数据表的类型</h1><table><thead><tr><th align="center"></th><th align="center">MYISM</th><th align="center">INNODB</th></tr></thead><tbody><tr><td align="center">事务支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">数据行锁定</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">外键约束</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">全文索引</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">表空间的大小</td><td align="center">较小</td><td align="center">较大，约为MYSIM2倍</td></tr></tbody></table><ul><li>MYSIM：节约空间，速度较快</li><li>INNODB：安全性高，支持事务处理，多表多用户操作</li></ul><h1 id="DROP、TRUNCATE和DELETE的区别"><a href="#DROP、TRUNCATE和DELETE的区别" class="headerlink" title="DROP、TRUNCATE和DELETE的区别"></a>DROP、TRUNCATE和DELETE的区别</h1><ul><li><p>TRUNCATE和DELETE的相同点：都能删除数据面都不会删除表结构</p></li><li><p>区别：</p><ul><li>DROP table 【表名】<ul><li><strong>删除内容和定义</strong>，并释放空间。执行drop语句，<strong>将使此表的结构</strong>一起删除。</li></ul></li><li>TRUNCATE <ul><li><strong>删除内容、释放空间但不删除定义</strong>(也就是保留表的数据结构)。与drop不同的是,只是<strong>清空表数据</strong>而已。</li><li>重新设置，自增列计数器会归零</li><li>不会影响事务</li></ul></li><li>DELETE from 【表名】(where 【列名】= 值)<ul><li><strong>只删除内容、释放空间但不删除定义</strong>；但是delete即<strong>可以对行数据进行删除</strong>，也可以对整表数据进行删除。</li><li>自增列计数器保持原来的值</li></ul></li></ul></li><li><p>注意</p><ul><li>delete语句执行删除的过程是<strong>每次从表中删除一行</strong>，并且同时将该行的删除操作作为事务<strong>记录在日志</strong>中保存，以便进行进行回滚操作。</li><li><strong>执行速度</strong>一般来说：drop&gt;truncate&gt;delete</li><li>delete语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，<strong>事务提交之后才生效</strong>；如果有相应的 trigger，执行的时候将被触发。truncate、drop 是数据库定义语言(ddl)<strong>，操作立即生效</strong>，原数据不放到 rollback segment 中，不能回滚，操作不触发trigger。</li><li> truncate语句执行以后，<strong>id标识列还是按顺序排列</strong>，保持连续；而delete语句执行后，<strong>ID标识列不连续</strong></li></ul></li></ul><h1 id="为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？"><a href="#为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？" class="headerlink" title="为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？"></a>为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？</h1><p>分解关联查询的方式重构查询的优势有：</p><blockquote><ul><li><p><strong>让缓存的效率更高</strong>。我们知道执行一条sql的时候，会先去查询缓存中查找。那么许多应用程序可以方便地缓存单表查询对应的结果对象。如果关联查询，那么关联中的某个表发生了变化，那么就无法使用查询缓存，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。<br>将查询拆分后，执行单个查询可以减少锁的竞争。</p></li><li><p>在应用层做关联，可以更容易对数据库进行拆分，在现如今分库分表普遍使用的情景下，更容易做到高性能和可扩展。</p></li><li><p>查询本身效率也可能会有所提升。比如：让某些查询用IN()代替关联查询，可以让Mysql按照ID顺序进行查询，着可能比随机的关联要更高效。</p></li><li><p>可以减少冗余记录的查询。在应用层做关联，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能徐娅重复地访问一部分数据。从这方面看，这样的重构还可能会减少网络和内存的消耗。</p></li><li><p>分解关联查询，相当于在应用中实现了哈希关联，而不是使用Mysql的类似嵌套循环关联。某些场景哈希关联的效率更高效</p></li></ul></blockquote><p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/1.png" alt="avatar"></p><h1 id="MySQL索引原理"><a href="#MySQL索引原理" class="headerlink" title="MySQL索引原理"></a>MySQL索引原理</h1><h2 id="索引的目的"><a href="#索引的目的" class="headerlink" title="索引的目的"></a>索引的目的</h2><p>&emsp;&emsp;索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。</p><h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><p>&emsp;&emsp;除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。</p><p>&emsp;&emsp;数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？我们会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p><p>&emsp;&emsp;考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>&emsp;&emsp;前面讲了生活中索引的例子，索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。</p><p><img lazyload src="/images/loading.svg" data-src="%E5%9B%BE%E7%AE%97%E6%B3%95/2.jpg" alt="avatar"></p><p>&emsp;&emsp;如上图，是一颗b+树，关于b+树的定义可以参见<a class="link" href="http://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B+树<i class="fas fa-external-link-alt"></i></a>，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p><ul><li>b+树的查找过程</li></ul><p>&emsp;&emsp;如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p><ul><li>b+树的性质</li></ul><ol><li><p>通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即<strong>索引字段要尽量的小</strong>，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</p></li><li><p>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的<strong>最左匹配特性</strong>。</p></li></ol><h2 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h2><h3 id="建索引的几大原则"><a href="#建索引的几大原则" class="headerlink" title="建索引的几大原则"></a>建索引的几大原则</h3><ol><li><strong>最左前缀匹配原则</strong>，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li><strong>=和in可以乱序</strong>，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</li><li><strong>尽量选择区分度高的列作为索引</strong>，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</li><li><strong>索引列不能参与计算</strong>，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</li><li><strong>尽量的扩展索引，不要新建索引</strong>。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li></ol><h3 id="慢查询优化的基本步骤"><a href="#慢查询优化的基本步骤" class="headerlink" title="慢查询优化的基本步骤"></a>慢查询优化的基本步骤</h3><ol start="0"><li>先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li><li>where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看看那个字段的区分度最高</li><li>expalin查看执行计划，是否与预期一致（从锁定记录较少的表开始查）</li><li>order by limit 形式的sql语句让排序的表优先查</li><li>了解业务方使用场景</li><li>加索引时参照建立索引的几大原则</li><li>观察结果，不符合预期的继续从0分析</li></ol><h3 id="几个慢查询案例"><a href="#几个慢查询案例" class="headerlink" title="几个慢查询案例"></a>几个慢查询案例</h3><ul><li>案例一</li></ul><p>很多情况下，我们写SQL只是为了实现功能，这只是第一步，不同的语句书写方式对于效率往往有本质的差别，这要求我们对mysql的执行计划和索引原则有非常清楚的认识，请看下面的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   <span class="keyword">distinct</span> cert.emp_id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   (</span><br><span class="line">      <span class="keyword">select</span></span><br><span class="line">         emp.id <span class="keyword">as</span> emp_id,</span><br><span class="line">         emp_cert.id <span class="keyword">as</span> cert_id </span><br><span class="line">      <span class="keyword">from</span></span><br><span class="line">         employee emp </span><br><span class="line">      <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">         emp_certificate emp_cert </span><br><span class="line">            <span class="keyword">on</span> emp.id <span class="operator">=</span> emp_cert.emp_id </span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">         emp.is_deleted<span class="operator">=</span><span class="number">0</span></span><br><span class="line">   ) cert </span><br><span class="line">      <span class="keyword">on</span> (</span><br><span class="line">         cl.ref_table<span class="operator">=</span><span class="string">&#x27;Employee&#x27;</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid<span class="operator">=</span> cert.emp_id</span><br><span class="line">      ) </span><br><span class="line">      <span class="keyword">or</span> (</span><br><span class="line">         cl.ref_table<span class="operator">=</span><span class="string">&#x27;EmpCertificate&#x27;</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid<span class="operator">=</span> cert.cert_id</span><br><span class="line">      ) </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date <span class="operator">&gt;=</span><span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date<span class="operator">&lt;=</span><span class="string">&#x27;2013-11-08 16:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="0"><li>先运行一下，53条记录 1.87秒，又没有用聚合语句，比较慢</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">53</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">1.87</span> sec)</span><br></pre></td></tr></table></figure><ol><li>explain</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type  <span class="operator">|</span> possible_keys                   <span class="operator">|</span> key                   <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>               <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> Extra                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> cl         <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> cm_log_cls_id,idx_last_upd_date <span class="operator">|</span> idx_last_upd_date     <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>   <span class="number">379</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> temporary   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>                            <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span> <span class="number">63727</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> emp        <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>                            <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span> <span class="number">13317</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> emp_cert   <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> emp_certificate_empid           <span class="operator">|</span> emp_certificate_empid <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.emp.id <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> index                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;简述一下执行计划，首先mysql根据idx_last_upd_date索引扫描cm_log表获得379条记录；然后查表扫描了63727条记录，分为两部分，derived表示构造表，也就是不存在的表，可以简单理解成是一个语句形成的结果集，后面的数字表示语句的ID。derived2表示的是ID = 2的查询构造了虚拟表，并且返回了63727条记录。我们再来看看ID = 2的语句究竟做了写什么返回了这么大量的数据，首先全表扫描employee表13317条记录，然后根据索引emp_certificate_empid关联emp_certificate表，rows = 1表示，每个关联都只锁定了一条记录，效率比较高。获得后，再和cm_log的379条记录根据规则关联。从执行过程上可以看出返回了太多的数据，返回的数据绝大部分cm_log都用不到，因为cm_log只锁定了379条记录。</p><p>&emsp;&emsp;如何优化呢？可以看到我们在运行完后还是要和cm_log做join,那么我们能不能之前和cm_log做join呢？仔细分析语句不难发现，其基本思想是如果cm_log的ref_table是EmpCertificate就关联emp_certificate表，如果ref_table是Employee就关联employee表，我们完全可以拆成两部分，并用union连接起来，注意这里用union，而不用union all是因为原语句有“distinct”来得到唯一的记录，而union恰好具备了这种功能。如果原语句中没有distinct不需要去重，我们就可以直接使用union all了，因为使用union需要去重的动作，会影响SQL性能。</p><p>优化过的语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   emp.id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   employee emp </span><br><span class="line">      <span class="keyword">on</span> cl.ref_table <span class="operator">=</span> <span class="string">&#x27;Employee&#x27;</span> </span><br><span class="line">      <span class="keyword">and</span> cl.ref_oid <span class="operator">=</span> emp.id  </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date <span class="operator">&gt;=</span><span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date<span class="operator">&lt;=</span><span class="string">&#x27;2013-11-08 16:00:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> emp.is_deleted <span class="operator">=</span> <span class="number">0</span>  </span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">   emp.id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   emp_certificate ec </span><br><span class="line">      <span class="keyword">on</span> cl.ref_table <span class="operator">=</span> <span class="string">&#x27;EmpCertificate&#x27;</span> </span><br><span class="line">      <span class="keyword">and</span> cl.ref_oid <span class="operator">=</span> ec.id  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   employee emp </span><br><span class="line">      <span class="keyword">on</span> emp.id <span class="operator">=</span> ec.emp_id  </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date <span class="operator">&gt;=</span><span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date<span class="operator">&lt;=</span><span class="string">&#x27;2013-11-08 16:00:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> emp.is_deleted <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>不需要了解业务场景，只需要改造的语句和改造之前的语句保持结果一致</p></li><li><p>现有索引可以满足，不需要建索引</p></li><li><p>用改造后的语句实验一下，只需要10ms 降低了近200倍！</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type   <span class="operator">|</span> possible_keys                   <span class="operator">|</span> key               <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> cl         <span class="operator">|</span> <span class="keyword">range</span>  <span class="operator">|</span> cm_log_cls_id,idx_last_upd_date <span class="operator">|</span> idx_last_upd_date <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span>  <span class="number">379</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> emp        <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>                         <span class="operator">|</span> <span class="keyword">PRIMARY</span>           <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.cl.ref_oid <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> cl         <span class="operator">|</span> <span class="keyword">range</span>  <span class="operator">|</span> cm_log_cls_id,idx_last_upd_date <span class="operator">|</span> idx_last_upd_date <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span>  <span class="number">379</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> ec         <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>,emp_certificate_empid   <span class="operator">|</span> <span class="keyword">PRIMARY</span>           <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.cl.ref_oid <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> emp        <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>                         <span class="operator">|</span> <span class="keyword">PRIMARY</span>           <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.ec.emp_id  <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                            <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span></span><br><span class="line"><span class="number">53</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><ul><li>案例二</li></ul><p>举这个例子的目的在于颠覆我们对列的区分度的认知，一般上我们认为区分度越高的列，越容易锁定更少的记录，但在一些特殊的情况下，这种理论是有局限性的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   stage_poi sp </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   sp.accurate_result<span class="operator">=</span><span class="number">1</span> </span><br><span class="line">   <span class="keyword">and</span> (</span><br><span class="line">      sp.sync_status<span class="operator">=</span><span class="number">0</span> </span><br><span class="line">      <span class="keyword">or</span> sp.sync_status<span class="operator">=</span><span class="number">2</span> </span><br><span class="line">      <span class="keyword">or</span> sp.sync_status<span class="operator">=</span><span class="number">4</span></span><br><span class="line">   );</span><br></pre></td></tr></table></figure><ol start="0"><li>先看看运行多长时间,951条数据6.22秒，真的很慢。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">951</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">6.22</span> sec)</span><br></pre></td></tr></table></figure><ol><li>先explain，rows达到了361万，type = ALL表明是全表扫描。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>    <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> sp    <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">3613155</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>所有字段都应用查询返回记录数，因为是单表查询 0已经做过了951条。</p></li><li><p>让explain的rows 尽量逼近951。</p></li></ol><p>看一下accurate_result = 1的记录数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),accurate_result <span class="keyword">from</span> stage_poi  <span class="keyword">group</span> <span class="keyword">by</span> accurate_result;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span> accurate_result <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">1023</span> <span class="operator">|</span>              <span class="number">-1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2114655</span> <span class="operator">|</span>               <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">972815</span> <span class="operator">|</span>               <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们看到accurate_result这个字段的区分度非常低，整个表只有-1,0,1三个值，加上索引也无法锁定特别少量的数据。</p><p>再看一下sync_status字段的情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),sync_status <span class="keyword">from</span> stage_poi  <span class="keyword">group</span> <span class="keyword">by</span> sync_status;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span> sync_status <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">3080</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3085413</span> <span class="operator">|</span>           <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+</span></span><br></pre></td></tr></table></figure><p>同样的区分度也很低，根据理论，也不适合建立索引。</p><p>&emsp;&emsp;问题分析到这，好像得出了这个表无法优化的结论，两个列的区分度都很低，即便加上索引也只能适应这种情况，很难做普遍性的优化，比如当sync_status 0、3分布的很平均，那么锁ß定记录也是百万级别的。</p><ol start="4"><li><p>找业务方去沟通，看看使用场景。业务方是这么来使用这个SQL语句的，每隔五分钟会扫描符合条件的数据，处理完成后把sync_status这个字段变成1,五分钟符合条件的记录数并不会太多，1000个左右。了解了业务方的使用场景后，优化这个SQL就变得简单了，因为业务方保证了数据的不平衡，如果加上索引可以过滤掉绝大部分不需要的数据。</p></li><li><p>根据建立索引规则，使用如下语句建立索引</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stage_poi <span class="keyword">add</span> index idx_acc_status(accurate_result,sync_status);</span><br></pre></td></tr></table></figure><ol start="6"><li>观察预期结果,发现只需要200ms，快了30多倍。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">952</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.20</span> sec)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们再来回顾一下分析问题的过程，单表查询相对来说比较好优化，大部分时候只需要把where条件里面的字段依照规则加上索引就好，如果只是这种“无脑”优化的话，显然一些区分度非常低的列，不应该加索引的列也会被加上索引，这样会对插入、更新性能造成严重的影响，同时也有可能影响其它的查询语句。所以我们第4步调差SQL的使用场景非常关键，我们只有知道这个业务场景，才能更好地辅助我们更好的分析和优化查询语句。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据表的类型&quot;&gt;&lt;a href=&quot;#数据表的类型&quot; class=&quot;headerlink&quot; title=&quot;数据表的类型&quot;&gt;&lt;/a&gt;数据表的类型&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;th align=&quot;</summary>
      
    
    
    
    <category term="SQL" scheme="http://jiahaohong1997.github.io/categories/SQL/"/>
    
    
    <category term="MySQL" scheme="http://jiahaohong1997.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>缓存穿透与雪崩</title>
    <link href="http://jiahaohong1997.github.io/2021/11/12/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9/"/>
    <id>http://jiahaohong1997.github.io/2021/11/12/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9/</id>
    <published>2021-11-12T07:27:00.000Z</published>
    <updated>2022-01-05T03:07:07.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;用户想要查询一个数据，发现Redis数据库中没有，也就是缓存没有命中，于是向持久层数据库（例如Mysql）查询，发现也没有，于是本次查询失败。当用户很多时，缓存都没有命中（秒杀），于是都去请求持久层数据库，这会给持久层数据库造成很大压力，这时候就相当于出现了缓存穿透。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>&emsp;&emsp;布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。</p><p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/1.png" alt="avater"></p><ul><li>特点</li></ul><p>&emsp;&emsp;特点是高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><ul><li>结构</li></ul><p>&emsp;&emsp;布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：</p><p><img lazyload src="/images/loading.svg" data-src="%E5%9B%BE%E7%AE%97%E6%B3%95/2.jpg" alt="avatar"></p><p>&emsp;&emsp;如果我们要映射一个值到布隆过滤器中，我们需要使用<strong>多个不同的哈希函数</strong>生成<strong>多个哈希值，</strong>并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：</p><p><img lazyload src="/images/loading.svg" data-src="%E5%9B%BE%E7%AE%97%E6%B3%95/3.jpg" alt="avatar"></p><p>&emsp;&emsp;我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p><p><img lazyload src="/images/loading.svg" data-src="%E5%9B%BE%E7%AE%97%E6%B3%95/4.jpg" alt="avatar"></p><p>&emsp;&emsp;值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，<strong>说明没有任何一个值映射到这个 bit 位上</strong>，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” <strong>存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</strong></p><p>&emsp;&emsp;这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p><ul><li>如何选择哈希函数和布隆过滤器的长度</li></ul><p>&emsp;&emsp;很显然，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。</p><p>&emsp;&emsp;另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。</p><h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><p>&emsp;&emsp;当存储层布命中后，即使返回空对象也将其存储起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。</p><p> <img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/5.png" alt="avatar"></p><p>但是这种方法有两个问题：</p><ol><li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多空值的键；</li><li>即使对空值设置了过期时间，还是会存在缓存层和存储层数据有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li></ol><h1 id="缓存击穿（查询量太大，缓存过期）"><a href="#缓存击穿（查询量太大，缓存过期）" class="headerlink" title="缓存击穿（查询量太大，缓存过期）"></a>缓存击穿（查询量太大，缓存过期）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;这里需要注意和缓存穿透的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开一个洞。</p><p>&emsp;&emsp;当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同市访问数据库来查询最新数据，并且回写缓存，会导致数据库瞬间压力过大。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="设置热点数据永不过期"><a href="#设置热点数据永不过期" class="headerlink" title="设置热点数据永不过期"></a>设置热点数据永不过期</h3><p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题。</p><h3 id="加互斥锁"><a href="#加互斥锁" class="headerlink" title="加互斥锁"></a>加互斥锁</h3><p>分布式锁：使用分布式锁，保证每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;缓存雪崩，指在某一时间段，缓存集中过期失效，Redis宕机。产生雪崩的原因：比如双十一零点会迎来一波抢购，这波商品比较集中的放入了缓存，假设缓存一小时。那么到凌晨一点，这批商品的缓存都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会到达存储层，造成存储层挂掉。</p><p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/6.png" alt="avatar"></p><p>&emsp;&emsp;其实集中过期到不是非常致命，比较致命的是缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对服务器造成的压力是不可预知的美很有可能瞬间就把数据库压垮。</p><p>双十一：停掉一些服务（保证主要的服务可用），例如退款功能。</p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h3><p>&emsp;&emsp;既然Redis可能挂掉，那就多增设几台redis，这样一台挂掉之后其他的还能继续工作，其实就是搭建集群。（异地多活）。</p><h3 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h3><p>&emsp;&emsp;在缓存失效后，通过加锁或者队列来控制读数据写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><h3 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h3><p>&emsp;&emsp;在正式部署前，把可能的数据预先访问一遍，这样大部分的数据就回家再到缓存中。在即将发生大并发访问前手动出发家在缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;缓存穿透（查不到）&quot;&gt;&lt;a href=&quot;#缓存穿透（查不到）&quot; class=&quot;headerlink&quot; title=&quot;缓存穿透（查不到）&quot;&gt;&lt;/a&gt;缓存穿透（查不到）&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="中间件" scheme="http://jiahaohong1997.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="缓存" scheme="http://jiahaohong1997.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Go语言中的字符串操作</title>
    <link href="http://jiahaohong1997.github.io/2021/11/10/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
    <id>http://jiahaohong1997.github.io/2021/11/10/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</id>
    <published>2021-11-10T11:30:00.000Z</published>
    <updated>2021-11-11T17:56:06.530Z</updated>
    
    <content type="html"><![CDATA[<p>注：本节内容参考自<a class="link" href="http://books.studygolang.com/The-Golang-Standard-Library-by-Example/">《Go语言标准库》<i class="fas fa-external-link-alt"></i></a>，结合自己实际的使用体验进行总结。</p><h1 id="字符串的常见操作"><a href="#字符串的常见操作" class="headerlink" title="字符串的常见操作"></a>字符串的常见操作</h1><ul><li>字符串长度</li><li>求子串</li><li>是否存在某个字符或子串</li><li>子串出现的次数（字符串匹配）</li><li>字符串切割为[]string</li><li>字符串是否存在某个前缀或后缀</li><li>字符或子串在字符串中首次出现的位置或最后一次出现的位置</li><li>通过某个字符串将[]string连接起来</li><li>字符串重复几次</li><li>字符串中子串替换</li><li>大小写转换</li><li>Trim操作</li><li>…</li></ul><p>&emsp;&emsp;string类型可以看做一种特殊的slice类型，因此获取长度可以使用内置的函数 <code>len()</code>，同时支持切片操作，因此子串很容易获得。这里说的字符，指得是 rune 类型，即一个 UTF-8 字符（Unicode 代码点）</p><h1 id="1-字符串比较"><a href="#1-字符串比较" class="headerlink" title="1.字符串比较"></a>1.字符串比较</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compare函数，用于比较两个字符串的大小，如果两个字符串相等，返回0；如果a小于b，返回-1；如果a大于b，返回1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compare</span><span class="params">(a,b <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EqualFold函数，计算s与t忽略字母大小写是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EqualFold</span><span class="params">(s,t <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p> <strong>示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&quot;gopher&quot;</span></span><br><span class="line">b := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">fmt.Println(strings.Compare(a, b))</span><br><span class="line">fmt.Println(strings.Compare(a, a))</span><br><span class="line">fmt.Println(strings.Compare(b, a))</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.EqualFold(<span class="string">&quot;GO&quot;</span>, <span class="string">&quot;go&quot;</span>))</span><br><span class="line">fmt.Println(strings.EqualFold(<span class="string">&quot;壹&quot;</span>, <span class="string">&quot;一&quot;</span>))</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="2-是否存在某个字符或子串"><a href="#2-是否存在某个字符或子串" class="headerlink" title="2.是否存在某个字符或子串"></a>2.是否存在某个字符或子串</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子串 substr 在 s 中，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// chars 中任何一个 Unicode 代码点在 s 中，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsAny</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// Unicode 代码点 r 在 s 中，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsRune</span><span class="params">(s <span class="keyword">string</span>, r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>这里对 ContainsAny 函数进行一下说明，看如下例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;team&quot;</span>, <span class="string">&quot;i&quot;</span>))</span><br><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;failure&quot;</span>, <span class="string">&quot;u &amp; i&quot;</span>))</span><br><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;in failure&quot;</span>, <span class="string">&quot;s g&quot;</span>))</span><br><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说，第二个参数 chars 中任意一个字符（Unicode Code Point）如果在第一个参数 s 中存在，则返回 true。</p><p>&emsp;&emsp;查看这三个函数的源码，发现它们只是调用了相应的 Index 函数（子串出现的位置），然后和 0 作比较返回 true 或 fale。如，Contains：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Index(s, substr) &gt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-子串出现的次数"><a href="#3-子串出现的次数" class="headerlink" title="3.子串出现的次数"></a>3.子串出现的次数</h1><p>&emsp;&emsp;在数据结构与算法中，可能会讲解以下字符串匹配算法：</p><ul><li>朴素匹配算法</li><li>KMP 算法</li><li>Rabin-Karp 算法</li><li>Boyer-Moore 算法</li></ul><p>&emsp;&emsp;在 Go 中，查找子串出现次数即字符串模式匹配，实现的是 Rabin-Karp 算法。Count 函数的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在 Count 的实现中，处理了几种特殊情况，属于字符匹配预处理的一部分。这里要特别说明一下的是当 sep 为空时，Count 的返回值是：utf8.RuneCountInString(s) + 1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.Count(<span class="string">&quot;cheese&quot;</span>, <span class="string">&quot;e&quot;</span>))</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(<span class="string">&quot;谷歌中国&quot;</span>))</span><br><span class="line">fmt.Println(strings.Count(<span class="string">&quot;谷歌中国&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">12</span>  </span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>另外，Count 是计算子串在字符串中出现的无重叠的次数，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.Count(<span class="string">&quot;fivevev&quot;</span>, <span class="string">&quot;vev&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="4-字符串分割为-string"><a href="#4-字符串分割为-string" class="headerlink" title="4.字符串分割为[]string"></a>4.字符串分割为[]string</h1><h2 id="Fields-和-FieldsFunc"><a href="#Fields-和-FieldsFunc" class="headerlink" title="Fields 和 FieldsFunc"></a>Fields 和 FieldsFunc</h2><p>这两个函数的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FieldsFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) []<span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Fields 用一个或多个连续的空格分隔字符串 s，返回子字符串的数组（slice）。如果字符串 s 只包含空格，则返回空列表 ([]string 的长度为 0）。其中，空格的定义是 unicode.IsSpace，常见间隔符包括：’\t’, ‘\n’, ‘\v’, ‘\f’, ‘\r’, ‘ ‘, U+0085 (NEL), U+00A0 (NBSP)。</p><p>由于是用空格分隔，因此结果中不会含有空格或空子字符串，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;Fields are: %q&quot;</span>, strings.Fields(<span class="string">&quot;  foo bar  baz   &quot;</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fields are: [<span class="string">&quot;foo&quot;</span> <span class="string">&quot;bar&quot;</span> <span class="string">&quot;baz&quot;</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;FieldsFunc 用这样的 Unicode 代码点 c 进行分隔：满足 f(c) 返回 true。该函数返回[]string。如果字符串 s 中所有的代码点 (unicode code points) 都满足 f(c) 或者 s 是空，则 FieldsFunc 返回空 slice。</p><p>也就是说，我们可以通过实现一个回调函数来指定分隔字符串 s 的字符。比如上面的例子，我们通过 FieldsFunc 来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.FieldsFunc(<span class="string">&quot;  foo bar  baz   &quot;</span>, unicode.IsSpace))</span><br></pre></td></tr></table></figure><p>实际上，Fields 函数就是调用 FieldsFunc 实现的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> FieldsFunc(s, unicode.IsSpace)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目示例：</strong></p><p><a class="link" href="https://leetcode-cn.com/problems/count-vowel-substrings-of-a-string/">2062. 统计字符串中的元音子字符串<i class="fas fa-external-link-alt"></i></a></p><p><strong>子字符串</strong> 是字符串中的一个连续（非空）的字符序列。</p><p><strong>元音子字符串</strong> 是 <strong>仅</strong> 由元音（<code>&#39;a&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;i&#39;</code>、<code>&#39;o&#39;</code> 和 <code>&#39;u&#39;</code>）组成的一个子字符串，且必须包含 <strong>全部五种</strong> 元音。给你一个字符串 <code>word</code> ，统计并返回 <code>word</code> 中 <strong>元音子字符串的数目</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：word &#x3D; &quot;aeiouu&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：下面列出 word 中的元音子字符串（斜体加粗部分）：</span><br><span class="line">- &quot;aeiouu&quot;</span><br><span class="line">- &quot;aeiouu&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word &#x3D; &quot;unicornarihan&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：word 中不含 5 种元音，所以也不会存在元音子字符串。</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countVowelSubstrings</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="params">(ans <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> strings.FieldsFunc(word, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> !strings.ContainsRune(<span class="string">&quot;aeiou&quot;</span>, r) &#125;) &#123; <span class="comment">// 分割出仅包含元音的字符串</span></span><br><span class="line"></span><br><span class="line">cnt := [<span class="string">&#x27;v&#x27;</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">l := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">cnt[ch]++</span><br><span class="line"><span class="keyword">for</span> cnt[s[l]] &gt; <span class="number">1</span> &#123; <span class="comment">// 双指针，仅当该元音个数不止一个时才移动左指针</span></span><br><span class="line">cnt[s[l]]--</span><br><span class="line">l++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cnt[<span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[<span class="string">&#x27;e&#x27;</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[<span class="string">&#x27;i&#x27;</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[<span class="string">&#x27;o&#x27;</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[<span class="string">&#x27;u&#x27;</span>] &gt; <span class="number">0</span> &#123; <span class="comment">// 必须包含全部五种元音</span></span><br><span class="line">ans += l + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Split、SplitAfter、SplitN和SplitAfterN"><a href="#Split、SplitAfter、SplitN和SplitAfterN" class="headerlink" title="Split、SplitAfter、SplitN和SplitAfterN"></a>Split、SplitAfter、SplitN和SplitAfterN</h2><p>&emsp;&emsp;之所以将这四个函数放在一起讲，是因为它们都是通过一个同一个内部函数来实现的。它们的函数签名及其实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123; <span class="keyword">return</span> genSplit(s, sep, <span class="number">0</span>, <span class="number">-1</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitAfter</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123; <span class="keyword">return</span> genSplit(s, sep, <span class="built_in">len</span>(sep), <span class="number">-1</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitN</span><span class="params">(s, sep <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123; <span class="keyword">return</span> genSplit(s, sep, <span class="number">0</span>, n) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitAfterN</span><span class="params">(s, sep <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123; <span class="keyword">return</span> genSplit(s, sep, <span class="built_in">len</span>(sep), n) &#125;</span><br></pre></td></tr></table></figure><p>它们都调用了 genSplit 函数。</p><p>这四个函数都是通过 sep 进行分割，返回[]string。如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 <code>Split(&quot;abc&quot;,&quot;&quot;)</code>，得到的是[a b c]。</p><p>Split(s, sep) 和 SplitN(s, sep, -1) 等价；SplitAfter(s, sep) 和 SplitAfterN(s, sep, -1) 等价。</p><p>那么，Split 和 SplitAfter 有啥区别呢？通过这两句代码的结果就知道它们的区别了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;foo,bar,baz&quot;</span>, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.SplitAfter(<span class="string">&quot;foo,bar,baz&quot;</span>, <span class="string">&quot;,&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;foo&quot;</span> <span class="string">&quot;bar&quot;</span> <span class="string">&quot;baz&quot;</span>]</span><br><span class="line">[<span class="string">&quot;foo,&quot;</span> <span class="string">&quot;bar,&quot;</span> <span class="string">&quot;baz&quot;</span>]</span><br></pre></td></tr></table></figure><p>也就是说，Split 会将 s 中的 sep 去掉，而 SplitAfter 会保留 sep。</p><p>&emsp;&emsp;带 N 的方法可以通过最后一个参数 n 控制返回的结果中的 slice 中的元素个数，当 n &lt; 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n &gt; 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.SplitN(<span class="string">&quot;foo,bar,baz&quot;</span>, <span class="string">&quot;,&quot;</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;foo&quot;</span> <span class="string">&quot;bar,baz&quot;</span>]</span><br></pre></td></tr></table></figure><p>另外看一下官方文档提供的例子，注意一下输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;a man a plan a canal panama&quot;</span>, <span class="string">&quot;a &quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot; xyz &quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Bernardo O&#x27;Higgins&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;a&quot;</span> <span class="string">&quot;b&quot;</span> <span class="string">&quot;c&quot;</span>]</span><br><span class="line">[<span class="string">&quot;&quot;</span> <span class="string">&quot;man &quot;</span> <span class="string">&quot;plan &quot;</span> <span class="string">&quot;canal panama&quot;</span>]</span><br><span class="line">[<span class="string">&quot; &quot;</span> <span class="string">&quot;x&quot;</span> <span class="string">&quot;y&quot;</span> <span class="string">&quot;z&quot;</span> <span class="string">&quot; &quot;</span>]</span><br><span class="line">[<span class="string">&quot;&quot;</span>]</span><br></pre></td></tr></table></figure><h1 id="5-字符串中是否有某个前缀或后缀"><a href="#5-字符串中是否有某个前缀或后缀" class="headerlink" title="5.字符串中是否有某个前缀或后缀"></a>5.字符串中是否有某个前缀或后缀</h1><p>这两个函数比较简单，源码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s 中是否以 prefix 开始</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) &gt;= <span class="built_in">len</span>(prefix) &amp;&amp; s[<span class="number">0</span>:<span class="built_in">len</span>(prefix)] == prefix</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s 中是否以 suffix 结尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasSuffix</span><span class="params">(s, suffix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) &gt;= <span class="built_in">len</span>(suffix) &amp;&amp; s[<span class="built_in">len</span>(s)-<span class="built_in">len</span>(suffix):] == suffix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 prefix 或 suffix 为 “” , 返回值总是 true。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.HasPrefix(<span class="string">&quot;Gopher&quot;</span>, <span class="string">&quot;Go&quot;</span>))</span><br><span class="line">fmt.Println(strings.HasPrefix(<span class="string">&quot;Gopher&quot;</span>, <span class="string">&quot;C&quot;</span>))</span><br><span class="line">fmt.Println(strings.HasPrefix(<span class="string">&quot;Gopher&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">fmt.Println(strings.HasSuffix(<span class="string">&quot;Amigo&quot;</span>, <span class="string">&quot;go&quot;</span>))</span><br><span class="line">fmt.Println(strings.HasSuffix(<span class="string">&quot;Amigo&quot;</span>, <span class="string">&quot;Ami&quot;</span>))</span><br><span class="line">fmt.Println(strings.HasSuffix(<span class="string">&quot;Amigo&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="6-字符或子串在字符串中出现的位置"><a href="#6-字符或子串在字符串中出现的位置" class="headerlink" title="6.字符或子串在字符串中出现的位置"></a>6.字符或子串在字符串中出现的位置</h1><p>有一序列函数与该功能有关：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 s 中查找 sep 的第一次出现，返回第一次出现的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 在 s 中查找字节 c 的第一次出现，返回第一次出现的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexByte</span><span class="params">(s <span class="keyword">string</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// chars 中任何一个 Unicode 代码点在 s 中首次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexAny</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br><span class="line"><span class="comment">// Unicode 代码点 r 在 s 中第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexRune</span><span class="params">(s <span class="keyword">string</span>, r <span class="keyword">rune</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有三个对应的查找最后一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndex</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexByte</span><span class="params">(s <span class="keyword">string</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexAny</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>在 2.1.1 小节提到过，Contain 相关的函数内部调用的是响应的 Index 函数。</p><p>这一序列函数，只举 IndexFunc 的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">han := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unicode.Is(unicode.Han, c) <span class="comment">// 汉字</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(strings.IndexFunc(<span class="string">&quot;Hello, world&quot;</span>, han))</span><br><span class="line">fmt.Println(strings.IndexFunc(<span class="string">&quot;Hello, 世界&quot;</span>, han))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h1 id="7-字符串拼接（JOIN）操作"><a href="#7-字符串拼接（JOIN）操作" class="headerlink" title="7.字符串拼接（JOIN）操作"></a>7.字符串拼接（JOIN）操作</h1><p>&emsp;&emsp;将字符串数组（或slice）连接起来可以通过Join来实现，函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>看一下标准库的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  n := <span class="built_in">len</span>(sep) * (<span class="built_in">len</span>(a) - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">      n += <span class="built_in">len</span>(a[i])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">  bp := <span class="built_in">copy</span>(b, a[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">for</span> _, s := <span class="keyword">range</span> a[<span class="number">1</span>:] &#123;</span><br><span class="line">      bp += <span class="built_in">copy</span>(b[bp:], sep)</span><br><span class="line">      bp += <span class="built_in">copy</span>(b[bp:], s)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(Join([]<span class="keyword">string</span>&#123;<span class="string">&quot;name=xxx&quot;</span>, <span class="string">&quot;age=xx&quot;</span>&#125;, <span class="string">&quot;&amp;&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=xxx&amp;age=xx</span><br></pre></td></tr></table></figure><h1 id="8-字符串重复几次"><a href="#8-字符串重复几次" class="headerlink" title="8.字符串重复几次"></a>8.字符串重复几次</h1><p>函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(s <span class="keyword">string</span>, count <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>将 s 重复 count 次，如果 count 为负数或返回值长度 len(s)*count 超出 string 上限会导致 panic，这个函数使用很简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;ba&quot;</span> + strings.Repeat(<span class="string">&quot;na&quot;</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">banana</span><br></pre></td></tr></table></figure><h1 id="9-字符替换"><a href="#9-字符替换" class="headerlink" title="9.字符替换"></a>9.字符替换</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(mapping <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">rune</span>, <span class="title">s</span> <span class="title">string</span>) <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>Map 函数，将 s 的每一个字符按照 mapping 的规则做映射替换，如果 mapping 返回值 &lt;0 ，则舍弃该字符。该方法只能对每一个字符做处理，但处理方式很灵活，可以方便的过滤，筛选汉字等。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mapping := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> r &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; r &lt;= <span class="string">&#x27;Z&#x27;</span>: <span class="comment">// 大写字母转小写</span></span><br><span class="line">        <span class="keyword">return</span> r + <span class="number">32</span></span><br><span class="line">    <span class="keyword">case</span> r &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; r &lt;= <span class="string">&#x27;z&#x27;</span>: <span class="comment">// 小写字母不处理</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    <span class="keyword">case</span> unicode.Is(unicode.Han, r): <span class="comment">// 汉字换行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 过滤所有非字母、汉字的字符</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(strings.Map(mapping, <span class="string">&quot;Hello你#￥%……\n（&#x27;World\n,好Hello^(&amp;(*界gopher...&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">gopher</span><br></pre></td></tr></table></figure><h1 id="10-字符串子串替换"><a href="#10-字符串子串替换" class="headerlink" title="10.字符串子串替换"></a>10.字符串子串替换</h1><p>进行字符串替换时，考虑到性能问题，能不用正则尽量别用，应该用这里的函数。</p><p>字符串替换的函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 new 替换 s 中的 old，一共替换 n 个。</span></span><br><span class="line"><span class="comment">// 如果 n &lt; 0，则不限制替换次数，即全部替换</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 该函数内部直接调用了函数 Replace(s, old, new , -1)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReplaceAll</span><span class="params">(s, old, <span class="built_in">new</span> <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.Replace(<span class="string">&quot;oink oink oink&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;ky&quot;</span>, <span class="number">2</span>))</span><br><span class="line">fmt.Println(strings.Replace(<span class="string">&quot;oink oink oink&quot;</span>, <span class="string">&quot;oink&quot;</span>, <span class="string">&quot;moo&quot;</span>, <span class="number">-1</span>))</span><br><span class="line">fmt.Println(strings.ReplaceAll(<span class="string">&quot;oink oink oink&quot;</span>, <span class="string">&quot;oink&quot;</span>, <span class="string">&quot;moo&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oinky oinky oink</span><br><span class="line">moo moo moo</span><br><span class="line">moo moo moo</span><br></pre></td></tr></table></figure><h1 id="11-大小写转换"><a href="#11-大小写转换" class="headerlink" title="11.大小写转换"></a>11.大小写转换</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLowerSpecial</span><span class="params">(c unicode.SpecialCase, s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpperSpecial</span><span class="params">(c unicode.SpecialCase, s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>大小写转换包含了 4 个相关函数，ToLower,ToUpper 用于大小写转换。ToLowerSpecial,ToUpperSpecial 可以转换特殊字符的大小写。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.ToLower(<span class="string">&quot;HELLO WORLD&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToLower(<span class="string">&quot;Ā Á Ǎ À&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, <span class="string">&quot;壹&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, <span class="string">&quot;HELLO WORLD&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToLower(<span class="string">&quot;Önnek İş&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, <span class="string">&quot;Önnek İş&quot;</span>))</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.ToUpper(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToUpper(<span class="string">&quot;ā á ǎ à&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, <span class="string">&quot;一&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, <span class="string">&quot;hello world&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToUpper(<span class="string">&quot;örnek iş&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, <span class="string">&quot;örnek iş&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">ā á ǎ à</span><br><span class="line">壹</span><br><span class="line">hello world</span><br><span class="line">önnek iş</span><br><span class="line">önnek iş</span><br><span class="line">HELLO WORLD</span><br><span class="line">Ā Á Ǎ À       // 汉字拼音有效</span><br><span class="line">一           //  汉字无效</span><br><span class="line">HELLO WORLD</span><br><span class="line">ÖRNEK IŞ</span><br><span class="line">ÖRNEK İŞ    // 有细微差别</span><br></pre></td></tr></table></figure><h1 id="12-标题处理"><a href="#12-标题处理" class="headerlink" title="12.标题处理"></a>12.标题处理</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Title</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToTitle</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToTitleSpecial</span><span class="params">(c unicode.SpecialCase, s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>标题处理包含 3 个相关函数，其中 Title 会将 s 每个单词的首字母大写，不处理该单词的后续字符。ToTitle 将 s 的每个字母大写。ToTitleSpecial 将 s 的每个字母大写，并且会将一些特殊字母转换为其对应的特殊大写字母。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.Title(<span class="string">&quot;hElLo wOrLd&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitle(<span class="string">&quot;hElLo wOrLd&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, <span class="string">&quot;hElLo wOrLd&quot;</span>))</span><br><span class="line">fmt.Println(strings.Title(<span class="string">&quot;āáǎà ōóǒò êēéěè&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitle(<span class="string">&quot;āáǎà ōóǒò êēéěè&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, <span class="string">&quot;āáǎà ōóǒò êēéěè&quot;</span>))</span><br><span class="line">fmt.Println(strings.Title(<span class="string">&quot;dünyanın ilk borsa yapısı Aizonai kabul edilir&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitle(<span class="string">&quot;dünyanın ilk borsa yapısı Aizonai kabul edilir&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, <span class="string">&quot;dünyanın ilk borsa yapısı Aizonai kabul edilir&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HElLo WOrLd</span><br><span class="line">HELLO WORLD</span><br><span class="line">HELLO WORLD</span><br><span class="line">Āáǎà Ōóǒò Êēéěè</span><br><span class="line">ĀÁǍÀ ŌÓǑÒ ÊĒÉĚÈ</span><br><span class="line">ĀÁǍÀ ŌÓǑÒ ÊĒÉĚÈ</span><br><span class="line">Dünyanın Ilk Borsa Yapısı Aizonai Kabul Edilir</span><br><span class="line">DÜNYANIN ILK BORSA YAPISI AIZONAI KABUL EDILIR</span><br><span class="line">DÜNYANIN İLK BORSA YAPISI AİZONAİ KABUL EDİLİR</span><br></pre></td></tr></table></figure><h1 id="13-修剪（Trim）"><a href="#13-修剪（Trim）" class="headerlink" title="13.修剪（Trim）"></a>13.修剪（Trim）</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 s 左侧和右侧中匹配 cutset 中的任一字符的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 左侧的匹配 cutset 中的任一字符的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeft</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 右侧的匹配 cutset 中的任一字符的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRight</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 如果 s 的前缀为 prefix 则返回去掉前缀后的 string , 否则 s 没有变化。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 如果 s 的后缀为 suffix 则返回去掉后缀后的 string , 否则 s 没有变化。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSuffix</span><span class="params">(s, suffix <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 左侧和右侧的间隔符去掉。常见间隔符包括：&#x27;\t&#x27;, &#x27;\n&#x27;, &#x27;\v&#x27;, &#x27;\f&#x27;, &#x27;\r&#x27;, &#x27; &#x27;, U+0085 (NEL)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 左侧和右侧的匹配 f 的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 左侧的匹配 f 的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeftFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 右侧的匹配 f 的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRightFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>包含了 9 个相关函数用于修剪字符串。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="string">&quot;!!!@@@你好,!@#$ Gophers###$$$&quot;</span></span><br><span class="line">fmt.Println(strings.Trim(x, <span class="string">&quot;@#$!%^&amp;*()_+=-&quot;</span>))</span><br><span class="line">fmt.Println(strings.TrimLeft(x, <span class="string">&quot;@#$!%^&amp;*()_+=-&quot;</span>))</span><br><span class="line">fmt.Println(strings.TrimRight(x, <span class="string">&quot;@#$!%^&amp;*()_+=-&quot;</span>))</span><br><span class="line">fmt.Println(strings.TrimSpace(<span class="string">&quot; \t\n Hello, Gophers \n\t\r\n&quot;</span>))</span><br><span class="line">fmt.Println(strings.TrimPrefix(x, <span class="string">&quot;!&quot;</span>))</span><br><span class="line">fmt.Println(strings.TrimSuffix(x, <span class="string">&quot;$&quot;</span>))</span><br><span class="line"></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !unicode.Is(unicode.Han, r) <span class="comment">// 非汉字返回 true</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(strings.TrimFunc(x, f))</span><br><span class="line">fmt.Println(strings.TrimLeftFunc(x, f))</span><br><span class="line">fmt.Println(strings.TrimRightFunc(x, f))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">你好,!@<span class="comment">#$ Gophers</span></span><br><span class="line">你好,!@<span class="comment">#$ Gophers###$$$</span></span><br><span class="line">!!!@@@你好,!@<span class="comment">#$ Gophers</span></span><br><span class="line">Hello, Gophers</span><br><span class="line">!!@@@你好,!@<span class="comment">#$ Gophers###$$$</span></span><br><span class="line">!!!@@@你好,!@<span class="comment">#$ Gophers###$$</span></span><br><span class="line">你好</span><br><span class="line">你好,!@<span class="comment">#$ Gophers###$$$</span></span><br><span class="line">!!!@@@你好</span><br></pre></td></tr></table></figure><h1 id="14-Reader类型"><a href="#14-Reader类型" class="headerlink" title="14.Reader类型"></a>14.Reader类型</h1><p>&emsp;&emsp;看到名字就能猜到，这是实现了 <code>io</code> 包中的接口。它实现了 io.Reader（Read 方法），io.ReaderAt（ReadAt 方法），io.Seeker（Seek 方法），io.WriterTo（WriteTo 方法），io.ByteReader（ReadByte 方法），io.ByteScanner（ReadByte 和 UnreadByte 方法），io.RuneReader（ReadRune 方法） 和 io.RuneScanner（ReadRune 和 UnreadRune 方法）。</p><p>Reader 结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">  s        <span class="keyword">string</span>    <span class="comment">// Reader 读取的数据来源</span></span><br><span class="line">  i        <span class="keyword">int</span> <span class="comment">// current reading index（当前读的索引位置）</span></span><br><span class="line">  prevRune <span class="keyword">int</span> <span class="comment">// index of previous rune; or &lt; 0（前一个读取的 rune 索引位置）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 Reader 结构没有导出任何字段，而是提供一个实例化方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">Reader</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该方法接收一个字符串，返回的 Reader 实例就是从该参数字符串读数据。在后面学习了 bytes 包之后，可以知道 bytes.NewBufferString 有类似的功能，不过，如果只是为了读取，NewReader 会更高效。</p><p>&emsp;&emsp;其他方法不介绍了，都是之前接口的实现，有兴趣的可以看看源码实现，大部分都是根据 i、prevRune 两个属性来控制。</p><h1 id="15-Builder类型"><a href="#15-Builder类型" class="headerlink" title="15.Builder类型"></a>15.Builder类型</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Builder <span class="keyword">struct</span> &#123;</span><br><span class="line">    addr *Builder <span class="comment">// of receiver, to detect copies by value</span></span><br><span class="line">    buf  []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该类型实现了 io 包下的 Writer, ByteWriter, StringWriter 等接口，可以向该对象内写入数据，Builder 没有实现 Reader 等接口，所以该类型不可读，但提供了 String 方法可以获取对象内的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法向 b 写入一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteByte</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// WriteRune 方法向 b 写入一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="comment">// WriteRune 方法向 b 写入字节数组 p</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="comment">// WriteRune 方法向 b 写入字符串 s</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="comment">// Len 方法返回 b 的数据长度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// Cap 方法返回 b 的 cap。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// Grow 方法将 b 的 cap 至少增加 n (可能会更多)。如果 n 为负数，会导致 panic。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Grow</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// Reset 方法将 b 清空 b 的所有内容。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Reset</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// String 方法将 b 的数据以 string 类型返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>Builder 有 4 个与写入相关的方法，这 4 个方法的 error 都总是为 nil.</p><p>Builder 的 cap 会自动增长，一般不需要手动调用 Grow 方法。</p><p>String 方法可以方便的获取 Builder 的内容。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">b := strings.Builder&#123;&#125;</span><br><span class="line">_ = b.WriteByte(<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">n, _ := b.WriteRune(<span class="string">&#x27;夕&#x27;</span>)</span><br><span class="line">fmt.Println(n)</span><br><span class="line">n, _ = b.Write([]<span class="keyword">byte</span>(<span class="string">&quot;Hello, World&quot;</span>))</span><br><span class="line">fmt.Println(n)</span><br><span class="line">n, _ = b.WriteString(<span class="string">&quot;你好，世界&quot;</span>)</span><br><span class="line">fmt.Println(n)</span><br><span class="line">fmt.Println(b.Len())</span><br><span class="line">fmt.Println(b.Cap())</span><br><span class="line">b.Grow(<span class="number">100</span>)</span><br><span class="line">fmt.Println(b.Len())</span><br><span class="line">fmt.Println(b.Cap())</span><br><span class="line">fmt.Println(b.String())</span><br><span class="line">b.Reset()</span><br><span class="line">fmt.Println(b.String())</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">12</span><br><span class="line">15</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">31</span><br><span class="line">164</span><br><span class="line">7夕Hello, World你好，世界</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注：本节内容参考自&lt;a class=&quot;link&quot; href=&quot;http://books.studygolang.com/The-Golang-Standard-Library-by-Example/&quot;&gt;《Go语言标准库》&lt;i class=&quot;fas fa-external-l</summary>
      
    
    
    
    <category term="Go语言标准库" scheme="http://jiahaohong1997.github.io/categories/Go%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
    
    <category term="strings" scheme="http://jiahaohong1997.github.io/tags/strings/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://jiahaohong1997.github.io/2021/11/09/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://jiahaohong1997.github.io/2021/11/09/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2021-11-09T15:21:00.000Z</published>
    <updated>2022-01-05T03:08:35.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;主从复制，是指将一台Redis服务器上的数据，复制到其他的Redis服务器上。前者称为主节点（Master），后者称为从节点（Slave）。数据的复制是单向的，只能从主节点到从节点。Master以写为主，Slave以读为主。</p><p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/1.png" alt="avatar"></p><p>主从复制，读写分离，80%的情况都是读操作，可以减缓服务器的压力。</p><p>&emsp;&emsp;默认情况下，每台Redis服务器都是主节点，且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。主从复制的作用主要包括：</p><ul><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式；</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余；</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量；</li><li>高可用(集群)基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><p>&emsp;&emsp;一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：</p><ul><li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</li><li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256GB，也不能将所有的内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20GB</li></ul><p>&emsp;&emsp;对于电商网站上的商品，一般都是一次上传，无数次浏览的，也就是“多读少写”。</p><h2 id="环境配置-单机上模拟，多机同理"><a href="#环境配置-单机上模拟，多机同理" class="headerlink" title="环境配置(单机上模拟，多机同理)"></a>环境配置(单机上模拟，多机同理)</h2><p>只配置从库，不用配置主库。</p><p>查看当前库的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0   <span class="comment"># 没有从机</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:05fce2cd1d05bab4c0c503cb7ef7c5c4c1b445e0</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将redis的配置文件复制若干次（要配置的从节点个数）：</p><p><img lazyload src="/images/loading.svg" data-src="%E5%9B%BE%E7%AE%97%E6%B3%95/2.jpg" alt="avatar"></p><p>然后修改每个配置文件中的项目如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port 6380  <span class="comment"># 端口号要改成从服务的节点</span></span><br><span class="line">pidfile /var/run/redis_6380.pid  <span class="comment"># pid file也要改成对应的名字</span></span><br><span class="line">logfile <span class="string">&quot;6380.log&quot;</span><span class="comment"># 日志文件名也要对应</span></span><br><span class="line">dbfilename dump6380.rdb  <span class="comment"># rdb文件命名也要修改</span></span><br></pre></td></tr></table></figure><p>然后分别启动主从服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-config/redis79.conf</span><br><span class="line">redis-server redis-config/redis80.conf</span><br><span class="line">redis-server redis-config/redis81.conf</span><br></pre></td></tr></table></figure><p>查看进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br><span class="line">  501 76856     1   0 12:08上午 ??         0:00.15 redis-server 127.0.0.1:6379</span><br><span class="line">  501 76963     1   0 12:09上午 ??         0:00.09 redis-server 127.0.0.1:6380</span><br><span class="line">  501 77118     1   0 12:09上午 ??         0:00.02 redis-server 127.0.0.1:6381</span><br><span class="line">  501 77166 73157   0 12:09上午 ttys004    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox redis</span><br></pre></td></tr></table></figure><h3 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h3><p>&emsp;&emsp;默认情况下，redis服务都是主机，一般情况下只需要配置从机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## port 6379</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:35cf0a87f4009c0db73dc38088333e56c6ae4ebd</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 6380</span></span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:89cbbf9896b1e99c65b6ce88e7d67af16bbb49f6</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 6381</span></span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:e0f2e6d24e37f5ce033a886d647c641b10289329</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;若将6379端口上的服务设为主机，6380、6381端口上的服务为从机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># slaveof [host] [port]</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6380&gt; slaveof 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave<span class="comment"># 角色转变为从机</span></span><br><span class="line">master_host:127.0.0.1<span class="comment"># 主机地址</span></span><br><span class="line">master_port:6379<span class="comment"># 主机端口</span></span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:2</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:84</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:494f98ba6749c752bb7ff2fb6e47f7c89c5712b8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:84</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:84</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6381&gt; slaveof 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:3</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:364</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:494f98ba6749c752bb7ff2fb6e47f7c89c5712b8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:364</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:351</span><br><span class="line">repl_backlog_histlen:14</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再查看一下主机（6379）上的主从信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=392,lag=1<span class="comment"># 从机信息</span></span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=392,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:494f98ba6749c752bb7ff2fb6e47f7c89c5712b8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:392</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:392</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;真实的主从配置应该在配置文件中配置，这样才是永久的，在redis客户端中通过命令来配置只是暂时的。</p><p>在配置文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################# REPLICATION #################################</span></span><br><span class="line"><span class="comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;  # 在此处配置主机的地址和端口</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在一主二从的配置方式中，主机可以写，从机不能写只能读。主机中的所有信息和数据，都会自动被从机保存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 主机</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment">### 从机1</span></span><br><span class="line">127.0.0.1:6380&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 从机2</span></span><br><span class="line">127.0.0.1:6381&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k1&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;若尝试在从机中写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">(error) READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;默认情况下，主机断开连接，从机依旧是连接到主机的，但是没有写操作了。当主机重新连回来时，从机依旧可以重新开始接收主机写入的数据。</p><p>&emsp;&emsp;如果是使用命令行配置的主从，若主机断开连接，重新连回来仍然是其他从机的主机；若某一个从机断开连接，再连回来就不再是从机了，在其断开连接后主机写入的数据就无法同步了。但只要重新将其设置为原来主机的丛机，马上就会写入主机的全部数据。</p><blockquote><p>复制原理</p></blockquote><p>Slave启动成功连接到master后会发送一个sync同步命令。Master接收到命令，启动后台的存盘进程，同时收集所有接受到的用于修改数据集命令，在后台进程执行完毕之后，Master将传送整个数据文件到Slave，并完成一次完全同步。Slave服务在接收集到数据文件数据后，将其存盘并加载到内存中。Master继续将新的所有收集到的修改命令一次传给Slave，完成同步。但是只要重新连接Master，一次完全同步（全量复制）将被自动执行。</p><ul><li>全量复制：Slave在接收到数据文件数据后，将其存盘并加载到内存中</li><li>增量复制：继续将新的所有收集到的修改命令一次传给Slave</li></ul><h3 id="层层链路"><a href="#层层链路" class="headerlink" title="层层链路"></a>层层链路</h3><p>&emsp;&emsp;另一种主从节点的配置方式如下图所示，1号服务既作为0号服务的从节点，也作为2号服务的主节点，打印看它的主从信息。</p><p><img lazyload src="/images/loading.svg" data-src="3.png" alt="avater"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:3</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:99242</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:494f98ba6749c752bb7ff2fb6e47f7c89c5712b8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:99242</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:99242</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;它的身份（role）还是作为从节点，所以是无法写入信息的。此时再向0号节点（Master）写入，1号、2号均能读取0号节点的值。这种形式也能完成主从复制。</p><p>&emsp;&emsp;如果此时Master断开，这时候能不能剩下的从节点选出一个作为Master吗？此时需要手动将其中一个从节点设置为主节点，使用<code>slaveof no one</code>让某个Slave变成Master，再其他节点手动连接到这个节点上（变来就以该节点作为Master的从节点不需要设置）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; slaveof no one</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=100321,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:7f67d870c3fd771f6427ea40516d4e8bdd26ab20</span><br><span class="line">master_replid2:494f98ba6749c752bb7ff2fb6e47f7c89c5712b8</span><br><span class="line">master_repl_offset:100321</span><br><span class="line">second_repl_offset:100308</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:100321</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;若原来的Master连回来之后，是不能够再自动将其作为主节点的。它已经被谋朝篡位了！！！！</p><h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>&emsp;&emsp;这是一种自动选取Master的模式。主从切换技术的方法是：当主机服务宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务不可用。这是一种不推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵模式）架构来解决这个问题。</p><p>&emsp;&emsp;谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库切换为主库。哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，他会独立运行。<strong>其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控多个Redis实例。</strong></p><p><img lazyload src="/images/loading.svg" data-src="4.png" alt="avatar"></p><p>&emsp;&emsp;哨兵有两个作用：</p><ol><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器；</li><li>当哨兵监测到Master宕机，会自动将Slave切换成Master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让他们切换主机。</li></ol><p>&emsp;&emsp;然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。哥哥哨兵之间还会进行监控，这样就形成了多哨兵模式。</p><p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/5.png" alt="avatar"></p><p>&emsp;&emsp;假设主服务器宕机，哨兵1监测到这个结果，系统不会马上进行failover过程，仅仅是哨兵1主观认为主服务器不可用，这个现象称为<strong>主观下线</strong>，当其他的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover（故障转移）操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的主服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>&emsp;&emsp;采用一主二从的方式。</p><ol><li>配置哨兵配置文件<code>sentinel.conf</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 1</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><p>后面这个数字1，代表主机挂了，Slave投票让谁接替称为主机，票数最多的，就会成为主机。</p><ol start="2"><li>启动哨兵</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">hongjiahao@Mac  /usr/<span class="built_in">local</span>/bin  redis-sentinel redis-config/sentinel/sentinel.conf</span><br><span class="line">6546:X 12 Nov 2021 00:57:31.378 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.378 <span class="comment"># Redis version=6.2.3, bits=64, commit=00000000, modified=0, pid=6546, just started</span></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.378 <span class="comment"># Configuration loaded</span></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.379 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 256).</span><br><span class="line">6546:X 12 Nov 2021 00:57:31.379 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._</span><br><span class="line">           _.-``__ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line">      _.-``    `.  `_.  <span class="string">&#x27;&#x27;</span>-._           Redis 6.2.3 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line"> (    <span class="string">&#x27;      ,       .-`  | `,    )     Running in sentinel mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="string">&#x27;|     Port: 26379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 6546</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |           https://redis.io</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line">      `-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line">          `-._        _.-<span class="string">&#x27;</span></span><br><span class="line"><span class="string">              `-.__.-&#x27;</span></span><br><span class="line"></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.382 <span class="comment"># Sentinel ID is 4a00c3f869d1b542c0ae2f9c6c26ff69c0ebb5bc</span></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.382 <span class="comment"># +monitor master myredis 127.0.0.1 6379 quorum 1</span></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.384 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379</span><br><span class="line">6546:X 12 Nov 2021 00:57:31.385 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379</span><br></pre></td></tr></table></figure><ol start="3"><li>主机6379宕机，此时就会从从机中选择一个服务作为新的Master</li></ol><p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/6.jpg" alt="avater"></p><p>&emsp;&emsp;此时主机变成6380，若原主机6379重新连上，<strong>只能成为新Master的从机</strong>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1、哨兵集群，基于主从复制，所有的主从配置优点全有；</p><p>2、主从节点可以切换，鼓掌可以转移，系统的可用性会更好；</p><p>3、哨兵模式就是主从模式的升级，手动到自动，更加健壮。</p><p>缺点：</p><p>1、Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦；</p><p>2、实现哨兵模式的配置其实很麻烦，里面有很多选择。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的ip port</span></span><br><span class="line"><span class="comment"># master-name 可以自己命名主节点名字。只能由字母A-Z、数字0-9、三个字符“.-_”组成</span></span><br><span class="line"><span class="comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联，呢么这是客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; </span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6380 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel实例的运行端口 默认26379。    如果有哨兵集群，还需要配置每个哨兵的端口</span></span><br><span class="line">port 26379</span><br><span class="line">user default on nopass ~* &amp;* +@all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码，这样所有连接Redis实例的客户端都需要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel连接主从的密码，注意必须主从设置一样的验证码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass myredis ********</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多少毫秒之后，主节点没有应答哨兵sentinel。此时哨兵主观认为主节点下线，默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds muredis 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定了在发生failover主从切换时每次最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长。</span></span><br><span class="line"><span class="comment"># 但如果这个数字越大，就意味着越多的slave因为replication而不可用</span></span><br><span class="line"><span class="comment"># 可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态</span></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs myredis 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel notification-script myredis /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关客户端master地址已经发生改变的信息</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本：</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script myredis /var/redis/reconfig.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir <span class="string">&quot;/usr/local/bin&quot;</span></span><br><span class="line"></span><br><span class="line">sentinel myid 4a00c3f869d1b542c0ae2f9c6c26ff69c0ebb5bc</span><br><span class="line">sentinel config-epoch myredis 1</span><br><span class="line">sentinel leader-epoch myredis 1</span><br><span class="line">sentinel current-epoch 1</span><br><span class="line">sentinel known-replica myredis 127.0.0.1 6379</span><br><span class="line">sentinel known-replica myredis 127.0.0.1 6381</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis主从复制&quot;&gt;&lt;a href=&quot;#Redis主从复制&quot; class=&quot;headerlink&quot; title=&quot;Redis主从复制&quot;&gt;&lt;/a&gt;Redis主从复制&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="中间件" scheme="http://jiahaohong1997.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Redis" scheme="http://jiahaohong1997.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>位运算技巧</title>
    <link href="http://jiahaohong1997.github.io/2021/10/29/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/"/>
    <id>http://jiahaohong1997.github.io/2021/10/29/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/</id>
    <published>2021-10-29T12:00:00.000Z</published>
    <updated>2021-10-29T12:56:40.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几个有趣的位操作"><a href="#几个有趣的位操作" class="headerlink" title="几个有趣的位操作"></a>几个有趣的位操作</h1><h2 id="利用或操作｜和空格将英文字符转换成小写"><a href="#利用或操作｜和空格将英文字符转换成小写" class="headerlink" title="利用或操作｜和空格将英文字符转换成小写"></a>利用或操作<code>｜</code>和空格将英文字符转换成小写</h2> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&#x27;a&#x27;</span></span><br><span class="line">A := <span class="string">&#x27;A&#x27;</span></span><br><span class="line"> </span><br><span class="line">t1 := <span class="keyword">string</span>(a | <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">t2 := <span class="keyword">string</span>(A | <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"> </span><br><span class="line">fmt.Println(t1)  <span class="comment">// a</span></span><br><span class="line">fmt.Println(t2)  <span class="comment">// a</span></span><br></pre></td></tr></table></figure><h2 id="利用与操作-amp-和下划线将英文字符转换成大写"><a href="#利用与操作-amp-和下划线将英文字符转换成大写" class="headerlink" title="利用与操作&amp;和下划线将英文字符转换成大写"></a>利用与操作<code>&amp;</code>和下划线将英文字符转换成大写</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="string">&#x27;b&#x27;</span></span><br><span class="line">B := <span class="string">&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line">t3 := <span class="keyword">string</span>(b &amp; <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">t4 := <span class="keyword">string</span>(B &amp; <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(t3)<span class="comment">// B</span></span><br><span class="line">fmt.Println(t4)<span class="comment">// B</span></span><br></pre></td></tr></table></figure><h2 id="利用异或操作-和空格进行英文大小写互换"><a href="#利用异或操作-和空格进行英文大小写互换" class="headerlink" title="利用异或操作^和空格进行英文大小写互换"></a>利用异或操作<code>^</code>和空格进行英文大小写互换</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="string">&#x27;c&#x27;</span></span><br><span class="line">C := <span class="string">&#x27;C&#x27;</span></span><br><span class="line"></span><br><span class="line">t5 := <span class="keyword">string</span>(c ^ <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">t6 := <span class="keyword">string</span>(C ^ <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(t5)<span class="comment">// C</span></span><br><span class="line">fmt.Println(t6)<span class="comment">// c</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;几个有趣的位操作&quot;&gt;&lt;a href=&quot;#几个有趣的位操作&quot; class=&quot;headerlink&quot; title=&quot;几个有趣的位操作&quot;&gt;&lt;/a&gt;几个有趣的位操作&lt;/h1&gt;&lt;h2 id=&quot;利用或操作｜和空格将英文字符转换成小写&quot;&gt;&lt;a href=&quot;#利用或操作｜和空格将</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="位运算" scheme="http://jiahaohong1997.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>最大栈</title>
    <link href="http://jiahaohong1997.github.io/2021/10/03/%E6%9C%80%E5%A4%A7%E6%A0%88/"/>
    <id>http://jiahaohong1997.github.io/2021/10/03/%E6%9C%80%E5%A4%A7%E6%A0%88/</id>
    <published>2021-10-03T07:16:00.000Z</published>
    <updated>2021-10-19T15:57:30.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大栈介绍"><a href="#最大栈介绍" class="headerlink" title="最大栈介绍"></a>最大栈介绍</h1><p>&emsp;&emsp;直接参考Leetcode上895题：<a class="link" href="https://leetcode-cn.com/problems/maximum-frequency-stack/">895. 最大频率栈<i class="fas fa-external-link-alt"></i></a></p><p>实现 <code>FreqStack</code>，模拟类似栈的数据结构的操作的一个类。</p><p><code>FreqStack</code> 有两个函数：</p><ul><li><code>push(int x)</code>，将整数 <code>x</code> 推入栈中。</li><li><code>pop()</code>，它移除并返回栈中出现最频繁的元素。<ul><li>如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],</span><br><span class="line">[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]</span><br><span class="line">输出：[null,null,null,null,null,null,null,5,7,5,4]</span><br><span class="line">解释：</span><br><span class="line">执行六次 .push 操作后，栈自底向上为 [5,7,5,7,4,5]。然后：</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 5，因为 5 是出现频率最高的。</span><br><span class="line">栈变成 [5,7,5,7,4]。</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 7，因为 5 和 7 都是频率最高的，但 7 最接近栈顶。</span><br><span class="line">栈变成 [5,7,5,4]。</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 5 。</span><br><span class="line">栈变成 [5,7,4]。</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 4 。</span><br><span class="line">栈变成 [5,7]。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>对 <code>FreqStack.push(int x)</code> 的调用中 <code>0 &lt;= x &lt;= 10^9</code>。</li><li>如果栈的元素数目为零，则保证不会调用 <code>FreqStack.pop()</code>。</li><li>单个测试样例中，对 <code>FreqStack.push</code> 的总调用次数不会超过 <code>10000</code>。</li><li>单个测试样例中，对 <code>FreqStack.pop</code> 的总调用次数不会超过 <code>10000</code>。</li><li>所有测试样例中，对 <code>FreqStack.push</code> 和 <code>FreqStack.pop</code> 的总调用次数不会超过 <code>150000</code>。</li></ul><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>&emsp;&emsp;<strong>这种设计数据结构的问题，主要是要搞清楚问题的难点在哪里，然后结合各种基本数据结构的特性，高效实现题目要求的 API</strong>。</p><p>那么，我们仔细思考一下 <code>push</code> 和 <code>pop</code> 方法，难点如下：</p><p>1、每次 <code>pop</code> 时，必须要知道频率最高的元素是什么。</p><p>2、如果频率最高的元素有多个，还得知道哪个是最近 <code>push</code> 进来的元素是哪个。</p><p>为了实现上述难点，我们要做到以下几点：</p><p>1、肯定要有一个变量 <code>maxFreq</code> 记录当前栈中最高的频率是多少。</p><p>2、我们得知道一个频率 <code>freq</code> 对应的元素有哪些，且这些元素要有时间顺序。</p><p>3、随着 <code>pop</code> 的调用，每个 <code>val</code> 对应的频率会变化，所以还得维持一个映射记录每个 <code>val</code> 对应的 <code>freq</code>。</p><h1 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h1><p>&emsp;&emsp;综上，我们可以先实现 <code>FreqStack</code> 所需的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FreqStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    maxFreq     <span class="keyword">int</span>     <span class="comment">// 出现最大频数的记录</span></span><br><span class="line">    valToFreq   <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">    freqToVal   <span class="keyword">map</span>[<span class="keyword">int</span>]*stack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">FreqStack</span></span> &#123;<span class="comment">// 初始化最大栈</span></span><br><span class="line">    mf := <span class="number">0</span></span><br><span class="line">    vf := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    fv := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*stack,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> FreqStack&#123;</span><br><span class="line">        maxFreq     :       mf,</span><br><span class="line">        valToFreq   :       vf,</span><br><span class="line">        freqToVal   :       fv,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们来亲自构建<code>stack</code>这一数据结构及其方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;<span class="comment">// 栈可以用一个简单的切片来表示</span></span><br><span class="line">    list        []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorStack</span><span class="params">()</span> *<span class="title">stack</span></span> &#123;<span class="comment">// 初始化栈</span></span><br><span class="line">    l := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;stack&#123;</span><br><span class="line">        list    :       l,   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">push</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;<span class="comment">// 入栈方法</span></span><br><span class="line">    s.list = <span class="built_in">append</span>(s.list,val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;<span class="comment">// 出栈方法，返回出栈的元素</span></span><br><span class="line">    n := <span class="built_in">len</span>(s.list)</span><br><span class="line">    old := s.list</span><br><span class="line">    last := old[n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        s.list = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s.list = old[:n<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">len</span><span class="params">()</span> <span class="title">int</span></span> &#123;<span class="comment">// 计算栈的容量的方法</span></span><br><span class="line">    n := <span class="built_in">len</span>(s.list)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其实这有点类似前文<a href="https://jiahaohong1997.github.io/tags/LFU/">LFU算法</a>，注意 <code>freqToVal</code> 中 <code>val</code> 列表用一个栈实现，如果一个 <code>freq</code> 对应的元素有多个，根据栈的特点，可以首先取出最近添加的元素。</p><p>要记住在 <code>push</code> 和 <code>pop</code> 方法中同时修改 <code>maxFreq</code>、<code>VF</code> 表、<code>FV</code> 表，否则容易出现 bug。</p><h2 id="Push方法"><a href="#Push方法" class="headerlink" title="Push方法"></a><code>Push</code>方法</h2><p>现在，我们可以来实现 <code>push</code> 方法了。</p><p>我们要分别实现对<code>FreqStack</code>结构体中三个元素的更新。</p><ul><li><code>valToFreq(VF表)</code>：如果<code>val</code>对应的映射存在，则映射到的值加1；如果不存在，则初始为1；</li><li><code>freqToVal(FV表)</code>：如果新加入的<code>val</code>对应的新的<code>freq</code>在<code>FV</code>表中没有初始化的栈，则创建一个新栈，将该<code>val</code>入栈；否则直接入栈；</li><li><code>maxFreq</code>：比较新的<code>freq</code>与原始的<code>maxFreq</code>，取大者作为<code>maxFreq</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FreqStack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> freq <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改vf表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.valToFreq[val]; !ok &#123;</span><br><span class="line">        this.valToFreq[val] = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.valToFreq[val]++</span><br><span class="line">    &#125;</span><br><span class="line">    freq = this.valToFreq[val]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改fv表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToVal[freq]; !ok &#123;</span><br><span class="line">        this.freqToVal[freq] = constructorStack()</span><br><span class="line">        this.freqToVal[freq].push(val)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.freqToVal[freq].push(val)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改最大频数</span></span><br><span class="line">    <span class="keyword">if</span> freq &gt; this.maxFreq &#123;</span><br><span class="line">        this.maxFreq = freq</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pop-方法"><a href="#Pop-方法" class="headerlink" title="Pop()方法"></a><code>Pop()</code>方法</h2><p>我们要分别实现对<code>FreqStack</code>结构体中三个元素的更新。</p><ul><li><code>freqToVal(FV表)</code>：找到<code>maxFreq</code>在<code>FV</code>表中的映射，如果映射到的<code>stack</code>容量为1(说明只有一个数的频率是<code>maxFreq</code>)，则将<code>maxFreq</code>减一并将栈顶元素出栈；否则直接将栈顶元素出栈；</li><li><code>valToFreq(VF表)</code>：找到出栈元素对应的<code>VF</code>表的映射（代表其出现频率），将其直接减一；</li><li><code>maxFreq</code>：已经在修改<code>FV</code>表时进行了选择性的修改，不做特殊操作。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FreqStack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.maxFreq == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> popNum <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改fv表</span></span><br><span class="line">    freq := this.maxFreq</span><br><span class="line">    <span class="keyword">if</span> this.freqToVal[freq].<span class="built_in">len</span>() == <span class="number">1</span> &#123;</span><br><span class="line">        popNum = this.freqToVal[freq].pop()</span><br><span class="line">        this.maxFreq--      <span class="comment">// 修改最大频数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        popNum = this.freqToVal[freq].pop() </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改vf表</span></span><br><span class="line">    this.valToFreq[popNum]--</span><br><span class="line">    <span class="keyword">return</span> popNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>完整的最大栈实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    list        []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">push</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s.list = <span class="built_in">append</span>(s.list,val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s.list)</span><br><span class="line">    old := s.list</span><br><span class="line">    last := old[n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        s.list = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s.list = old[:n<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s.list)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorStack</span><span class="params">()</span> *<span class="title">stack</span></span> &#123;</span><br><span class="line">    l := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;stack&#123;</span><br><span class="line">        list    :       l,   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FreqStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    maxFreq     <span class="keyword">int</span>     <span class="comment">// 出现最大频数的记录</span></span><br><span class="line">    valToFreq   <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">    freqToVal   <span class="keyword">map</span>[<span class="keyword">int</span>]*stack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">FreqStack</span></span> &#123;</span><br><span class="line">    mf := <span class="number">0</span></span><br><span class="line">    vf := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    fv := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*stack,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> FreqStack&#123;</span><br><span class="line">        maxFreq     :       mf,</span><br><span class="line">        valToFreq   :       vf,</span><br><span class="line">        freqToVal   :       fv,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FreqStack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> freq <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改vf表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.valToFreq[val]; !ok &#123;</span><br><span class="line">        this.valToFreq[val] = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.valToFreq[val]++</span><br><span class="line">    &#125;</span><br><span class="line">    freq = this.valToFreq[val]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改fv表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToVal[freq]; !ok &#123;</span><br><span class="line">        this.freqToVal[freq] = constructorStack()</span><br><span class="line">        this.freqToVal[freq].push(val)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.freqToVal[freq].push(val)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改最大频数</span></span><br><span class="line">    <span class="keyword">if</span> freq &gt; this.maxFreq &#123;</span><br><span class="line">        this.maxFreq = freq</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FreqStack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.maxFreq == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> popNum <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改fv表</span></span><br><span class="line">    freq := this.maxFreq</span><br><span class="line">    <span class="keyword">if</span> this.freqToVal[freq].<span class="built_in">len</span>() == <span class="number">1</span> &#123;</span><br><span class="line">        popNum = this.freqToVal[freq].pop()</span><br><span class="line">        this.maxFreq--      <span class="comment">// 修改最大频数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        popNum = this.freqToVal[freq].pop() </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改vf表</span></span><br><span class="line">    this.valToFreq[popNum]--</span><br><span class="line">    <span class="keyword">return</span> popNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FreqStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(val);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Pop();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最大栈介绍&quot;&gt;&lt;a href=&quot;#最大栈介绍&quot; class=&quot;headerlink&quot; title=&quot;最大栈介绍&quot;&gt;&lt;/a&gt;最大栈介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;直接参考Leetcode上895题：&lt;a class=&quot;link&quot; href=&quot;https:</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="最大栈" scheme="http://jiahaohong1997.github.io/tags/%E6%9C%80%E5%A4%A7%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的序列化和反序列化</title>
    <link href="http://jiahaohong1997.github.io/2021/10/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://jiahaohong1997.github.io/2021/10/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-10-02T09:19:00.000Z</published>
    <updated>2022-01-05T03:08:35.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列化的目的"><a href="#序列化的目的" class="headerlink" title="序列化的目的"></a>序列化的目的</h1><p>&emsp;&emsp;JSON 的运用非常广泛，比如我们经常将变成语言中的结构体序列化成 JSON 字符串，存入缓存或者通过网络发送给远端服务，消费者接受 JSON 字符串然后进行反序列化，就可以得到原始数据了。这就是「序列化」和「反序列化」的目的，以某种固定格式组织字符串，使得数据可以独立于编程语言。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><a class="link" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化<i class="fas fa-external-link-alt"></i></a></p><p>&emsp;&emsp;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>&emsp;&emsp;请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示:</strong> 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="serdeser.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,null,null,4,5]</span><br><span class="line">输出：[1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 104]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>&emsp;&emsp;我们可以用 <code>serialize</code> 方法将二叉树序列化成字符串，用 <code>deserialize</code> 方法将序列化的字符串反序列化成二叉树，至于以什么格式序列化和反序列化，这个完全由你决定。比如说输入如下这样一棵二叉树：</p><p><img lazyload src="/images/loading.svg" data-src="%E5%9B%BE%E7%AE%97%E6%B3%95/2.jpg" alt="avatar"></p><p>&emsp;&emsp;<code>serialize</code> 方法也许会把它序列化成字符串 <code>2,1,#,6,3,#,#</code>，其中 <code>#</code> 表示 <code>null</code> 指针，那么把这个字符串再输入 <code>deserialize</code> 方法，依然可以还原出这棵二叉树。也就是说，这两个方法会成对儿使用，你只要保证他俩能够自洽就行了。</p><p>&emsp;&emsp;想象一下，二叉树结该是一个二维平面内的结构，而序列化出来的字符串是一个线性的一维结构。<strong>所谓的序列化不过就是把结构化的数据「打平」，其实就是在考察二叉树的遍历方式</strong>。</p><p>&emsp;&emsp;二叉树的遍历方式有哪些？递归遍历方式有前序遍历，中序遍历，后序遍历；迭代方式一般是层级遍历。本文就把这些方式都尝试一遍，来实现 <code>serialize</code> 方法和 <code>deserialize</code> 方法。</p><h2 id="结构体构造"><a href="#结构体构造" class="headerlink" title="结构体构造"></a>结构体构造</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Codec <span class="keyword">struct</span> &#123;</span><br><span class="line">    s       <span class="keyword">string</span></span><br><span class="line">    null    <span class="keyword">string</span></span><br><span class="line">    sep     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">Codec</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Codec&#123;</span><br><span class="line">        null    :   <span class="string">&quot;#&quot;</span>,  <span class="comment">// 空节点</span></span><br><span class="line">        sep     :   <span class="string">&quot;,&quot;</span>,  <span class="comment">// 分隔符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>&emsp;&emsp;如下二叉树（<code>#</code> 代表空指针 null），可以直观看出前序遍历做的事情：</p><p><img lazyload src="/images/loading.svg" data-src="%E5%9B%BE%E7%AE%97%E6%B3%95/1.jpg" alt="avatar"></p><p>&emsp;&emsp;那么 <code>res = [1,2,-1,4,-1,-1,3,-1,-1]</code>，这就是将二叉树「打平」到了一个列表中，其中 -1 代表 null。</p><p>那么，将二叉树打平到一个字符串中也是完全一样的，至此，我们已经可以写出序列化函数 <code>serialize</code> 的代码了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serializes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">serialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        this.s = this.s + this.null + this.sep</span><br><span class="line">        <span class="keyword">return</span> this.s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node := strconv.Itoa(root.Val)</span><br><span class="line">    this.s = this.s + node + this.sep</span><br><span class="line">    this.serialize(root.Left)</span><br><span class="line">    this.serialize(root.Right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> this.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在，思考一下如何写 <code>deserialize</code> 函数，将字符串反过来构造二叉树。首先我们可以把字符串转化成列表：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.s = <span class="string">&quot;1,2,#,4,#,#,3,#,#,&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一般语境下，单单前序遍历结果是不能还原二叉树结构的，因为缺少空指针的信息，至少要得到前、中、后序遍历中的两种才能还原二叉树。但是这里的 <code>node</code>列表包含空指针的信息，所以只使用 <code>node</code> 列表就可以还原二叉树。那么，反序列化过程也是一样，<strong>先确定根节点 <code>root</code>，然后遵循前序遍历的规则，递归生成左右子树即可</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deserializes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">deserialize</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>) </span><br><span class="line">    j := <span class="number">0</span></span><br><span class="line">    f := <span class="number">0</span></span><br><span class="line">    x := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> data[i] == <span class="string">&#x27;,&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;#&#x27;</span> &#123;<span class="comment">// 当前节点是空指针</span></span><br><span class="line">            m = <span class="built_in">append</span>(m,math.MinInt32)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;-&#x27;</span> &#123;<span class="comment">// 当前节点是负值</span></span><br><span class="line">            <span class="keyword">for</span> j = i+<span class="number">1</span>; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span>+x</span><br><span class="line">            &#125;           </span><br><span class="line">            m = <span class="built_in">append</span>(m,<span class="number">-1</span>*f)</span><br><span class="line">            i = j</span><br><span class="line">            f = <span class="number">0</span> </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j = i; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span>+x</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            m = <span class="built_in">append</span>(m,f)</span><br><span class="line">            i = j</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(&amp;m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(m *[]<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(*m) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 列表最左侧就是根节点</span></span><br><span class="line">    first := (*m)[<span class="number">0</span>]</span><br><span class="line">    *m = (*m)[<span class="number">1</span>:]<span class="comment">// 引用全局变量进行操作，就不会随递归栈进行变化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> first == math.MinInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    root := &amp;TreeNode&#123;first,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">    root.Left = helper(m)</span><br><span class="line">    root.Right = helper(m)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><p>&emsp;&emsp;明白了前序遍历的解法，后序遍历就比较容易理解了，我们首先实现 <code>serialize</code> 序列化方法，只需要稍微修改辅助方法即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">serialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        this.s = this.s + this.null + this.sep</span><br><span class="line">        <span class="keyword">return</span> this.s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.serialize(root.Left)</span><br><span class="line">    this.serialize(root.Right)</span><br><span class="line"></span><br><span class="line">    x := strconv.Itoa(root.Val)</span><br><span class="line">    this.s = this.s + x + this.sep</span><br><span class="line">    <span class="keyword">return</span> this.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;后序遍历导致结果的顺序发生变化：</p><p><img lazyload src="/images/loading.svg" data-src="postorder.jpg" alt="avatar"></p><p>&emsp;&emsp;关键的难点在于，如何实现后序遍历的 <code>deserialize</code> 方法呢？是不是也简单地将关键代码放到后序遍历的位置就行了呢？**<code>deserialize</code> 方法首先寻找 <code>root</code> 节点的值，然后递归计算左右子节点<strong>。那么我们这里也应该顺着这个基本思路走，后续遍历中，<code>root</code> 节点的值能不能找到？<code>root</code> 的值是列表的最后一个元素。我们应该从后往前取出列表元素，先用最后一个元素构造 <code>root</code>，然后递归调用生成 <code>root</code> 的左右子树。</strong>注意，根据上图，从后往前在 <code>nodes</code> 列表中取元素，一定要先构造 <code>root.right</code> 子树，后构造 <code>root.left</code> 子树**。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">deserialize</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(data);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> data[i] == <span class="string">&#x27;,&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;#&#x27;</span> &#123;</span><br><span class="line">            m = <span class="built_in">append</span>(m,math.MinInt32)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;-&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j=i+<span class="number">1</span>; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span> + x</span><br><span class="line">            &#125;</span><br><span class="line">            m = <span class="built_in">append</span>(m,<span class="number">-1</span>*f)</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">            i = j</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j=i; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span> + x</span><br><span class="line">            &#125;</span><br><span class="line">            m = <span class="built_in">append</span>(m,f)</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">            i = j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(&amp;m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(m *[]<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(*m) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n := <span class="built_in">len</span>(*m)</span><br><span class="line">    last := (*m)[n<span class="number">-1</span>]</span><br><span class="line">    *m = (*m)[:n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> last == math.MinInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    root := &amp;TreeNode&#123;</span><br><span class="line">        Val     :       last,</span><br><span class="line">        Left    :       <span class="literal">nil</span>,</span><br><span class="line">        Right   :       <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    root.Right = helper(m)<span class="comment">//一定要先构造 root.right 子树</span></span><br><span class="line">    root.Left = helper(m)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历-不能实现"><a href="#中序遍历-不能实现" class="headerlink" title="中序遍历(不能实现)"></a>中序遍历(不能实现)</h2><p>&emsp;&emsp;先说结论，中序遍历的方式行不通，因为无法实现反序列化方法 <code>deserialize</code>。</p><p>&emsp;&emsp;序列化方法 <code>serialize</code> 依然容易，只要把字符串的拼接操作放到中序遍历的位置就行了。但是，我们刚才说了，要想实现反序列方法，首先要构造 <code>root</code> 节点。前序遍历得到的 <code>nodes</code> 列表中，第一个元素是 <code>root</code> 节点的值；后序遍历得到的 <code>nodes</code> 列表中，最后一个元素是 <code>root</code> 节点的值。</p><p>&emsp;&emsp;而中序遍历的<code>root</code> 的值被夹在两棵子树的中间，也就是在 <code>nodes</code> 列表的中间，我们不知道确切的索引位置，所以无法找到 <code>root</code> 节点，也就无法进行反序列化。</p><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>序列化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">serialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        this.s = this.s + this.null + this.sep</span><br><span class="line">        <span class="keyword">return</span> this.s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    nodeNum := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; nodeNum&gt;<span class="number">0</span>; i++ &#123;</span><br><span class="line">        p := []*TreeNode&#123;&#125;</span><br><span class="line">        nodeNum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(q); j++ &#123;</span><br><span class="line">            node := q[j]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">                this.s = this.s + this.null + this.sep</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            this.s = this.s + strconv.Itoa(node.Val) + this.sep</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                nodeNum++</span><br><span class="line">                p = <span class="built_in">append</span>(p,node.Left)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p,<span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                nodeNum++</span><br><span class="line">                p = <span class="built_in">append</span>(p,node.Right)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p,<span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层级遍历序列化得出的结果如下图：</p><p><img lazyload src="/images/loading.svg" data-src="%E5%9B%BE%E7%AE%97%E6%B3%95/3.jpg" alt="avatar"></p><p>&emsp;&emsp;可以看到，每一个非空节点都会对应两个子节点，<strong>那么反序列化的思路也是用队列进行层级遍历，同时用索引 <code>i</code> 记录对应子节点的位置</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">deserialize</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(data);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> data[i] == <span class="string">&#x27;,&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;#&#x27;</span> &#123;</span><br><span class="line">            m = <span class="built_in">append</span>(m,math.MinInt32)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;-&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j=i+<span class="number">1</span>; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span> + x</span><br><span class="line">            &#125;</span><br><span class="line">            m = <span class="built_in">append</span>(m,<span class="number">-1</span>*f)</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">            i = j</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j=i; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span> + x</span><br><span class="line">            &#125;</span><br><span class="line">            m = <span class="built_in">append</span>(m,f)</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">            i = j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(m []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(m) == <span class="number">0</span> || m[<span class="number">0</span>] == math.MinInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root := &amp;TreeNode&#123;m[<span class="number">0</span>],<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(m); &#123;</span><br><span class="line">        parent := q[<span class="number">0</span>]</span><br><span class="line">        q = q[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> m[i] != math.MinInt32 &#123;<span class="comment">// 左子树</span></span><br><span class="line">            parent.Left = &amp;TreeNode&#123;m[i],<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">            q = <span class="built_in">append</span>(q,parent.Left)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.Left = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> m[i] != math.MinInt32 &#123;<span class="comment">// 右子树</span></span><br><span class="line">            parent.Right = &amp;TreeNode&#123;m[i],<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">            q = <span class="built_in">append</span>(q,parent.Right)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.Right = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;序列化的目的&quot;&gt;&lt;a href=&quot;#序列化的目的&quot; class=&quot;headerlink&quot; title=&quot;序列化的目的&quot;&gt;&lt;/a&gt;序列化的目的&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;JSON 的运用非常广泛，比如我们经常将变成语言中的结构体序列化成 JSON 字符串</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="二叉树" scheme="http://jiahaohong1997.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>堆的Go语言实现</title>
    <link href="http://jiahaohong1997.github.io/2021/09/27/%E5%A0%86%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
    <id>http://jiahaohong1997.github.io/2021/09/27/%E5%A0%86%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-09-27T07:07:00.000Z</published>
    <updated>2022-01-05T03:08:36.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆的简介"><a href="#堆的简介" class="headerlink" title="堆的简介"></a>堆的简介</h1><p>&emsp;&emsp;首先，堆和二叉树有啥关系呢，为什么人们总数把堆画成一棵二叉树？因为，堆在逻辑上其实是一种特殊的二叉树<strong>（完全二叉树）</strong>，只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针：</p><p>&emsp;&emsp;画个图你立即就能理解了，比如 <code>arr</code> 是一个字符数组，注意数组的第一个索引 0 空着不用：</p><p><img lazyload src="/images/loading.svg" data-src="2.png" alt="avatar"></p><p>&emsp;&emsp;因为这棵二叉树是<font color="red">「完全二叉树」</font>，所以把 <code>arr[1]</code> 作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。</p><p>&emsp;&emsp;为了方便讲解，下面都会画的图都是二叉树结构，相信你能把树和数组对应起来。二叉堆还分为最大堆和最小堆。<strong>最大堆的性质是：每个节点都大于等于它的两个子节点。</strong>类似的，最小堆的性质是：每个节点都小于等于它的子节点。</p><h1 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h1><p>&emsp;&emsp;在Go语言的标准库<code>container/heap</code>中，实现了二叉堆，我们先来看看这个包下面有什么内容。</p><ol><li>接口定义</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这个堆结构继承自 sort.Interface, 回顾下 <a href="https://jiahaohong1997.github.io/2021/06/10/%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89sort%E5%87%BD%E6%95%B0/">sort.Interface</a>，它需要实现三个方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">Len() <span class="keyword">int</span></span><br><span class="line">Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上堆接口定义的两个方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(h Interface, x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span> <span class="title">interface</span></span>&#123;&#125; &#123;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说，要实现一个堆需要完整实现上述5个方法。</p><ol start="2"><li>上浮<code>up</code>和下沉<code>down</code>方法</li></ol><p>&emsp;&emsp;我们要讲的是最小堆，每个节点都比它的两个子节点小，但是在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。</p><p>&emsp;&emsp;对于最小堆，会破坏堆性质的有有两种情况：</p><ul><li><code>down</code>：如果某个节点 A 比它的子节点（中的一个）大，那么 A 就不配做父节点，应该下去，下面那个更小的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">down</span><span class="params">(h Interface, i0, n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">i := i0</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">j1 := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> j1 &gt;= n || j1 &lt; <span class="number">0</span> &#123; <span class="comment">// j1 &lt; 0 after int overflow</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">j := j1 <span class="comment">// left child</span></span><br><span class="line"><span class="keyword">if</span> j2 := j1 + <span class="number">1</span>; j2 &lt; n &amp;&amp; h.Less(j2, j1) &#123;</span><br><span class="line">j = j2 <span class="comment">// = 2*i + 2  // right child</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !h.Less(j, i) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">h.Swap(i, j)</span><br><span class="line">i = j</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i &gt; i0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>up</code>：如果某个节点 A 比它的父节点小，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">up</span><span class="params">(h Interface, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i := (j - <span class="number">1</span>) / <span class="number">2</span> <span class="comment">// parent</span></span><br><span class="line"><span class="keyword">if</span> i == j || !h.Less(j, i) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">h.Swap(i, j)</span><br><span class="line">j = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然，错位的节点 A 可能要上浮（或下沉）很多次，才能到达正确的位置，恢复堆的性质。所以代码中肯定有一个 <code>for</code> 循环。</p><ul><li><code>fix</code>：当堆中某一节点的值发生改变后，要对其进行<strong>上浮</strong>或<strong>下沉</strong>操作</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fix</span><span class="params">(h Interface, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !down(h, i, h.Len()) &#123;</span><br><span class="line">up(h, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>初始化结构体（建堆）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(h Interface)</span></span> &#123;</span><br><span class="line"><span class="comment">// heapify</span></span><br><span class="line">n := h.Len()</span><br><span class="line"><span class="keyword">for</span> i := n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">down(h, i, n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可见，在Go语言中是以<code>0</code>为首开始存储的，所以对于这歌满二叉树，索引为<code>x</code>的节点左子树索引为<code>2*x+1</code>，右子树为<code>2*x+2</code>。</p><ol start="4"><li>堆的增，出堆和删操作</li></ol><ul><li>增<code>Push</code></li></ul><p>&emsp;&emsp;当在当前堆中增加元素时，先在队列的最末尾处（完全二叉树的最后一个节点）将其插入，然后再利用<strong>上浮</strong>操作调整其位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Push pushes the element x onto the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(h Interface, x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    h.Push(x)<span class="comment">// h.Push(x)是外层实体的方法，与本方法不相同</span></span><br><span class="line">up(h, h.Len()<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>出堆<code>Pop</code></li></ul><p>&emsp;&emsp;堆的Pop操作是先将堆顶元素与最后一个元素交换位置，然后再将交换后的堆顶元素<strong>下沉</strong>到属于它的位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pop removes and returns the minimum element (according to Less) from the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="comment">// Pop is equivalent to Remove(h, 0).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">n := h.Len() - <span class="number">1</span></span><br><span class="line">h.Swap(<span class="number">0</span>, n)</span><br><span class="line">down(h, <span class="number">0</span>, n)</span><br><span class="line">    <span class="keyword">return</span> h.Pop()<span class="comment">// 这里的h.Pop()是用户自己定义的方法，以上部分操作都只负责将堆顶元素放到末尾并使堆保持其规则，最后这一行是用户自己对实体的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除任意节点<code>Remove</code></li></ul><p>&emsp;&emsp;删除任意节点的索引为<code>i</code>，将其与最后一个节点调换位置，然后将调换到索引<code>i</code>处的节点<strong>下沉</strong>到属于它的位置。特别的：出堆操作就是删除最后一个节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove removes and returns the element at index i from the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(h Interface, i <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">n := h.Len() - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> n != i &#123;</span><br><span class="line">h.Swap(i, n)</span><br><span class="line"><span class="keyword">if</span> !down(h, i, n) &#123;</span><br><span class="line">up(h, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> h.Pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现int类型的堆"><a href="#实现int类型的堆" class="headerlink" title="实现int类型的堆"></a>实现int类型的堆</h1><p>&emsp;&emsp;在官方文档给的示例中<a class="link" href="https://github1s.com/golang/go/blob/master/src/container/heap/example_intheap_test.go">example_intheap_test.go<i class="fas fa-external-link-alt"></i></a>，介绍了怎么通过调用heap包来实现int类型的二叉堆。我们来看看其具体的实现流程。</p><ol><li>定义一个新的类型，实现五个固定的方法</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;<span class="comment">// 小端堆用&lt;，大端堆则反过来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;<span class="comment">// 增添一个新元素</span></span><br><span class="line"><span class="comment">// Push and Pop use pointer receivers because they modify the slice&#x27;s length,</span></span><br><span class="line"><span class="comment">// not just its contents.</span></span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;<span class="comment">// 推出最后一个元素</span></span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>完整代码</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2012 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This example demonstrates an integer heap built using the heap interface.</span></span><br><span class="line"><span class="keyword">package</span> heap_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// Push and Pop use pointer receivers because they modify the slice&#x27;s length,</span></span><br><span class="line"><span class="comment">// not just its contents.</span></span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example inserts several ints into an IntHeap, checks the minimum,</span></span><br><span class="line"><span class="comment">// and removes them in order of priority.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example_intHeap</span><span class="params">()</span></span> &#123;</span><br><span class="line">h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">heap.Init(h)<span class="comment">// 初始化这个堆，此时堆已经建好了</span></span><br><span class="line">heap.Push(h, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;minimum: %d\n&quot;</span>, (*h)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, heap.Pop(h))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// minimum: 1</span></span><br><span class="line"><span class="comment">// 1 2 3 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>&emsp;&emsp;在<code>/src/container/heap/example_pq_test.go</code>文件中给出了使用堆实现一个优先队列的示例。不同于int类型的堆，可以直接根据元素的值的大小决定其优先级，优先队列中的每个元素需要通过一个<code>priority</code>变量设置各自的优先级。同时，还需要设置一个变量<code>index</code>来保持与队列中的索引号一致。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An Item is something we manage in a priority queue.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">    value<span class="keyword">string</span> <span class="comment">// The value of the item; arbitrary.</span></span><br><span class="line">    priority<span class="keyword">int</span> <span class="comment">// The priority of the item in the queue.</span></span><br><span class="line">    <span class="comment">// The index is needed by update and is maintained by the heap.Interface methods.</span></span><br><span class="line">    index<span class="keyword">int</span> <span class="comment">// The index of the item in the heap.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后就可以初始化一个堆了，我们要为这个优先队列设立<code>Len()</code>、<code>Swap()</code>、<code>Less()</code>三个方法使其先变成一个<code>sort.Interface</code>类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A PriorityQueue implements heap.Interface and holds Items.</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(pq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">    pq[i].index = i</span><br><span class="line">    pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// We want Pop to give us the highest, not lowest, priority so we use greater than here.</span></span><br><span class="line">    <span class="keyword">return</span> pq[i].priority &gt; pq[j].priority</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后就是经典的<code>Push()</code>和<code>Pop()</code>方法的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(*pq)</span><br><span class="line">    item := x.(*Item)</span><br><span class="line">    item.index = n</span><br><span class="line">    *pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *pq</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    item := old[n<span class="number">-1</span>]</span><br><span class="line">    old[n<span class="number">-1</span>] = <span class="literal">nil</span><span class="comment">// avoid memory leak</span></span><br><span class="line">    item.index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">    *pq = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当某一个节点的值或优先级发生改变时，再实现一个<code>update</code>方法来调整优先队列的顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">update</span><span class="params">(item *Item, value, priority)</span></span> &#123;</span><br><span class="line">    item.value = value</span><br><span class="line">    item.priority = priority</span><br><span class="line">    heap.fix(pq, item.index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;完整的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> heap_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An Item is something we manage in a priority queue.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">    value<span class="keyword">string</span><span class="comment">// The value of the item; arbitrary.</span></span><br><span class="line">    priority<span class="keyword">int</span><span class="comment">// The priority of the item in the queue.</span></span><br><span class="line">    <span class="comment">// The index is needed by update and is maintained by the heap.Interface methods.</span></span><br><span class="line">    index<span class="keyword">int</span><span class="comment">// The index of the item in the heap.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A PriorityQueue implements heap.Interface and holds Items.</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(pq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">    pq[i].index = i</span><br><span class="line">    pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// We want Pop to give us the highest, not lowest, priority so we use greater than here.</span></span><br><span class="line">    <span class="keyword">return</span> pq[i].priority &gt; pq[j].priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(*pq)</span><br><span class="line">    item := x.(*Item)</span><br><span class="line">    item.index = n</span><br><span class="line">    *pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *pq</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    item := old[n<span class="number">-1</span>]</span><br><span class="line">    old[n<span class="number">-1</span>] = <span class="literal">nil</span><span class="comment">// avoid memory leak</span></span><br><span class="line">    item.index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">    *pq = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">update</span><span class="params">(item *Item, value, priority)</span></span> &#123;</span><br><span class="line">    item.value = value</span><br><span class="line">    item.priority = priority</span><br><span class="line">    heap.fix(pq, item.index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// This example creates a PriorityQueue with some items, adds and manipulates an item,</span></span><br><span class="line"><span class="comment">// and then removes the items in priority order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example_priorityQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Some items and their priorities.</span></span><br><span class="line">items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">&quot;banana&quot;</span>: <span class="number">3</span>, <span class="string">&quot;apple&quot;</span>: <span class="number">2</span>, <span class="string">&quot;pear&quot;</span>: <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create a priority queue, put the items in it, and</span></span><br><span class="line">    <span class="comment">// establish the priority queue (heap) invariants.</span></span><br><span class="line">    pq := <span class="built_in">make</span>(PriorityQueue,<span class="built_in">len</span>(items))</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> value, priority := <span class="keyword">range</span> items &#123;</span><br><span class="line">        pq[i] = &amp;Items &#123;</span><br><span class="line">            value:value,</span><br><span class="line">            priority:priority,</span><br><span class="line">            index:i,</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    heap.Init(&amp;pq)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Insert a new item and then modify its priority.</span></span><br><span class="line">    item := &amp;Item&#123;</span><br><span class="line">        value:    <span class="string">&quot;orange&quot;</span>,</span><br><span class="line">        priority: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    heap.Push(&amp;pq, item)</span><br><span class="line">    pq.update(item, item.value, <span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Take the items out; they arrive in decreasing priority order.</span></span><br><span class="line">    <span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        item := heap.Pop(&amp;pq).(*Item)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%.2d:%s &quot;</span>, item.priority, item.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// 05:orange 04:pear 03:banana 02:apple</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LeetCode经典题目"><a href="#LeetCode经典题目" class="headerlink" title="LeetCode经典题目"></a>LeetCode经典题目</h1><h2 id="实现一个优先队列"><a href="#实现一个优先队列" class="headerlink" title="实现一个优先队列"></a>实现一个优先队列</h2><p>&emsp;&emsp;优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。 优先队列往往用堆来实现。我们在上一节实现了一个int类型的堆，它的排序规则是直接根据存入的数据的值来决定的。对于优先队列而言，我们存入的数据可能是一个切片的索引数组，其排序规则是该切片的值的大小，只不过体现在堆中，存入的是其索引。这样我们就可以通过其索引控制出入优先队列是时机，并保证能够适时地得到堆顶的值。如下图所示：</p><p><img lazyload src="/images/loading.svg" data-src="%E5%9B%BE%E7%AE%97%E6%B3%95/1.jpg" alt="avatar"></p><p>&emsp;&emsp;接下来我们来看一道很经典的题。</p><p><a class="link" href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值<i class="fas fa-external-link-alt"></i></a></p><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,-1], k &#x3D; 1</span><br><span class="line">输出：[1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [9,11], k &#x3D; 2</span><br><span class="line">输出：[11]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,-2], k &#x3D; 2</span><br><span class="line">输出：[4]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= nums.length &lt;= 105</code></p></li><li><p><code>-104 &lt;= nums[i] &lt;= 104</code></p></li><li><p><code>1 &lt;= k &lt;= nums.length</code></p></li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;由于每次都要找到最大值，很自然的想到一种数据结构：<strong>优先队列（堆）</strong>，其中的大根堆可以帮助我们实时维护一系列元素中的最大值。</p><p>&emsp;&emsp;对于本题而言，初始时，我们使用数组 <code>nums</code> 的前 <code>k</code> 个元素的索引初始化大根堆，堆中索引的排序规则是数组 <code>nums</code> 的大小所决定。每当我们向右移动窗口时，我们就可以把一个新的元素的索引放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。我们在什么情况下出堆呢？每次有新元素入堆时，我们都要先判断一下位于堆顶的索引是否<code>&lt;=新入堆元素索引-k</code>。如果条件成立，则执行出堆操作，直到堆顶元素的索引在滑动窗口的范围内。</p><p>&emsp;&emsp;本题可以学习到的很重要的一个技巧就是出堆的操作可以不用着急，可以根据题目的实际需求，判断堆顶元素的索引是否符合当前选择范围再统一执行出堆操作，直到堆顶元素代表的索引在要求的范围内。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a[h[i]] &gt; a[h[j]]<span class="comment">// 排序规则不是索引大小，而是数组元素的值的大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    v := old[<span class="built_in">len</span>(old)<span class="number">-1</span>]</span><br><span class="line">    h = old[:<span class="built_in">len</span>(old)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    a = nums</span><br><span class="line">    <span class="keyword">var</span> h IntHeap</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;k; i++ &#123;</span><br><span class="line">        h = <span class="built_in">append</span>(h,i)</span><br><span class="line">    &#125;</span><br><span class="line">    heap.Init(&amp;h)<span class="comment">// 初始化堆</span></span><br><span class="line">    </span><br><span class="line">    ret := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">1</span>)</span><br><span class="line">    ret[<span class="number">0</span>] = a[h[<span class="number">0</span>]]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=k; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        heap.Push(&amp;h, i.(<span class="keyword">int</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> h[<span class="number">0</span>] &lt;= i-k &#123;<span class="comment">// 判断堆顶索引对应的元素是否在滑动窗口中，不在则持续出堆</span></span><br><span class="line">            heap.Pop(&amp;h)</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, a[h[<span class="number">0</span>]])<span class="comment">// 堆顶元素在滑动窗口中，加入输出数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;堆的简介&quot;&gt;&lt;a href=&quot;#堆的简介&quot; class=&quot;headerlink&quot; title=&quot;堆的简介&quot;&gt;&lt;/a&gt;堆的简介&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;首先，堆和二叉树有啥关系呢，为什么人们总数把堆画成一棵二叉树？因为，堆在逻辑上其实是一种特殊的二叉树</summary>
      
    
    
    
    <category term="Go语言标准库" scheme="http://jiahaohong1997.github.io/categories/Go%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
    
    <category term="堆" scheme="http://jiahaohong1997.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>链表习题解析</title>
    <link href="http://jiahaohong1997.github.io/2021/09/24/%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    <id>http://jiahaohong1997.github.io/2021/09/24/%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/</id>
    <published>2021-09-24T12:10:00.000Z</published>
    <updated>2022-01-05T03:08:36.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表高频题目"><a href="#链表高频题目" class="headerlink" title="链表高频题目"></a>链表高频题目</h1><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a class="link" href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加<i class="fas fa-external-link-alt"></i></a></h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="addtwonumber1.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;本题很自然的就想到先将两个链表保存的数都转化成变量的形式存储下来，直接相加后再逐位用链表保存后输出。但是，在提交代码后，发现其中一个测试用例没有通过。原来是其中一个链表转换成数字变量后，它直接溢出了，导致出错。所以要完全AC这道题，这种方法肯定是不行的。</p><p>&emsp;&emsp;由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为<code>n1,n2</code>，进位值为<code>carry</code>，他们的和为<code>n1+n2+carry</code>，其中答案链表处相应位置的数字为<code>(n1+n2+carry)%10</code>，而新的进位值为<code>(n1+n2+carry)/10</code>。</p><p>&emsp;&emsp;如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0 。此外，如果链表遍历结束后，有 <code>carry&gt;0</code>，还需要在答案链表的后面附加一个节点，节点的值为 <code>carry</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    carry := <span class="number">0</span></span><br><span class="line">    v := <span class="number">0</span></span><br><span class="line">    h1 := l1<span class="comment">// 保存头节点</span></span><br><span class="line">    f1 := l1<span class="comment">// 记录前一节点，方便拼接</span></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;<span class="comment">// 当l1和l2都没有遍历到表尾</span></span><br><span class="line">        v = (l1.Val+l2.Val+carry)%<span class="number">10</span><span class="comment">// 值</span></span><br><span class="line">        carry = (l1.Val+l2.Val+carry)/<span class="number">10</span>   <span class="comment">//进位</span></span><br><span class="line">        l1.Val = v<span class="comment">//保存到l1中（直接替换掉这个位置节点的值）</span></span><br><span class="line">        f1 = l1<span class="comment">//f1跟进</span></span><br><span class="line">        l1 = l1.Next<span class="comment">//l1指向其Next</span></span><br><span class="line">        l2 = l2.Next<span class="comment">//l2指向其Next</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry != <span class="number">0</span> &#123;<span class="comment">// l1和l2等长且最后还有一位进位</span></span><br><span class="line">        f1.Next = &amp;ListNode&#123;<span class="comment">// 创造一个节点，其值为进位值</span></span><br><span class="line">            Val     :       carry,</span><br><span class="line">            Next    :       <span class="literal">nil</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;<span class="comment">//l1更长，处理完l1剩余的节点</span></span><br><span class="line">        <span class="keyword">for</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            v = (l1.Val+carry)%<span class="number">10</span></span><br><span class="line">            carry = (l1.Val+carry)/<span class="number">10</span>        </span><br><span class="line">            l1.Val = v</span><br><span class="line">            f1 = l1</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> carry != <span class="number">0</span> &#123;<span class="comment">//考虑最后是否有进位</span></span><br><span class="line">            f1.Next = &amp;ListNode&#123;</span><br><span class="line">                Val     :       carry,</span><br><span class="line">                Next    :       <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;<span class="comment">//l2更长，处理完l2剩余的节点</span></span><br><span class="line">        f1.Next = l2</span><br><span class="line">        <span class="keyword">for</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            v = (l2.Val+carry)%<span class="number">10</span></span><br><span class="line">            carry = (l2.Val+carry)/<span class="number">10</span>     </span><br><span class="line">            l2.Val = v</span><br><span class="line">            f1 = l2</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> carry != <span class="number">0</span> &#123;<span class="comment">//考虑最后是否有进位</span></span><br><span class="line">            f1.Next = &amp;ListNode&#123;</span><br><span class="line">                Val     :       carry,</span><br><span class="line">                Next    :       <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h1><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a class="link" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表<i class="fas fa-external-link-alt"></i></a></h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="merge_ex1.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><p>这题思路很简单，用下图就可以概括：</p><p><img lazyload src="/images/loading.svg" data-src="1.gif" alt="avatar"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    dummy := &amp;ListNode&#123;Val:<span class="number">0</span>,Next:<span class="literal">nil</span>,&#125;</span><br><span class="line">    tail := dummy</span><br><span class="line">    <span class="keyword">var</span> node *ListNode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l1.Val &lt;= l2.Val &#123;</span><br><span class="line">            node = &amp;ListNode&#123;</span><br><span class="line">                Val     :   l1.Val,</span><br><span class="line">                Next    :   <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = &amp;ListNode&#123;</span><br><span class="line">                Val     :   l2.Val,</span><br><span class="line">                Next    :   <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        tail.Next = node</span><br><span class="line">        tail = node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        tail.Next = l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        tail.Next = l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a class="link" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表<i class="fas fa-external-link-alt"></i></a></h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 升序 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;将每个链表的节点分别填充入最小堆中，就可以实现所有节点数值的升序排列。最小堆的实现参考我的另一篇文章<a href="https://jiahaohong1997.github.io/2021/09/27/%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/">二叉堆的Go语言实现</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h[i]&lt;h[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(*h)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    l := <span class="built_in">len</span>(lists)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    h := &amp;IntHeap&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;l; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> lists[i] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        node := lists[i]</span><br><span class="line">        <span class="keyword">for</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            *h = <span class="built_in">append</span>(*h, node.Val)</span><br><span class="line">            node = node.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> h.Len() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line"></span><br><span class="line">    head := &amp;ListNode&#123;</span><br><span class="line">        Val     :       (*h)[<span class="number">0</span>],</span><br><span class="line">        Next    :       <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    t := head</span><br><span class="line">    heap.Pop(h)</span><br><span class="line">    <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        x := heap.Pop(h).(<span class="keyword">int</span>)</span><br><span class="line">        node := &amp;ListNode&#123;</span><br><span class="line">            Val     :       x,</span><br><span class="line">            Next    :       <span class="literal">nil</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        t.Next = node</span><br><span class="line">        t = node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a class="link" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点<i class="fas fa-external-link-alt"></i></a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="remove_ex1.jpg" alt="avatat"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], n &#x3D; 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], n &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;这个逻辑就很简单了，要删除倒数第 <code>n</code> 个节点，就得获得倒数第 <code>n + 1</code> 个节点的引用，首先，我们先让一个指针 <code>p1</code> 指向链表的头节点 <code>head</code>，然后走 <code>k</code> 步：</p><p><img lazyload src="/images/loading.svg" data-src="%E5%9B%BE%E7%AE%97%E6%B3%95/1.jpg" alt="avatar"></p><p>现在的 <code>p1</code>，只要再走 <code>n - k</code> 步，就能走到链表末尾的空指针了对吧？</p><p>趁这个时候，再用一个指针 <code>p2</code> 指向链表头节点 <code>head</code>：</p><p><img lazyload src="/images/loading.svg" data-src="%E5%9B%BE%E7%AE%97%E6%B3%95/2.jpg" alt="avatar"></p><p>接下来就很显然了，让 <code>p1</code> 和 <code>p2</code> 同时向前走，<code>p1</code> 走到链表末尾的空指针时走了 <code>n - k</code> 步，<code>p2</code> 也走了 <code>n - k</code> 步，也就是链表的倒数第 <code>k</code> 个节点：</p><p><img lazyload src="/images/loading.svg" data-src="%E5%9B%BE%E7%AE%97%E6%B3%95/3.jpg" alt="avatar"></p><p>这样，只遍历了一次链表，就获得了倒数第 <code>k</code> 个节点 <code>p2</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    fast, slow := head, head</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;<span class="comment">//fast指向nil，说明n=链表的节点数，即删除第一个节点</span></span><br><span class="line">        <span class="keyword">return</span> head.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fast.Next != <span class="literal">nil</span> &#123;<span class="comment">// 定位到要删除节点的前一个节点</span></span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    slow.Next = slow.Next.Next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a class="link" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表<i class="fas fa-external-link-alt"></i></a></h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img lazyload src="/images/loading.svg" data-src="160_statement.png" alt="avatar"></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="160_example_1.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Intersected at &#39;8&#39;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img lazyload src="/images/loading.svg" data-src="160_example_2.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Intersected at &#39;2&#39;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img lazyload src="/images/loading.svg" data-src="160_example_3.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA </code>中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为<code>n</code></li><li><code>0 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA </code>和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果<code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;这个题直接的想法可能是用 <code>HashSet</code> 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间。</p><p>&emsp;&emsp;如果不用额外的空间，只使用两个指针，你如何做呢？难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：</p><p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/5.jpg" alt="avatar"></p><p>&emsp;&emsp;如果用两个指针 <code>p1</code> 和 <code>p2</code> 分别在两条链表上前进，并不能<strong>同时</strong>走到公共节点，也就无法得到相交节点 <code>c1</code>。</p><p>&emsp;&emsp;<strong>所以，解决这个问题的关键是，通过某些方式，让</strong> <strong><code>p1</code></strong> <strong>和</strong> <strong><code>p2</code></strong> <strong>能够同时到达相交节点</strong> **<code>c1</code>**。</p><p>&emsp;&emsp;所以，我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。如果这样进行拼接，就可以让 <code>p1</code> 和 <code>p2</code> 同时进入公共部分，也就是同时到达相交节点 <code>c1</code>：</p><p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/7.jpg" alt="avatar"></p><p>&emsp;&emsp;那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 <code>nil</code> 呢？这个逻辑可以覆盖这种情况的，相当于 <code>c1</code> 节点是 <code>nil</code> 空指针嘛，可以正确返回 <code>nil</code>。</p><p>按照这个思路，可以写出如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    a, b := headA, headB</span><br><span class="line">    <span class="keyword">for</span> a != b &#123;</span><br><span class="line">        <span class="keyword">if</span> a != <span class="literal">nil</span> &#123;</span><br><span class="line">            a = a.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a = headB</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> b != <span class="literal">nil</span> &#123;</span><br><span class="line">            b = b.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b = headA</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，这道题就解决了，空间复杂度为 <code>O(1)</code>，时间复杂度为 <code>O(N)</code>。</p><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="反转整个链表"><a href="#反转整个链表" class="headerlink" title="反转整个链表"></a>反转整个链表</h2><ul><li>递归</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;<span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    last := reverse(head.Next)</span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    first := head.Next.Next</span><br><span class="line">    second := head.Next</span><br><span class="line">    third := head</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> first != <span class="literal">nil</span> &#123;</span><br><span class="line">        second.Next = third</span><br><span class="line">        third = second</span><br><span class="line">        second = first</span><br><span class="line">        first = first.Next</span><br><span class="line">    &#125;</span><br><span class="line">    second.Next = third</span><br><span class="line">    <span class="keyword">return</span> second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表前n个节点"><a href="#反转链表前n个节点" class="headerlink" title="反转链表前n个节点"></a>反转链表前n个节点</h2><p>&emsp;&emsp;比如说对于下图链表，执行 <code>reverseN(head, 3)</code>：</p><p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/6.jpg" alt="avatar"></p><ul><li>递归</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> successor *ListNode<span class="comment">// 后驱节点</span></span><br><span class="line">successor = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseN</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        successor = head.Next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    last := reverseN(head.Next,n<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    head.Next = successor</span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseN</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    first := head.Next.Next</span><br><span class="line">    second := head.Next</span><br><span class="line">    third := head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;<span class="comment">// n=1,不需要翻转</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> &#123;<span class="comment">// n=2,直接翻转前两个节点即可</span></span><br><span class="line">        second.Next = third</span><br><span class="line">        third.Next = first</span><br><span class="line">        <span class="keyword">return</span> second</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> n<span class="number">-2</span> &gt; <span class="number">0</span> &#123;<span class="comment">// n&gt;2时的情况，结合上图来推一遍会比较清晰</span></span><br><span class="line">        second.Next = third</span><br><span class="line">        third = second</span><br><span class="line">        second = first</span><br><span class="line">        first = first.Next</span><br><span class="line">        n--</span><br><span class="line">    &#125;</span><br><span class="line">    second.Next = third</span><br><span class="line">    third.Next = first</span><br><span class="line">    <span class="keyword">return</span> second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表的一部分"><a href="#反转链表的一部分" class="headerlink" title="反转链表的一部分"></a>反转链表的一部分</h2><p>&emsp;&emsp;给一个索引区间 <code>[m,n]</code>（索引从 1 开始），仅仅反转区间中的链表元素。</p><ul><li>递归</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, m,n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">1</span> &#123;<span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">return</span> reverseN(head,n)<span class="comment">// 相当于反转前n个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">    head.Next = reverseBetween(head.Next, m<span class="number">-1</span>, n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代</li></ul><p><a class="link" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II<i class="fas fa-external-link-alt"></i></a></p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="rev2ex2.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4</span><br><span class="line">输出：[1,4,3,2,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [5], left &#x3D; 1, right &#x3D; 1</span><br><span class="line">输出：[5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目为 <code>n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>-500 &lt;= Node.val &lt;= 500</code></li><li><code>1 &lt;= left &lt;= right &lt;= n</code></li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;我们以下图中黄色区域的链表反转为例。</p><p><img lazyload src="/images/loading.svg" data-src="1615105129-iUPoGi-image.png" alt="avatar"></p><p>&emsp;&emsp;反转 <code>left</code> 到 <code>right</code> 部分以后，再拼接起来。我们还需要记录 <code>left</code>的前一个节点，和 <code>right</code> 的后一个节点。如图所示：</p><p><img lazyload src="/images/loading.svg" data-src="1615105150-pfWiGq-image.png" alt="avatar"></p><ul><li>第 1 步：先将待反转的区域反转；</li><li>第 2 步：把 pre 的 next 指针指向反转以后的链表头节点，把反转以后的链表的尾节点的 next 指针指向 succ</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    dummyNode := &amp;ListNode&#123;Val:<span class="number">-1</span>&#125;</span><br><span class="line">    dummyNode.Next = head</span><br><span class="line">    pre := dummyNode</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;left<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        pre = pre.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点</span></span><br><span class="line">    rightNode := pre</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; right-left+<span class="number">1</span>; i++ &#123;</span><br><span class="line">        rightNode = rightNode.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 3 步：切断出一个子链表（截取链表）</span></span><br><span class="line">    leftNode := pre.Next;</span><br><span class="line">    curr := rightNode.Next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：切断链接</span></span><br><span class="line">    pre.Next = <span class="literal">nil</span></span><br><span class="line">    rightNode.Next = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第4步：反转区间</span></span><br><span class="line">    reverse(leftNode)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 5 步：接回到原来的链表中</span></span><br><span class="line">    pre.Next = rightNode</span><br><span class="line">    leftNode.Next = curr</span><br><span class="line">    <span class="keyword">return</span> dummyNode.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何判断回文链表"><a href="#如何判断回文链表" class="headerlink" title="如何判断回文链表"></a>如何判断回文链表</h1><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a class="link" href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表<i class="fas fa-external-link-alt"></i></a></h2><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="pal1linked-list.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img lazyload src="/images/loading.svg" data-src="pal2linked-list.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围<code>[1, 105]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li></ul><p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p><p><strong>解题思路：</strong></p><p>&emsp;&emsp;最一般的做法是先用一个数组将整个链表存储下来，再从数组的两端向中间逼近来判断是否是回文串。进阶要求是用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题。</p><p>&emsp;&emsp;先通过快慢指针翻转后半部分链表（注意分情况讨论奇数和偶数）。然后翻转后半部分链表（如果是奇数链表，slow指针还要再走一步），最后通过比较前后两部分来判断是否是回文链表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fast, slow := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;<span class="comment">// 找到链表的中间位置</span></span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;  <span class="comment">// 偶数串，slow指向后半部分的第一个节点处</span></span><br><span class="line">        backHead := reverse(slow)</span><br><span class="line">        <span class="keyword">for</span> backHead != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> backHead.Val != head.Val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            backHead = backHead.Next</span><br><span class="line">            head = head.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 奇数串，slow指向前后两段的正中间</span></span><br><span class="line">        slow = slow.Next</span><br><span class="line">        backHead := reverse(slow)</span><br><span class="line">        <span class="keyword">for</span> backHead != <span class="literal">nil</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> backHead.Val != head.Val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            backHead = backHead.Next</span><br><span class="line">            head = head.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    pre, cur := head, head.Next</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        nxt := cur.Next</span><br><span class="line">        cur.Next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = nxt</span><br><span class="line">    &#125;</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表高频题目&quot;&gt;&lt;a href=&quot;#链表高频题目&quot; class=&quot;headerlink&quot; title=&quot;链表高频题目&quot;&gt;&lt;/a&gt;链表高频题目&lt;/h1&gt;&lt;h2 id=&quot;2-两数相加&quot;&gt;&lt;a href=&quot;#2-两数相加&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="链表" scheme="http://jiahaohong1997.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LFU算法</title>
    <link href="http://jiahaohong1997.github.io/2021/09/22/LFU%E7%AE%97%E6%B3%95/"/>
    <id>http://jiahaohong1997.github.io/2021/09/22/LFU%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-22T05:00:00.000Z</published>
    <updated>2021-09-22T10:52:46.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LFU算法介绍"><a href="#LFU算法介绍" class="headerlink" title="LFU算法介绍"></a>LFU算法介绍</h1><h2 id="LFU缓存机制"><a href="#LFU缓存机制" class="headerlink" title="LFU缓存机制"></a>LFU缓存机制</h2><p>&emsp;&emsp;LFU 算法的淘汰策略是 Least Frequently Used，也就是每次淘汰那些使用次数最少的数据。对比于在<a href="https://jiahaohong1997.github.io/2021/09/21/LRU%E7%AE%97%E6%B3%95/">LRU算法</a>中介绍的LRU 缓存淘汰算法，LRU 算法的淘汰策略是 Least Recently Used，也就是每次淘汰那些最久没被使用的数据。LRU 算法的核心数据结构是使用哈希链表 <code>LinkedHashMap</code>，首先借助链表的有序性使得链表元素维持插入顺序，同时借助哈希映射的快速访问能力使得我们可以在 O(1) 时间访问链表的任意元素。</p><p>&emsp;&emsp;而 LFU 算法相当于是把数据按照访问频次进行排序，这个需求恐怕没有那么简单，而且还有一种情况，如果多个数据拥有相同的访问频次，我们就得删除最早插入的那个数据。也就是说 LFU 算法是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>&emsp;&emsp;要求你写一个类，接受一个 <code>capacity</code> 参数，实现 <code>get</code> 和 <code>put</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LFUCache</span></span> &#123;&#125; <span class="comment">// 构造容量为 capacity 的缓存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;&#125;  <span class="comment">// 在缓存中查询 key</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;&#125; <span class="comment">// 将 key 和 val 存入缓存</span></span><br></pre></td></tr></table></figure><p><code>Get(key)</code> 方法会去缓存中查询键 <code>key</code>，如果 <code>key</code> 存在，则返回 <code>key</code> 对应的 <code>val</code>，否则返回 -1。</p><p><code>Put(key, value)</code> 方法插入或修改缓存。如果 <code>key</code> 已存在，则将它对应的值改为 <code>val</code>；如果 <code>key</code> 不存在，则插入键值对 <code>(key, val)</code>。</p><p>&emsp;&emsp;当缓存达到容量 <code>capacity</code> 时，则应该在插入新的键值对之前，删除使用频次（后文用 <code>freq</code> 表示）最低的键值对。如果 <code>freq</code> 最低的键值对有多个，则删除其中最旧的那个。</p><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>&emsp;&emsp;首先我们需要理解LFU算法执行过程的几个事实：</p><ol><li>调用<code>Get(key int)</code>方法时，要返回<code>key</code>对应的<code>val</code>。</li><li>只要用到<code>Get</code>或<code>Put</code>方法访问一次某个<code>key</code>，该<code>key</code>的<code>freq</code>就要加一。</li><li>如果在容量满了的时候插入，则需要将 <code>freq</code> 最小的 <code>key</code> 删除，如果最小的 <code>freq</code> 对应多个 <code>key</code>，则删除其中最旧的那一个。</li></ol><p>&emsp;&emsp;现在我们来逐一解决:</p><ol><li>调用<code>Get(key int)</code>方法时，要返回<code>key</code>对应的<code>val</code>。</li></ol><p>&emsp;&emsp;使用一个 <code>HashMap</code> 存储 <code>key</code> 到 <code>val</code> 的映射，就可以快速计算 <code>get(key)</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyToVal := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>只要用到<code>Get</code>或<code>Put</code>方法访问一次某个<code>key</code>，该<code>key</code>的<code>freq</code>就要加一。</li></ol><p>&emsp;&emsp;使用一个 <code>HashMap</code> 存储 <code>key</code> 到 <code>freq</code> 的映射，就可以快速操作 <code>key</code> 对应的 <code>freq</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyToFreq := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>如果在容量满了的时候插入，则需要将 <code>freq</code> 最小的 <code>key</code> 删除，如果最小的 <code>freq</code> 对应多个 <code>key</code>，则删除其中最旧的那一个。</li></ol><p>&emsp;&emsp;这个需求应该是 LFU 算法的核心，所以我们分开说。</p><ul><li>首先，肯定是需要 <code>freq</code> 到 <code>key</code> 的映射，用来找到 <code>freq</code> 最小的 <code>key</code>。</li><li>将 <code>freq</code> 最小的 <code>key</code> 删除，那你就得快速得到当前所有 <code>key</code> 最小的 <code>freq</code> 是多少。想要时间复杂度 O(1) 的话，肯定不能遍历一遍去找，那就用一个变量 <code>minFreq</code> 来记录当前最小的 <code>freq</code> 吧。</li><li>可能有多个 <code>key</code> 拥有相同的 <code>freq</code>，所以 <strong><code>freq</code></strong> <strong>对</strong> <strong><code>key</code></strong> <strong>是一对多的关系</strong>，即一个 <code>freq</code> 对应一个 <code>key</code> 的列表。</li><li>希望 <code>freq</code> 对应的 <code>key</code> 的列表是<strong>存在时序</strong>的，便于快速查找并删除最旧的 <code>key</code>。</li><li>希望<strong>能够快速删除</strong> <strong><code>key</code></strong> <strong>列表中的任何一个</strong> **<code>key</code>**，因为如果频次为 <code>freq</code> 的某个 <code>key</code> 被访问，那么它的频次就会变成 <code>freq+1</code>，就应该从 <code>freq</code> 对应的 <code>key</code> 列表中删除，加到 <code>freq+1</code> 对应的 <code>key</code> 的列表中。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">freqToKeys := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet)</span><br><span class="line">minFreq := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key<span class="keyword">int</span></span><br><span class="line">    prev*node</span><br><span class="line">    next*node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DoubleList <span class="keyword">struct</span> &#123;</span><br><span class="line">    head*node</span><br><span class="line">    tail*node</span><br><span class="line">    size<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorDL</span><span class="params">()</span> *<span class="title">DoubleList</span></span> &#123;</span><br><span class="line">    dh := &amp;node&#123;</span><br><span class="line">        key:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dt := &amp;node &#123;</span><br><span class="line">        key:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dh.next,dt.prev = dt,dh</span><br><span class="line">    <span class="keyword">return</span> &amp;DoubleList&#123;</span><br><span class="line">        head:dh,</span><br><span class="line">        tail:dt,</span><br><span class="line">        size:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LinkedHashSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashMap<span class="keyword">map</span>[<span class="keyword">int</span>]*node</span><br><span class="line">    doubleList*DoubleList    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorLH</span><span class="params">()</span> *<span class="title">LinkedHashSet</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node)</span><br><span class="line">    dl := constructorDL()</span><br><span class="line">    <span class="keyword">return</span> &amp;LinkedHashSet&#123;</span><br><span class="line">        hashMap:m,</span><br><span class="line">        doubleList:dl,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>LinkedHashSet</code> 顾名思义，是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插入元素具有时序；哈希集合中的元素无序，但是可以对元素进行快速的访问和删除。那么，它俩结合起来就兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，又可以保持插入的时序。</p><p>综上，我们可以写出 LFU 算法的基本数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    keyToVal<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span><span class="comment">// key 到 val 的映射，我们后文称为 KV 表</span></span><br><span class="line">    keyToFreq<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span><span class="comment">// key 到 freq 的映射，我们后文称为 KF 表</span></span><br><span class="line">    freqToKeys<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet<span class="comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span></span><br><span class="line">    minFreq<span class="keyword">int</span><span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="built_in">cap</span><span class="keyword">int</span><span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity)</span> <span class="title">LFUCache</span></span> &#123;</span><br><span class="line">    kv := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    kf := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    fk := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet)</span><br><span class="line">    <span class="keyword">return</span> LFUCache&#123;</span><br><span class="line">        keyToVal:kv,</span><br><span class="line">        keyToFreq:kf,</span><br><span class="line">        freqToKeys:fk,</span><br><span class="line">        minFreq:<span class="number">0</span>,</span><br><span class="line">        <span class="built_in">cap</span>:capacity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;&#125;  <span class="comment">// 在缓存中查询 key</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;&#125; <span class="comment">// 将 key 和 val 存入缓存</span></span><br></pre></td></tr></table></figure><h1 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h1><h2 id="实现Get-key-int-方法"><a href="#实现Get-key-int-方法" class="headerlink" title="实现Get(key int)方法"></a>实现<code>Get(key int)</code>方法</h2><p>&emsp;&emsp;逻辑很简单，返回 <code>key</code> 对应的 <code>val</code>，然后增加 <code>key</code> 对应的 <code>freq</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.increaseFreq(key)</span><br><span class="line">    <span class="keyword">return</span> this.keyToVal[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;增加<code>key</code>对应的<code>freq</code>是LFU算法的核心，所以我们干脆抽象一个方法<code>increaseFreq</code>，这样<code>Get</code>方法就比较简洁。</p><h2 id="实现Put-key-int-val-int-方法"><a href="#实现Put-key-int-val-int-方法" class="headerlink" title="实现Put(key int,val int) 方法"></a>实现<code>Put(key int,val int)</code> 方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; ok &#123;  <span class="comment">// 若key已存在，修改对应的val即可</span></span><br><span class="line">        this.keyToVal[key] = value</span><br><span class="line">        this.increaseFreq(key)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// key不存在，需要插入</span></span><br><span class="line">    <span class="comment">// 容量已满的话需要淘汰一个freq最小的key</span></span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> == <span class="built_in">len</span>(this.keyToVal) &#123;</span><br><span class="line">        this.removeMinFreqKey()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入key和val，对应的freq为1</span></span><br><span class="line">    this.keyToVal[key] = value<span class="comment">// 插入KV表</span></span><br><span class="line">    this.keyToFreq[key] = <span class="number">1</span><span class="comment">// 插入KF表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[<span class="number">1</span>]; !ok &#123;  <span class="comment">// 如果没有freq为1的LinkedHashSet，则生成一个</span></span><br><span class="line">        this.freqToKeys[<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,<span class="number">1</span>)  <span class="comment">// 插入新key后的freq肯定是1</span></span><br><span class="line">    this.minFreq = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现核心逻辑（中间抽象层）"><a href="#实现核心逻辑（中间抽象层）" class="headerlink" title="实现核心逻辑（中间抽象层）"></a>实现核心逻辑（中间抽象层）</h2><h3 id="实现removeMinFreqKey方法"><a href="#实现removeMinFreqKey方法" class="headerlink" title="实现removeMinFreqKey方法"></a>实现<code>removeMinFreqKey</code>方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">removeMinFreqKey</span><span class="params">()</span></span> &#123;</span><br><span class="line">    keyList := this.freqToKeys[this.minFreq].doubleList<span class="comment">// 获得最小freq的LinkedHashSet</span></span><br><span class="line">    deleteKey := keyList.removeFirst()<span class="comment">// 删除LinkedHashSet的双链表头的元素</span></span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[this.minFreq].hashMap,deleteKey.key)<span class="comment">// 删除LinkedHashSet的哈希表对应元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[this.minFreq].hashMap) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,this.minFreq)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delete</span>(this.keyToVal,deleteKey.key)<span class="comment">// 更新KV表</span></span><br><span class="line">    <span class="built_in">delete</span>(this.keyToFreq,deleteKey.key)<span class="comment">// 更新KF表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;删除某个<code>key</code>肯定是要同时映射三个表的，借助<code>minFreq</code>参数可以从<code>FK</code>表中找到<code>freq</code>最小的<code>keyList</code>，删除其表头元素即可，同时删除<code>Fk</code>表中<code>freq</code>最小的<code>hashMap</code>对应的元素。然后根据要被淘汰的<code>deleteKey</code>删除其余两个表中的映射关系。</p><p>&emsp;&emsp;这里有个细节问题，如果<code>keyList</code>中只有一个元素，那么删除之后<code>minFreq</code>对应的<code>key</code>列表就为空了，也就是<code>minFreq</code>变量需要更新。实际上没办法快速计算<code>minFreq</code>，只能线性遍历<code>FK</code>表或者<code>KF</code>表来计算，这样肯定不能保证 O(1) 的时间复杂度。<strong>但是，其实这里没必要更新<code>minFreq</code>变量</strong>，因为你想想<code>removeMinFreqKey</code>这个函数是在什么时候调用？在<code>put</code>方法中插入新<code>key</code>时可能调用。而你回头看<code>put</code>的代码，插入新<code>key</code>时一定会把<code>minFreq</code>更新成 1，所以说即便这里<code>minFreq</code>变了，我们也不需要管它。</p><h3 id="实现increaseFreq方法"><a href="#实现increaseFreq方法" class="headerlink" title="实现increaseFreq方法"></a>实现<code>increaseFreq</code>方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">increaseFreq</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    freq := this.keyToFreq[key]</span><br><span class="line">    this.keyToFreq[key] = freq+<span class="number">1</span><span class="comment">// 更新KF表</span></span><br><span class="line">    <span class="comment">// 将key从freq对应的列表和哈希表中删除</span></span><br><span class="line">    this.freqToKeys[freq].doubleList.remove(this.freqToKeys[freq].hashMap[key])</span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[freq].hashMap,key)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[freq].hashMap) == <span class="number">0</span> &#123; <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,freq)</span><br><span class="line">        <span class="keyword">if</span> freq == this.minFreq &#123;  <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">            this.minFreq++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将key加入到freq+1对应的列表和哈希表中</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[freq+<span class="number">1</span>]; !ok &#123;</span><br><span class="line">        this.freqToKeys[freq+<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,freq+<span class="number">1</span>)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="实现addRecently方法"><a href="#实现addRecently方法" class="headerlink" title="实现addRecently方法"></a>实现<code>addRecently</code>方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">addRecently</span><span class="params">(key <span class="keyword">int</span>, freq <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := &amp;node&#123;</span><br><span class="line">        key:key,</span><br><span class="line">    &#125;</span><br><span class="line">    this.freqToKeys[freq].doubleList.addLast(x)</span><br><span class="line">    this.freqToKeys[freq].hashMap[key] = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在插入新的节点时，需要修改<code>FK</code>表的哈希表和双链表。</p><h2 id="对底层数据结构进行操作"><a href="#对底层数据结构进行操作" class="headerlink" title="对底层数据结构进行操作"></a>对底层数据结构进行操作</h2><p>&emsp;&emsp;该层的主要作用是对我们实现的<code>LinkedHashSet</code>结构封装一些通用操作，用以满足<code>FK</code>表的更新和删除操作，主要包含以下几个方法：</p><ol><li>删除<code>DoubleList</code>中某一节点的方法<code>remove(x *node)</code>。</li><li>删除<code>DoubleList</code>中表首元素的方法<code>removeFirst()</code>。</li><li>在<code>DoubleList</code>中表尾部增加新元素的<code>addLast()</code>。</li></ol><h3 id="实现remove方法"><a href="#实现remove方法" class="headerlink" title="实现remove方法"></a>实现<code>remove</code>方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">remove</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev.next = x.next</span><br><span class="line">    x.next.prev = x.prev</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="实现removeFirst方法"><a href="#实现removeFirst方法" class="headerlink" title="实现removeFirst方法"></a>实现<code>removeFirst</code>方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">removeFirst</span><span class="params">()</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dl.head.next == dl.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    first := dl.head.next</span><br><span class="line">    dl.remove(first)</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现addLast方法"><a href="#实现addLast方法" class="headerlink" title="实现addLast方法"></a>实现<code>addLast</code>方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">addLast</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev = dl.tail.prev</span><br><span class="line">    x.next = dl.tail</span><br><span class="line">    dl.tail.prev.next = x</span><br><span class="line">    dl.tail.prev = x</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="总体算法"><a href="#总体算法" class="headerlink" title="总体算法"></a>总体算法</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ###############基础数据结构###################</span></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key<span class="keyword">int</span></span><br><span class="line">    prev*node</span><br><span class="line">    next*node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双端链表</span></span><br><span class="line"><span class="keyword">type</span> DoubleList <span class="keyword">struct</span> &#123;</span><br><span class="line">    head*node</span><br><span class="line">    tail*node</span><br><span class="line">    size<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化双端链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorDL</span><span class="params">()</span> *<span class="title">DoubleList</span></span> &#123;</span><br><span class="line">    dh := &amp;node&#123;</span><br><span class="line">        key:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dt := &amp;node &#123;</span><br><span class="line">        key:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dh.next,dt.prev = dt,dh</span><br><span class="line">    <span class="keyword">return</span> &amp;DoubleList&#123;</span><br><span class="line">        head:dh,</span><br><span class="line">        tail:dt,</span><br><span class="line">        size:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造LinkedHashSet作为freqToKeys表</span></span><br><span class="line"><span class="keyword">type</span> LinkedHashSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashMap<span class="keyword">map</span>[<span class="keyword">int</span>]*node</span><br><span class="line">    doubleList*DoubleList    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化LinkedHashSet</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorLH</span><span class="params">()</span> *<span class="title">LinkedHashSet</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node)</span><br><span class="line">    dl := constructorDL()</span><br><span class="line">    <span class="keyword">return</span> &amp;LinkedHashSet&#123;</span><br><span class="line">        hashMap:m,</span><br><span class="line">        doubleList:dl,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ##############底层方法（用于直接操作数据结构）####################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除双端链表中的某一节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">remove</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev.next = x.next</span><br><span class="line">    x.next.prev = x.prev</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除双端链表表头元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">removeFirst</span><span class="params">()</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dl.head.next == dl.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    first := dl.head.next</span><br><span class="line">    dl.remove(first)</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在双端链表尾部添加新元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">addLast</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev = dl.tail.prev</span><br><span class="line">    x.next = dl.tail</span><br><span class="line">    dl.tail.prev.next = x</span><br><span class="line">    dl.tail.prev = x</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ###############LFU类的实现##################</span></span><br><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    keyToVal<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span><span class="comment">// key 到 val 的映射，我们后文称为 KV 表</span></span><br><span class="line">    keyToFreq<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span><span class="comment">// key 到 freq 的映射，我们后文称为 KF 表</span></span><br><span class="line">    freqToKeys<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet<span class="comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span></span><br><span class="line">    minFreq<span class="keyword">int</span><span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="built_in">cap</span><span class="keyword">int</span><span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化LFU类，加载KV表、KF表以及FK表，设置最小频率树minFreq</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LFUCache</span></span> &#123;</span><br><span class="line">    kv := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    kf := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    fk := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet)</span><br><span class="line">    <span class="keyword">return</span> LFUCache&#123;</span><br><span class="line">        keyToVal:kv,</span><br><span class="line">        keyToFreq:kf,</span><br><span class="line">        freqToKeys:fk,</span><br><span class="line">        minFreq:<span class="number">0</span>,</span><br><span class="line">        <span class="built_in">cap</span>:capacity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.increaseFreq(key)</span><br><span class="line">    <span class="keyword">return</span> this.keyToVal[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Put方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; ok &#123;  <span class="comment">// 若key已存在，修改对应的val即可</span></span><br><span class="line">        this.keyToVal[key] = value</span><br><span class="line">        this.increaseFreq(key)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// key不存在，需要插入</span></span><br><span class="line">    <span class="comment">// 容量已满的话需要淘汰一个freq最小的key</span></span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> &lt;= <span class="built_in">len</span>(this.keyToVal) &#123;</span><br><span class="line">        this.removeMinFreqKey()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入key和val，对应的freq为1</span></span><br><span class="line">    this.keyToVal[key] = value<span class="comment">// 插入KV表</span></span><br><span class="line">    this.keyToFreq[key] = <span class="number">1</span><span class="comment">// 插入KF表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[<span class="number">1</span>]; !ok &#123;  <span class="comment">// 如果没有freq为1的LinkedHashSet，则生成一个</span></span><br><span class="line">        this.freqToKeys[<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,<span class="number">1</span>)  <span class="comment">// 插入新key后的freq肯定是1</span></span><br><span class="line">    this.minFreq = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ################中间抽象层####################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除使用频率最低节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">removeMinFreqKey</span><span class="params">()</span></span> &#123;</span><br><span class="line">    keyList := this.freqToKeys[this.minFreq].doubleList<span class="comment">// 获得最小freq的LinkedHashSet</span></span><br><span class="line">    deleteKey := keyList.removeFirst()<span class="comment">// 删除LinkedHashSet的双链表头的元素</span></span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[this.minFreq].hashMap,deleteKey.key)<span class="comment">// 删除LinkedHashSet的哈希表对应元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[this.minFreq].hashMap) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,this.minFreq)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delete</span>(this.keyToVal,deleteKey.key)<span class="comment">// 更新KV表</span></span><br><span class="line">    <span class="built_in">delete</span>(this.keyToFreq,deleteKey.key)<span class="comment">// 更新KF表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加某一节点的使用频数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">increaseFreq</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    freq := this.keyToFreq[key]</span><br><span class="line">    this.keyToFreq[key] = freq+<span class="number">1</span><span class="comment">// 更新KF表</span></span><br><span class="line">    <span class="comment">// 将key从freq对应的列表和哈希表中删除</span></span><br><span class="line">    this.freqToKeys[freq].doubleList.remove(this.freqToKeys[freq].hashMap[key])</span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[freq].hashMap,key)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[freq].hashMap) == <span class="number">0</span> &#123; <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,freq)</span><br><span class="line">        <span class="keyword">if</span> freq == this.minFreq &#123;  <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">            this.minFreq++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将key加入到freq+1对应的列表和哈希表中</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[freq+<span class="number">1</span>]; !ok &#123;</span><br><span class="line">        this.freqToKeys[freq+<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,freq+<span class="number">1</span>)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 对最近使用的节点的处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">addRecently</span><span class="params">(key <span class="keyword">int</span>, freq <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := &amp;node&#123;</span><br><span class="line">        key:key,</span><br><span class="line">    &#125;</span><br><span class="line">    this.freqToKeys[freq].doubleList.addLast(x)</span><br><span class="line">    this.freqToKeys[freq].hashMap[key] = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LFU算法介绍&quot;&gt;&lt;a href=&quot;#LFU算法介绍&quot; class=&quot;headerlink&quot; title=&quot;LFU算法介绍&quot;&gt;&lt;/a&gt;LFU算法介绍&lt;/h1&gt;&lt;h2 id=&quot;LFU缓存机制&quot;&gt;&lt;a href=&quot;#LFU缓存机制&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="LFU" scheme="http://jiahaohong1997.github.io/tags/LFU/"/>
    
  </entry>
  
</feed>
