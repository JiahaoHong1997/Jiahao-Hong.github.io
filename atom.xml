<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洪笳淏的个人博客</title>
  
  
  <link href="http://jiahaohong1997.github.io/atom.xml" rel="self"/>
  
  <link href="http://jiahaohong1997.github.io/"/>
  <updated>2021-12-08T11:39:05.441Z</updated>
  <id>http://jiahaohong1997.github.io/</id>
  
  <author>
    <name>洪笳淏</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Gin如何优雅的停止监听</title>
    <link href="http://jiahaohong1997.github.io/2021/12/08/%E4%BD%BF%E7%94%A8Gin%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%81%9C%E6%AD%A2%E7%9B%91%E5%90%AC/"/>
    <id>http://jiahaohong1997.github.io/2021/12/08/%E4%BD%BF%E7%94%A8Gin%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%81%9C%E6%AD%A2%E7%9B%91%E5%90%AC/</id>
    <published>2021-12-08T11:34:00.000Z</published>
    <updated>2021-12-08T11:39:05.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="暴力停止"><a href="#暴力停止" class="headerlink" title="暴力停止"></a>暴力停止</h1><p>&emsp;&emsp;我们在 go run main.go 后，若需要停止监听，需要使用 <code>ctrl+c</code> 终止监听。该方案会立即终止服务器监听，同时结束正在处理的请求，也就是说若存在未处理完毕的请求，是不能继续处理的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run() <span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优雅停止"><a href="#优雅停止" class="headerlink" title="优雅停止"></a>优雅停止</h1><p>&emsp;&emsp;代替示例代码中 <code>router.Run()</code> 方法，我们可以使用 <code>http.Server</code> 内置的 <a class="link" href="https://golang.org/pkg/net/http/#Server.Shutdown">Shutdown()<i class="fas fa-external-link-alt"></i></a> 方法优雅地停止。所谓优雅，指的是可以将正在处理的请求处理完毕后再关闭服务器。示例代码如下 main.go ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 常规的初始化路由</span></span><br><span class="line">    router := gin.Default()</span><br><span class="line">    router.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">        c.String(http.StatusOK, <span class="string">&quot;Welcome Gin Server&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 定义服务器</span></span><br><span class="line">    srv := &amp;http.Server&#123;</span><br><span class="line">        Addr:    <span class="string">&quot;:8080&quot;</span>,</span><br><span class="line">        Handler: router,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用 goroutine 启动监听</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// srv.ListenAndServe() 监听</span></span><br><span class="line">        <span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;</span><br><span class="line">            log.Fatalf(<span class="string">&quot;listen: %s\n&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待中断信号以优雅地关闭服务器（设置 5 秒的超时时间）</span></span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(quit, os.Interrupt)</span><br><span class="line">    <span class="comment">// quit 信道是同步信道，若没有信号进来，处于阻塞状态</span></span><br><span class="line">    <span class="comment">// 反之，则执行后续代码</span></span><br><span class="line">    &lt;-quit</span><br><span class="line">    log.Println(<span class="string">&quot;Shutdown Server ...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    <span class="comment">// 调用 srv.Shutdown() 完成优雅停止</span></span><br><span class="line">    <span class="comment">// 调用时传递了一个上下文对象，对象中定义了超时时间</span></span><br><span class="line">    <span class="keyword">if</span> err := srv.Shutdown(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;Server Shutdown:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;Server exiting&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试以上代码，结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running <span class="keyword">in</span> <span class="string">&quot;debug&quot;</span> mode. Switch to <span class="string">&quot;release&quot;</span> mode <span class="keyword">in</span> production.</span><br><span class="line"> - using env:   <span class="built_in">export</span> GIN_MODE=release</span><br><span class="line"> - using code:  gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /                         --&gt; main.main.func1 (3 handlers)</span><br><span class="line">2019/11/05 22:49:04 Shutdown Server ...</span><br><span class="line">[GIN] 2019/11/05 - 22:49:07 | 200 |    5.0000438s |             ::1 | GET      /</span><br><span class="line">2019/11/05 22:49:08 Server exiting</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;暴力停止&quot;&gt;&lt;a href=&quot;#暴力停止&quot; class=&quot;headerlink&quot; title=&quot;暴力停止&quot;&gt;&lt;/a&gt;暴力停止&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;我们在 go run main.go 后，若需要停止监听，需要使用 &lt;code&gt;ctrl+c&lt;/co</summary>
      
    
    
    
    <category term="Go框架" scheme="http://jiahaohong1997.github.io/categories/Go%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="web框架" scheme="http://jiahaohong1997.github.io/tags/web%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>微服务概览与设计</title>
    <link href="http://jiahaohong1997.github.io/2021/11/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <id>http://jiahaohong1997.github.io/2021/11/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-11-28T07:45:00.000Z</published>
    <updated>2021-12-05T10:16:53.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微服务概念"><a href="#微服务概念" class="headerlink" title="微服务概念"></a>微服务概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现<strong>服务组件化</strong>，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活：</p><ul><li>原子服务：关注单一业务场景</li><li>独立进程：能够独立部署和交付</li><li>隔离部署：减小某一物理机crash对全局的影响</li><li>去中心化服务治理：服务之间的通讯rpc直连，减少集中的负载均衡</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>基础设施的建设、复杂度高</li><li>微服务应用是分布式系统，由此会带来固有的复杂性。开发者不得不使用RPC或者消息传递，来实现进程间的通信；此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题</li><li>分区的数据库架构，同时更新多个业务主体的事务很普遍。这种事务对于单体应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务锁使用的不同数据库，从而对开发者提出了更高的要求和挑战</li><li>测试一个基于微服务架构的应用是很复杂的任务</li><li>服务模块间的依赖，应用的升级有可能会涉及多个服务模块的修改</li><li>对运维的基础设施的挑战比较大</li></ul><h2 id="组件服务化"><a href="#组件服务化" class="headerlink" title="组件服务化"></a>组件服务化</h2><p>&emsp;&emsp;传统实现组件的方式是通过库(library)，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。我们用 Go 实施一个微服务：</p><ul><li>kit：一个微服务的基础库（框架）</li><li>service：业务代码＋ hit 依赖＋ 第三方依赖组成的业务微服务</li><li>RPC + message queue: 轻量级通讯</li></ul><p>&emsp;&emsp;<strong>本质上等同于，多个微服务组合(compose)完成了一个完整的用户场景(usecase)。</strong></p><h2 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h2><p>&emsp;&emsp;每个服务面临的业务场景不同，可以针对性的选择合适的技术解决方案。但也需要避免过度多样化，结合团队实际情况来选择取舍，要是每个服务都用不同的语言的技术栈来实现，想想维护成本真够高的。</p><ul><li>数据去中心化：每个服务独享自身的数据存储设施(缓存，数据库等)</li><li>治理去中心化：避免集中式做流量分发和负载均衡</li><li>技术去中心化：不绑定某一特定语言</li></ul><p>&emsp;&emsp;<strong>每个服务独享自身的数据存储设施(缓存，数据库等)，不像传统应用共享一个缓存和数据库，这样有利于服务的独立性，隔旁相关干扰。</strong></p><h2 id="基础设施自动化"><a href="#基础设施自动化" class="headerlink" title="基础设施自动化"></a>基础设施自动化</h2><p>&emsp;&emsp;无自动化不微服务，自动化包括测试和部署。单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、监控和部署的复杂度都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。</p><ul><li>CICD: Gitlab + Gitlab Hooks + kubernetes</li><li>Testing：测试环境、单元测试、API 自动化测试</li><li>在线运行时: kubernetes, 以及一系列Prometheus, ELK, Conrtol Panle</li></ul><h2 id="可用性-amp-兼容性设计"><a href="#可用性-amp-兼容性设计" class="headerlink" title="可用性 &amp; 兼容性设计"></a>可用性 &amp; 兼容性设计</h2><p>&emsp;&emsp;微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的新问题，如网络延迟、消息格式、负载均衡和容错，忽略其中任何一点都属于对“分布式计算的误解”。</p><ul><li>隔离</li><li>超时控制</li><li>负载保护</li><li>限流</li><li>降级</li><li>重试</li><li>负载均衡</li></ul><p>&emsp;&emsp;一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻蓮记保持服务契约（接口）的兼容性。发送时要保守，接收时要开放。按照伯斯塔次法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。</p><h1 id="微服务设计"><a href="#微服务设计" class="headerlink" title="微服务设计"></a>微服务设计</h1><h2 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h2><ol><li>按照垂直功能进行拆分，对外暴露了一批微服务，但是因为缺乏统一的出口面临不少问题：</li></ol><p><img lazyload src="/images/loading.svg" data-src="1.png" alt="avatar"></p><ul><li>客户端到微服务直接通信，强耦合：不利于服务的更新迭代，要始终保留过往版本的接口</li><li>需要多次请求，客户端聚合数据，工作量巨大，延迟高</li><li>协议不利于统一，各个部门间有差异，需要端来兼容</li><li>面向“端”（不同终端）的API适配，耦合到了内部服务</li><li>多终端兼容逻辑复杂，每个服务都需要处理</li><li>统一逻辑无法收敛，比如安全认证、限流</li></ul><ol start="2"><li>新增一个app-interface 用于统一的协议出口，在服务哪进行大量的 dataset join（各种微服务数据的聚合），按照业务的场景来设计粗粒度的 API，给后续业务演进带来很多优势：</li></ol><p><img lazyload src="/images/loading.svg" data-src="2.png" alt="avatar"></p><ul><li>轻量交互：协议精简、聚合</li><li>差异服务：数据裁剪以及聚合、针对终端定制化API</li><li>动态升级：原有系统兼容升级，更新服务而非协议</li><li>沟通效率提升，协作模式演进为移动业务+网关小组</li></ul><p>BFF 可以认为是一种适配服务，将后端的微服务进行适配（主要包括聚合裁剪和格式适配等逻辑），向无线端设备暴露友好和统一的API，方便无线设备接入访问后端服务。</p><p>最致命的一个问题是整个 app-interface 属于单点故障，严重代码缺陷或流量洪峰可能引发集群宕机。</p><p><img lazyload src="/images/loading.svg" data-src="3.png" alt="avatar"></p><ul><li>但各模块也会导致后续业务集成复杂度高，根据康威法则，单块的无线BFF和多团队之间就出现不匹配问题，团队之间沟通协调成本高，交付效率低下</li><li>很多跨横切面逻辑，比如安全认证，日志监控，限流熔断。随着时间推移，代码变得越来越复杂，技术栈越来越多</li></ul><ol start="3"><li>跨横切面(Cross-Cutting Concerns)的功能, 需要协调更新框架升级发版(路由、认证、限流、安<br>全），因此全部上沉，引入了 API Gateway，把业务集成度高的 BFF 层和通用功能服务层 API<br>Gateway 进行了分层处理。</li></ol><p><img lazyload src="/images/loading.svg" data-src="4.png" alt="avatar"></p><p>在新的架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器。在网关的配合下，单块 BFF<br>实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提开。另外，把跨横切面逻<br>辑从 BFF 剥离到网关上去以后，BFF 的开发人员可以更加专法业务逻辑交付，实现了架构上的关注分离<br>(Separation of Concerns).</p><p>业务流量实所为：<br>移动端 -&gt; API Gateway -&gt; BFF -&gt; Mircoservice, 在 FE Web业务中，BFF 可以是nodejs 来做服务端渲染<br>(SSR, Server-Side Rendering), 注意这里忽略了上游的 CDN、4/7层负载均衡(ELB)。</p><h2 id="Mircoservice划分"><a href="#Mircoservice划分" class="headerlink" title="Mircoservice划分"></a>Mircoservice划分</h2><p>&emsp;&emsp;微服务架构时遇到的第一个问题就是如何划分服务的边界。在实际项目中通常会采用两种不同的方式划分服务便捷，即通过业务职能（Business Capbility）或是DDD的限界上下文（Bounded Context）。</p><ul><li>Business Capbility</li></ul><p>&emsp;&emsp;由公司内部不同的部门提供的职能。例如客户服务部门提供客户服务职能，财务部门提供财务相关的职能。</p><ul><li>Bounded Context</li></ul><p>&emsp;&emsp;限界上下文DDD中用来划分不同业务边界的元素，这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案域，为了解决某种类型的业务问题，贴近领域知识，也就是业务。</p><p>这本质上也促进了组织结构的演进：Service per team</p><p><img lazyload src="/images/loading.svg" data-src="5.png" alt="avatar"></p><ul><li><p>CQRS</p><p>将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新。(其实就是读写分离)</p></li></ul><p>在稿件服务演进过程中，围绕着创作稿件、审核稿件、最终发布稿件有大量的逻辑揉在一块，其中稿件本身的状态也有非常多种，但是最终前台用户只关注稿件能否查看，依赖稿件数据库 binlog 以及订阅binlog 的中间 canal， 将稿件结果发布到消息队列katka 中，最终消费数据独立组建一个稿件查阅结果数据库，并对外提供一个独立查询服务，来板分复杂架构和业务。<br><img lazyload src="/images/loading.svg" data-src="6.jpg" alt="avatar"></p><p>将稿件审核并写入数据库(archive-result-database)的服务(稿件job)和外部用户查看稿件审核结果的服务(稿件结果)分离开来。</p><h2 id="Mircoservice安全"><a href="#Mircoservice安全" class="headerlink" title="Mircoservice安全"></a>Mircoservice安全</h2><p>&emsp;&emsp;对于外网的请求来说，我们通常在 API Gateway进行统一的认证拦截，一旦认证成功，我们会使用 Header 方式通过 RPC 元数据传递的方式带到 BFF 层，BFF 获取后把身份信息注入到应用的 Context 中，BFF 到其他下层的微服务，建议是直接在 RPC Request 中带入用户身份信息(UserID)请求服务。</p><ul><li><p>API Gateway -&gt; BFF -&gt; Service</p></li><li><p>Biz Auth -&gt; UID -&gt; Request Args</p></li></ul><p>对于服务内部，一般要区分身份认证和授权。</p><ul><li>Full Trust</li><li>Half Trust</li><li>Zero Trust </li></ul><h1 id="gRPC和服务发现"><a href="#gRPC和服务发现" class="headerlink" title="gRPC和服务发现"></a>gRPC和服务发现</h1><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p><img lazyload src="/images/loading.svg" data-src="7.jpg" alt="avatar"></p><ul><li><p>多语言：语言中立，支持多种语言。</p></li><li><p>轻量级、高性能序列化支持 PB（Protocol Buffer）和 JSON，PB 是一种语言无关的高性能系列化框架</p></li><li><p>可插拔。</p></li><li><p>IDL：基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端口以及客户端 Stub。</p></li><li><p>移动端：基于标准的 HTTP/2 设计，支持双向流、消息头压缩、单TCP的多路复用、服务端推送等特性。这些特性是的 gRPC 在移动端设备上更加省电和节省网络流量。</p></li><li><p>服务而非对象、消息而非引用：促进微服务的系统间粗粒度消息交互设计理念。</p></li><li><p>负载无关的：不同的服务需要使用不同的消息类型和编码, 例如 protocol buffers, JSON, XML 和 Thrift。</p></li><li><p>流: Streaming APl。</p></li><li><p>阻塞式和非阻塞式：支持异步和同步处理在客户端和服务端间交互的消息序列。</p></li><li><p>元数据交换：常见的横切关注点，如认证或跟踪，依赖数据交换。</p></li><li><p>标准化状态码：客户端通常以有限的方式响应 API 调用返回的错误。</p></li></ul><h2 id="gRPC-HealthCheck"><a href="#gRPC-HealthCheck" class="headerlink" title="gRPC - HealthCheck"></a>gRPC - HealthCheck</h2><p>gRPC 有一个标准的健康检测协议，在 gRPC 的所有语言实现中基本都提供了生成代码和用于设置运行状态的功能。</p><p>主动健康检查 health check，，可以在服务提供者服务不稳定时，被消费者所感知，份时从负载均衡中摘除，减少错误请求。当服务提供者重新稳定后，health check 成功，重新加入到消费者的负载均衡，恢复请求。health check  同样也被用于外挂方式的容器健康检测，或者流量检测(K8sliveness &amp; readiness)。</p><p><img lazyload src="/images/loading.svg" data-src="8.jpg" alt="avatar"></p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><h3 id="客户端发现"><a href="#客户端发现" class="headerlink" title="客户端发现"></a>客户端发现</h3><p>&emsp;&emsp;一个服务实例被启动时，它的网络地址会被写到注册表上；当服务实例终止时，再从注册表中删除；这个服务实例的注册表通过心跳机制动态刷新；客户端使用一个负载均衡算法，去选择一个可用的服务实例，来响应这个请求。</p><h3 id="服务端发现"><a href="#服务端发现" class="headerlink" title="服务端发现"></a>服务端发现</h3><p>&emsp;&emsp;客户端通过负载均衡器向一个服务发送请求，这个负载均衡器会查询服务注册表，并将请求路由到可用的服务实例上。服务实例在服务注册表上被注册和注销(Consul Template+Nginx, kubernetesteted)。</p><p><img lazyload src="/images/loading.svg" data-src="9.jpg" alt="avatar"></p><p>微服务的核心是去中心化，使用客户端发现模式。</p><p><img lazyload src="/images/loading.svg" data-src="10.jpg" alt="avatar"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微服务概念&quot;&gt;&lt;a href=&quot;#微服务概念&quot; class=&quot;headerlink&quot; title=&quot;微服务概念&quot;&gt;&lt;/a&gt;微服务概念&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定</summary>
      
    
    
    
    <category term="微服务" scheme="http://jiahaohong1997.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="开发" scheme="http://jiahaohong1997.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常见问题补充</title>
    <link href="http://jiahaohong1997.github.io/2021/11/20/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85/"/>
    <id>http://jiahaohong1997.github.io/2021/11/20/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85/</id>
    <published>2021-11-19T16:21:00.000Z</published>
    <updated>2021-11-24T05:50:38.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据表的类型"><a href="#数据表的类型" class="headerlink" title="数据表的类型"></a>数据表的类型</h1><table><thead><tr><th align="center"></th><th align="center">MYISM</th><th align="center">INNODB</th></tr></thead><tbody><tr><td align="center">事务支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">数据行锁定</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">外键约束</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">全文索引</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">表空间的大小</td><td align="center">较小</td><td align="center">较大，约为MYSIM2倍</td></tr></tbody></table><ul><li>MYSIM：节约空间，速度较快</li><li>INNODB：安全性高，支持事务处理，多表多用户操作</li></ul><h1 id="DROP、TRUNCATE和DELETE的区别"><a href="#DROP、TRUNCATE和DELETE的区别" class="headerlink" title="DROP、TRUNCATE和DELETE的区别"></a>DROP、TRUNCATE和DELETE的区别</h1><ul><li><p>TRUNCATE和DELETE的相同点：都能删除数据面都不会删除表结构</p></li><li><p>区别：</p><ul><li>DROP table 【表名】<ul><li><strong>删除内容和定义</strong>，并释放空间。执行drop语句，<strong>将使此表的结构</strong>一起删除。</li></ul></li><li>TRUNCATE <ul><li><strong>删除内容、释放空间但不删除定义</strong>(也就是保留表的数据结构)。与drop不同的是,只是<strong>清空表数据</strong>而已。</li><li>重新设置，自增列计数器会归零</li><li>不会影响事务</li></ul></li><li>DELETE from 【表名】(where 【列名】= 值)<ul><li><strong>只删除内容、释放空间但不删除定义</strong>；但是delete即<strong>可以对行数据进行删除</strong>，也可以对整表数据进行删除。</li><li>自增列计数器保持原来的值</li></ul></li></ul></li><li><p>注意</p><ul><li>delete语句执行删除的过程是<strong>每次从表中删除一行</strong>，并且同时将该行的删除操作作为事务<strong>记录在日志</strong>中保存，以便进行进行回滚操作。</li><li><strong>执行速度</strong>一般来说：drop&gt;truncate&gt;delete</li><li>delete语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，<strong>事务提交之后才生效</strong>；如果有相应的 trigger，执行的时候将被触发。truncate、drop 是数据库定义语言(ddl)<strong>，操作立即生效</strong>，原数据不放到 rollback segment 中，不能回滚，操作不触发trigger。</li><li> truncate语句执行以后，<strong>id标识列还是按顺序排列</strong>，保持连续；而delete语句执行后，<strong>ID标识列不连续</strong></li></ul></li></ul><h1 id="为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？"><a href="#为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？" class="headerlink" title="为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？"></a>为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？</h1><p>分解关联查询的方式重构查询的优势有：</p><blockquote><ul><li><p><strong>让缓存的效率更高</strong>。我们知道执行一条sql的时候，会先去查询缓存中查找。那么许多应用程序可以方便地缓存单表查询对应的结果对象。如果关联查询，那么关联中的某个表发生了变化，那么就无法使用查询缓存，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。<br>将查询拆分后，执行单个查询可以减少锁的竞争。</p></li><li><p>在应用层做关联，可以更容易对数据库进行拆分，在现如今分库分表普遍使用的情景下，更容易做到高性能和可扩展。</p></li><li><p>查询本身效率也可能会有所提升。比如：让某些查询用IN()代替关联查询，可以让Mysql按照ID顺序进行查询，着可能比随机的关联要更高效。</p></li><li><p>可以减少冗余记录的查询。在应用层做关联，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能徐娅重复地访问一部分数据。从这方面看，这样的重构还可能会减少网络和内存的消耗。</p></li><li><p>分解关联查询，相当于在应用中实现了哈希关联，而不是使用Mysql的类似嵌套循环关联。某些场景哈希关联的效率更高效</p></li></ul></blockquote><p><img lazyload src="/images/loading.svg" data-src="1.png" alt="avatar"></p><h1 id="MySQL索引原理"><a href="#MySQL索引原理" class="headerlink" title="MySQL索引原理"></a>MySQL索引原理</h1><h2 id="索引的目的"><a href="#索引的目的" class="headerlink" title="索引的目的"></a>索引的目的</h2><p>&emsp;&emsp;索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。</p><h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><p>&emsp;&emsp;除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。</p><p>&emsp;&emsp;数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？我们会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p><p>&emsp;&emsp;考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>&emsp;&emsp;前面讲了生活中索引的例子，索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。</p><p><img lazyload src="/images/loading.svg" data-src="2.jpg" alt="avatar"></p><p>&emsp;&emsp;如上图，是一颗b+树，关于b+树的定义可以参见<a class="link" href="http://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B+树<i class="fas fa-external-link-alt"></i></a>，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p><ul><li>b+树的查找过程</li></ul><p>&emsp;&emsp;如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p><ul><li>b+树的性质</li></ul><ol><li><p>通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即<strong>索引字段要尽量的小</strong>，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</p></li><li><p>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的<strong>最左匹配特性</strong>。</p></li></ol><h2 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h2><h3 id="建索引的几大原则"><a href="#建索引的几大原则" class="headerlink" title="建索引的几大原则"></a>建索引的几大原则</h3><ol><li><strong>最左前缀匹配原则</strong>，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li><strong>=和in可以乱序</strong>，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</li><li><strong>尽量选择区分度高的列作为索引</strong>，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</li><li><strong>索引列不能参与计算</strong>，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</li><li><strong>尽量的扩展索引，不要新建索引</strong>。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li></ol><h3 id="慢查询优化的基本步骤"><a href="#慢查询优化的基本步骤" class="headerlink" title="慢查询优化的基本步骤"></a>慢查询优化的基本步骤</h3><ol start="0"><li>先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li><li>where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看看那个字段的区分度最高</li><li>expalin查看执行计划，是否与预期一致（从锁定记录较少的表开始查）</li><li>order by limit 形式的sql语句让排序的表优先查</li><li>了解业务方使用场景</li><li>加索引时参照建立索引的几大原则</li><li>观察结果，不符合预期的继续从0分析</li></ol><h3 id="几个慢查询案例"><a href="#几个慢查询案例" class="headerlink" title="几个慢查询案例"></a>几个慢查询案例</h3><ul><li>案例一</li></ul><p>很多情况下，我们写SQL只是为了实现功能，这只是第一步，不同的语句书写方式对于效率往往有本质的差别，这要求我们对mysql的执行计划和索引原则有非常清楚的认识，请看下面的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   <span class="keyword">distinct</span> cert.emp_id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   (</span><br><span class="line">      <span class="keyword">select</span></span><br><span class="line">         emp.id <span class="keyword">as</span> emp_id,</span><br><span class="line">         emp_cert.id <span class="keyword">as</span> cert_id </span><br><span class="line">      <span class="keyword">from</span></span><br><span class="line">         employee emp </span><br><span class="line">      <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">         emp_certificate emp_cert </span><br><span class="line">            <span class="keyword">on</span> emp.id <span class="operator">=</span> emp_cert.emp_id </span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">         emp.is_deleted<span class="operator">=</span><span class="number">0</span></span><br><span class="line">   ) cert </span><br><span class="line">      <span class="keyword">on</span> (</span><br><span class="line">         cl.ref_table<span class="operator">=</span><span class="string">&#x27;Employee&#x27;</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid<span class="operator">=</span> cert.emp_id</span><br><span class="line">      ) </span><br><span class="line">      <span class="keyword">or</span> (</span><br><span class="line">         cl.ref_table<span class="operator">=</span><span class="string">&#x27;EmpCertificate&#x27;</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid<span class="operator">=</span> cert.cert_id</span><br><span class="line">      ) </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date <span class="operator">&gt;=</span><span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date<span class="operator">&lt;=</span><span class="string">&#x27;2013-11-08 16:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="0"><li>先运行一下，53条记录 1.87秒，又没有用聚合语句，比较慢</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">53</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">1.87</span> sec)</span><br></pre></td></tr></table></figure><ol><li>explain</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type  <span class="operator">|</span> possible_keys                   <span class="operator">|</span> key                   <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>               <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> Extra                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> cl         <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> cm_log_cls_id,idx_last_upd_date <span class="operator">|</span> idx_last_upd_date     <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>   <span class="number">379</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> temporary   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>                            <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span> <span class="number">63727</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> emp        <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>                            <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span> <span class="number">13317</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> emp_cert   <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> emp_certificate_empid           <span class="operator">|</span> emp_certificate_empid <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.emp.id <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> index                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;简述一下执行计划，首先mysql根据idx_last_upd_date索引扫描cm_log表获得379条记录；然后查表扫描了63727条记录，分为两部分，derived表示构造表，也就是不存在的表，可以简单理解成是一个语句形成的结果集，后面的数字表示语句的ID。derived2表示的是ID = 2的查询构造了虚拟表，并且返回了63727条记录。我们再来看看ID = 2的语句究竟做了写什么返回了这么大量的数据，首先全表扫描employee表13317条记录，然后根据索引emp_certificate_empid关联emp_certificate表，rows = 1表示，每个关联都只锁定了一条记录，效率比较高。获得后，再和cm_log的379条记录根据规则关联。从执行过程上可以看出返回了太多的数据，返回的数据绝大部分cm_log都用不到，因为cm_log只锁定了379条记录。</p><p>&emsp;&emsp;如何优化呢？可以看到我们在运行完后还是要和cm_log做join,那么我们能不能之前和cm_log做join呢？仔细分析语句不难发现，其基本思想是如果cm_log的ref_table是EmpCertificate就关联emp_certificate表，如果ref_table是Employee就关联employee表，我们完全可以拆成两部分，并用union连接起来，注意这里用union，而不用union all是因为原语句有“distinct”来得到唯一的记录，而union恰好具备了这种功能。如果原语句中没有distinct不需要去重，我们就可以直接使用union all了，因为使用union需要去重的动作，会影响SQL性能。</p><p>优化过的语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   emp.id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   employee emp </span><br><span class="line">      <span class="keyword">on</span> cl.ref_table <span class="operator">=</span> <span class="string">&#x27;Employee&#x27;</span> </span><br><span class="line">      <span class="keyword">and</span> cl.ref_oid <span class="operator">=</span> emp.id  </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date <span class="operator">&gt;=</span><span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date<span class="operator">&lt;=</span><span class="string">&#x27;2013-11-08 16:00:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> emp.is_deleted <span class="operator">=</span> <span class="number">0</span>  </span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">   emp.id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   emp_certificate ec </span><br><span class="line">      <span class="keyword">on</span> cl.ref_table <span class="operator">=</span> <span class="string">&#x27;EmpCertificate&#x27;</span> </span><br><span class="line">      <span class="keyword">and</span> cl.ref_oid <span class="operator">=</span> ec.id  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   employee emp </span><br><span class="line">      <span class="keyword">on</span> emp.id <span class="operator">=</span> ec.emp_id  </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date <span class="operator">&gt;=</span><span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date<span class="operator">&lt;=</span><span class="string">&#x27;2013-11-08 16:00:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> emp.is_deleted <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>不需要了解业务场景，只需要改造的语句和改造之前的语句保持结果一致</p></li><li><p>现有索引可以满足，不需要建索引</p></li><li><p>用改造后的语句实验一下，只需要10ms 降低了近200倍！</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type   <span class="operator">|</span> possible_keys                   <span class="operator">|</span> key               <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> cl         <span class="operator">|</span> <span class="keyword">range</span>  <span class="operator">|</span> cm_log_cls_id,idx_last_upd_date <span class="operator">|</span> idx_last_upd_date <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span>  <span class="number">379</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> emp        <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>                         <span class="operator">|</span> <span class="keyword">PRIMARY</span>           <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.cl.ref_oid <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> cl         <span class="operator">|</span> <span class="keyword">range</span>  <span class="operator">|</span> cm_log_cls_id,idx_last_upd_date <span class="operator">|</span> idx_last_upd_date <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span>  <span class="number">379</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> ec         <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>,emp_certificate_empid   <span class="operator">|</span> <span class="keyword">PRIMARY</span>           <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.cl.ref_oid <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> emp        <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>                         <span class="operator">|</span> <span class="keyword">PRIMARY</span>           <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.ec.emp_id  <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                            <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span></span><br><span class="line"><span class="number">53</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><ul><li>案例二</li></ul><p>举这个例子的目的在于颠覆我们对列的区分度的认知，一般上我们认为区分度越高的列，越容易锁定更少的记录，但在一些特殊的情况下，这种理论是有局限性的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   stage_poi sp </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   sp.accurate_result<span class="operator">=</span><span class="number">1</span> </span><br><span class="line">   <span class="keyword">and</span> (</span><br><span class="line">      sp.sync_status<span class="operator">=</span><span class="number">0</span> </span><br><span class="line">      <span class="keyword">or</span> sp.sync_status<span class="operator">=</span><span class="number">2</span> </span><br><span class="line">      <span class="keyword">or</span> sp.sync_status<span class="operator">=</span><span class="number">4</span></span><br><span class="line">   );</span><br></pre></td></tr></table></figure><ol start="0"><li>先看看运行多长时间,951条数据6.22秒，真的很慢。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">951</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">6.22</span> sec)</span><br></pre></td></tr></table></figure><ol><li>先explain，rows达到了361万，type = ALL表明是全表扫描。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>    <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> sp    <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">3613155</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>所有字段都应用查询返回记录数，因为是单表查询 0已经做过了951条。</p></li><li><p>让explain的rows 尽量逼近951。</p></li></ol><p>看一下accurate_result = 1的记录数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),accurate_result <span class="keyword">from</span> stage_poi  <span class="keyword">group</span> <span class="keyword">by</span> accurate_result;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span> accurate_result <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">1023</span> <span class="operator">|</span>              <span class="number">-1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2114655</span> <span class="operator">|</span>               <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">972815</span> <span class="operator">|</span>               <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们看到accurate_result这个字段的区分度非常低，整个表只有-1,0,1三个值，加上索引也无法锁定特别少量的数据。</p><p>再看一下sync_status字段的情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),sync_status <span class="keyword">from</span> stage_poi  <span class="keyword">group</span> <span class="keyword">by</span> sync_status;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span> sync_status <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">3080</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3085413</span> <span class="operator">|</span>           <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+</span></span><br></pre></td></tr></table></figure><p>同样的区分度也很低，根据理论，也不适合建立索引。</p><p>&emsp;&emsp;问题分析到这，好像得出了这个表无法优化的结论，两个列的区分度都很低，即便加上索引也只能适应这种情况，很难做普遍性的优化，比如当sync_status 0、3分布的很平均，那么锁ß定记录也是百万级别的。</p><ol start="4"><li><p>找业务方去沟通，看看使用场景。业务方是这么来使用这个SQL语句的，每隔五分钟会扫描符合条件的数据，处理完成后把sync_status这个字段变成1,五分钟符合条件的记录数并不会太多，1000个左右。了解了业务方的使用场景后，优化这个SQL就变得简单了，因为业务方保证了数据的不平衡，如果加上索引可以过滤掉绝大部分不需要的数据。</p></li><li><p>根据建立索引规则，使用如下语句建立索引</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stage_poi <span class="keyword">add</span> index idx_acc_status(accurate_result,sync_status);</span><br></pre></td></tr></table></figure><ol start="6"><li>观察预期结果,发现只需要200ms，快了30多倍。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">952</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.20</span> sec)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们再来回顾一下分析问题的过程，单表查询相对来说比较好优化，大部分时候只需要把where条件里面的字段依照规则加上索引就好，如果只是这种“无脑”优化的话，显然一些区分度非常低的列，不应该加索引的列也会被加上索引，这样会对插入、更新性能造成严重的影响，同时也有可能影响其它的查询语句。所以我们第4步调差SQL的使用场景非常关键，我们只有知道这个业务场景，才能更好地辅助我们更好的分析和优化查询语句。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据表的类型&quot;&gt;&lt;a href=&quot;#数据表的类型&quot; class=&quot;headerlink&quot; title=&quot;数据表的类型&quot;&gt;&lt;/a&gt;数据表的类型&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;th align=&quot;</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiahaohong1997.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="SQL数据库" scheme="http://jiahaohong1997.github.io/tags/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存穿透与雪崩</title>
    <link href="http://jiahaohong1997.github.io/2021/11/12/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9/"/>
    <id>http://jiahaohong1997.github.io/2021/11/12/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9/</id>
    <published>2021-11-12T07:27:00.000Z</published>
    <updated>2021-11-12T10:52:09.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;用户想要查询一个数据，发现Redis数据库中没有，也就是缓存没有命中，于是向持久层数据库（例如Mysql）查询，发现也没有，于是本次查询失败。当用户很多时，缓存都没有命中（秒杀），于是都去请求持久层数据库，这会给持久层数据库造成很大压力，这时候就相当于出现了缓存穿透。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>&emsp;&emsp;布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。</p><p><img lazyload src="/images/loading.svg" data-src="1.png" alt="avater"></p><ul><li>特点</li></ul><p>&emsp;&emsp;特点是高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><ul><li>结构</li></ul><p>&emsp;&emsp;布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：</p><p><img lazyload src="/images/loading.svg" data-src="2.jpg" alt="avatar"></p><p>&emsp;&emsp;如果我们要映射一个值到布隆过滤器中，我们需要使用<strong>多个不同的哈希函数</strong>生成<strong>多个哈希值，</strong>并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：</p><p><img lazyload src="/images/loading.svg" data-src="3.jpg" alt="avatar"></p><p>&emsp;&emsp;我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p><p><img lazyload src="/images/loading.svg" data-src="4.jpg" alt="avatar"></p><p>&emsp;&emsp;值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，<strong>说明没有任何一个值映射到这个 bit 位上</strong>，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” <strong>存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</strong></p><p>&emsp;&emsp;这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p><ul><li>如何选择哈希函数和布隆过滤器的长度</li></ul><p>&emsp;&emsp;很显然，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。</p><p>&emsp;&emsp;另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。</p><h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><p>&emsp;&emsp;当存储层布命中后，即使返回空对象也将其存储起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。</p><p> <img lazyload src="/images/loading.svg" data-src="5.png" alt="avatar"></p><p>但是这种方法有两个问题：</p><ol><li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多空值的键；</li><li>即使对空值设置了过期时间，还是会存在缓存层和存储层数据有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li></ol><h1 id="缓存击穿（查询量太大，缓存过期）"><a href="#缓存击穿（查询量太大，缓存过期）" class="headerlink" title="缓存击穿（查询量太大，缓存过期）"></a>缓存击穿（查询量太大，缓存过期）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;这里需要注意和缓存穿透的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开一个洞。</p><p>&emsp;&emsp;当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同市访问数据库来查询最新数据，并且回写缓存，会导致数据库瞬间压力过大。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="设置热点数据永不过期"><a href="#设置热点数据永不过期" class="headerlink" title="设置热点数据永不过期"></a>设置热点数据永不过期</h3><p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题。</p><h3 id="加互斥锁"><a href="#加互斥锁" class="headerlink" title="加互斥锁"></a>加互斥锁</h3><p>分布式锁：使用分布式锁，保证每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;缓存雪崩，指在某一时间段，缓存集中过期失效，Redis宕机。产生雪崩的原因：比如双十一零点会迎来一波抢购，这波商品比较集中的放入了缓存，假设缓存一小时。那么到凌晨一点，这批商品的缓存都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会到达存储层，造成存储层挂掉。</p><p><img lazyload src="/images/loading.svg" data-src="6.png" alt="avatar"></p><p>&emsp;&emsp;其实集中过期到不是非常致命，比较致命的是缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对服务器造成的压力是不可预知的美很有可能瞬间就把数据库压垮。</p><p>双十一：停掉一些服务（保证主要的服务可用），例如退款功能。</p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h3><p>&emsp;&emsp;既然Redis可能挂掉，那就多增设几台redis，这样一台挂掉之后其他的还能继续工作，其实就是搭建集群。（异地多活）。</p><h3 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h3><p>&emsp;&emsp;在缓存失效后，通过加锁或者队列来控制读数据写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><h3 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h3><p>&emsp;&emsp;在正式部署前，把可能的数据预先访问一遍，这样大部分的数据就回家再到缓存中。在即将发生大并发访问前手动出发家在缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;缓存穿透（查不到）&quot;&gt;&lt;a href=&quot;#缓存穿透（查不到）&quot; class=&quot;headerlink&quot; title=&quot;缓存穿透（查不到）&quot;&gt;&lt;/a&gt;缓存穿透（查不到）&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="中间件" scheme="http://jiahaohong1997.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Redis" scheme="http://jiahaohong1997.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Go语言中的字符串操作</title>
    <link href="http://jiahaohong1997.github.io/2021/11/10/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
    <id>http://jiahaohong1997.github.io/2021/11/10/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</id>
    <published>2021-11-10T11:30:00.000Z</published>
    <updated>2021-11-11T17:56:06.530Z</updated>
    
    <content type="html"><![CDATA[<p>注：本节内容参考自<a class="link" href="http://books.studygolang.com/The-Golang-Standard-Library-by-Example/">《Go语言标准库》<i class="fas fa-external-link-alt"></i></a>，结合自己实际的使用体验进行总结。</p><h1 id="字符串的常见操作"><a href="#字符串的常见操作" class="headerlink" title="字符串的常见操作"></a>字符串的常见操作</h1><ul><li>字符串长度</li><li>求子串</li><li>是否存在某个字符或子串</li><li>子串出现的次数（字符串匹配）</li><li>字符串切割为[]string</li><li>字符串是否存在某个前缀或后缀</li><li>字符或子串在字符串中首次出现的位置或最后一次出现的位置</li><li>通过某个字符串将[]string连接起来</li><li>字符串重复几次</li><li>字符串中子串替换</li><li>大小写转换</li><li>Trim操作</li><li>…</li></ul><p>&emsp;&emsp;string类型可以看做一种特殊的slice类型，因此获取长度可以使用内置的函数 <code>len()</code>，同时支持切片操作，因此子串很容易获得。这里说的字符，指得是 rune 类型，即一个 UTF-8 字符（Unicode 代码点）</p><h1 id="1-字符串比较"><a href="#1-字符串比较" class="headerlink" title="1.字符串比较"></a>1.字符串比较</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compare函数，用于比较两个字符串的大小，如果两个字符串相等，返回0；如果a小于b，返回-1；如果a大于b，返回1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compare</span><span class="params">(a,b <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EqualFold函数，计算s与t忽略字母大小写是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EqualFold</span><span class="params">(s,t <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p> <strong>示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&quot;gopher&quot;</span></span><br><span class="line">b := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">fmt.Println(strings.Compare(a, b))</span><br><span class="line">fmt.Println(strings.Compare(a, a))</span><br><span class="line">fmt.Println(strings.Compare(b, a))</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.EqualFold(<span class="string">&quot;GO&quot;</span>, <span class="string">&quot;go&quot;</span>))</span><br><span class="line">fmt.Println(strings.EqualFold(<span class="string">&quot;壹&quot;</span>, <span class="string">&quot;一&quot;</span>))</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="2-是否存在某个字符或子串"><a href="#2-是否存在某个字符或子串" class="headerlink" title="2.是否存在某个字符或子串"></a>2.是否存在某个字符或子串</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子串 substr 在 s 中，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// chars 中任何一个 Unicode 代码点在 s 中，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsAny</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// Unicode 代码点 r 在 s 中，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsRune</span><span class="params">(s <span class="keyword">string</span>, r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>这里对 ContainsAny 函数进行一下说明，看如下例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;team&quot;</span>, <span class="string">&quot;i&quot;</span>))</span><br><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;failure&quot;</span>, <span class="string">&quot;u &amp; i&quot;</span>))</span><br><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;in failure&quot;</span>, <span class="string">&quot;s g&quot;</span>))</span><br><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说，第二个参数 chars 中任意一个字符（Unicode Code Point）如果在第一个参数 s 中存在，则返回 true。</p><p>&emsp;&emsp;查看这三个函数的源码，发现它们只是调用了相应的 Index 函数（子串出现的位置），然后和 0 作比较返回 true 或 fale。如，Contains：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Index(s, substr) &gt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-子串出现的次数"><a href="#3-子串出现的次数" class="headerlink" title="3.子串出现的次数"></a>3.子串出现的次数</h1><p>&emsp;&emsp;在数据结构与算法中，可能会讲解以下字符串匹配算法：</p><ul><li>朴素匹配算法</li><li>KMP 算法</li><li>Rabin-Karp 算法</li><li>Boyer-Moore 算法</li></ul><p>&emsp;&emsp;在 Go 中，查找子串出现次数即字符串模式匹配，实现的是 Rabin-Karp 算法。Count 函数的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在 Count 的实现中，处理了几种特殊情况，属于字符匹配预处理的一部分。这里要特别说明一下的是当 sep 为空时，Count 的返回值是：utf8.RuneCountInString(s) + 1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.Count(<span class="string">&quot;cheese&quot;</span>, <span class="string">&quot;e&quot;</span>))</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(<span class="string">&quot;谷歌中国&quot;</span>))</span><br><span class="line">fmt.Println(strings.Count(<span class="string">&quot;谷歌中国&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">12</span>  </span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>另外，Count 是计算子串在字符串中出现的无重叠的次数，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.Count(<span class="string">&quot;fivevev&quot;</span>, <span class="string">&quot;vev&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="4-字符串分割为-string"><a href="#4-字符串分割为-string" class="headerlink" title="4.字符串分割为[]string"></a>4.字符串分割为[]string</h1><h2 id="Fields-和-FieldsFunc"><a href="#Fields-和-FieldsFunc" class="headerlink" title="Fields 和 FieldsFunc"></a>Fields 和 FieldsFunc</h2><p>这两个函数的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FieldsFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) []<span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Fields 用一个或多个连续的空格分隔字符串 s，返回子字符串的数组（slice）。如果字符串 s 只包含空格，则返回空列表 ([]string 的长度为 0）。其中，空格的定义是 unicode.IsSpace，常见间隔符包括：’\t’, ‘\n’, ‘\v’, ‘\f’, ‘\r’, ‘ ‘, U+0085 (NEL), U+00A0 (NBSP)。</p><p>由于是用空格分隔，因此结果中不会含有空格或空子字符串，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;Fields are: %q&quot;</span>, strings.Fields(<span class="string">&quot;  foo bar  baz   &quot;</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fields are: [<span class="string">&quot;foo&quot;</span> <span class="string">&quot;bar&quot;</span> <span class="string">&quot;baz&quot;</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;FieldsFunc 用这样的 Unicode 代码点 c 进行分隔：满足 f(c) 返回 true。该函数返回[]string。如果字符串 s 中所有的代码点 (unicode code points) 都满足 f(c) 或者 s 是空，则 FieldsFunc 返回空 slice。</p><p>也就是说，我们可以通过实现一个回调函数来指定分隔字符串 s 的字符。比如上面的例子，我们通过 FieldsFunc 来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.FieldsFunc(<span class="string">&quot;  foo bar  baz   &quot;</span>, unicode.IsSpace))</span><br></pre></td></tr></table></figure><p>实际上，Fields 函数就是调用 FieldsFunc 实现的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> FieldsFunc(s, unicode.IsSpace)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目示例：</strong></p><p><a class="link" href="https://leetcode-cn.com/problems/count-vowel-substrings-of-a-string/">2062. 统计字符串中的元音子字符串<i class="fas fa-external-link-alt"></i></a></p><p><strong>子字符串</strong> 是字符串中的一个连续（非空）的字符序列。</p><p><strong>元音子字符串</strong> 是 <strong>仅</strong> 由元音（<code>&#39;a&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;i&#39;</code>、<code>&#39;o&#39;</code> 和 <code>&#39;u&#39;</code>）组成的一个子字符串，且必须包含 <strong>全部五种</strong> 元音。给你一个字符串 <code>word</code> ，统计并返回 <code>word</code> 中 <strong>元音子字符串的数目</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：word &#x3D; &quot;aeiouu&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：下面列出 word 中的元音子字符串（斜体加粗部分）：</span><br><span class="line">- &quot;aeiouu&quot;</span><br><span class="line">- &quot;aeiouu&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word &#x3D; &quot;unicornarihan&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：word 中不含 5 种元音，所以也不会存在元音子字符串。</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countVowelSubstrings</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="params">(ans <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> strings.FieldsFunc(word, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> !strings.ContainsRune(<span class="string">&quot;aeiou&quot;</span>, r) &#125;) &#123; <span class="comment">// 分割出仅包含元音的字符串</span></span><br><span class="line"></span><br><span class="line">cnt := [<span class="string">&#x27;v&#x27;</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">l := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">cnt[ch]++</span><br><span class="line"><span class="keyword">for</span> cnt[s[l]] &gt; <span class="number">1</span> &#123; <span class="comment">// 双指针，仅当该元音个数不止一个时才移动左指针</span></span><br><span class="line">cnt[s[l]]--</span><br><span class="line">l++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cnt[<span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[<span class="string">&#x27;e&#x27;</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[<span class="string">&#x27;i&#x27;</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[<span class="string">&#x27;o&#x27;</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[<span class="string">&#x27;u&#x27;</span>] &gt; <span class="number">0</span> &#123; <span class="comment">// 必须包含全部五种元音</span></span><br><span class="line">ans += l + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Split、SplitAfter、SplitN和SplitAfterN"><a href="#Split、SplitAfter、SplitN和SplitAfterN" class="headerlink" title="Split、SplitAfter、SplitN和SplitAfterN"></a>Split、SplitAfter、SplitN和SplitAfterN</h2><p>&emsp;&emsp;之所以将这四个函数放在一起讲，是因为它们都是通过一个同一个内部函数来实现的。它们的函数签名及其实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123; <span class="keyword">return</span> genSplit(s, sep, <span class="number">0</span>, <span class="number">-1</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitAfter</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123; <span class="keyword">return</span> genSplit(s, sep, <span class="built_in">len</span>(sep), <span class="number">-1</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitN</span><span class="params">(s, sep <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123; <span class="keyword">return</span> genSplit(s, sep, <span class="number">0</span>, n) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitAfterN</span><span class="params">(s, sep <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123; <span class="keyword">return</span> genSplit(s, sep, <span class="built_in">len</span>(sep), n) &#125;</span><br></pre></td></tr></table></figure><p>它们都调用了 genSplit 函数。</p><p>这四个函数都是通过 sep 进行分割，返回[]string。如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 <code>Split(&quot;abc&quot;,&quot;&quot;)</code>，得到的是[a b c]。</p><p>Split(s, sep) 和 SplitN(s, sep, -1) 等价；SplitAfter(s, sep) 和 SplitAfterN(s, sep, -1) 等价。</p><p>那么，Split 和 SplitAfter 有啥区别呢？通过这两句代码的结果就知道它们的区别了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;foo,bar,baz&quot;</span>, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.SplitAfter(<span class="string">&quot;foo,bar,baz&quot;</span>, <span class="string">&quot;,&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;foo&quot;</span> <span class="string">&quot;bar&quot;</span> <span class="string">&quot;baz&quot;</span>]</span><br><span class="line">[<span class="string">&quot;foo,&quot;</span> <span class="string">&quot;bar,&quot;</span> <span class="string">&quot;baz&quot;</span>]</span><br></pre></td></tr></table></figure><p>也就是说，Split 会将 s 中的 sep 去掉，而 SplitAfter 会保留 sep。</p><p>&emsp;&emsp;带 N 的方法可以通过最后一个参数 n 控制返回的结果中的 slice 中的元素个数，当 n &lt; 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n &gt; 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.SplitN(<span class="string">&quot;foo,bar,baz&quot;</span>, <span class="string">&quot;,&quot;</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;foo&quot;</span> <span class="string">&quot;bar,baz&quot;</span>]</span><br></pre></td></tr></table></figure><p>另外看一下官方文档提供的例子，注意一下输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;a man a plan a canal panama&quot;</span>, <span class="string">&quot;a &quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot; xyz &quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Bernardo O&#x27;Higgins&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;a&quot;</span> <span class="string">&quot;b&quot;</span> <span class="string">&quot;c&quot;</span>]</span><br><span class="line">[<span class="string">&quot;&quot;</span> <span class="string">&quot;man &quot;</span> <span class="string">&quot;plan &quot;</span> <span class="string">&quot;canal panama&quot;</span>]</span><br><span class="line">[<span class="string">&quot; &quot;</span> <span class="string">&quot;x&quot;</span> <span class="string">&quot;y&quot;</span> <span class="string">&quot;z&quot;</span> <span class="string">&quot; &quot;</span>]</span><br><span class="line">[<span class="string">&quot;&quot;</span>]</span><br></pre></td></tr></table></figure><h1 id="5-字符串中是否有某个前缀或后缀"><a href="#5-字符串中是否有某个前缀或后缀" class="headerlink" title="5.字符串中是否有某个前缀或后缀"></a>5.字符串中是否有某个前缀或后缀</h1><p>这两个函数比较简单，源码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s 中是否以 prefix 开始</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) &gt;= <span class="built_in">len</span>(prefix) &amp;&amp; s[<span class="number">0</span>:<span class="built_in">len</span>(prefix)] == prefix</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s 中是否以 suffix 结尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasSuffix</span><span class="params">(s, suffix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) &gt;= <span class="built_in">len</span>(suffix) &amp;&amp; s[<span class="built_in">len</span>(s)-<span class="built_in">len</span>(suffix):] == suffix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 prefix 或 suffix 为 “” , 返回值总是 true。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.HasPrefix(<span class="string">&quot;Gopher&quot;</span>, <span class="string">&quot;Go&quot;</span>))</span><br><span class="line">fmt.Println(strings.HasPrefix(<span class="string">&quot;Gopher&quot;</span>, <span class="string">&quot;C&quot;</span>))</span><br><span class="line">fmt.Println(strings.HasPrefix(<span class="string">&quot;Gopher&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">fmt.Println(strings.HasSuffix(<span class="string">&quot;Amigo&quot;</span>, <span class="string">&quot;go&quot;</span>))</span><br><span class="line">fmt.Println(strings.HasSuffix(<span class="string">&quot;Amigo&quot;</span>, <span class="string">&quot;Ami&quot;</span>))</span><br><span class="line">fmt.Println(strings.HasSuffix(<span class="string">&quot;Amigo&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="6-字符或子串在字符串中出现的位置"><a href="#6-字符或子串在字符串中出现的位置" class="headerlink" title="6.字符或子串在字符串中出现的位置"></a>6.字符或子串在字符串中出现的位置</h1><p>有一序列函数与该功能有关：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 s 中查找 sep 的第一次出现，返回第一次出现的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 在 s 中查找字节 c 的第一次出现，返回第一次出现的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexByte</span><span class="params">(s <span class="keyword">string</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// chars 中任何一个 Unicode 代码点在 s 中首次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexAny</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br><span class="line"><span class="comment">// Unicode 代码点 r 在 s 中第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexRune</span><span class="params">(s <span class="keyword">string</span>, r <span class="keyword">rune</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有三个对应的查找最后一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndex</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexByte</span><span class="params">(s <span class="keyword">string</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexAny</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>在 2.1.1 小节提到过，Contain 相关的函数内部调用的是响应的 Index 函数。</p><p>这一序列函数，只举 IndexFunc 的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">han := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unicode.Is(unicode.Han, c) <span class="comment">// 汉字</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(strings.IndexFunc(<span class="string">&quot;Hello, world&quot;</span>, han))</span><br><span class="line">fmt.Println(strings.IndexFunc(<span class="string">&quot;Hello, 世界&quot;</span>, han))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h1 id="7-字符串拼接（JOIN）操作"><a href="#7-字符串拼接（JOIN）操作" class="headerlink" title="7.字符串拼接（JOIN）操作"></a>7.字符串拼接（JOIN）操作</h1><p>&emsp;&emsp;将字符串数组（或slice）连接起来可以通过Join来实现，函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>看一下标准库的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  n := <span class="built_in">len</span>(sep) * (<span class="built_in">len</span>(a) - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">      n += <span class="built_in">len</span>(a[i])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">  bp := <span class="built_in">copy</span>(b, a[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">for</span> _, s := <span class="keyword">range</span> a[<span class="number">1</span>:] &#123;</span><br><span class="line">      bp += <span class="built_in">copy</span>(b[bp:], sep)</span><br><span class="line">      bp += <span class="built_in">copy</span>(b[bp:], s)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(Join([]<span class="keyword">string</span>&#123;<span class="string">&quot;name=xxx&quot;</span>, <span class="string">&quot;age=xx&quot;</span>&#125;, <span class="string">&quot;&amp;&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=xxx&amp;age=xx</span><br></pre></td></tr></table></figure><h1 id="8-字符串重复几次"><a href="#8-字符串重复几次" class="headerlink" title="8.字符串重复几次"></a>8.字符串重复几次</h1><p>函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(s <span class="keyword">string</span>, count <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>将 s 重复 count 次，如果 count 为负数或返回值长度 len(s)*count 超出 string 上限会导致 panic，这个函数使用很简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;ba&quot;</span> + strings.Repeat(<span class="string">&quot;na&quot;</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">banana</span><br></pre></td></tr></table></figure><h1 id="9-字符替换"><a href="#9-字符替换" class="headerlink" title="9.字符替换"></a>9.字符替换</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(mapping <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">rune</span>, <span class="title">s</span> <span class="title">string</span>) <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>Map 函数，将 s 的每一个字符按照 mapping 的规则做映射替换，如果 mapping 返回值 &lt;0 ，则舍弃该字符。该方法只能对每一个字符做处理，但处理方式很灵活，可以方便的过滤，筛选汉字等。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mapping := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> r &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; r &lt;= <span class="string">&#x27;Z&#x27;</span>: <span class="comment">// 大写字母转小写</span></span><br><span class="line">        <span class="keyword">return</span> r + <span class="number">32</span></span><br><span class="line">    <span class="keyword">case</span> r &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; r &lt;= <span class="string">&#x27;z&#x27;</span>: <span class="comment">// 小写字母不处理</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    <span class="keyword">case</span> unicode.Is(unicode.Han, r): <span class="comment">// 汉字换行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 过滤所有非字母、汉字的字符</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(strings.Map(mapping, <span class="string">&quot;Hello你#￥%……\n（&#x27;World\n,好Hello^(&amp;(*界gopher...&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">gopher</span><br></pre></td></tr></table></figure><h1 id="10-字符串子串替换"><a href="#10-字符串子串替换" class="headerlink" title="10.字符串子串替换"></a>10.字符串子串替换</h1><p>进行字符串替换时，考虑到性能问题，能不用正则尽量别用，应该用这里的函数。</p><p>字符串替换的函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 new 替换 s 中的 old，一共替换 n 个。</span></span><br><span class="line"><span class="comment">// 如果 n &lt; 0，则不限制替换次数，即全部替换</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 该函数内部直接调用了函数 Replace(s, old, new , -1)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReplaceAll</span><span class="params">(s, old, <span class="built_in">new</span> <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.Replace(<span class="string">&quot;oink oink oink&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;ky&quot;</span>, <span class="number">2</span>))</span><br><span class="line">fmt.Println(strings.Replace(<span class="string">&quot;oink oink oink&quot;</span>, <span class="string">&quot;oink&quot;</span>, <span class="string">&quot;moo&quot;</span>, <span class="number">-1</span>))</span><br><span class="line">fmt.Println(strings.ReplaceAll(<span class="string">&quot;oink oink oink&quot;</span>, <span class="string">&quot;oink&quot;</span>, <span class="string">&quot;moo&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oinky oinky oink</span><br><span class="line">moo moo moo</span><br><span class="line">moo moo moo</span><br></pre></td></tr></table></figure><h1 id="11-大小写转换"><a href="#11-大小写转换" class="headerlink" title="11.大小写转换"></a>11.大小写转换</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLowerSpecial</span><span class="params">(c unicode.SpecialCase, s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpperSpecial</span><span class="params">(c unicode.SpecialCase, s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>大小写转换包含了 4 个相关函数，ToLower,ToUpper 用于大小写转换。ToLowerSpecial,ToUpperSpecial 可以转换特殊字符的大小写。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.ToLower(<span class="string">&quot;HELLO WORLD&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToLower(<span class="string">&quot;Ā Á Ǎ À&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, <span class="string">&quot;壹&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, <span class="string">&quot;HELLO WORLD&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToLower(<span class="string">&quot;Önnek İş&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, <span class="string">&quot;Önnek İş&quot;</span>))</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.ToUpper(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToUpper(<span class="string">&quot;ā á ǎ à&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, <span class="string">&quot;一&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, <span class="string">&quot;hello world&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToUpper(<span class="string">&quot;örnek iş&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, <span class="string">&quot;örnek iş&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">ā á ǎ à</span><br><span class="line">壹</span><br><span class="line">hello world</span><br><span class="line">önnek iş</span><br><span class="line">önnek iş</span><br><span class="line">HELLO WORLD</span><br><span class="line">Ā Á Ǎ À       // 汉字拼音有效</span><br><span class="line">一           //  汉字无效</span><br><span class="line">HELLO WORLD</span><br><span class="line">ÖRNEK IŞ</span><br><span class="line">ÖRNEK İŞ    // 有细微差别</span><br></pre></td></tr></table></figure><h1 id="12-标题处理"><a href="#12-标题处理" class="headerlink" title="12.标题处理"></a>12.标题处理</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Title</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToTitle</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToTitleSpecial</span><span class="params">(c unicode.SpecialCase, s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>标题处理包含 3 个相关函数，其中 Title 会将 s 每个单词的首字母大写，不处理该单词的后续字符。ToTitle 将 s 的每个字母大写。ToTitleSpecial 将 s 的每个字母大写，并且会将一些特殊字母转换为其对应的特殊大写字母。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.Title(<span class="string">&quot;hElLo wOrLd&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitle(<span class="string">&quot;hElLo wOrLd&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, <span class="string">&quot;hElLo wOrLd&quot;</span>))</span><br><span class="line">fmt.Println(strings.Title(<span class="string">&quot;āáǎà ōóǒò êēéěè&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitle(<span class="string">&quot;āáǎà ōóǒò êēéěè&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, <span class="string">&quot;āáǎà ōóǒò êēéěè&quot;</span>))</span><br><span class="line">fmt.Println(strings.Title(<span class="string">&quot;dünyanın ilk borsa yapısı Aizonai kabul edilir&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitle(<span class="string">&quot;dünyanın ilk borsa yapısı Aizonai kabul edilir&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, <span class="string">&quot;dünyanın ilk borsa yapısı Aizonai kabul edilir&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HElLo WOrLd</span><br><span class="line">HELLO WORLD</span><br><span class="line">HELLO WORLD</span><br><span class="line">Āáǎà Ōóǒò Êēéěè</span><br><span class="line">ĀÁǍÀ ŌÓǑÒ ÊĒÉĚÈ</span><br><span class="line">ĀÁǍÀ ŌÓǑÒ ÊĒÉĚÈ</span><br><span class="line">Dünyanın Ilk Borsa Yapısı Aizonai Kabul Edilir</span><br><span class="line">DÜNYANIN ILK BORSA YAPISI AIZONAI KABUL EDILIR</span><br><span class="line">DÜNYANIN İLK BORSA YAPISI AİZONAİ KABUL EDİLİR</span><br></pre></td></tr></table></figure><h1 id="13-修剪（Trim）"><a href="#13-修剪（Trim）" class="headerlink" title="13.修剪（Trim）"></a>13.修剪（Trim）</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 s 左侧和右侧中匹配 cutset 中的任一字符的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 左侧的匹配 cutset 中的任一字符的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeft</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 右侧的匹配 cutset 中的任一字符的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRight</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 如果 s 的前缀为 prefix 则返回去掉前缀后的 string , 否则 s 没有变化。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 如果 s 的后缀为 suffix 则返回去掉后缀后的 string , 否则 s 没有变化。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSuffix</span><span class="params">(s, suffix <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 左侧和右侧的间隔符去掉。常见间隔符包括：&#x27;\t&#x27;, &#x27;\n&#x27;, &#x27;\v&#x27;, &#x27;\f&#x27;, &#x27;\r&#x27;, &#x27; &#x27;, U+0085 (NEL)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 左侧和右侧的匹配 f 的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 左侧的匹配 f 的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeftFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 右侧的匹配 f 的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRightFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>包含了 9 个相关函数用于修剪字符串。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="string">&quot;!!!@@@你好,!@#$ Gophers###$$$&quot;</span></span><br><span class="line">fmt.Println(strings.Trim(x, <span class="string">&quot;@#$!%^&amp;*()_+=-&quot;</span>))</span><br><span class="line">fmt.Println(strings.TrimLeft(x, <span class="string">&quot;@#$!%^&amp;*()_+=-&quot;</span>))</span><br><span class="line">fmt.Println(strings.TrimRight(x, <span class="string">&quot;@#$!%^&amp;*()_+=-&quot;</span>))</span><br><span class="line">fmt.Println(strings.TrimSpace(<span class="string">&quot; \t\n Hello, Gophers \n\t\r\n&quot;</span>))</span><br><span class="line">fmt.Println(strings.TrimPrefix(x, <span class="string">&quot;!&quot;</span>))</span><br><span class="line">fmt.Println(strings.TrimSuffix(x, <span class="string">&quot;$&quot;</span>))</span><br><span class="line"></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !unicode.Is(unicode.Han, r) <span class="comment">// 非汉字返回 true</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(strings.TrimFunc(x, f))</span><br><span class="line">fmt.Println(strings.TrimLeftFunc(x, f))</span><br><span class="line">fmt.Println(strings.TrimRightFunc(x, f))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">你好,!@<span class="comment">#$ Gophers</span></span><br><span class="line">你好,!@<span class="comment">#$ Gophers###$$$</span></span><br><span class="line">!!!@@@你好,!@<span class="comment">#$ Gophers</span></span><br><span class="line">Hello, Gophers</span><br><span class="line">!!@@@你好,!@<span class="comment">#$ Gophers###$$$</span></span><br><span class="line">!!!@@@你好,!@<span class="comment">#$ Gophers###$$</span></span><br><span class="line">你好</span><br><span class="line">你好,!@<span class="comment">#$ Gophers###$$$</span></span><br><span class="line">!!!@@@你好</span><br></pre></td></tr></table></figure><h1 id="14-Reader类型"><a href="#14-Reader类型" class="headerlink" title="14.Reader类型"></a>14.Reader类型</h1><p>&emsp;&emsp;看到名字就能猜到，这是实现了 <code>io</code> 包中的接口。它实现了 io.Reader（Read 方法），io.ReaderAt（ReadAt 方法），io.Seeker（Seek 方法），io.WriterTo（WriteTo 方法），io.ByteReader（ReadByte 方法），io.ByteScanner（ReadByte 和 UnreadByte 方法），io.RuneReader（ReadRune 方法） 和 io.RuneScanner（ReadRune 和 UnreadRune 方法）。</p><p>Reader 结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">  s        <span class="keyword">string</span>    <span class="comment">// Reader 读取的数据来源</span></span><br><span class="line">  i        <span class="keyword">int</span> <span class="comment">// current reading index（当前读的索引位置）</span></span><br><span class="line">  prevRune <span class="keyword">int</span> <span class="comment">// index of previous rune; or &lt; 0（前一个读取的 rune 索引位置）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 Reader 结构没有导出任何字段，而是提供一个实例化方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">Reader</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该方法接收一个字符串，返回的 Reader 实例就是从该参数字符串读数据。在后面学习了 bytes 包之后，可以知道 bytes.NewBufferString 有类似的功能，不过，如果只是为了读取，NewReader 会更高效。</p><p>&emsp;&emsp;其他方法不介绍了，都是之前接口的实现，有兴趣的可以看看源码实现，大部分都是根据 i、prevRune 两个属性来控制。</p><h1 id="15-Builder类型"><a href="#15-Builder类型" class="headerlink" title="15.Builder类型"></a>15.Builder类型</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Builder <span class="keyword">struct</span> &#123;</span><br><span class="line">    addr *Builder <span class="comment">// of receiver, to detect copies by value</span></span><br><span class="line">    buf  []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该类型实现了 io 包下的 Writer, ByteWriter, StringWriter 等接口，可以向该对象内写入数据，Builder 没有实现 Reader 等接口，所以该类型不可读，但提供了 String 方法可以获取对象内的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法向 b 写入一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteByte</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// WriteRune 方法向 b 写入一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="comment">// WriteRune 方法向 b 写入字节数组 p</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="comment">// WriteRune 方法向 b 写入字符串 s</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="comment">// Len 方法返回 b 的数据长度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// Cap 方法返回 b 的 cap。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// Grow 方法将 b 的 cap 至少增加 n (可能会更多)。如果 n 为负数，会导致 panic。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Grow</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// Reset 方法将 b 清空 b 的所有内容。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Reset</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// String 方法将 b 的数据以 string 类型返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>Builder 有 4 个与写入相关的方法，这 4 个方法的 error 都总是为 nil.</p><p>Builder 的 cap 会自动增长，一般不需要手动调用 Grow 方法。</p><p>String 方法可以方便的获取 Builder 的内容。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">b := strings.Builder&#123;&#125;</span><br><span class="line">_ = b.WriteByte(<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">n, _ := b.WriteRune(<span class="string">&#x27;夕&#x27;</span>)</span><br><span class="line">fmt.Println(n)</span><br><span class="line">n, _ = b.Write([]<span class="keyword">byte</span>(<span class="string">&quot;Hello, World&quot;</span>))</span><br><span class="line">fmt.Println(n)</span><br><span class="line">n, _ = b.WriteString(<span class="string">&quot;你好，世界&quot;</span>)</span><br><span class="line">fmt.Println(n)</span><br><span class="line">fmt.Println(b.Len())</span><br><span class="line">fmt.Println(b.Cap())</span><br><span class="line">b.Grow(<span class="number">100</span>)</span><br><span class="line">fmt.Println(b.Len())</span><br><span class="line">fmt.Println(b.Cap())</span><br><span class="line">fmt.Println(b.String())</span><br><span class="line">b.Reset()</span><br><span class="line">fmt.Println(b.String())</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">12</span><br><span class="line">15</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">31</span><br><span class="line">164</span><br><span class="line">7夕Hello, World你好，世界</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注：本节内容参考自&lt;a class=&quot;link&quot; href=&quot;http://books.studygolang.com/The-Golang-Standard-Library-by-Example/&quot;&gt;《Go语言标准库》&lt;i class=&quot;fas fa-external-l</summary>
      
    
    
    
    <category term="Go语言标准库" scheme="http://jiahaohong1997.github.io/categories/Go%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
    
    <category term="strings" scheme="http://jiahaohong1997.github.io/tags/strings/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://jiahaohong1997.github.io/2021/11/09/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://jiahaohong1997.github.io/2021/11/09/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2021-11-09T15:21:00.000Z</published>
    <updated>2021-11-11T17:34:27.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;主从复制，是指将一台Redis服务器上的数据，复制到其他的Redis服务器上。前者称为主节点（Master），后者称为从节点（Slave）。数据的复制是单向的，只能从主节点到从节点。Master以写为主，Slave以读为主。</p><p><img lazyload src="/images/loading.svg" data-src="1.png" alt="avatar"></p><p>主从复制，读写分离，80%的情况都是读操作，可以减缓服务器的压力。</p><p>&emsp;&emsp;默认情况下，每台Redis服务器都是主节点，且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。主从复制的作用主要包括：</p><ul><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式；</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余；</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量；</li><li>高可用(集群)基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><p>&emsp;&emsp;一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：</p><ul><li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</li><li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256GB，也不能将所有的内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20GB</li></ul><p>&emsp;&emsp;对于电商网站上的商品，一般都是一次上传，无数次浏览的，也就是“多读少写”。</p><h2 id="环境配置-单机上模拟，多机同理"><a href="#环境配置-单机上模拟，多机同理" class="headerlink" title="环境配置(单机上模拟，多机同理)"></a>环境配置(单机上模拟，多机同理)</h2><p>只配置从库，不用配置主库。</p><p>查看当前库的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0   <span class="comment"># 没有从机</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:05fce2cd1d05bab4c0c503cb7ef7c5c4c1b445e0</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将redis的配置文件复制若干次（要配置的从节点个数）：</p><p><img lazyload src="/images/loading.svg" data-src="2.jpg" alt="avatar"></p><p>然后修改每个配置文件中的项目如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port 6380  <span class="comment"># 端口号要改成从服务的节点</span></span><br><span class="line">pidfile /var/run/redis_6380.pid  <span class="comment"># pid file也要改成对应的名字</span></span><br><span class="line">logfile <span class="string">&quot;6380.log&quot;</span><span class="comment"># 日志文件名也要对应</span></span><br><span class="line">dbfilename dump6380.rdb  <span class="comment"># rdb文件命名也要修改</span></span><br></pre></td></tr></table></figure><p>然后分别启动主从服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-config/redis79.conf</span><br><span class="line">redis-server redis-config/redis80.conf</span><br><span class="line">redis-server redis-config/redis81.conf</span><br></pre></td></tr></table></figure><p>查看进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br><span class="line">  501 76856     1   0 12:08上午 ??         0:00.15 redis-server 127.0.0.1:6379</span><br><span class="line">  501 76963     1   0 12:09上午 ??         0:00.09 redis-server 127.0.0.1:6380</span><br><span class="line">  501 77118     1   0 12:09上午 ??         0:00.02 redis-server 127.0.0.1:6381</span><br><span class="line">  501 77166 73157   0 12:09上午 ttys004    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox redis</span><br></pre></td></tr></table></figure><h3 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h3><p>&emsp;&emsp;默认情况下，redis服务都是主机，一般情况下只需要配置从机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## port 6379</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:35cf0a87f4009c0db73dc38088333e56c6ae4ebd</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 6380</span></span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:89cbbf9896b1e99c65b6ce88e7d67af16bbb49f6</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 6381</span></span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:e0f2e6d24e37f5ce033a886d647c641b10289329</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;若将6379端口上的服务设为主机，6380、6381端口上的服务为从机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># slaveof [host] [port]</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6380&gt; slaveof 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave<span class="comment"># 角色转变为从机</span></span><br><span class="line">master_host:127.0.0.1<span class="comment"># 主机地址</span></span><br><span class="line">master_port:6379<span class="comment"># 主机端口</span></span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:2</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:84</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:494f98ba6749c752bb7ff2fb6e47f7c89c5712b8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:84</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:84</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6381&gt; slaveof 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:3</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:364</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:494f98ba6749c752bb7ff2fb6e47f7c89c5712b8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:364</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:351</span><br><span class="line">repl_backlog_histlen:14</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再查看一下主机（6379）上的主从信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=392,lag=1<span class="comment"># 从机信息</span></span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=392,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:494f98ba6749c752bb7ff2fb6e47f7c89c5712b8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:392</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:392</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;真实的主从配置应该在配置文件中配置，这样才是永久的，在redis客户端中通过命令来配置只是暂时的。</p><p>在配置文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################# REPLICATION #################################</span></span><br><span class="line"><span class="comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;  # 在此处配置主机的地址和端口</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在一主二从的配置方式中，主机可以写，从机不能写只能读。主机中的所有信息和数据，都会自动被从机保存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 主机</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment">### 从机1</span></span><br><span class="line">127.0.0.1:6380&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 从机2</span></span><br><span class="line">127.0.0.1:6381&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k1&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;若尝试在从机中写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">(error) READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;默认情况下，主机断开连接，从机依旧是连接到主机的，但是没有写操作了。当主机重新连回来时，从机依旧可以重新开始接收主机写入的数据。</p><p>&emsp;&emsp;如果是使用命令行配置的主从，若主机断开连接，重新连回来仍然是其他从机的主机；若某一个从机断开连接，再连回来就不再是从机了，在其断开连接后主机写入的数据就无法同步了。但只要重新将其设置为原来主机的丛机，马上就会写入主机的全部数据。</p><blockquote><p>复制原理</p></blockquote><p>Slave启动成功连接到master后会发送一个sync同步命令。Master接收到命令，启动后台的存盘进程，同时收集所有接受到的用于修改数据集命令，在后台进程执行完毕之后，Master将传送整个数据文件到Slave，并完成一次完全同步。Slave服务在接收集到数据文件数据后，将其存盘并加载到内存中。Master继续将新的所有收集到的修改命令一次传给Slave，完成同步。但是只要重新连接Master，一次完全同步（全量复制）将被自动执行。</p><ul><li>全量复制：Slave在接收到数据文件数据后，将其存盘并加载到内存中</li><li>增量复制：继续将新的所有收集到的修改命令一次传给Slave</li></ul><h3 id="层层链路"><a href="#层层链路" class="headerlink" title="层层链路"></a>层层链路</h3><p>&emsp;&emsp;另一种主从节点的配置方式如下图所示，1号服务既作为0号服务的从节点，也作为2号服务的主节点，打印看它的主从信息。</p><p><img lazyload src="/images/loading.svg" data-src="3.png" alt="avater"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:3</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:99242</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:494f98ba6749c752bb7ff2fb6e47f7c89c5712b8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:99242</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:99242</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;它的身份（role）还是作为从节点，所以是无法写入信息的。此时再向0号节点（Master）写入，1号、2号均能读取0号节点的值。这种形式也能完成主从复制。</p><p>&emsp;&emsp;如果此时Master断开，这时候能不能剩下的从节点选出一个作为Master吗？此时需要手动将其中一个从节点设置为主节点，使用<code>slaveof no one</code>让某个Slave变成Master，再其他节点手动连接到这个节点上（变来就以该节点作为Master的从节点不需要设置）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; slaveof no one</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=100321,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:7f67d870c3fd771f6427ea40516d4e8bdd26ab20</span><br><span class="line">master_replid2:494f98ba6749c752bb7ff2fb6e47f7c89c5712b8</span><br><span class="line">master_repl_offset:100321</span><br><span class="line">second_repl_offset:100308</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:100321</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;若原来的Master连回来之后，是不能够再自动将其作为主节点的。它已经被谋朝篡位了！！！！</p><h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>&emsp;&emsp;这是一种自动选取Master的模式。主从切换技术的方法是：当主机服务宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务不可用。这是一种不推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵模式）架构来解决这个问题。</p><p>&emsp;&emsp;谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库切换为主库。哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，他会独立运行。<strong>其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控多个Redis实例。</strong></p><p><img lazyload src="/images/loading.svg" data-src="4.png" alt="avatar"></p><p>&emsp;&emsp;哨兵有两个作用：</p><ol><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器；</li><li>当哨兵监测到Master宕机，会自动将Slave切换成Master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让他们切换主机。</li></ol><p>&emsp;&emsp;然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。哥哥哨兵之间还会进行监控，这样就形成了多哨兵模式。</p><p><img lazyload src="/images/loading.svg" data-src="5.png" alt="avatar"></p><p>&emsp;&emsp;假设主服务器宕机，哨兵1监测到这个结果，系统不会马上进行failover过程，仅仅是哨兵1主观认为主服务器不可用，这个现象称为<strong>主观下线</strong>，当其他的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover（故障转移）操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的主服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>&emsp;&emsp;采用一主二从的方式。</p><ol><li>配置哨兵配置文件<code>sentinel.conf</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 1</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><p>后面这个数字1，代表主机挂了，Slave投票让谁接替称为主机，票数最多的，就会成为主机。</p><ol start="2"><li>启动哨兵</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">hongjiahao@Mac  /usr/<span class="built_in">local</span>/bin  redis-sentinel redis-config/sentinel/sentinel.conf</span><br><span class="line">6546:X 12 Nov 2021 00:57:31.378 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.378 <span class="comment"># Redis version=6.2.3, bits=64, commit=00000000, modified=0, pid=6546, just started</span></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.378 <span class="comment"># Configuration loaded</span></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.379 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 256).</span><br><span class="line">6546:X 12 Nov 2021 00:57:31.379 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._</span><br><span class="line">           _.-``__ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line">      _.-``    `.  `_.  <span class="string">&#x27;&#x27;</span>-._           Redis 6.2.3 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line"> (    <span class="string">&#x27;      ,       .-`  | `,    )     Running in sentinel mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="string">&#x27;|     Port: 26379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 6546</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |           https://redis.io</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line">      `-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line">          `-._        _.-<span class="string">&#x27;</span></span><br><span class="line"><span class="string">              `-.__.-&#x27;</span></span><br><span class="line"></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.382 <span class="comment"># Sentinel ID is 4a00c3f869d1b542c0ae2f9c6c26ff69c0ebb5bc</span></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.382 <span class="comment"># +monitor master myredis 127.0.0.1 6379 quorum 1</span></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.384 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379</span><br><span class="line">6546:X 12 Nov 2021 00:57:31.385 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379</span><br></pre></td></tr></table></figure><ol start="3"><li>主机6379宕机，此时就会从从机中选择一个服务作为新的Master</li></ol><p><img lazyload src="/images/loading.svg" data-src="6.jpg" alt="avater"></p><p>&emsp;&emsp;此时主机变成6380，若原主机6379重新连上，<strong>只能成为新Master的从机</strong>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1、哨兵集群，基于主从复制，所有的主从配置优点全有；</p><p>2、主从节点可以切换，鼓掌可以转移，系统的可用性会更好；</p><p>3、哨兵模式就是主从模式的升级，手动到自动，更加健壮。</p><p>缺点：</p><p>1、Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦；</p><p>2、实现哨兵模式的配置其实很麻烦，里面有很多选择。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的ip port</span></span><br><span class="line"><span class="comment"># master-name 可以自己命名主节点名字。只能由字母A-Z、数字0-9、三个字符“.-_”组成</span></span><br><span class="line"><span class="comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联，呢么这是客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; </span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6380 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel实例的运行端口 默认26379。    如果有哨兵集群，还需要配置每个哨兵的端口</span></span><br><span class="line">port 26379</span><br><span class="line">user default on nopass ~* &amp;* +@all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码，这样所有连接Redis实例的客户端都需要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel连接主从的密码，注意必须主从设置一样的验证码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass myredis ********</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多少毫秒之后，主节点没有应答哨兵sentinel。此时哨兵主观认为主节点下线，默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds muredis 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定了在发生failover主从切换时每次最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长。</span></span><br><span class="line"><span class="comment"># 但如果这个数字越大，就意味着越多的slave因为replication而不可用</span></span><br><span class="line"><span class="comment"># 可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态</span></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs myredis 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel notification-script myredis /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关客户端master地址已经发生改变的信息</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本：</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script myredis /var/redis/reconfig.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir <span class="string">&quot;/usr/local/bin&quot;</span></span><br><span class="line"></span><br><span class="line">sentinel myid 4a00c3f869d1b542c0ae2f9c6c26ff69c0ebb5bc</span><br><span class="line">sentinel config-epoch myredis 1</span><br><span class="line">sentinel leader-epoch myredis 1</span><br><span class="line">sentinel current-epoch 1</span><br><span class="line">sentinel known-replica myredis 127.0.0.1 6379</span><br><span class="line">sentinel known-replica myredis 127.0.0.1 6381</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis主从复制&quot;&gt;&lt;a href=&quot;#Redis主从复制&quot; class=&quot;headerlink&quot; title=&quot;Redis主从复制&quot;&gt;&lt;/a&gt;Redis主从复制&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="中间件" scheme="http://jiahaohong1997.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Redis" scheme="http://jiahaohong1997.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>位运算技巧</title>
    <link href="http://jiahaohong1997.github.io/2021/10/29/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/"/>
    <id>http://jiahaohong1997.github.io/2021/10/29/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/</id>
    <published>2021-10-29T12:00:00.000Z</published>
    <updated>2021-10-29T12:56:40.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几个有趣的位操作"><a href="#几个有趣的位操作" class="headerlink" title="几个有趣的位操作"></a>几个有趣的位操作</h1><h2 id="利用或操作｜和空格将英文字符转换成小写"><a href="#利用或操作｜和空格将英文字符转换成小写" class="headerlink" title="利用或操作｜和空格将英文字符转换成小写"></a>利用或操作<code>｜</code>和空格将英文字符转换成小写</h2> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&#x27;a&#x27;</span></span><br><span class="line">A := <span class="string">&#x27;A&#x27;</span></span><br><span class="line"> </span><br><span class="line">t1 := <span class="keyword">string</span>(a | <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">t2 := <span class="keyword">string</span>(A | <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"> </span><br><span class="line">fmt.Println(t1)  <span class="comment">// a</span></span><br><span class="line">fmt.Println(t2)  <span class="comment">// a</span></span><br></pre></td></tr></table></figure><h2 id="利用与操作-amp-和下划线将英文字符转换成大写"><a href="#利用与操作-amp-和下划线将英文字符转换成大写" class="headerlink" title="利用与操作&amp;和下划线将英文字符转换成大写"></a>利用与操作<code>&amp;</code>和下划线将英文字符转换成大写</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="string">&#x27;b&#x27;</span></span><br><span class="line">B := <span class="string">&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line">t3 := <span class="keyword">string</span>(b &amp; <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">t4 := <span class="keyword">string</span>(B &amp; <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(t3)<span class="comment">// B</span></span><br><span class="line">fmt.Println(t4)<span class="comment">// B</span></span><br></pre></td></tr></table></figure><h2 id="利用异或操作-和空格进行英文大小写互换"><a href="#利用异或操作-和空格进行英文大小写互换" class="headerlink" title="利用异或操作^和空格进行英文大小写互换"></a>利用异或操作<code>^</code>和空格进行英文大小写互换</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="string">&#x27;c&#x27;</span></span><br><span class="line">C := <span class="string">&#x27;C&#x27;</span></span><br><span class="line"></span><br><span class="line">t5 := <span class="keyword">string</span>(c ^ <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">t6 := <span class="keyword">string</span>(C ^ <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(t5)<span class="comment">// C</span></span><br><span class="line">fmt.Println(t6)<span class="comment">// c</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;几个有趣的位操作&quot;&gt;&lt;a href=&quot;#几个有趣的位操作&quot; class=&quot;headerlink&quot; title=&quot;几个有趣的位操作&quot;&gt;&lt;/a&gt;几个有趣的位操作&lt;/h1&gt;&lt;h2 id=&quot;利用或操作｜和空格将英文字符转换成小写&quot;&gt;&lt;a href=&quot;#利用或操作｜和空格将</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="位运算" scheme="http://jiahaohong1997.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>最大栈</title>
    <link href="http://jiahaohong1997.github.io/2021/10/03/%E6%9C%80%E5%A4%A7%E6%A0%88/"/>
    <id>http://jiahaohong1997.github.io/2021/10/03/%E6%9C%80%E5%A4%A7%E6%A0%88/</id>
    <published>2021-10-03T07:16:00.000Z</published>
    <updated>2021-10-19T15:57:30.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大栈介绍"><a href="#最大栈介绍" class="headerlink" title="最大栈介绍"></a>最大栈介绍</h1><p>&emsp;&emsp;直接参考Leetcode上895题：<a class="link" href="https://leetcode-cn.com/problems/maximum-frequency-stack/">895. 最大频率栈<i class="fas fa-external-link-alt"></i></a></p><p>实现 <code>FreqStack</code>，模拟类似栈的数据结构的操作的一个类。</p><p><code>FreqStack</code> 有两个函数：</p><ul><li><code>push(int x)</code>，将整数 <code>x</code> 推入栈中。</li><li><code>pop()</code>，它移除并返回栈中出现最频繁的元素。<ul><li>如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],</span><br><span class="line">[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]</span><br><span class="line">输出：[null,null,null,null,null,null,null,5,7,5,4]</span><br><span class="line">解释：</span><br><span class="line">执行六次 .push 操作后，栈自底向上为 [5,7,5,7,4,5]。然后：</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 5，因为 5 是出现频率最高的。</span><br><span class="line">栈变成 [5,7,5,7,4]。</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 7，因为 5 和 7 都是频率最高的，但 7 最接近栈顶。</span><br><span class="line">栈变成 [5,7,5,4]。</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 5 。</span><br><span class="line">栈变成 [5,7,4]。</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 4 。</span><br><span class="line">栈变成 [5,7]。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>对 <code>FreqStack.push(int x)</code> 的调用中 <code>0 &lt;= x &lt;= 10^9</code>。</li><li>如果栈的元素数目为零，则保证不会调用 <code>FreqStack.pop()</code>。</li><li>单个测试样例中，对 <code>FreqStack.push</code> 的总调用次数不会超过 <code>10000</code>。</li><li>单个测试样例中，对 <code>FreqStack.pop</code> 的总调用次数不会超过 <code>10000</code>。</li><li>所有测试样例中，对 <code>FreqStack.push</code> 和 <code>FreqStack.pop</code> 的总调用次数不会超过 <code>150000</code>。</li></ul><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>&emsp;&emsp;<strong>这种设计数据结构的问题，主要是要搞清楚问题的难点在哪里，然后结合各种基本数据结构的特性，高效实现题目要求的 API</strong>。</p><p>那么，我们仔细思考一下 <code>push</code> 和 <code>pop</code> 方法，难点如下：</p><p>1、每次 <code>pop</code> 时，必须要知道频率最高的元素是什么。</p><p>2、如果频率最高的元素有多个，还得知道哪个是最近 <code>push</code> 进来的元素是哪个。</p><p>为了实现上述难点，我们要做到以下几点：</p><p>1、肯定要有一个变量 <code>maxFreq</code> 记录当前栈中最高的频率是多少。</p><p>2、我们得知道一个频率 <code>freq</code> 对应的元素有哪些，且这些元素要有时间顺序。</p><p>3、随着 <code>pop</code> 的调用，每个 <code>val</code> 对应的频率会变化，所以还得维持一个映射记录每个 <code>val</code> 对应的 <code>freq</code>。</p><h1 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h1><p>&emsp;&emsp;综上，我们可以先实现 <code>FreqStack</code> 所需的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FreqStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    maxFreq     <span class="keyword">int</span>     <span class="comment">// 出现最大频数的记录</span></span><br><span class="line">    valToFreq   <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">    freqToVal   <span class="keyword">map</span>[<span class="keyword">int</span>]*stack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">FreqStack</span></span> &#123;<span class="comment">// 初始化最大栈</span></span><br><span class="line">    mf := <span class="number">0</span></span><br><span class="line">    vf := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    fv := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*stack,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> FreqStack&#123;</span><br><span class="line">        maxFreq     :       mf,</span><br><span class="line">        valToFreq   :       vf,</span><br><span class="line">        freqToVal   :       fv,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们来亲自构建<code>stack</code>这一数据结构及其方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;<span class="comment">// 栈可以用一个简单的切片来表示</span></span><br><span class="line">    list        []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorStack</span><span class="params">()</span> *<span class="title">stack</span></span> &#123;<span class="comment">// 初始化栈</span></span><br><span class="line">    l := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;stack&#123;</span><br><span class="line">        list    :       l,   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">push</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;<span class="comment">// 入栈方法</span></span><br><span class="line">    s.list = <span class="built_in">append</span>(s.list,val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;<span class="comment">// 出栈方法，返回出栈的元素</span></span><br><span class="line">    n := <span class="built_in">len</span>(s.list)</span><br><span class="line">    old := s.list</span><br><span class="line">    last := old[n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        s.list = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s.list = old[:n<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">len</span><span class="params">()</span> <span class="title">int</span></span> &#123;<span class="comment">// 计算栈的容量的方法</span></span><br><span class="line">    n := <span class="built_in">len</span>(s.list)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其实这有点类似前文<a href="https://jiahaohong1997.github.io/tags/LFU/">LFU算法</a>，注意 <code>freqToVal</code> 中 <code>val</code> 列表用一个栈实现，如果一个 <code>freq</code> 对应的元素有多个，根据栈的特点，可以首先取出最近添加的元素。</p><p>要记住在 <code>push</code> 和 <code>pop</code> 方法中同时修改 <code>maxFreq</code>、<code>VF</code> 表、<code>FV</code> 表，否则容易出现 bug。</p><h2 id="Push方法"><a href="#Push方法" class="headerlink" title="Push方法"></a><code>Push</code>方法</h2><p>现在，我们可以来实现 <code>push</code> 方法了。</p><p>我们要分别实现对<code>FreqStack</code>结构体中三个元素的更新。</p><ul><li><code>valToFreq(VF表)</code>：如果<code>val</code>对应的映射存在，则映射到的值加1；如果不存在，则初始为1；</li><li><code>freqToVal(FV表)</code>：如果新加入的<code>val</code>对应的新的<code>freq</code>在<code>FV</code>表中没有初始化的栈，则创建一个新栈，将该<code>val</code>入栈；否则直接入栈；</li><li><code>maxFreq</code>：比较新的<code>freq</code>与原始的<code>maxFreq</code>，取大者作为<code>maxFreq</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FreqStack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> freq <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改vf表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.valToFreq[val]; !ok &#123;</span><br><span class="line">        this.valToFreq[val] = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.valToFreq[val]++</span><br><span class="line">    &#125;</span><br><span class="line">    freq = this.valToFreq[val]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改fv表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToVal[freq]; !ok &#123;</span><br><span class="line">        this.freqToVal[freq] = constructorStack()</span><br><span class="line">        this.freqToVal[freq].push(val)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.freqToVal[freq].push(val)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改最大频数</span></span><br><span class="line">    <span class="keyword">if</span> freq &gt; this.maxFreq &#123;</span><br><span class="line">        this.maxFreq = freq</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pop-方法"><a href="#Pop-方法" class="headerlink" title="Pop()方法"></a><code>Pop()</code>方法</h2><p>我们要分别实现对<code>FreqStack</code>结构体中三个元素的更新。</p><ul><li><code>freqToVal(FV表)</code>：找到<code>maxFreq</code>在<code>FV</code>表中的映射，如果映射到的<code>stack</code>容量为1(说明只有一个数的频率是<code>maxFreq</code>)，则将<code>maxFreq</code>减一并将栈顶元素出栈；否则直接将栈顶元素出栈；</li><li><code>valToFreq(VF表)</code>：找到出栈元素对应的<code>VF</code>表的映射（代表其出现频率），将其直接减一；</li><li><code>maxFreq</code>：已经在修改<code>FV</code>表时进行了选择性的修改，不做特殊操作。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FreqStack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.maxFreq == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> popNum <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改fv表</span></span><br><span class="line">    freq := this.maxFreq</span><br><span class="line">    <span class="keyword">if</span> this.freqToVal[freq].<span class="built_in">len</span>() == <span class="number">1</span> &#123;</span><br><span class="line">        popNum = this.freqToVal[freq].pop()</span><br><span class="line">        this.maxFreq--      <span class="comment">// 修改最大频数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        popNum = this.freqToVal[freq].pop() </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改vf表</span></span><br><span class="line">    this.valToFreq[popNum]--</span><br><span class="line">    <span class="keyword">return</span> popNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>完整的最大栈实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    list        []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">push</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s.list = <span class="built_in">append</span>(s.list,val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s.list)</span><br><span class="line">    old := s.list</span><br><span class="line">    last := old[n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        s.list = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s.list = old[:n<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s.list)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorStack</span><span class="params">()</span> *<span class="title">stack</span></span> &#123;</span><br><span class="line">    l := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;stack&#123;</span><br><span class="line">        list    :       l,   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FreqStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    maxFreq     <span class="keyword">int</span>     <span class="comment">// 出现最大频数的记录</span></span><br><span class="line">    valToFreq   <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">    freqToVal   <span class="keyword">map</span>[<span class="keyword">int</span>]*stack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">FreqStack</span></span> &#123;</span><br><span class="line">    mf := <span class="number">0</span></span><br><span class="line">    vf := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    fv := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*stack,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> FreqStack&#123;</span><br><span class="line">        maxFreq     :       mf,</span><br><span class="line">        valToFreq   :       vf,</span><br><span class="line">        freqToVal   :       fv,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FreqStack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> freq <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改vf表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.valToFreq[val]; !ok &#123;</span><br><span class="line">        this.valToFreq[val] = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.valToFreq[val]++</span><br><span class="line">    &#125;</span><br><span class="line">    freq = this.valToFreq[val]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改fv表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToVal[freq]; !ok &#123;</span><br><span class="line">        this.freqToVal[freq] = constructorStack()</span><br><span class="line">        this.freqToVal[freq].push(val)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.freqToVal[freq].push(val)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改最大频数</span></span><br><span class="line">    <span class="keyword">if</span> freq &gt; this.maxFreq &#123;</span><br><span class="line">        this.maxFreq = freq</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FreqStack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.maxFreq == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> popNum <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改fv表</span></span><br><span class="line">    freq := this.maxFreq</span><br><span class="line">    <span class="keyword">if</span> this.freqToVal[freq].<span class="built_in">len</span>() == <span class="number">1</span> &#123;</span><br><span class="line">        popNum = this.freqToVal[freq].pop()</span><br><span class="line">        this.maxFreq--      <span class="comment">// 修改最大频数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        popNum = this.freqToVal[freq].pop() </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改vf表</span></span><br><span class="line">    this.valToFreq[popNum]--</span><br><span class="line">    <span class="keyword">return</span> popNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FreqStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(val);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Pop();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最大栈介绍&quot;&gt;&lt;a href=&quot;#最大栈介绍&quot; class=&quot;headerlink&quot; title=&quot;最大栈介绍&quot;&gt;&lt;/a&gt;最大栈介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;直接参考Leetcode上895题：&lt;a class=&quot;link&quot; href=&quot;https:</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="最大栈" scheme="http://jiahaohong1997.github.io/tags/%E6%9C%80%E5%A4%A7%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的序列化和反序列化</title>
    <link href="http://jiahaohong1997.github.io/2021/10/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://jiahaohong1997.github.io/2021/10/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-10-02T09:19:00.000Z</published>
    <updated>2021-10-02T10:12:32.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列化的目的"><a href="#序列化的目的" class="headerlink" title="序列化的目的"></a>序列化的目的</h1><p>&emsp;&emsp;JSON 的运用非常广泛，比如我们经常将变成语言中的结构体序列化成 JSON 字符串，存入缓存或者通过网络发送给远端服务，消费者接受 JSON 字符串然后进行反序列化，就可以得到原始数据了。这就是「序列化」和「反序列化」的目的，以某种固定格式组织字符串，使得数据可以独立于编程语言。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><a class="link" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化<i class="fas fa-external-link-alt"></i></a></p><p>&emsp;&emsp;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>&emsp;&emsp;请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示:</strong> 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="serdeser.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,null,null,4,5]</span><br><span class="line">输出：[1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 104]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>&emsp;&emsp;我们可以用 <code>serialize</code> 方法将二叉树序列化成字符串，用 <code>deserialize</code> 方法将序列化的字符串反序列化成二叉树，至于以什么格式序列化和反序列化，这个完全由你决定。比如说输入如下这样一棵二叉树：</p><p><img lazyload src="/images/loading.svg" data-src="2.jpg" alt="avatar"></p><p>&emsp;&emsp;<code>serialize</code> 方法也许会把它序列化成字符串 <code>2,1,#,6,3,#,#</code>，其中 <code>#</code> 表示 <code>null</code> 指针，那么把这个字符串再输入 <code>deserialize</code> 方法，依然可以还原出这棵二叉树。也就是说，这两个方法会成对儿使用，你只要保证他俩能够自洽就行了。</p><p>&emsp;&emsp;想象一下，二叉树结该是一个二维平面内的结构，而序列化出来的字符串是一个线性的一维结构。<strong>所谓的序列化不过就是把结构化的数据「打平」，其实就是在考察二叉树的遍历方式</strong>。</p><p>&emsp;&emsp;二叉树的遍历方式有哪些？递归遍历方式有前序遍历，中序遍历，后序遍历；迭代方式一般是层级遍历。本文就把这些方式都尝试一遍，来实现 <code>serialize</code> 方法和 <code>deserialize</code> 方法。</p><h2 id="结构体构造"><a href="#结构体构造" class="headerlink" title="结构体构造"></a>结构体构造</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Codec <span class="keyword">struct</span> &#123;</span><br><span class="line">    s       <span class="keyword">string</span></span><br><span class="line">    null    <span class="keyword">string</span></span><br><span class="line">    sep     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">Codec</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Codec&#123;</span><br><span class="line">        null    :   <span class="string">&quot;#&quot;</span>,  <span class="comment">// 空节点</span></span><br><span class="line">        sep     :   <span class="string">&quot;,&quot;</span>,  <span class="comment">// 分隔符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>&emsp;&emsp;如下二叉树（<code>#</code> 代表空指针 null），可以直观看出前序遍历做的事情：</p><p><img lazyload src="/images/loading.svg" data-src="1.jpg" alt="avatar"></p><p>&emsp;&emsp;那么 <code>res = [1,2,-1,4,-1,-1,3,-1,-1]</code>，这就是将二叉树「打平」到了一个列表中，其中 -1 代表 null。</p><p>那么，将二叉树打平到一个字符串中也是完全一样的，至此，我们已经可以写出序列化函数 <code>serialize</code> 的代码了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serializes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">serialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        this.s = this.s + this.null + this.sep</span><br><span class="line">        <span class="keyword">return</span> this.s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node := strconv.Itoa(root.Val)</span><br><span class="line">    this.s = this.s + node + this.sep</span><br><span class="line">    this.serialize(root.Left)</span><br><span class="line">    this.serialize(root.Right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> this.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在，思考一下如何写 <code>deserialize</code> 函数，将字符串反过来构造二叉树。首先我们可以把字符串转化成列表：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.s = <span class="string">&quot;1,2,#,4,#,#,3,#,#,&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一般语境下，单单前序遍历结果是不能还原二叉树结构的，因为缺少空指针的信息，至少要得到前、中、后序遍历中的两种才能还原二叉树。但是这里的 <code>node</code>列表包含空指针的信息，所以只使用 <code>node</code> 列表就可以还原二叉树。那么，反序列化过程也是一样，<strong>先确定根节点 <code>root</code>，然后遵循前序遍历的规则，递归生成左右子树即可</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deserializes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">deserialize</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>) </span><br><span class="line">    j := <span class="number">0</span></span><br><span class="line">    f := <span class="number">0</span></span><br><span class="line">    x := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> data[i] == <span class="string">&#x27;,&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;#&#x27;</span> &#123;<span class="comment">// 当前节点是空指针</span></span><br><span class="line">            m = <span class="built_in">append</span>(m,math.MinInt32)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;-&#x27;</span> &#123;<span class="comment">// 当前节点是负值</span></span><br><span class="line">            <span class="keyword">for</span> j = i+<span class="number">1</span>; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span>+x</span><br><span class="line">            &#125;           </span><br><span class="line">            m = <span class="built_in">append</span>(m,<span class="number">-1</span>*f)</span><br><span class="line">            i = j</span><br><span class="line">            f = <span class="number">0</span> </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j = i; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span>+x</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            m = <span class="built_in">append</span>(m,f)</span><br><span class="line">            i = j</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(&amp;m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(m *[]<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(*m) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 列表最左侧就是根节点</span></span><br><span class="line">    first := (*m)[<span class="number">0</span>]</span><br><span class="line">    *m = (*m)[<span class="number">1</span>:]<span class="comment">// 引用全局变量进行操作，就不会随递归栈进行变化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> first == math.MinInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    root := &amp;TreeNode&#123;first,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">    root.Left = helper(m)</span><br><span class="line">    root.Right = helper(m)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><p>&emsp;&emsp;明白了前序遍历的解法，后序遍历就比较容易理解了，我们首先实现 <code>serialize</code> 序列化方法，只需要稍微修改辅助方法即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">serialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        this.s = this.s + this.null + this.sep</span><br><span class="line">        <span class="keyword">return</span> this.s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.serialize(root.Left)</span><br><span class="line">    this.serialize(root.Right)</span><br><span class="line"></span><br><span class="line">    x := strconv.Itoa(root.Val)</span><br><span class="line">    this.s = this.s + x + this.sep</span><br><span class="line">    <span class="keyword">return</span> this.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;后序遍历导致结果的顺序发生变化：</p><p><img lazyload src="/images/loading.svg" data-src="postorder.jpg" alt="avatar"></p><p>&emsp;&emsp;关键的难点在于，如何实现后序遍历的 <code>deserialize</code> 方法呢？是不是也简单地将关键代码放到后序遍历的位置就行了呢？**<code>deserialize</code> 方法首先寻找 <code>root</code> 节点的值，然后递归计算左右子节点<strong>。那么我们这里也应该顺着这个基本思路走，后续遍历中，<code>root</code> 节点的值能不能找到？<code>root</code> 的值是列表的最后一个元素。我们应该从后往前取出列表元素，先用最后一个元素构造 <code>root</code>，然后递归调用生成 <code>root</code> 的左右子树。</strong>注意，根据上图，从后往前在 <code>nodes</code> 列表中取元素，一定要先构造 <code>root.right</code> 子树，后构造 <code>root.left</code> 子树**。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">deserialize</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(data);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> data[i] == <span class="string">&#x27;,&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;#&#x27;</span> &#123;</span><br><span class="line">            m = <span class="built_in">append</span>(m,math.MinInt32)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;-&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j=i+<span class="number">1</span>; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span> + x</span><br><span class="line">            &#125;</span><br><span class="line">            m = <span class="built_in">append</span>(m,<span class="number">-1</span>*f)</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">            i = j</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j=i; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span> + x</span><br><span class="line">            &#125;</span><br><span class="line">            m = <span class="built_in">append</span>(m,f)</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">            i = j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(&amp;m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(m *[]<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(*m) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n := <span class="built_in">len</span>(*m)</span><br><span class="line">    last := (*m)[n<span class="number">-1</span>]</span><br><span class="line">    *m = (*m)[:n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> last == math.MinInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    root := &amp;TreeNode&#123;</span><br><span class="line">        Val     :       last,</span><br><span class="line">        Left    :       <span class="literal">nil</span>,</span><br><span class="line">        Right   :       <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    root.Right = helper(m)<span class="comment">//一定要先构造 root.right 子树</span></span><br><span class="line">    root.Left = helper(m)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历-不能实现"><a href="#中序遍历-不能实现" class="headerlink" title="中序遍历(不能实现)"></a>中序遍历(不能实现)</h2><p>&emsp;&emsp;先说结论，中序遍历的方式行不通，因为无法实现反序列化方法 <code>deserialize</code>。</p><p>&emsp;&emsp;序列化方法 <code>serialize</code> 依然容易，只要把字符串的拼接操作放到中序遍历的位置就行了。但是，我们刚才说了，要想实现反序列方法，首先要构造 <code>root</code> 节点。前序遍历得到的 <code>nodes</code> 列表中，第一个元素是 <code>root</code> 节点的值；后序遍历得到的 <code>nodes</code> 列表中，最后一个元素是 <code>root</code> 节点的值。</p><p>&emsp;&emsp;而中序遍历的<code>root</code> 的值被夹在两棵子树的中间，也就是在 <code>nodes</code> 列表的中间，我们不知道确切的索引位置，所以无法找到 <code>root</code> 节点，也就无法进行反序列化。</p><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>序列化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">serialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        this.s = this.s + this.null + this.sep</span><br><span class="line">        <span class="keyword">return</span> this.s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    nodeNum := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; nodeNum&gt;<span class="number">0</span>; i++ &#123;</span><br><span class="line">        p := []*TreeNode&#123;&#125;</span><br><span class="line">        nodeNum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(q); j++ &#123;</span><br><span class="line">            node := q[j]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">                this.s = this.s + this.null + this.sep</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            this.s = this.s + strconv.Itoa(node.Val) + this.sep</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                nodeNum++</span><br><span class="line">                p = <span class="built_in">append</span>(p,node.Left)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p,<span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                nodeNum++</span><br><span class="line">                p = <span class="built_in">append</span>(p,node.Right)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p,<span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层级遍历序列化得出的结果如下图：</p><p><img lazyload src="/images/loading.svg" data-src="3.jpg" alt="avatar"></p><p>&emsp;&emsp;可以看到，每一个非空节点都会对应两个子节点，<strong>那么反序列化的思路也是用队列进行层级遍历，同时用索引 <code>i</code> 记录对应子节点的位置</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">deserialize</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(data);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> data[i] == <span class="string">&#x27;,&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;#&#x27;</span> &#123;</span><br><span class="line">            m = <span class="built_in">append</span>(m,math.MinInt32)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;-&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j=i+<span class="number">1</span>; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span> + x</span><br><span class="line">            &#125;</span><br><span class="line">            m = <span class="built_in">append</span>(m,<span class="number">-1</span>*f)</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">            i = j</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j=i; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span> + x</span><br><span class="line">            &#125;</span><br><span class="line">            m = <span class="built_in">append</span>(m,f)</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">            i = j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(m []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(m) == <span class="number">0</span> || m[<span class="number">0</span>] == math.MinInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root := &amp;TreeNode&#123;m[<span class="number">0</span>],<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(m); &#123;</span><br><span class="line">        parent := q[<span class="number">0</span>]</span><br><span class="line">        q = q[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> m[i] != math.MinInt32 &#123;<span class="comment">// 左子树</span></span><br><span class="line">            parent.Left = &amp;TreeNode&#123;m[i],<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">            q = <span class="built_in">append</span>(q,parent.Left)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.Left = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> m[i] != math.MinInt32 &#123;<span class="comment">// 右子树</span></span><br><span class="line">            parent.Right = &amp;TreeNode&#123;m[i],<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">            q = <span class="built_in">append</span>(q,parent.Right)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.Right = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;序列化的目的&quot;&gt;&lt;a href=&quot;#序列化的目的&quot; class=&quot;headerlink&quot; title=&quot;序列化的目的&quot;&gt;&lt;/a&gt;序列化的目的&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;JSON 的运用非常广泛，比如我们经常将变成语言中的结构体序列化成 JSON 字符串</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="二叉树" scheme="http://jiahaohong1997.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>堆的Go语言实现</title>
    <link href="http://jiahaohong1997.github.io/2021/09/27/%E5%A0%86%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
    <id>http://jiahaohong1997.github.io/2021/09/27/%E5%A0%86%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-09-27T07:07:00.000Z</published>
    <updated>2021-11-14T15:18:37.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆的简介"><a href="#堆的简介" class="headerlink" title="堆的简介"></a>堆的简介</h1><p>&emsp;&emsp;首先，堆和二叉树有啥关系呢，为什么人们总数把堆画成一棵二叉树？因为，堆在逻辑上其实是一种特殊的二叉树<strong>（完全二叉树）</strong>，只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针：</p><p>&emsp;&emsp;画个图你立即就能理解了，比如 <code>arr</code> 是一个字符数组，注意数组的第一个索引 0 空着不用：</p><p><img lazyload src="/images/loading.svg" data-src="2.png" alt="avatar"></p><p>&emsp;&emsp;因为这棵二叉树是<font color="red">「完全二叉树」</font>，所以把 <code>arr[1]</code> 作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。</p><p>&emsp;&emsp;为了方便讲解，下面都会画的图都是二叉树结构，相信你能把树和数组对应起来。二叉堆还分为最大堆和最小堆。<strong>最大堆的性质是：每个节点都大于等于它的两个子节点。</strong>类似的，最小堆的性质是：每个节点都小于等于它的子节点。</p><h1 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h1><p>&emsp;&emsp;在Go语言的标准库<code>container/heap</code>中，实现了二叉堆，我们先来看看这个包下面有什么内容。</p><ol><li>接口定义</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这个堆结构继承自 sort.Interface, 回顾下 <a href="https://jiahaohong1997.github.io/2021/06/10/%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89sort%E5%87%BD%E6%95%B0/">sort.Interface</a>，它需要实现三个方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">Len() <span class="keyword">int</span></span><br><span class="line">Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上堆接口定义的两个方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(h Interface, x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span> <span class="title">interface</span></span>&#123;&#125; &#123;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也就是说，要实现一个堆需要完整实现上述5个方法。</p><ol start="2"><li>上浮<code>up</code>和下沉<code>down</code>方法</li></ol><p>&emsp;&emsp;我们要讲的是最小堆，每个节点都比它的两个子节点小，但是在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。</p><p>&emsp;&emsp;对于最小堆，会破坏堆性质的有有两种情况：</p><ul><li><code>down</code>：如果某个节点 A 比它的子节点（中的一个）大，那么 A 就不配做父节点，应该下去，下面那个更小的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">down</span><span class="params">(h Interface, i0, n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">i := i0</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">j1 := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> j1 &gt;= n || j1 &lt; <span class="number">0</span> &#123; <span class="comment">// j1 &lt; 0 after int overflow</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">j := j1 <span class="comment">// left child</span></span><br><span class="line"><span class="keyword">if</span> j2 := j1 + <span class="number">1</span>; j2 &lt; n &amp;&amp; h.Less(j2, j1) &#123;</span><br><span class="line">j = j2 <span class="comment">// = 2*i + 2  // right child</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !h.Less(j, i) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">h.Swap(i, j)</span><br><span class="line">i = j</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i &gt; i0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>up</code>：如果某个节点 A 比它的父节点小，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">up</span><span class="params">(h Interface, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i := (j - <span class="number">1</span>) / <span class="number">2</span> <span class="comment">// parent</span></span><br><span class="line"><span class="keyword">if</span> i == j || !h.Less(j, i) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">h.Swap(i, j)</span><br><span class="line">j = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然，错位的节点 A 可能要上浮（或下沉）很多次，才能到达正确的位置，恢复堆的性质。所以代码中肯定有一个 <code>for</code> 循环。</p><ul><li><code>fix</code>：当堆中某一节点的值发生改变后，要对其进行<strong>上浮</strong>或<strong>下沉</strong>操作</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fix</span><span class="params">(h Interface, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !down(h, i, h.Len()) &#123;</span><br><span class="line">up(h, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>初始化结构体（建堆）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(h Interface)</span></span> &#123;</span><br><span class="line"><span class="comment">// heapify</span></span><br><span class="line">n := h.Len()</span><br><span class="line"><span class="keyword">for</span> i := n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">down(h, i, n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可见，在Go语言中是以<code>0</code>为首开始存储的，所以对于这歌满二叉树，索引为<code>x</code>的节点左子树索引为<code>2*x+1</code>，右子树为<code>2*x+2</code>。</p><ol start="4"><li>堆的增，出堆和删操作</li></ol><ul><li>增<code>Push</code></li></ul><p>&emsp;&emsp;当在当前堆中增加元素时，先在队列的最末尾处（完全二叉树的最后一个节点）将其插入，然后再利用<strong>上浮</strong>操作调整其位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Push pushes the element x onto the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(h Interface, x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    h.Push(x)<span class="comment">// h.Push(x)是外层实体的方法，与本方法不相同</span></span><br><span class="line">up(h, h.Len()<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>出堆<code>Pop</code></li></ul><p>&emsp;&emsp;堆的Pop操作是先将堆顶元素与最后一个元素交换位置，然后再将交换后的堆顶元素<strong>下沉</strong>到属于它的位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pop removes and returns the minimum element (according to Less) from the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="comment">// Pop is equivalent to Remove(h, 0).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">n := h.Len() - <span class="number">1</span></span><br><span class="line">h.Swap(<span class="number">0</span>, n)</span><br><span class="line">down(h, <span class="number">0</span>, n)</span><br><span class="line">    <span class="keyword">return</span> h.Pop()<span class="comment">// 这里的h.Pop()是用户自己定义的方法，以上部分操作都只负责将堆顶元素放到末尾并使堆保持其规则，最后这一行是用户自己对实体的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除任意节点<code>Remove</code></li></ul><p>&emsp;&emsp;删除任意节点的索引为<code>i</code>，将其与最后一个节点调换位置，然后将调换到索引<code>i</code>处的节点<strong>下沉</strong>到属于它的位置。特别的：出堆操作就是删除最后一个节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove removes and returns the element at index i from the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(h Interface, i <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">n := h.Len() - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> n != i &#123;</span><br><span class="line">h.Swap(i, n)</span><br><span class="line"><span class="keyword">if</span> !down(h, i, n) &#123;</span><br><span class="line">up(h, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> h.Pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现int类型的堆"><a href="#实现int类型的堆" class="headerlink" title="实现int类型的堆"></a>实现int类型的堆</h1><p>&emsp;&emsp;在官方文档给的示例中<a class="link" href="https://github1s.com/golang/go/blob/master/src/container/heap/example_intheap_test.go">example_intheap_test.go<i class="fas fa-external-link-alt"></i></a>，介绍了怎么通过调用heap包来实现int类型的二叉堆。我们来看看其具体的实现流程。</p><ol><li>定义一个新的类型，实现五个固定的方法</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;<span class="comment">// 小端堆用&lt;，大端堆则反过来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;<span class="comment">// 增添一个新元素</span></span><br><span class="line"><span class="comment">// Push and Pop use pointer receivers because they modify the slice&#x27;s length,</span></span><br><span class="line"><span class="comment">// not just its contents.</span></span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;<span class="comment">// 推出最后一个元素</span></span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>完整代码</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2012 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This example demonstrates an integer heap built using the heap interface.</span></span><br><span class="line"><span class="keyword">package</span> heap_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// Push and Pop use pointer receivers because they modify the slice&#x27;s length,</span></span><br><span class="line"><span class="comment">// not just its contents.</span></span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example inserts several ints into an IntHeap, checks the minimum,</span></span><br><span class="line"><span class="comment">// and removes them in order of priority.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example_intHeap</span><span class="params">()</span></span> &#123;</span><br><span class="line">h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">heap.Init(h)<span class="comment">// 初始化这个堆，此时堆已经建好了</span></span><br><span class="line">heap.Push(h, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;minimum: %d\n&quot;</span>, (*h)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, heap.Pop(h))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// minimum: 1</span></span><br><span class="line"><span class="comment">// 1 2 3 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>&emsp;&emsp;在<code>/src/container/heap/example_pq_test.go</code>文件中给出了使用堆实现一个优先队列的示例。不同于int类型的堆，可以直接根据元素的值的大小决定其优先级，优先队列中的每个元素需要通过一个<code>priority</code>变量设置各自的优先级。同时，还需要设置一个变量<code>index</code>来保持与队列中的索引号一致。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An Item is something we manage in a priority queue.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">    value<span class="keyword">string</span> <span class="comment">// The value of the item; arbitrary.</span></span><br><span class="line">    priority<span class="keyword">int</span> <span class="comment">// The priority of the item in the queue.</span></span><br><span class="line">    <span class="comment">// The index is needed by update and is maintained by the heap.Interface methods.</span></span><br><span class="line">    index<span class="keyword">int</span> <span class="comment">// The index of the item in the heap.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后就可以初始化一个堆了，我们要为这个优先队列设立<code>Len()</code>、<code>Swap()</code>、<code>Less()</code>三个方法使其先变成一个<code>sort.Interface</code>类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A PriorityQueue implements heap.Interface and holds Items.</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(pq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">    pq[i].index = i</span><br><span class="line">    pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// We want Pop to give us the highest, not lowest, priority so we use greater than here.</span></span><br><span class="line">    <span class="keyword">return</span> pq[i].priority &gt; pq[j].priority</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后就是经典的<code>Push()</code>和<code>Pop()</code>方法的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(*pq)</span><br><span class="line">    item := x.(*Item)</span><br><span class="line">    item.index = n</span><br><span class="line">    *pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *pq</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    item := old[n<span class="number">-1</span>]</span><br><span class="line">    old[n<span class="number">-1</span>] = <span class="literal">nil</span><span class="comment">// avoid memory leak</span></span><br><span class="line">    item.index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">    *pq = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当某一个节点的值或优先级发生改变时，再实现一个<code>update</code>方法来调整优先队列的顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">update</span><span class="params">(item *Item, value, priority)</span></span> &#123;</span><br><span class="line">    item.value = value</span><br><span class="line">    item.priority = priority</span><br><span class="line">    heap.fix(pq, item.index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;完整的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> heap_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An Item is something we manage in a priority queue.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">    value<span class="keyword">string</span><span class="comment">// The value of the item; arbitrary.</span></span><br><span class="line">    priority<span class="keyword">int</span><span class="comment">// The priority of the item in the queue.</span></span><br><span class="line">    <span class="comment">// The index is needed by update and is maintained by the heap.Interface methods.</span></span><br><span class="line">    index<span class="keyword">int</span><span class="comment">// The index of the item in the heap.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A PriorityQueue implements heap.Interface and holds Items.</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(pq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">    pq[i].index = i</span><br><span class="line">    pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// We want Pop to give us the highest, not lowest, priority so we use greater than here.</span></span><br><span class="line">    <span class="keyword">return</span> pq[i].priority &gt; pq[j].priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(*pq)</span><br><span class="line">    item := x.(*Item)</span><br><span class="line">    item.index = n</span><br><span class="line">    *pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *pq</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    item := old[n<span class="number">-1</span>]</span><br><span class="line">    old[n<span class="number">-1</span>] = <span class="literal">nil</span><span class="comment">// avoid memory leak</span></span><br><span class="line">    item.index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">    *pq = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">update</span><span class="params">(item *Item, value, priority)</span></span> &#123;</span><br><span class="line">    item.value = value</span><br><span class="line">    item.priority = priority</span><br><span class="line">    heap.fix(pq, item.index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// This example creates a PriorityQueue with some items, adds and manipulates an item,</span></span><br><span class="line"><span class="comment">// and then removes the items in priority order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example_priorityQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Some items and their priorities.</span></span><br><span class="line">items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">&quot;banana&quot;</span>: <span class="number">3</span>, <span class="string">&quot;apple&quot;</span>: <span class="number">2</span>, <span class="string">&quot;pear&quot;</span>: <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create a priority queue, put the items in it, and</span></span><br><span class="line">    <span class="comment">// establish the priority queue (heap) invariants.</span></span><br><span class="line">    pq := <span class="built_in">make</span>(PriorityQueue,<span class="built_in">len</span>(items))</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> value, priority := <span class="keyword">range</span> items &#123;</span><br><span class="line">        pq[i] = &amp;Items &#123;</span><br><span class="line">            value:value,</span><br><span class="line">            priority:priority,</span><br><span class="line">            index:i,</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    heap.Init(&amp;pq)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Insert a new item and then modify its priority.</span></span><br><span class="line">    item := &amp;Item&#123;</span><br><span class="line">        value:    <span class="string">&quot;orange&quot;</span>,</span><br><span class="line">        priority: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    heap.Push(&amp;pq, item)</span><br><span class="line">    pq.update(item, item.value, <span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Take the items out; they arrive in decreasing priority order.</span></span><br><span class="line">    <span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        item := heap.Pop(&amp;pq).(*Item)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%.2d:%s &quot;</span>, item.priority, item.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// 05:orange 04:pear 03:banana 02:apple</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LeetCode经典题目"><a href="#LeetCode经典题目" class="headerlink" title="LeetCode经典题目"></a>LeetCode经典题目</h1><h2 id="实现一个优先队列"><a href="#实现一个优先队列" class="headerlink" title="实现一个优先队列"></a>实现一个优先队列</h2><p>&emsp;&emsp;优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。 优先队列往往用堆来实现。我们在上一节实现了一个int类型的堆，它的排序规则是直接根据存入的数据的值来决定的。对于优先队列而言，我们存入的数据可能是一个切片的索引数组，其排序规则是该切片的值的大小，只不过体现在堆中，存入的是其索引。这样我们就可以通过其索引控制出入优先队列是时机，并保证能够适时地得到堆顶的值。如下图所示：</p><p><img lazyload src="/images/loading.svg" data-src="1.jpg" alt="avatar"></p><p>&emsp;&emsp;接下来我们来看一道很经典的题。</p><p><a class="link" href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值<i class="fas fa-external-link-alt"></i></a></p><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,-1], k &#x3D; 1</span><br><span class="line">输出：[1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [9,11], k &#x3D; 2</span><br><span class="line">输出：[11]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,-2], k &#x3D; 2</span><br><span class="line">输出：[4]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= nums.length &lt;= 105</code></p></li><li><p><code>-104 &lt;= nums[i] &lt;= 104</code></p></li><li><p><code>1 &lt;= k &lt;= nums.length</code></p></li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;由于每次都要找到最大值，很自然的想到一种数据结构：<strong>优先队列（堆）</strong>，其中的大根堆可以帮助我们实时维护一系列元素中的最大值。</p><p>&emsp;&emsp;对于本题而言，初始时，我们使用数组 <code>nums</code> 的前 <code>k</code> 个元素的索引初始化大根堆，堆中索引的排序规则是数组 <code>nums</code> 的大小所决定。每当我们向右移动窗口时，我们就可以把一个新的元素的索引放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。我们在什么情况下出堆呢？每次有新元素入堆时，我们都要先判断一下位于堆顶的索引是否<code>&lt;=新入堆元素索引-k</code>。如果条件成立，则执行出堆操作，直到堆顶元素的索引在滑动窗口的范围内。</p><p>&emsp;&emsp;本题可以学习到的很重要的一个技巧就是出堆的操作可以不用着急，可以根据题目的实际需求，判断堆顶元素的索引是否符合当前选择范围再统一执行出堆操作，直到堆顶元素代表的索引在要求的范围内。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a[h[i]] &gt; a[h[j]]<span class="comment">// 排序规则不是索引大小，而是数组元素的值的大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    v := old[<span class="built_in">len</span>(old)<span class="number">-1</span>]</span><br><span class="line">    h = old[:<span class="built_in">len</span>(old)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    a = nums</span><br><span class="line">    <span class="keyword">var</span> h IntHeap</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;k; i++ &#123;</span><br><span class="line">        h = <span class="built_in">append</span>(h,i)</span><br><span class="line">    &#125;</span><br><span class="line">    heap.Init(&amp;h)<span class="comment">// 初始化堆</span></span><br><span class="line">    </span><br><span class="line">    ret := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">1</span>)</span><br><span class="line">    ret[<span class="number">0</span>] = a[h[<span class="number">0</span>]]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=k; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        heap.Push(&amp;h, i.(<span class="keyword">int</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> h[<span class="number">0</span>] &lt;= i-k &#123;<span class="comment">// 判断堆顶索引对应的元素是否在滑动窗口中，不在则持续出堆</span></span><br><span class="line">            heap.Pop(&amp;h)</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, a[h[<span class="number">0</span>]])<span class="comment">// 堆顶元素在滑动窗口中，加入输出数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;堆的简介&quot;&gt;&lt;a href=&quot;#堆的简介&quot; class=&quot;headerlink&quot; title=&quot;堆的简介&quot;&gt;&lt;/a&gt;堆的简介&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;首先，堆和二叉树有啥关系呢，为什么人们总数把堆画成一棵二叉树？因为，堆在逻辑上其实是一种特殊的二叉树</summary>
      
    
    
    
    <category term="Go语言标准库" scheme="http://jiahaohong1997.github.io/categories/Go%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
    
    <category term="堆" scheme="http://jiahaohong1997.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>链表习题解析</title>
    <link href="http://jiahaohong1997.github.io/2021/09/24/%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    <id>http://jiahaohong1997.github.io/2021/09/24/%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/</id>
    <published>2021-09-24T12:10:00.000Z</published>
    <updated>2021-09-28T07:43:17.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表高频题目"><a href="#链表高频题目" class="headerlink" title="链表高频题目"></a>链表高频题目</h1><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a class="link" href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加<i class="fas fa-external-link-alt"></i></a></h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="addtwonumber1.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;本题很自然的就想到先将两个链表保存的数都转化成变量的形式存储下来，直接相加后再逐位用链表保存后输出。但是，在提交代码后，发现其中一个测试用例没有通过。原来是其中一个链表转换成数字变量后，它直接溢出了，导致出错。所以要完全AC这道题，这种方法肯定是不行的。</p><p>&emsp;&emsp;由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为<code>n1,n2</code>，进位值为<code>carry</code>，他们的和为<code>n1+n2+carry</code>，其中答案链表处相应位置的数字为<code>(n1+n2+carry)%10</code>，而新的进位值为<code>(n1+n2+carry)/10</code>。</p><p>&emsp;&emsp;如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0 。此外，如果链表遍历结束后，有 <code>carry&gt;0</code>，还需要在答案链表的后面附加一个节点，节点的值为 <code>carry</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    carry := <span class="number">0</span></span><br><span class="line">    v := <span class="number">0</span></span><br><span class="line">    h1 := l1<span class="comment">// 保存头节点</span></span><br><span class="line">    f1 := l1<span class="comment">// 记录前一节点，方便拼接</span></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;<span class="comment">// 当l1和l2都没有遍历到表尾</span></span><br><span class="line">        v = (l1.Val+l2.Val+carry)%<span class="number">10</span><span class="comment">// 值</span></span><br><span class="line">        carry = (l1.Val+l2.Val+carry)/<span class="number">10</span>   <span class="comment">//进位</span></span><br><span class="line">        l1.Val = v<span class="comment">//保存到l1中（直接替换掉这个位置节点的值）</span></span><br><span class="line">        f1 = l1<span class="comment">//f1跟进</span></span><br><span class="line">        l1 = l1.Next<span class="comment">//l1指向其Next</span></span><br><span class="line">        l2 = l2.Next<span class="comment">//l2指向其Next</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry != <span class="number">0</span> &#123;<span class="comment">// l1和l2等长且最后还有一位进位</span></span><br><span class="line">        f1.Next = &amp;ListNode&#123;<span class="comment">// 创造一个节点，其值为进位值</span></span><br><span class="line">            Val     :       carry,</span><br><span class="line">            Next    :       <span class="literal">nil</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;<span class="comment">//l1更长，处理完l1剩余的节点</span></span><br><span class="line">        <span class="keyword">for</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            v = (l1.Val+carry)%<span class="number">10</span></span><br><span class="line">            carry = (l1.Val+carry)/<span class="number">10</span>        </span><br><span class="line">            l1.Val = v</span><br><span class="line">            f1 = l1</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> carry != <span class="number">0</span> &#123;<span class="comment">//考虑最后是否有进位</span></span><br><span class="line">            f1.Next = &amp;ListNode&#123;</span><br><span class="line">                Val     :       carry,</span><br><span class="line">                Next    :       <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;<span class="comment">//l2更长，处理完l2剩余的节点</span></span><br><span class="line">        f1.Next = l2</span><br><span class="line">        <span class="keyword">for</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            v = (l2.Val+carry)%<span class="number">10</span></span><br><span class="line">            carry = (l2.Val+carry)/<span class="number">10</span>     </span><br><span class="line">            l2.Val = v</span><br><span class="line">            f1 = l2</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> carry != <span class="number">0</span> &#123;<span class="comment">//考虑最后是否有进位</span></span><br><span class="line">            f1.Next = &amp;ListNode&#123;</span><br><span class="line">                Val     :       carry,</span><br><span class="line">                Next    :       <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h1><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a class="link" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表<i class="fas fa-external-link-alt"></i></a></h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="merge_ex1.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><p>这题思路很简单，用下图就可以概括：</p><p><img lazyload src="/images/loading.svg" data-src="1.gif" alt="avatar"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    dummy := &amp;ListNode&#123;Val:<span class="number">0</span>,Next:<span class="literal">nil</span>,&#125;</span><br><span class="line">    tail := dummy</span><br><span class="line">    <span class="keyword">var</span> node *ListNode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l1.Val &lt;= l2.Val &#123;</span><br><span class="line">            node = &amp;ListNode&#123;</span><br><span class="line">                Val     :   l1.Val,</span><br><span class="line">                Next    :   <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = &amp;ListNode&#123;</span><br><span class="line">                Val     :   l2.Val,</span><br><span class="line">                Next    :   <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        tail.Next = node</span><br><span class="line">        tail = node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        tail.Next = l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        tail.Next = l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a class="link" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表<i class="fas fa-external-link-alt"></i></a></h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 升序 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;将每个链表的节点分别填充入最小堆中，就可以实现所有节点数值的升序排列。最小堆的实现参考我的另一篇文章<a href="https://jiahaohong1997.github.io/2021/09/27/%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/">二叉堆的Go语言实现</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h[i]&lt;h[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(*h)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    l := <span class="built_in">len</span>(lists)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    h := &amp;IntHeap&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;l; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> lists[i] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        node := lists[i]</span><br><span class="line">        <span class="keyword">for</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            *h = <span class="built_in">append</span>(*h, node.Val)</span><br><span class="line">            node = node.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> h.Len() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line"></span><br><span class="line">    head := &amp;ListNode&#123;</span><br><span class="line">        Val     :       (*h)[<span class="number">0</span>],</span><br><span class="line">        Next    :       <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    t := head</span><br><span class="line">    heap.Pop(h)</span><br><span class="line">    <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        x := heap.Pop(h).(<span class="keyword">int</span>)</span><br><span class="line">        node := &amp;ListNode&#123;</span><br><span class="line">            Val     :       x,</span><br><span class="line">            Next    :       <span class="literal">nil</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        t.Next = node</span><br><span class="line">        t = node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a class="link" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点<i class="fas fa-external-link-alt"></i></a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="remove_ex1.jpg" alt="avatat"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], n &#x3D; 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], n &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;这个逻辑就很简单了，要删除倒数第 <code>n</code> 个节点，就得获得倒数第 <code>n + 1</code> 个节点的引用，首先，我们先让一个指针 <code>p1</code> 指向链表的头节点 <code>head</code>，然后走 <code>k</code> 步：</p><p><img lazyload src="/images/loading.svg" data-src="1.jpg" alt="avatar"></p><p>现在的 <code>p1</code>，只要再走 <code>n - k</code> 步，就能走到链表末尾的空指针了对吧？</p><p>趁这个时候，再用一个指针 <code>p2</code> 指向链表头节点 <code>head</code>：</p><p><img lazyload src="/images/loading.svg" data-src="2.jpg" alt="avatar"></p><p>接下来就很显然了，让 <code>p1</code> 和 <code>p2</code> 同时向前走，<code>p1</code> 走到链表末尾的空指针时走了 <code>n - k</code> 步，<code>p2</code> 也走了 <code>n - k</code> 步，也就是链表的倒数第 <code>k</code> 个节点：</p><p><img lazyload src="/images/loading.svg" data-src="3.jpg" alt="avatar"></p><p>这样，只遍历了一次链表，就获得了倒数第 <code>k</code> 个节点 <code>p2</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    fast, slow := head, head</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;<span class="comment">//fast指向nil，说明n=链表的节点数，即删除第一个节点</span></span><br><span class="line">        <span class="keyword">return</span> head.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fast.Next != <span class="literal">nil</span> &#123;<span class="comment">// 定位到要删除节点的前一个节点</span></span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    slow.Next = slow.Next.Next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a class="link" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表<i class="fas fa-external-link-alt"></i></a></h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img lazyload src="/images/loading.svg" data-src="160_statement.png" alt="avatar"></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="160_example_1.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Intersected at &#39;8&#39;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img lazyload src="/images/loading.svg" data-src="160_example_2.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Intersected at &#39;2&#39;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img lazyload src="/images/loading.svg" data-src="160_example_3.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA </code>中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为<code>n</code></li><li><code>0 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA </code>和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果<code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;这个题直接的想法可能是用 <code>HashSet</code> 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间。</p><p>&emsp;&emsp;如果不用额外的空间，只使用两个指针，你如何做呢？难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：</p><p><img lazyload src="/images/loading.svg" data-src="5.jpg" alt="avatar"></p><p>&emsp;&emsp;如果用两个指针 <code>p1</code> 和 <code>p2</code> 分别在两条链表上前进，并不能<strong>同时</strong>走到公共节点，也就无法得到相交节点 <code>c1</code>。</p><p>&emsp;&emsp;<strong>所以，解决这个问题的关键是，通过某些方式，让</strong> <strong><code>p1</code></strong> <strong>和</strong> <strong><code>p2</code></strong> <strong>能够同时到达相交节点</strong> **<code>c1</code>**。</p><p>&emsp;&emsp;所以，我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。如果这样进行拼接，就可以让 <code>p1</code> 和 <code>p2</code> 同时进入公共部分，也就是同时到达相交节点 <code>c1</code>：</p><p><img lazyload src="/images/loading.svg" data-src="7.jpg" alt="avatar"></p><p>&emsp;&emsp;那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 <code>nil</code> 呢？这个逻辑可以覆盖这种情况的，相当于 <code>c1</code> 节点是 <code>nil</code> 空指针嘛，可以正确返回 <code>nil</code>。</p><p>按照这个思路，可以写出如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    a, b := headA, headB</span><br><span class="line">    <span class="keyword">for</span> a != b &#123;</span><br><span class="line">        <span class="keyword">if</span> a != <span class="literal">nil</span> &#123;</span><br><span class="line">            a = a.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a = headB</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> b != <span class="literal">nil</span> &#123;</span><br><span class="line">            b = b.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b = headA</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，这道题就解决了，空间复杂度为 <code>O(1)</code>，时间复杂度为 <code>O(N)</code>。</p><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="反转整个链表"><a href="#反转整个链表" class="headerlink" title="反转整个链表"></a>反转整个链表</h2><ul><li>递归</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;<span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    last := reverse(head.Next)</span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    first := head.Next.Next</span><br><span class="line">    second := head.Next</span><br><span class="line">    third := head</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> first != <span class="literal">nil</span> &#123;</span><br><span class="line">        second.Next = third</span><br><span class="line">        third = second</span><br><span class="line">        second = first</span><br><span class="line">        first = first.Next</span><br><span class="line">    &#125;</span><br><span class="line">    second.Next = third</span><br><span class="line">    <span class="keyword">return</span> second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表前n个节点"><a href="#反转链表前n个节点" class="headerlink" title="反转链表前n个节点"></a>反转链表前n个节点</h2><p>&emsp;&emsp;比如说对于下图链表，执行 <code>reverseN(head, 3)</code>：</p><p><img lazyload src="/images/loading.svg" data-src="6.jpg" alt="avatar"></p><ul><li>递归</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> successor *ListNode<span class="comment">// 后驱节点</span></span><br><span class="line">successor = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseN</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        successor = head.Next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    last := reverseN(head.Next,n<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    head.Next = successor</span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseN</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    first := head.Next.Next</span><br><span class="line">    second := head.Next</span><br><span class="line">    third := head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;<span class="comment">// n=1,不需要翻转</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> &#123;<span class="comment">// n=2,直接翻转前两个节点即可</span></span><br><span class="line">        second.Next = third</span><br><span class="line">        third.Next = first</span><br><span class="line">        <span class="keyword">return</span> second</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> n<span class="number">-2</span> &gt; <span class="number">0</span> &#123;<span class="comment">// n&gt;2时的情况，结合上图来推一遍会比较清晰</span></span><br><span class="line">        second.Next = third</span><br><span class="line">        third = second</span><br><span class="line">        second = first</span><br><span class="line">        first = first.Next</span><br><span class="line">        n--</span><br><span class="line">    &#125;</span><br><span class="line">    second.Next = third</span><br><span class="line">    third.Next = first</span><br><span class="line">    <span class="keyword">return</span> second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表的一部分"><a href="#反转链表的一部分" class="headerlink" title="反转链表的一部分"></a>反转链表的一部分</h2><p>&emsp;&emsp;给一个索引区间 <code>[m,n]</code>（索引从 1 开始），仅仅反转区间中的链表元素。</p><ul><li>递归</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, m,n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">1</span> &#123;<span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">return</span> reverseN(head,n)<span class="comment">// 相当于反转前n个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">    head.Next = reverseBetween(head.Next, m<span class="number">-1</span>, n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代</li></ul><p><a class="link" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II<i class="fas fa-external-link-alt"></i></a></p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="rev2ex2.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4</span><br><span class="line">输出：[1,4,3,2,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [5], left &#x3D; 1, right &#x3D; 1</span><br><span class="line">输出：[5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目为 <code>n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>-500 &lt;= Node.val &lt;= 500</code></li><li><code>1 &lt;= left &lt;= right &lt;= n</code></li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;我们以下图中黄色区域的链表反转为例。</p><p><img lazyload src="/images/loading.svg" data-src="1615105129-iUPoGi-image.png" alt="avatar"></p><p>&emsp;&emsp;反转 <code>left</code> 到 <code>right</code> 部分以后，再拼接起来。我们还需要记录 <code>left</code>的前一个节点，和 <code>right</code> 的后一个节点。如图所示：</p><p><img lazyload src="/images/loading.svg" data-src="1615105150-pfWiGq-image.png" alt="avatar"></p><ul><li>第 1 步：先将待反转的区域反转；</li><li>第 2 步：把 pre 的 next 指针指向反转以后的链表头节点，把反转以后的链表的尾节点的 next 指针指向 succ</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    dummyNode := &amp;ListNode&#123;Val:<span class="number">-1</span>&#125;</span><br><span class="line">    dummyNode.Next = head</span><br><span class="line">    pre := dummyNode</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;left<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        pre = pre.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点</span></span><br><span class="line">    rightNode := pre</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; right-left+<span class="number">1</span>; i++ &#123;</span><br><span class="line">        rightNode = rightNode.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 3 步：切断出一个子链表（截取链表）</span></span><br><span class="line">    leftNode := pre.Next;</span><br><span class="line">    curr := rightNode.Next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：切断链接</span></span><br><span class="line">    pre.Next = <span class="literal">nil</span></span><br><span class="line">    rightNode.Next = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第4步：反转区间</span></span><br><span class="line">    reverse(leftNode)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 5 步：接回到原来的链表中</span></span><br><span class="line">    pre.Next = rightNode</span><br><span class="line">    leftNode.Next = curr</span><br><span class="line">    <span class="keyword">return</span> dummyNode.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何判断回文链表"><a href="#如何判断回文链表" class="headerlink" title="如何判断回文链表"></a>如何判断回文链表</h1><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a class="link" href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表<i class="fas fa-external-link-alt"></i></a></h2><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="pal1linked-list.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img lazyload src="/images/loading.svg" data-src="pal2linked-list.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围<code>[1, 105]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li></ul><p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p><p><strong>解题思路：</strong></p><p>&emsp;&emsp;最一般的做法是先用一个数组将整个链表存储下来，再从数组的两端向中间逼近来判断是否是回文串。进阶要求是用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题。</p><p>&emsp;&emsp;先通过快慢指针翻转后半部分链表（注意分情况讨论奇数和偶数）。然后翻转后半部分链表（如果是奇数链表，slow指针还要再走一步），最后通过比较前后两部分来判断是否是回文链表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fast, slow := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;<span class="comment">// 找到链表的中间位置</span></span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;  <span class="comment">// 偶数串，slow指向后半部分的第一个节点处</span></span><br><span class="line">        backHead := reverse(slow)</span><br><span class="line">        <span class="keyword">for</span> backHead != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> backHead.Val != head.Val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            backHead = backHead.Next</span><br><span class="line">            head = head.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 奇数串，slow指向前后两段的正中间</span></span><br><span class="line">        slow = slow.Next</span><br><span class="line">        backHead := reverse(slow)</span><br><span class="line">        <span class="keyword">for</span> backHead != <span class="literal">nil</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> backHead.Val != head.Val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            backHead = backHead.Next</span><br><span class="line">            head = head.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    pre, cur := head, head.Next</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        nxt := cur.Next</span><br><span class="line">        cur.Next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = nxt</span><br><span class="line">    &#125;</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表高频题目&quot;&gt;&lt;a href=&quot;#链表高频题目&quot; class=&quot;headerlink&quot; title=&quot;链表高频题目&quot;&gt;&lt;/a&gt;链表高频题目&lt;/h1&gt;&lt;h2 id=&quot;2-两数相加&quot;&gt;&lt;a href=&quot;#2-两数相加&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="链表" scheme="http://jiahaohong1997.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LFU算法</title>
    <link href="http://jiahaohong1997.github.io/2021/09/22/LFU%E7%AE%97%E6%B3%95/"/>
    <id>http://jiahaohong1997.github.io/2021/09/22/LFU%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-22T05:00:00.000Z</published>
    <updated>2021-09-22T10:52:46.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LFU算法介绍"><a href="#LFU算法介绍" class="headerlink" title="LFU算法介绍"></a>LFU算法介绍</h1><h2 id="LFU缓存机制"><a href="#LFU缓存机制" class="headerlink" title="LFU缓存机制"></a>LFU缓存机制</h2><p>&emsp;&emsp;LFU 算法的淘汰策略是 Least Frequently Used，也就是每次淘汰那些使用次数最少的数据。对比于在<a href="https://jiahaohong1997.github.io/2021/09/21/LRU%E7%AE%97%E6%B3%95/">LRU算法</a>中介绍的LRU 缓存淘汰算法，LRU 算法的淘汰策略是 Least Recently Used，也就是每次淘汰那些最久没被使用的数据。LRU 算法的核心数据结构是使用哈希链表 <code>LinkedHashMap</code>，首先借助链表的有序性使得链表元素维持插入顺序，同时借助哈希映射的快速访问能力使得我们可以在 O(1) 时间访问链表的任意元素。</p><p>&emsp;&emsp;而 LFU 算法相当于是把数据按照访问频次进行排序，这个需求恐怕没有那么简单，而且还有一种情况，如果多个数据拥有相同的访问频次，我们就得删除最早插入的那个数据。也就是说 LFU 算法是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>&emsp;&emsp;要求你写一个类，接受一个 <code>capacity</code> 参数，实现 <code>get</code> 和 <code>put</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LFUCache</span></span> &#123;&#125; <span class="comment">// 构造容量为 capacity 的缓存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;&#125;  <span class="comment">// 在缓存中查询 key</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;&#125; <span class="comment">// 将 key 和 val 存入缓存</span></span><br></pre></td></tr></table></figure><p><code>Get(key)</code> 方法会去缓存中查询键 <code>key</code>，如果 <code>key</code> 存在，则返回 <code>key</code> 对应的 <code>val</code>，否则返回 -1。</p><p><code>Put(key, value)</code> 方法插入或修改缓存。如果 <code>key</code> 已存在，则将它对应的值改为 <code>val</code>；如果 <code>key</code> 不存在，则插入键值对 <code>(key, val)</code>。</p><p>&emsp;&emsp;当缓存达到容量 <code>capacity</code> 时，则应该在插入新的键值对之前，删除使用频次（后文用 <code>freq</code> 表示）最低的键值对。如果 <code>freq</code> 最低的键值对有多个，则删除其中最旧的那个。</p><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>&emsp;&emsp;首先我们需要理解LFU算法执行过程的几个事实：</p><ol><li>调用<code>Get(key int)</code>方法时，要返回<code>key</code>对应的<code>val</code>。</li><li>只要用到<code>Get</code>或<code>Put</code>方法访问一次某个<code>key</code>，该<code>key</code>的<code>freq</code>就要加一。</li><li>如果在容量满了的时候插入，则需要将 <code>freq</code> 最小的 <code>key</code> 删除，如果最小的 <code>freq</code> 对应多个 <code>key</code>，则删除其中最旧的那一个。</li></ol><p>&emsp;&emsp;现在我们来逐一解决:</p><ol><li>调用<code>Get(key int)</code>方法时，要返回<code>key</code>对应的<code>val</code>。</li></ol><p>&emsp;&emsp;使用一个 <code>HashMap</code> 存储 <code>key</code> 到 <code>val</code> 的映射，就可以快速计算 <code>get(key)</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyToVal := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>只要用到<code>Get</code>或<code>Put</code>方法访问一次某个<code>key</code>，该<code>key</code>的<code>freq</code>就要加一。</li></ol><p>&emsp;&emsp;使用一个 <code>HashMap</code> 存储 <code>key</code> 到 <code>freq</code> 的映射，就可以快速操作 <code>key</code> 对应的 <code>freq</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyToFreq := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>如果在容量满了的时候插入，则需要将 <code>freq</code> 最小的 <code>key</code> 删除，如果最小的 <code>freq</code> 对应多个 <code>key</code>，则删除其中最旧的那一个。</li></ol><p>&emsp;&emsp;这个需求应该是 LFU 算法的核心，所以我们分开说。</p><ul><li>首先，肯定是需要 <code>freq</code> 到 <code>key</code> 的映射，用来找到 <code>freq</code> 最小的 <code>key</code>。</li><li>将 <code>freq</code> 最小的 <code>key</code> 删除，那你就得快速得到当前所有 <code>key</code> 最小的 <code>freq</code> 是多少。想要时间复杂度 O(1) 的话，肯定不能遍历一遍去找，那就用一个变量 <code>minFreq</code> 来记录当前最小的 <code>freq</code> 吧。</li><li>可能有多个 <code>key</code> 拥有相同的 <code>freq</code>，所以 <strong><code>freq</code></strong> <strong>对</strong> <strong><code>key</code></strong> <strong>是一对多的关系</strong>，即一个 <code>freq</code> 对应一个 <code>key</code> 的列表。</li><li>希望 <code>freq</code> 对应的 <code>key</code> 的列表是<strong>存在时序</strong>的，便于快速查找并删除最旧的 <code>key</code>。</li><li>希望<strong>能够快速删除</strong> <strong><code>key</code></strong> <strong>列表中的任何一个</strong> **<code>key</code>**，因为如果频次为 <code>freq</code> 的某个 <code>key</code> 被访问，那么它的频次就会变成 <code>freq+1</code>，就应该从 <code>freq</code> 对应的 <code>key</code> 列表中删除，加到 <code>freq+1</code> 对应的 <code>key</code> 的列表中。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">freqToKeys := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet)</span><br><span class="line">minFreq := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key<span class="keyword">int</span></span><br><span class="line">    prev*node</span><br><span class="line">    next*node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DoubleList <span class="keyword">struct</span> &#123;</span><br><span class="line">    head*node</span><br><span class="line">    tail*node</span><br><span class="line">    size<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorDL</span><span class="params">()</span> *<span class="title">DoubleList</span></span> &#123;</span><br><span class="line">    dh := &amp;node&#123;</span><br><span class="line">        key:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dt := &amp;node &#123;</span><br><span class="line">        key:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dh.next,dt.prev = dt,dh</span><br><span class="line">    <span class="keyword">return</span> &amp;DoubleList&#123;</span><br><span class="line">        head:dh,</span><br><span class="line">        tail:dt,</span><br><span class="line">        size:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LinkedHashSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashMap<span class="keyword">map</span>[<span class="keyword">int</span>]*node</span><br><span class="line">    doubleList*DoubleList    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorLH</span><span class="params">()</span> *<span class="title">LinkedHashSet</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node)</span><br><span class="line">    dl := constructorDL()</span><br><span class="line">    <span class="keyword">return</span> &amp;LinkedHashSet&#123;</span><br><span class="line">        hashMap:m,</span><br><span class="line">        doubleList:dl,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>LinkedHashSet</code> 顾名思义，是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插入元素具有时序；哈希集合中的元素无序，但是可以对元素进行快速的访问和删除。那么，它俩结合起来就兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，又可以保持插入的时序。</p><p>综上，我们可以写出 LFU 算法的基本数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    keyToVal<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span><span class="comment">// key 到 val 的映射，我们后文称为 KV 表</span></span><br><span class="line">    keyToFreq<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span><span class="comment">// key 到 freq 的映射，我们后文称为 KF 表</span></span><br><span class="line">    freqToKeys<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet<span class="comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span></span><br><span class="line">    minFreq<span class="keyword">int</span><span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="built_in">cap</span><span class="keyword">int</span><span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity)</span> <span class="title">LFUCache</span></span> &#123;</span><br><span class="line">    kv := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    kf := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    fk := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet)</span><br><span class="line">    <span class="keyword">return</span> LFUCache&#123;</span><br><span class="line">        keyToVal:kv,</span><br><span class="line">        keyToFreq:kf,</span><br><span class="line">        freqToKeys:fk,</span><br><span class="line">        minFreq:<span class="number">0</span>,</span><br><span class="line">        <span class="built_in">cap</span>:capacity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;&#125;  <span class="comment">// 在缓存中查询 key</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;&#125; <span class="comment">// 将 key 和 val 存入缓存</span></span><br></pre></td></tr></table></figure><h1 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h1><h2 id="实现Get-key-int-方法"><a href="#实现Get-key-int-方法" class="headerlink" title="实现Get(key int)方法"></a>实现<code>Get(key int)</code>方法</h2><p>&emsp;&emsp;逻辑很简单，返回 <code>key</code> 对应的 <code>val</code>，然后增加 <code>key</code> 对应的 <code>freq</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.increaseFreq(key)</span><br><span class="line">    <span class="keyword">return</span> this.keyToVal[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;增加<code>key</code>对应的<code>freq</code>是LFU算法的核心，所以我们干脆抽象一个方法<code>increaseFreq</code>，这样<code>Get</code>方法就比较简洁。</p><h2 id="实现Put-key-int-val-int-方法"><a href="#实现Put-key-int-val-int-方法" class="headerlink" title="实现Put(key int,val int) 方法"></a>实现<code>Put(key int,val int)</code> 方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; ok &#123;  <span class="comment">// 若key已存在，修改对应的val即可</span></span><br><span class="line">        this.keyToVal[key] = value</span><br><span class="line">        this.increaseFreq(key)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// key不存在，需要插入</span></span><br><span class="line">    <span class="comment">// 容量已满的话需要淘汰一个freq最小的key</span></span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> == <span class="built_in">len</span>(this.keyToVal) &#123;</span><br><span class="line">        this.removeMinFreqKey()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入key和val，对应的freq为1</span></span><br><span class="line">    this.keyToVal[key] = value<span class="comment">// 插入KV表</span></span><br><span class="line">    this.keyToFreq[key] = <span class="number">1</span><span class="comment">// 插入KF表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[<span class="number">1</span>]; !ok &#123;  <span class="comment">// 如果没有freq为1的LinkedHashSet，则生成一个</span></span><br><span class="line">        this.freqToKeys[<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,<span class="number">1</span>)  <span class="comment">// 插入新key后的freq肯定是1</span></span><br><span class="line">    this.minFreq = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现核心逻辑（中间抽象层）"><a href="#实现核心逻辑（中间抽象层）" class="headerlink" title="实现核心逻辑（中间抽象层）"></a>实现核心逻辑（中间抽象层）</h2><h3 id="实现removeMinFreqKey方法"><a href="#实现removeMinFreqKey方法" class="headerlink" title="实现removeMinFreqKey方法"></a>实现<code>removeMinFreqKey</code>方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">removeMinFreqKey</span><span class="params">()</span></span> &#123;</span><br><span class="line">    keyList := this.freqToKeys[this.minFreq].doubleList<span class="comment">// 获得最小freq的LinkedHashSet</span></span><br><span class="line">    deleteKey := keyList.removeFirst()<span class="comment">// 删除LinkedHashSet的双链表头的元素</span></span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[this.minFreq].hashMap,deleteKey.key)<span class="comment">// 删除LinkedHashSet的哈希表对应元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[this.minFreq].hashMap) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,this.minFreq)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delete</span>(this.keyToVal,deleteKey.key)<span class="comment">// 更新KV表</span></span><br><span class="line">    <span class="built_in">delete</span>(this.keyToFreq,deleteKey.key)<span class="comment">// 更新KF表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;删除某个<code>key</code>肯定是要同时映射三个表的，借助<code>minFreq</code>参数可以从<code>FK</code>表中找到<code>freq</code>最小的<code>keyList</code>，删除其表头元素即可，同时删除<code>Fk</code>表中<code>freq</code>最小的<code>hashMap</code>对应的元素。然后根据要被淘汰的<code>deleteKey</code>删除其余两个表中的映射关系。</p><p>&emsp;&emsp;这里有个细节问题，如果<code>keyList</code>中只有一个元素，那么删除之后<code>minFreq</code>对应的<code>key</code>列表就为空了，也就是<code>minFreq</code>变量需要更新。实际上没办法快速计算<code>minFreq</code>，只能线性遍历<code>FK</code>表或者<code>KF</code>表来计算，这样肯定不能保证 O(1) 的时间复杂度。<strong>但是，其实这里没必要更新<code>minFreq</code>变量</strong>，因为你想想<code>removeMinFreqKey</code>这个函数是在什么时候调用？在<code>put</code>方法中插入新<code>key</code>时可能调用。而你回头看<code>put</code>的代码，插入新<code>key</code>时一定会把<code>minFreq</code>更新成 1，所以说即便这里<code>minFreq</code>变了，我们也不需要管它。</p><h3 id="实现increaseFreq方法"><a href="#实现increaseFreq方法" class="headerlink" title="实现increaseFreq方法"></a>实现<code>increaseFreq</code>方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">increaseFreq</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    freq := this.keyToFreq[key]</span><br><span class="line">    this.keyToFreq[key] = freq+<span class="number">1</span><span class="comment">// 更新KF表</span></span><br><span class="line">    <span class="comment">// 将key从freq对应的列表和哈希表中删除</span></span><br><span class="line">    this.freqToKeys[freq].doubleList.remove(this.freqToKeys[freq].hashMap[key])</span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[freq].hashMap,key)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[freq].hashMap) == <span class="number">0</span> &#123; <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,freq)</span><br><span class="line">        <span class="keyword">if</span> freq == this.minFreq &#123;  <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">            this.minFreq++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将key加入到freq+1对应的列表和哈希表中</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[freq+<span class="number">1</span>]; !ok &#123;</span><br><span class="line">        this.freqToKeys[freq+<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,freq+<span class="number">1</span>)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="实现addRecently方法"><a href="#实现addRecently方法" class="headerlink" title="实现addRecently方法"></a>实现<code>addRecently</code>方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">addRecently</span><span class="params">(key <span class="keyword">int</span>, freq <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := &amp;node&#123;</span><br><span class="line">        key:key,</span><br><span class="line">    &#125;</span><br><span class="line">    this.freqToKeys[freq].doubleList.addLast(x)</span><br><span class="line">    this.freqToKeys[freq].hashMap[key] = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在插入新的节点时，需要修改<code>FK</code>表的哈希表和双链表。</p><h2 id="对底层数据结构进行操作"><a href="#对底层数据结构进行操作" class="headerlink" title="对底层数据结构进行操作"></a>对底层数据结构进行操作</h2><p>&emsp;&emsp;该层的主要作用是对我们实现的<code>LinkedHashSet</code>结构封装一些通用操作，用以满足<code>FK</code>表的更新和删除操作，主要包含以下几个方法：</p><ol><li>删除<code>DoubleList</code>中某一节点的方法<code>remove(x *node)</code>。</li><li>删除<code>DoubleList</code>中表首元素的方法<code>removeFirst()</code>。</li><li>在<code>DoubleList</code>中表尾部增加新元素的<code>addLast()</code>。</li></ol><h3 id="实现remove方法"><a href="#实现remove方法" class="headerlink" title="实现remove方法"></a>实现<code>remove</code>方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">remove</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev.next = x.next</span><br><span class="line">    x.next.prev = x.prev</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="实现removeFirst方法"><a href="#实现removeFirst方法" class="headerlink" title="实现removeFirst方法"></a>实现<code>removeFirst</code>方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">removeFirst</span><span class="params">()</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dl.head.next == dl.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    first := dl.head.next</span><br><span class="line">    dl.remove(first)</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现addLast方法"><a href="#实现addLast方法" class="headerlink" title="实现addLast方法"></a>实现<code>addLast</code>方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">addLast</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev = dl.tail.prev</span><br><span class="line">    x.next = dl.tail</span><br><span class="line">    dl.tail.prev.next = x</span><br><span class="line">    dl.tail.prev = x</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="总体算法"><a href="#总体算法" class="headerlink" title="总体算法"></a>总体算法</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ###############基础数据结构###################</span></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key<span class="keyword">int</span></span><br><span class="line">    prev*node</span><br><span class="line">    next*node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双端链表</span></span><br><span class="line"><span class="keyword">type</span> DoubleList <span class="keyword">struct</span> &#123;</span><br><span class="line">    head*node</span><br><span class="line">    tail*node</span><br><span class="line">    size<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化双端链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorDL</span><span class="params">()</span> *<span class="title">DoubleList</span></span> &#123;</span><br><span class="line">    dh := &amp;node&#123;</span><br><span class="line">        key:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dt := &amp;node &#123;</span><br><span class="line">        key:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dh.next,dt.prev = dt,dh</span><br><span class="line">    <span class="keyword">return</span> &amp;DoubleList&#123;</span><br><span class="line">        head:dh,</span><br><span class="line">        tail:dt,</span><br><span class="line">        size:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造LinkedHashSet作为freqToKeys表</span></span><br><span class="line"><span class="keyword">type</span> LinkedHashSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashMap<span class="keyword">map</span>[<span class="keyword">int</span>]*node</span><br><span class="line">    doubleList*DoubleList    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化LinkedHashSet</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorLH</span><span class="params">()</span> *<span class="title">LinkedHashSet</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node)</span><br><span class="line">    dl := constructorDL()</span><br><span class="line">    <span class="keyword">return</span> &amp;LinkedHashSet&#123;</span><br><span class="line">        hashMap:m,</span><br><span class="line">        doubleList:dl,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ##############底层方法（用于直接操作数据结构）####################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除双端链表中的某一节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">remove</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev.next = x.next</span><br><span class="line">    x.next.prev = x.prev</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除双端链表表头元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">removeFirst</span><span class="params">()</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dl.head.next == dl.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    first := dl.head.next</span><br><span class="line">    dl.remove(first)</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在双端链表尾部添加新元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">addLast</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev = dl.tail.prev</span><br><span class="line">    x.next = dl.tail</span><br><span class="line">    dl.tail.prev.next = x</span><br><span class="line">    dl.tail.prev = x</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ###############LFU类的实现##################</span></span><br><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    keyToVal<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span><span class="comment">// key 到 val 的映射，我们后文称为 KV 表</span></span><br><span class="line">    keyToFreq<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span><span class="comment">// key 到 freq 的映射，我们后文称为 KF 表</span></span><br><span class="line">    freqToKeys<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet<span class="comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span></span><br><span class="line">    minFreq<span class="keyword">int</span><span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="built_in">cap</span><span class="keyword">int</span><span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化LFU类，加载KV表、KF表以及FK表，设置最小频率树minFreq</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LFUCache</span></span> &#123;</span><br><span class="line">    kv := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    kf := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    fk := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet)</span><br><span class="line">    <span class="keyword">return</span> LFUCache&#123;</span><br><span class="line">        keyToVal:kv,</span><br><span class="line">        keyToFreq:kf,</span><br><span class="line">        freqToKeys:fk,</span><br><span class="line">        minFreq:<span class="number">0</span>,</span><br><span class="line">        <span class="built_in">cap</span>:capacity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.increaseFreq(key)</span><br><span class="line">    <span class="keyword">return</span> this.keyToVal[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Put方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; ok &#123;  <span class="comment">// 若key已存在，修改对应的val即可</span></span><br><span class="line">        this.keyToVal[key] = value</span><br><span class="line">        this.increaseFreq(key)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// key不存在，需要插入</span></span><br><span class="line">    <span class="comment">// 容量已满的话需要淘汰一个freq最小的key</span></span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> &lt;= <span class="built_in">len</span>(this.keyToVal) &#123;</span><br><span class="line">        this.removeMinFreqKey()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入key和val，对应的freq为1</span></span><br><span class="line">    this.keyToVal[key] = value<span class="comment">// 插入KV表</span></span><br><span class="line">    this.keyToFreq[key] = <span class="number">1</span><span class="comment">// 插入KF表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[<span class="number">1</span>]; !ok &#123;  <span class="comment">// 如果没有freq为1的LinkedHashSet，则生成一个</span></span><br><span class="line">        this.freqToKeys[<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,<span class="number">1</span>)  <span class="comment">// 插入新key后的freq肯定是1</span></span><br><span class="line">    this.minFreq = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ################中间抽象层####################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除使用频率最低节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">removeMinFreqKey</span><span class="params">()</span></span> &#123;</span><br><span class="line">    keyList := this.freqToKeys[this.minFreq].doubleList<span class="comment">// 获得最小freq的LinkedHashSet</span></span><br><span class="line">    deleteKey := keyList.removeFirst()<span class="comment">// 删除LinkedHashSet的双链表头的元素</span></span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[this.minFreq].hashMap,deleteKey.key)<span class="comment">// 删除LinkedHashSet的哈希表对应元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[this.minFreq].hashMap) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,this.minFreq)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delete</span>(this.keyToVal,deleteKey.key)<span class="comment">// 更新KV表</span></span><br><span class="line">    <span class="built_in">delete</span>(this.keyToFreq,deleteKey.key)<span class="comment">// 更新KF表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加某一节点的使用频数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">increaseFreq</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    freq := this.keyToFreq[key]</span><br><span class="line">    this.keyToFreq[key] = freq+<span class="number">1</span><span class="comment">// 更新KF表</span></span><br><span class="line">    <span class="comment">// 将key从freq对应的列表和哈希表中删除</span></span><br><span class="line">    this.freqToKeys[freq].doubleList.remove(this.freqToKeys[freq].hashMap[key])</span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[freq].hashMap,key)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[freq].hashMap) == <span class="number">0</span> &#123; <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,freq)</span><br><span class="line">        <span class="keyword">if</span> freq == this.minFreq &#123;  <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">            this.minFreq++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将key加入到freq+1对应的列表和哈希表中</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[freq+<span class="number">1</span>]; !ok &#123;</span><br><span class="line">        this.freqToKeys[freq+<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,freq+<span class="number">1</span>)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 对最近使用的节点的处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">addRecently</span><span class="params">(key <span class="keyword">int</span>, freq <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := &amp;node&#123;</span><br><span class="line">        key:key,</span><br><span class="line">    &#125;</span><br><span class="line">    this.freqToKeys[freq].doubleList.addLast(x)</span><br><span class="line">    this.freqToKeys[freq].hashMap[key] = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LFU算法介绍&quot;&gt;&lt;a href=&quot;#LFU算法介绍&quot; class=&quot;headerlink&quot; title=&quot;LFU算法介绍&quot;&gt;&lt;/a&gt;LFU算法介绍&lt;/h1&gt;&lt;h2 id=&quot;LFU缓存机制&quot;&gt;&lt;a href=&quot;#LFU缓存机制&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="LFU" scheme="http://jiahaohong1997.github.io/tags/LFU/"/>
    
  </entry>
  
  <entry>
    <title>LRU算法</title>
    <link href="http://jiahaohong1997.github.io/2021/09/21/LRU%E7%AE%97%E6%B3%95/"/>
    <id>http://jiahaohong1997.github.io/2021/09/21/LRU%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-21T14:25:07.498Z</published>
    <updated>2021-09-22T10:54:53.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LRU算法介绍"><a href="#LRU算法介绍" class="headerlink" title="LRU算法介绍"></a>LRU算法介绍</h1><p>&emsp;&emsp;LRU算法(Least Recently Used)算法实质上是一种缓存机制，常用于操作系统的缓存。计算机的缓存容量是有限的，如果缓存满了就要给新的内容腾位置。那淘汰哪些缓存，哪些继续以何种方式留在缓存中就是一个策略性的问题。LRU算法就是其中一种淘汰策略。其内核就是<strong>认为最近使用过的数据是最有用的，很久都没使用的数据是无用的，内存满了就应该优先淘汰很久没用过的数据</strong>。</p><p>&emsp;&emsp;举一个实际例子，安卓手机都可以把软件放到后台运行，比如我先后打开了「设置」「手机管家」「日历」，那么现在他们在后台排列的顺序是这样的：</p><p><img lazyload src="/images/loading.svg" data-src="1.jpg#pic_center" alt="avatar"></p><p>&emsp;&emsp;但是这时候如果我访问了一下「设置」界面，那么「设置」就会被提前到第一个，变成这样：</p><p><img lazyload src="/images/loading.svg" data-src="2.jpg#pic_center" alt="avatar"></p><p>&emsp;&emsp;假设我的手机只允许我同时开 3 个应用程序，现在已经满了。那么如果我新开了一个应用「时钟」，就必须关闭一个应用为「时钟」腾出一个位置，关那个呢？按照 LRU 的策略，就关最底下的「手机管家」，因为那是最久未使用的，然后把新开的应用放到最上面：</p><p><img lazyload src="/images/loading.svg" data-src="3.jpg#pic_center" alt="avatar"></p><h1 id="LRU算法的函数签名"><a href="#LRU算法的函数签名" class="headerlink" title="LRU算法的函数签名"></a>LRU算法的函数签名</h1><p>&emsp;&emsp;函数签名可以参考<a class="link" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制<i class="fas fa-external-link-alt"></i></a>的题目要求：</p><p>运用你所掌握的数据结构，设计和实现一个 <a class="link" href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存机制<i class="fas fa-external-link-alt"></i></a> 。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity) </code>以正整数作为容量 capacity 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><p><strong>进阶</strong>：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache &#x3D; new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1&#125;</span><br><span class="line">lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1, 2&#x3D;2&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 1</span><br><span class="line">lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 &#123;1&#x3D;1, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 &#123;4&#x3D;4, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    &#x2F;&#x2F; 返回 3</span><br><span class="line">lRUCache.get(4);    &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= capacity &lt;= 3000</li><li>0 &lt;= key &lt;= 10000</li><li>0 &lt;= value &lt;= 105</li><li>最多调用 2 * 105 次 get 和 put</li></ul><h1 id="LRU算法设计"><a href="#LRU算法设计" class="headerlink" title="LRU算法设计"></a>LRU算法设计</h1><p>&emsp;&emsp;分析上面的操作过程，要让 <code>put</code> 和 <code>get</code> 方法的时间复杂度为 O(1)，我们可以总结出 <code>cache</code> 这个数据结构必要的条件：</p><ol><li>显然 <code>cache</code> 中的元素必须有顺序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。</li><li>我们要在 <code>cache</code> 中快速找某个 <code>key</code> 是否已存在并得到对应的 <code>val</code>；</li><li>每次访问 <code>cache</code> 中的某个 <code>key</code>，需要将这个元素变为最近使用的，也就是说 <code>cache</code> 要支持在任意位置快速插入和删除元素。</li></ol><p>&emsp;&emsp;那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表 <code>LinkedHashMap</code>。LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：</p><p><img lazyload src="/images/loading.svg" data-src="4.jpg" alt="avatar"></p><p>&emsp;&emsp;借助这个结构，我们来逐一分析上面的 3 个条件：</p><ol><li>如果我们每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。</li><li>对于某一个 <code>key</code>，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 <code>val</code>。</li><li>链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 <code>key</code> 快速映射到任意一个链表节点，然后进行插入和删除。</li></ol><p>&emsp;&emsp;这里先引出两个问题：<strong>为什么要是双向链表，单链表行不行？另外，既然哈希表中已经存了</strong> **<code>key</code>**<strong>，为什么链表中还要存</strong> <strong><code>key</code></strong> <strong>和</strong> <strong><code>val</code></strong> <strong>呢，只存</strong> <strong><code>val</code></strong> <strong>不就行了</strong>？</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="双链表的实现"><a href="#双链表的实现" class="headerlink" title="双链表的实现"></a>双链表的实现</h2><p>&emsp;&emsp;首先实现连表的每个节点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key<span class="keyword">int</span></span><br><span class="line">    value<span class="keyword">int</span></span><br><span class="line">    prev*node</span><br><span class="line">    next*node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后依靠着这些节点实现一个双链表：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DoubleList <span class="keyword">struct</span> &#123;</span><br><span class="line">    head*node<span class="comment">// 头部虚节点</span></span><br><span class="line">    tail*node<span class="comment">// 尾部虚节点</span></span><br><span class="line">    size<span class="keyword">int</span><span class="comment">// 连表节点数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructDL</span><span class="params">()</span> *<span class="title">DoubleList</span></span> &#123;<span class="comment">// 初始化双链表</span></span><br><span class="line">    dh := &amp;node&#123;</span><br><span class="line">        key : <span class="number">0</span>,</span><br><span class="line">        value : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dt := &amp;node&#123;</span><br><span class="line">        key : <span class="number">0</span>,</span><br><span class="line">        value : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dh.next,dt.prev = dt,dh <span class="comment">// 收尾虚节点形成双链表</span></span><br><span class="line">    <span class="keyword">return</span> &amp;DoubleList&#123;</span><br><span class="line">        head : dh,</span><br><span class="line">    tail : dt,</span><br><span class="line">    size : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双链表的几个API的实现"><a href="#双链表的几个API的实现" class="headerlink" title="双链表的几个API的实现"></a>双链表的几个API的实现</h2><p>&emsp;&emsp;接下来我们实现操作双链表的几个API:</p><ol><li><code>addLast(x *node)</code>：将最近使用的节点加入到双链表中（从尾部进入双链表）</li><li><code>remove(x *node)</code>：删除双链表中的节点x（节点x一定存在的条件下）</li><li><code>removeFirst()</code>：当容量满时，将最久未使用的节点（表首的节点）删除</li><li><code>dlSize()</code>：返回双链表的节点数</li></ol><h3 id="addLast-x-node-方法的实现细节"><a href="#addLast-x-node-方法的实现细节" class="headerlink" title="addLast(x *node)方法的实现细节"></a><code>addLast(x *node)</code>方法的实现细节</h3><p>&emsp;&emsp;在双链表的尾部虚节点之前插入节点，需要注意插入过程中<code>prev</code>和<code>next</code>指针的插入顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">addLast</span><span class="params">(x *node)</span></span> &#123; <span class="comment">// 在链表尾部添加节点 x，时间 O(1)</span></span><br><span class="line">    x.prev = dl.tail.prev</span><br><span class="line">    x.next = dl.tail</span><br><span class="line">    dl.tail.prev.next = x</span><br><span class="line">    dl.tail.prev = x</span><br><span class="line">    dl.size++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-x-node-方法的实现细节"><a href="#remove-x-node-方法的实现细节" class="headerlink" title="remove(x *node)方法的实现细节"></a><code>remove(x *node)</code>方法的实现细节</h3><p>&emsp;&emsp;删除连表中的某一节点，x存在时才能使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">remove</span><span class="params">(x *node)</span></span> &#123; <span class="comment">// 由于是双链表且给的是目标 Node 节点，时间 O(1)</span></span><br><span class="line">    x.prev.next = x.next</span><br><span class="line">    x.next.prev = x.prev</span><br><span class="line">    dl.size--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="removeFirst-方法的实现细节"><a href="#removeFirst-方法的实现细节" class="headerlink" title="removeFirst()方法的实现细节"></a><code>removeFirst()</code>方法的实现细节</h3><p>&emsp;&emsp;缓存的空间占满，删除最久不使用节点（首部节点）。返回被删除的节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">removeFirst</span><span class="params">()</span> *<span class="title">node</span></span> &#123; <span class="comment">// 删除链表中第一个节点，并返回该节点，时间 O(1)</span></span><br><span class="line">    <span class="keyword">if</span> dl.head.next == dl.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> dl.head</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    first := dl.head.next</span><br><span class="line">    dl.remove(first)</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dlSize-返回链表长度"><a href="#dlSize-返回链表长度" class="headerlink" title="dlSize()返回链表长度"></a><code>dlSize()</code>返回链表长度</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">dlSize</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="comment">// 返回链表长度，时间 O(1)</span></span><br><span class="line">    <span class="keyword">return</span> dl.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LRUCache类的实现"><a href="#LRUCache类的实现" class="headerlink" title="LRUCache类的实现"></a>LRUCache类的实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashMap<span class="keyword">map</span>[<span class="keyword">int</span>]*node</span><br><span class="line">    cache*DoubleList</span><br><span class="line">    <span class="built_in">cap</span><span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity)</span> <span class="title">LRUCache</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node,capacity)</span><br><span class="line">    dl := constructDL()</span><br><span class="line">    <span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">        hashMap:m,</span><br><span class="line">        cache:dl,</span><br><span class="line">        <span class="built_in">cap</span>:capacity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象后的中间层"><a href="#抽象后的中间层" class="headerlink" title="抽象后的中间层"></a>抽象后的中间层</h2><p>&emsp;&emsp;为了避免直接对缓存进行操作时忘记同时对双链表和哈希表同时进行删除和插入操作，所以在具体的LRU的方法和数据结构之间添加一层作为抽象层（直接对数据结构进行操作）。</p><h3 id="makeRecently-key-int-将某个节点提升为最近使用"><a href="#makeRecently-key-int-将某个节点提升为最近使用" class="headerlink" title="makeRecently(key int)将某个节点提升为最近使用"></a><code>makeRecently(key int)</code>将某个节点提升为最近使用</h3><p>&emsp;&emsp;当某个节点被使用后，变为最近使用节点，被放到链表尾部。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">makeRecently</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := this.hashMap[key]</span><br><span class="line">    this.cache.remove(x)<span class="comment">// 现在双链表删除该节点</span></span><br><span class="line">    this.cache.addLast(x)<span class="comment">// 然后将该节点添加到双链表尾部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addRecently-key-int-val-将某个新节点提升为最近使用"><a href="#addRecently-key-int-val-将某个新节点提升为最近使用" class="headerlink" title="addRecently(key int, val)将某个新节点提升为最近使用"></a><code>addRecently(key int, val)</code>将某个新节点提升为最近使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">addRecently</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := node&#123;</span><br><span class="line">        key:key,</span><br><span class="line">        value:val,</span><br><span class="line">    &#125;</span><br><span class="line">    this.cache.addLast(&amp;x)</span><br><span class="line">    this.hashMap[key] = &amp;x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deleteKey-key-int-删除某一个节点"><a href="#deleteKey-key-int-删除某一个节点" class="headerlink" title="deleteKey(key int)删除某一个节点"></a><code>deleteKey(key int)</code>删除某一个节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">deleteKey</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := this.hashMap[key]</span><br><span class="line">    <span class="built_in">delete</span>(this.hashMap,x)</span><br><span class="line">    this.cache.remove(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deleteLeastRecently-删除最久未使用节点"><a href="#deleteLeastRecently-删除最久未使用节点" class="headerlink" title="deleteLeastRecently()删除最久未使用节点"></a><code>deleteLeastRecently()</code>删除最久未使用节点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">deleteLeastRecently</span><span class="params">()</span></span> &#123;</span><br><span class="line">    deleteNode := this.cache.removeFirst()</span><br><span class="line">    deleteKey := deleteNode.key</span><br><span class="line">    <span class="built_in">delete</span>(this.hashMap,deleteKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LRUCache类的更新Get-和淘汰Put-方法"><a href="#LRUCache类的更新Get-和淘汰Put-方法" class="headerlink" title="LRUCache类的更新Get()和淘汰Put()方法"></a>LRUCache类的更新Get()和淘汰Put()方法</h2><p>&emsp;&emsp;<code>Get(key int)</code>方法：如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.hashMap[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.makeRecently(key)<span class="comment">// 关键字存在于缓存中，将其置于双链表尾部位置</span></span><br><span class="line">    <span class="keyword">return</span> this.hashMap[key].value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>Put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.hashMap[key]; ok &#123; <span class="comment">// 如果存在与缓存中</span></span><br><span class="line">        this.deleteKey(key)<span class="comment">// 先删除原来节点（避免出现更新value的情况）</span></span><br><span class="line">        this.addRecently(key)<span class="comment">// 然后再将该节点重新插入</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> this.<span class="built_in">cap</span> == this.cache.dlSize &#123; <span class="comment">// 缓存容量已经达到上限</span></span><br><span class="line">            this.deleteLeastRecently()<span class="comment">// 删除最不常使用节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        this.addRecntly(key,val)<span class="comment">// 然后将该新节点添加到缓存中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key     <span class="keyword">int</span></span><br><span class="line">    value   <span class="keyword">int</span></span><br><span class="line">    prev    *node</span><br><span class="line">    next    *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DoubleList <span class="keyword">struct</span> &#123;</span><br><span class="line">    head    *node</span><br><span class="line">    tail    *node</span><br><span class="line">    size    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructDL</span><span class="params">()</span> *<span class="title">DoubleList</span></span> &#123;</span><br><span class="line">    dh := &amp;node&#123;</span><br><span class="line">        key :   <span class="number">0</span>,</span><br><span class="line">        value : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dt := &amp;node&#123;</span><br><span class="line">        key :   <span class="number">0</span>,</span><br><span class="line">        value : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dh.next,dt.prev = dt,dh</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;DoubleList&#123;</span><br><span class="line">        head    :   dh,</span><br><span class="line">        tail    :   dt,</span><br><span class="line">        size    :   <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">addLast</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev = dl.tail.prev</span><br><span class="line">    x.next = dl.tail</span><br><span class="line">    dl.tail.prev.next = x</span><br><span class="line">    dl.tail.prev = x</span><br><span class="line">    dl.size++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">remove</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev.next = x.next</span><br><span class="line">    x.next.prev = x.prev</span><br><span class="line">    dl.size--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">removeFirst</span><span class="params">()</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dl.head.next == dl.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> dl.head</span><br><span class="line">    &#125;</span><br><span class="line">    first := dl.head.next</span><br><span class="line">    dl.remove(first)</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">dlSize</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dl.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashMap     <span class="keyword">map</span>[<span class="keyword">int</span>]*node</span><br><span class="line">    cache       *DoubleList</span><br><span class="line">    <span class="built_in">cap</span>         <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LRUCache</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node,capacity)</span><br><span class="line">    dl := constructDL()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">        hashMap :   m,</span><br><span class="line">        cache   :   dl,</span><br><span class="line">        <span class="built_in">cap</span>     :   capacity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.hashMap[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.makeRecently(key)</span><br><span class="line">    <span class="keyword">return</span> this.hashMap[key].value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.hashMap[key]; ok &#123;</span><br><span class="line">        this.deleteKey(key)</span><br><span class="line">        this.addRecently(key,value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> this.<span class="built_in">cap</span> == this.cache.dlSize() &#123;</span><br><span class="line">            this.deleteLeastRecently()</span><br><span class="line">        &#125;</span><br><span class="line">        this.addRecently(key,value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">makeRecently</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := this.hashMap[key]</span><br><span class="line">    this.cache.remove(x)</span><br><span class="line">    this.cache.addLast(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">addRecently</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := &amp;node&#123;</span><br><span class="line">        key :   key,</span><br><span class="line">        value : val,</span><br><span class="line">    &#125;</span><br><span class="line">    this.cache.addLast(x)</span><br><span class="line">    this.hashMap[key] = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">deleteKey</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := this.hashMap[key]</span><br><span class="line">    this.cache.remove(x)</span><br><span class="line">    <span class="built_in">delete</span>(this.hashMap,key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">deleteLeastRecently</span><span class="params">()</span></span> &#123;</span><br><span class="line">    deleteNode := this.cache.removeFirst()</span><br><span class="line">    deleteKey := deleteNode.key</span><br><span class="line">    <span class="built_in">delete</span>(this.hashMap, deleteKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LRU算法介绍&quot;&gt;&lt;a href=&quot;#LRU算法介绍&quot; class=&quot;headerlink&quot; title=&quot;LRU算法介绍&quot;&gt;&lt;/a&gt;LRU算法介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;LRU算法(Least Recently Used)算法实质上是一种缓存机制</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="LRU" scheme="http://jiahaohong1997.github.io/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记</title>
    <link href="http://jiahaohong1997.github.io/2021/09/16/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://jiahaohong1997.github.io/2021/09/16/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-09-16T04:37:00.000Z</published>
    <updated>2021-11-09T15:20:09.145Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;学习视频地址：<a class="link" href="https://www.bilibili.com/video/BV1S54y1R7SB?p=4&spm_id_from=pageDriver">【狂神说Java】Redis最新超详细版教程通俗易懂<i class="fas fa-external-link-alt"></i></a></p><h1 id="为什么要用NoSQL"><a href="#为什么要用NoSQL" class="headerlink" title="为什么要用NoSQL"></a>为什么要用NoSQL</h1><p>&emsp;&emsp;用户的个人信息、社交网络、地理位置、用户自己产生的数据、用户日志等等爆发式增长。使用NoSQL数据库可以很好的解决上述情况。</p><h1 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h1><p>&emsp;&emsp;NoSQL=Not Only SQL。泛指非关系型数据库。随着web2.0互联网的诞生，传统的关系型数据库很难应付此时的需求。尤其是超大规模，高并发的社区。NoSQL在当今大数据时代下十分通用，Redis是发展最快的。</p><p>&emsp;&emsp;很多的数据类型用户的个人信息、社交网络、地理位置等数据的存储不需要一个固定的格式。不需要多余的操作就可以横向扩展（使用键值对来存储）。</p><p>&emsp;&emsp;特点：</p><ol><li>方便扩展（数据之间没有关系，很好扩展）</li><li>大数据条件下性能高（Redis一秒写8万次，读取11万次，NoSQL的缓存）</li><li>数据类型多样，不需要事先设计数据库，随取随用</li><li>传统的RDBMS和NoSQL</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">传统的RDBMS</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都在单独的表中</span><br><span class="line">- 数据操作语言，数据定义语言</span><br><span class="line">- 严格的一致性</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NoSQL</span><br><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储、列存储、文档存储、图形数据库（社交关系）</span><br><span class="line">- 最终一致性</span><br><span class="line">- CAP定理和BASE（异地多活）</span><br><span class="line">- 高性能、高可用、高可扩展</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;NoSQL的四大分类：</p><ol><li>kv键值对：<strong>Redis</strong>、memcache</li><li>文档型数据库（bson和json格式）：</li></ol><ul><li><strong>MangoDB</strong><ul><li>MangoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档</li><li>MangoDB是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库中功能最丰富的，最像关系型数据库的</li></ul></li><li>CouchDB</li></ul><ol start="3"><li>列存储数据库</li></ol><ul><li><strong>HBase</strong></li><li>分布式文件系统</li></ul><ol start="4"><li>图关系数据库（存放关系，比如：朋友圈，广告推荐）</li></ol><ul><li><strong>Neo4j</strong></li><li>InfoGrid</li></ul><h1 id="Mac下Redis的运行环境"><a href="#Mac下Redis的运行环境" class="headerlink" title="Mac下Redis的运行环境"></a>Mac下Redis的运行环境</h1><p>&emsp;&emsp;在Mac中，Redis的安装目录在<code>/usr/local/bin</code>下,Redis默认不是后台启动的，修改配置文件<code>redis.conf</code>中的<code>daemonize</code>项为yes，如下图：</p><p><img lazyload src="/images/loading.svg" data-src="1.jpg" alt="avatar"></p><h2 id="启动Redis"><a href="#启动Redis" class="headerlink" title="启动Redis"></a>启动Redis</h2><p>&emsp;&emsp;在<code>/usr/local/bin</code>目录下启动Redis，并使用之前修改后的配置文件：</p><p><img lazyload src="/images/loading.svg" data-src="2.jpg" alt="avatar"></p><p>&emsp;&emsp;使用<code>redis-cli</code>进行连接并验证Redis服务是否正常启动：</p><p><img lazyload src="/images/loading.svg" data-src="3.jpg" alt="avatar"></p><p>&emsp;&emsp;输入<code>Ping</code>后返回<code>Pong</code>说明连接成功。</p><p>&emsp;&emsp;查看redis进程是否开启：</p><p><img lazyload src="/images/loading.svg" data-src="4.jpg" alt="avatar"></p><h2 id="关闭Redis服务"><a href="#关闭Redis服务" class="headerlink" title="关闭Redis服务"></a>关闭Redis服务</h2><p>&emsp;&emsp;使用<code>shutdown</code>命令关闭服务：</p><p><img lazyload src="/images/loading.svg" data-src="5.jpg" alt="avatar"></p><h1 id="Redis-benchmark"><a href="#Redis-benchmark" class="headerlink" title="Redis-benchmark"></a>Redis-benchmark</h1><p>&emsp;&emsp;官方自带的性能测试工具，redis 性能测试工具可选参数如下所示：</p><p><img lazyload src="/images/loading.svg" data-src="6.jpg" alt="avatar"></p><p>&emsp;&emsp;简单测试下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试：100个并发连接，每个并发100000个请求</span></span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br></pre></td></tr></table></figure><p>测试结果如下图所示：</p><p><img lazyload src="/images/loading.svg" data-src="7.jpg" alt="avatar"></p><h1 id="Redis的基础知识"><a href="#Redis的基础知识" class="headerlink" title="Redis的基础知识"></a>Redis的基础知识</h1><p>&emsp;&emsp;Redis有16个数据库，默认使用第一个数据库，可以使用select切换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 3  <span class="comment"># 切换成3号数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; dbsize  <span class="comment"># 查看数据库的大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;切换回0号数据库后查看其大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; select 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;hongjiahao&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;查看数据库所有的key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;mylist&quot;</span></span><br><span class="line">2) <span class="string">&quot;myhash&quot;</span></span><br><span class="line">3) <span class="string">&quot;key:__rand_int__&quot;</span></span><br><span class="line">4) <span class="string">&quot;name&quot;</span></span><br><span class="line">5) <span class="string">&quot;counter:__rand_int__&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;清空当前数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;清空全部数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name hongjiahao  <span class="comment"># 在0号数据库插入键值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;hongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; select 3<span class="comment"># 切换到3号数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; flushall<span class="comment"># 清空所有数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; select 0<span class="comment"># 切回到0号数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *<span class="comment"># 查看0号数据库的所有键值</span></span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure><blockquote><p>Redis是单线程的！</p></blockquote><p>Redis很快，官方表示Redis是基于内存操作的，CPU不是其性能瓶颈，Redis的性能瓶颈时根据机器的内存和网络带宽决定的，所以可以使用单线程的方案来实现。</p><p>Redis是C语言写的，官方提供的数据是100000+ QPS，完全不比同样是使用key-value的Memecache差。</p><p><strong>Redis为什么是单线程但还很快？</strong></p><p>误区一：高性能的服务器一定是多线程的</p><p>误区二：多线程一定比单线程快</p><p>核心：Redis将全部的数据放在内存中，所以使用单线程来操作效率就是最高的，如果使用多线程，反而会因为上下文切换而降低其效率。</p><h1 id="Redis五大数据类型"><a href="#Redis五大数据类型" class="headerlink" title="Redis五大数据类型"></a>Redis五大数据类型</h1><blockquote><p>Redis是一个开源（BSD许可）的内存数据结构存储，被用作数据库、缓存和消息代理。Redis提供的数据结构包括：字符串、哈希值、列表、集合、带范围查询的排序集合、位图、超日志、地理空间索引和流。Redis有内置的复制、Lua脚本、LRU驱逐、事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster的自动分区提供高可用性。</p></blockquote><p>&emsp;&emsp;查看某个key是否存在&amp;移除某个键值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name hongjiahao</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 24</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists name  <span class="comment"># 查看name作为key是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; exists name1 <span class="comment"># 查看name1作为key是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; move name 1  <span class="comment"># 移除name</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;设置过期时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name hongjiahao</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;hongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; expire name 10 <span class="comment"># 设置name在10秒之后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name <span class="comment"># 查看还有几秒name过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) -2<span class="comment"># 返回-2，name已过期</span></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;查看当前key的类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name hongjiahao</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> name  <span class="comment"># 查看当前key的类型</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> age</span><br><span class="line">string</span><br></pre></td></tr></table></figure><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><h3 id="append、strlen"><a href="#append、strlen" class="headerlink" title="append、strlen"></a>append、strlen</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;hongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; append name 1997  <span class="comment"># 在键值对中追加字符串,如果key不存在，相当于set了一个新key</span></span><br><span class="line">(<span class="built_in">integer</span>) 14</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;hongjiahao1997&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; strlen name<span class="comment"># 获取字符串长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 14</span><br></pre></td></tr></table></figure><h3 id="incr、decr、incrby、decrby"><a href="#incr、decr、incrby、decrby" class="headerlink" title="incr、decr、incrby、decrby"></a>incr、decr、incrby、decrby</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> views 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr views  <span class="comment"># views中的值加一</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr views<span class="comment"># views中的值减一</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incrby views 10 <span class="comment"># views中的值加10</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decrby views 5<span class="comment"># views中的值减5</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br></pre></td></tr></table></figure><h3 id="getrange、strange、setex、sent、meet、mget、对象、getset"><a href="#getrange、strange、setex、sent、meet、mget、对象、getset" class="headerlink" title="getrange、strange、setex、sent、meet、mget、对象、getset"></a>getrange、strange、setex、sent、meet、mget、对象、getset</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 hello,hongjiahao</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; getrange k1 0 3<span class="comment"># 截取k1的0到3号索引</span></span><br><span class="line"><span class="string">&quot;hell&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange k1 0 -1 <span class="comment"># 截取k1整串</span></span><br><span class="line"><span class="string">&quot;hello,hongjiahao&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setrange:替换指定位置开始的字符</span></span><br><span class="line">127.0.0.1:6379&gt; setrange k1 1 a <span class="comment"># 将索引为1的字符替换为a</span></span><br><span class="line">(<span class="built_in">integer</span>) 16</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;hallo,hongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setrange k1 1 aaa <span class="comment"># 将索引为1的字符替换为aaa</span></span><br><span class="line">(<span class="built_in">integer</span>) 16</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;haaao,hongjiahao&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># setex(set with expire)  设置过期时间</span></span><br><span class="line"><span class="comment"># setnx(set if not exists)   不存在再设置(在分布式锁中常用)</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; setex k2 30 <span class="string">&quot;hello&quot;</span>  <span class="comment"># 设置一个键值对，并使其生命周期为30秒</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ttl k2</span><br><span class="line">(<span class="built_in">integer</span>) 23</span><br><span class="line">127.0.0.1:6379&gt; ttl k2</span><br><span class="line">(<span class="built_in">integer</span>) 18</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; setnx k3 <span class="string">&quot;Redis&quot;</span><span class="comment"># 若k3不存在，则初始化一个键值对</span></span><br><span class="line">(<span class="built_in">integer</span>) 1<span class="comment"># 成功</span></span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line"><span class="string">&quot;Redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setnx k3 <span class="string">&quot;MangoDB&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0<span class="comment"># 失败</span></span><br><span class="line">127.0.0.1:6379&gt; get k3<span class="comment"># 若直接使用set k3 MangoDB，会覆盖掉之前设置的Redis</span></span><br><span class="line"><span class="string">&quot;Redis&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># mset批量设置键值对</span></span><br><span class="line"><span class="comment"># mget批量打印键值对</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># msetnx批量设置（所有都不存在才初始化），是一个原子性的操作，要么一起成功，要么一起失败</span></span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 vv1 k2 vv2 k3 vv3 k4 vv4</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3 k4</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">4) (nil)</span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># 对象</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> user:1 &#123;name:lisi,age:13&#125; <span class="comment"># 设置一个user对象，值为json字符来保存一个对象</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get user:1</span><br><span class="line"><span class="string">&quot;&#123;name:lisi,age:13&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种巧妙的方式：user:&#123;id&#125;:&#123;field&#125;，如此设置在Redis中是完全ok的</span></span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 12</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">2) <span class="string">&quot;12&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># getset# 先获取，再设置。如果不存在值，则返回nil，如果存在值，先返回原来值，再设置新的值</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; getset db Redis</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;Redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getset db mangodb</span><br><span class="line"><span class="string">&quot;Redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;mangodb&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;String类型的使用场景：value除了是字符串还能是数字</p><ul><li>计数器</li><li>统计多单位的数量（eg.: set User:9999:follow 20000）</li><li>对象缓存存储</li></ul><h2 id="List类型-列表"><a href="#List类型-列表" class="headerlink" title="List类型(列表)"></a>List类型(列表)</h2><p>&emsp;&emsp;基本的数据类型，列表。在Redis中，可以使用List实现栈、队列、阻塞队列。所有的List命令都是L开头的。</p><h3 id="LPUSH、RPUSH、LRANGE"><a href="#LPUSH、RPUSH、LRANGE" class="headerlink" title="LPUSH、RPUSH、LRANGE"></a>LPUSH、RPUSH、LRANGE</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># LPUSH   向列表的左端插入</span></span><br><span class="line"><span class="comment"># RPUSH   向列表的右端插入</span></span><br><span class="line"><span class="comment"># LRANGE  获取列表中指定区间的值</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list one<span class="comment"># 将一个或多个值插入到列表的头部（左插）</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1  <span class="comment"># 获取list中的所有值</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 1 <span class="comment"># 获取list中的指定值</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPUSH list four<span class="comment"># 将一个或多个值插入到列表的头部（右插）</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;four&quot;</span></span><br></pre></td></tr></table></figure><h2 id="LPOP、LINDEX"><a href="#LPOP、LINDEX" class="headerlink" title="LPOP、LINDEX"></a>LPOP、LINDEX</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># LPOP  最左端的值出队</span></span><br><span class="line"><span class="comment"># LINDEX 获取列表的某一个值</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPOP list <span class="comment"># 移除列表的左端第一个元素</span></span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;four&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP list <span class="comment"># 移除列表的右端第一个元素</span></span><br><span class="line"><span class="string">&quot;four&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX list 0  <span class="comment"># 获取第一个值</span></span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Llen、Lrem、Ltrim"><a href="#Llen、Lrem、Ltrim" class="headerlink" title="Llen、Lrem、Ltrim"></a>Llen、Lrem、Ltrim</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># Llen 返回列表的长度</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Llen list</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># Lrem  移除指定值</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">4) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Lrem list 1 one<span class="comment"># 移除1个one</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Lrem list 2 three<span class="comment"># 移除2个three</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># Ltrim  截取指定区间内的值更新list</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello1&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello2&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello3&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello2&quot;</span></span><br><span class="line">4) <span class="string">&quot;hello3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ltrim mylist 1 2<span class="comment"># 截取索引[1,2]的值并修改List</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello2&quot;</span></span><br></pre></td></tr></table></figure><h3 id="组合命令，例如RPOPLPUSH"><a href="#组合命令，例如RPOPLPUSH" class="headerlink" title="组合命令，例如RPOPLPUSH"></a>组合命令，例如RPOPLPUSH</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># RPOPLPUSH  移除列表最后一个元素并将其添加到新的列表</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH mylist myotherlist <span class="comment"># 移除mylist列表最后一个元素并将其添加到myotherlist列表</span></span><br><span class="line"><span class="string">&quot;hello2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE myotherlist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="更新Lset、插入Linsert"><a href="#更新Lset、插入Linsert" class="headerlink" title="更新Lset、插入Linsert"></a>更新Lset、插入Linsert</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># lset 向一个已经存在的列表中添加值（指定已存在的索引），相当于更新操作</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exists list</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item</span><br><span class="line">(error) ERR no such key  <span class="comment"># 如果不存在列表，则会报错</span></span><br><span class="line">127.0.0.1:6379&gt; lpush list value  <span class="comment"># list: [value]</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) <span class="string">&quot;value&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item <span class="comment"># 相当于间接做了更新操作</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) <span class="string">&quot;item&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 1 other <span class="comment"># 不存在该索引的位置，添加错误</span></span><br><span class="line">(error) ERR index out of range</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># linsert (linsert key BEFORE|AFTER pivot element) 向一个列表中某个元素的前/后插入新值</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist world</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; linsert mylist before <span class="string">&quot;world&quot;</span> <span class="string">&quot;,&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;,&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; linsert mylist after world !</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;,&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br><span class="line">4) <span class="string">&quot;!&quot;</span></span><br></pre></td></tr></table></figure><ul><li>实际上是一个双端链表，可以在节点的前后插入新节点</li><li>如果key不存在，需要先创建之后再更改或添加</li><li>如果移除了一个链表中的所有值，那么就变成了空链表，也就代表它不存在了</li><li>在链表的两端插入或改动值，效率最高。中间的元素效率会相对低一些</li><li>作为消息队列：LPUSH  RPOP；作为栈：LPUSH  LPOP</li></ul><h2 id="Set类型-集合"><a href="#Set类型-集合" class="headerlink" title="Set类型(集合)"></a>Set类型(集合)</h2><p>&emsp;&emsp;Set中的值是不能重复的！Set的命令开头基本都是S。</p><h3 id="Sadd、Smembers、Sismember"><a href="#Sadd、Smembers、Sismember" class="headerlink" title="Sadd、Smembers、Sismember"></a>Sadd、Smembers、Sismember</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># sadd 向集合中添加元素</span></span><br><span class="line"><span class="comment"># smembers 查看置顶集合中的所有元素</span></span><br><span class="line"><span class="comment"># sismember 判断某个元素是否在指定的集合中</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hellohongjiahao&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hognjiahao&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hognjiahao&quot;</span></span><br><span class="line">3) <span class="string">&quot;hellohongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sismember myset hello <span class="comment"># 存在则返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember myset hhh<span class="comment"># 不存咋则返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span> <span class="comment"># 元素“hello”已存在，添加失败，返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="Scard、Srem"><a href="#Scard、Srem" class="headerlink" title="Scard、Srem"></a>Scard、Srem</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># scard 获取指定集合中的元素个数</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; scard myset<span class="comment"># 查看元素个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; srem myset hello  <span class="comment"># 移除hello</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember myset hello</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="Srandmember、Spop"><a href="#Srandmember、Spop" class="headerlink" title="Srandmember、Spop"></a>Srandmember、Spop</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># srandmember 随机获取元素</span></span><br><span class="line"><span class="comment"># spop 随机移除元素</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;hellohongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;hellohongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;hognjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;hellohongjiahao&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;wuxingyi&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;hognjiahao&quot;</span></span><br><span class="line">4) <span class="string">&quot;hellohongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line"><span class="string">&quot;hognjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;wuxingyi&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;hellohongjiahao&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Smove"><a href="#Smove" class="headerlink" title="Smove"></a>Smove</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># smove  将一个元素移到另一个集合中</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd myset1 hello world !</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 xixi haha fuck</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; smove myset1 myset2 hello <span class="comment"># 将myset1中的hello移到myset2中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset1</span><br><span class="line">1) <span class="string">&quot;world&quot;</span></span><br><span class="line">2) <span class="string">&quot;!&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) <span class="string">&quot;haha&quot;</span></span><br><span class="line">2) <span class="string">&quot;xixi&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">4) <span class="string">&quot;fuck&quot;</span></span><br></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul><li>差集Sdiff</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># sdiff A B 所有属于A集合但不属于B集合的元素</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd myset1 a b c d</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 a w d s c</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><ul><li>交集Sinter</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># sinter A B  A和B集合的交集</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sinter myset1 myset2</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;d&quot;</span></span><br><span class="line">3) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure><ul><li>并集Sunion</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># sunion A B  A和集合B的并集</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sunion myset1 myset2</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;w&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;s&quot;</span></span><br><span class="line">5) <span class="string">&quot;c&quot;</span></span><br><span class="line">6) <span class="string">&quot;d&quot;</span></span><br></pre></td></tr></table></figure><p>应用：</p><p>可以将A用户所有的关注up的uid放在一个set中，A的粉丝的uid放在另一个set中。</p><p>例如：共同关注，共同爱好，推荐好友</p><h2 id="Hash类型-哈希"><a href="#Hash类型-哈希" class="headerlink" title="Hash类型(哈希)"></a>Hash类型(哈希)</h2><p>&emsp;&emsp;Map集合，key-map集合，类似<code>key-&#123;&#123;key1,value1&#125;,&#123;key1,value2&#125;,...&#125;</code>，但本质和string类型没有太大区别，还是一个简单的key-value。</p><h3 id="Hset、Hget、Hmset、Hmget、Hgetall、Hdel"><a href="#Hset、Hget、Hmset、Hmget、Hgetall、Hdel" class="headerlink" title="Hset、Hget、Hmset、Hmget、Hgetall、Hdel"></a>Hset、Hget、Hmset、Hmget、Hgetall、Hdel</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># hset设置一个具体的key-value</span></span><br><span class="line"><span class="comment"># hget获取一个具体的key的value</span></span><br><span class="line"><span class="comment"># hmset同时设置多个字段值</span></span><br><span class="line"><span class="comment"># hmget同时获取多个key下的value</span></span><br><span class="line"><span class="comment"># hgetall 同时获得所有字段值</span></span><br><span class="line"><span class="comment"># hdel删除某个指定的字段</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> myhash field1 hongjiahao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash field1</span><br><span class="line"><span class="string">&quot;hongjiahao&quot;</span></span><br><span class="line">hmset myhash field1 hello field2 world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget myhash field1 field2<span class="comment"># &quot;hongjiahao&quot;被覆盖</span></span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;field2&quot;</span></span><br><span class="line">4) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash field1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;field2&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Hlen、Hexists、Hkeys、Hvals"><a href="#Hlen、Hexists、Hkeys、Hvals" class="headerlink" title="Hlen、Hexists、Hkeys、Hvals"></a>Hlen、Hexists、Hkeys、Hvals</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># hlen获取hash表的字段数量</span></span><br><span class="line"><span class="comment"># hexists判断哈希表中的指定字段是否存在</span></span><br><span class="line"><span class="comment"># hkeys获取哈希表的所有key</span></span><br><span class="line"><span class="comment"># hvals 获取哈希表的所有value</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hmset myhash field1 hello field2 world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hlen myhash</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field1<span class="comment"># 存在field1字段，返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field3<span class="comment"># 不存在field2字段，返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash<span class="comment"># 获取哈希表的所有key</span></span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;field2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hvals myhash<span class="comment"># 获取哈希表的所有value</span></span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Hincrby、Hsetnx"><a href="#Hincrby、Hsetnx" class="headerlink" title="Hincrby、Hsetnx"></a>Hincrby、Hsetnx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># hincrby 哈希表中指定字段的value加减</span></span><br><span class="line"><span class="comment"># hsetnx 如果不存在则设置</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hset myhash field3 5</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash field3 1</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash field3 -1</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field4 hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field4 world</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;field2&quot;</span></span><br><span class="line">4) <span class="string">&quot;world&quot;</span></span><br><span class="line">5) <span class="string">&quot;field3&quot;</span></span><br><span class="line">6) <span class="string">&quot;5&quot;</span></span><br><span class="line">7) <span class="string">&quot;field4&quot;</span></span><br><span class="line">8) <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;hash用于变更的数据 user{ name, age, hobby, …}，尤其是用户信息的保存，或经常变化的信息。hash更适合对象的存储，string更加适合字符串的存储。</p><h3 id="Zset类型（有序集合）"><a href="#Zset类型（有序集合）" class="headerlink" title="Zset类型（有序集合）"></a>Zset类型（有序集合）</h3><p>&emsp;&emsp;在set的基础上，增加了一个值<code>score</code>用于记录key的优先级。</p><h3 id="Zadd、Zrange、Zrangebyscore、Zrevrange"><a href="#Zadd、Zrange、Zrangebyscore、Zrevrange" class="headerlink" title="Zadd、Zrange、Zrangebyscore、Zrevrange"></a>Zadd、Zrange、Zrangebyscore、Zrevrange</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># zadd 添加字段</span></span><br><span class="line"><span class="comment"># zrange 按索引查找</span></span><br><span class="line"><span class="comment"># zrangebyscore 按照set字段的优先级排序(默认由低到高排序)</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 two</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 3 three 4 four</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange myset 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">4) <span class="string">&quot;four&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 2500 xiaohong</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 5000 zhangsan</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 500 kuangshen</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf  <span class="comment"># 按照薪水的优先级排序（范围负无穷到正无穷）</span></span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">3) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrevrange salary 0 -1<span class="comment"># 从大到小排序</span></span><br><span class="line">1) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">2) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">3) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf withscores <span class="comment"># 加上优先级</span></span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line">5) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">6) <span class="string">&quot;5000&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf 2500 withscores <span class="comment"># 上界是2500的情况</span></span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf (2500 withscores <span class="comment"># 上界2500是开区间，不能包含在内</span></span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary (500 2500 withscores <span class="comment"># 下界500是开区间，不能包含在内</span></span><br><span class="line">1) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">2) <span class="string">&quot;2500&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Zrem、Zcard、Zcount"><a href="#Zrem、Zcard、Zcount" class="headerlink" title="Zrem、Zcard、Zcount"></a>Zrem、Zcard、Zcount</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># zrem  移除set中的指定元素</span></span><br><span class="line"><span class="comment"># zcard 获取有序集合中的元素个数</span></span><br><span class="line"><span class="comment"># zcount 获取指定区间的成员数量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrem salary xiaohong</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zcard salary</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 hello 2 world 3 hongjiahao</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><p>其余的一些API可以通过官方文档查看</p><p>案例思路：set 排序（用于存储班级成绩表，工资表排序）</p><p>​                    普通消息（1），重要消息（2），带权重进行判断</p><p>​                    排行榜应用实现</p><h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h3><p>朋友的定位，附近的人，打车距离计算</p><p>Redis的Geo在Redis的3.2版本就已经推出了。该功能可以推算地理位置的信息，两地之间的距离，方圆几里的人。</p><p>查询城市经纬度的网站：<a class="link" href="http://www.jsons.cn/lngcode/">http://www.jsons.cn/lngcode/<i class="fas fa-external-link-alt"></i></a></p><p>只有6个命令。</p><h4 id="geoadd：添加地理位置"><a href="#geoadd：添加地理位置" class="headerlink" title="geoadd：添加地理位置"></a>geoadd：添加地理位置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># geoadd 添加城市数据（经纬度）</span></span><br><span class="line"><span class="comment"># 规则：两级无法直接添加，一般会下载城市数据然后一次性导入</span></span><br><span class="line"><span class="comment"># 参数：注意经纬度的有效范围</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 114.05 22.52 shenzhen 120.16 30.24 hangzhou 108.96 34.26 xian</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h4 id="geopos：查找指定的成员位置"><a href="#geopos：查找指定的成员位置" class="headerlink" title="geopos：查找指定的成员位置"></a>geopos：查找指定的成员位置</h4><p>获得当前定位：一定是个坐标值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># geopos： 获取指定的经纬度</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geopos china:city beijing chongqing</span><br><span class="line">1) 1) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">   2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br></pre></td></tr></table></figure><h4 id="geodist：两人之间的直线距离"><a href="#geodist：两人之间的直线距离" class="headerlink" title="geodist：两人之间的直线距离"></a>geodist：两人之间的直线距离</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai</span><br><span class="line"><span class="string">&quot;1067378.7564&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai km <span class="comment"># 单位：km</span></span><br><span class="line"><span class="string">&quot;1067.3788&quot;</span></span><br></pre></td></tr></table></figure><h4 id="georadius：以给定的经纬度为中心，找出某一半径内的元素"><a href="#georadius：以给定的经纬度为中心，找出某一半径内的元素" class="headerlink" title="georadius：以给定的经纬度为中心，找出某一半径内的元素"></a>georadius：以给定的经纬度为中心，找出某一半径内的元素</h4><p>我附近的人？（获得所有附近的人的地址：定位），然后通过半径来查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km <span class="comment"># 以（110，30）为中心，找出半径1000km内的城市</span></span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withdist <span class="comment"># 显示距离</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;341.9374&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) <span class="string">&quot;483.8340&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord <span class="comment"># 显示坐标</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord count 1 <span class="comment"># 只查询一个</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord count 2 <span class="comment"># 查询两个</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br></pre></td></tr></table></figure><h4 id="georadiusbymember：根据具体的元素查询"><a href="#georadiusbymember：根据具体的元素查询" class="headerlink" title="georadiusbymember：根据具体的元素查询"></a>georadiusbymember：根据具体的元素查询</h4><p>具体功能和上面一致，不过使用具体的成员代替坐标位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># georadiusbymember：查找位于指定元素指定距离的元素</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km</span><br><span class="line">1) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br></pre></td></tr></table></figure><h4 id="geohash：返回一个或多个位置元素的Geohash表示"><a href="#geohash：返回一个或多个位置元素的Geohash表示" class="headerlink" title="geohash：返回一个或多个位置元素的Geohash表示"></a>geohash：返回一个或多个位置元素的Geohash表示</h4><p>该命令将返回11个字符的Geohash字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># geohash：将二维的经纬度转换成一维的字符串，两个字符串越接近表示两个地点位置越近</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geohash china:city beijing chongqing</span><br><span class="line">1) <span class="string">&quot;wx4fbxxfke0&quot;</span></span><br><span class="line">2) <span class="string">&quot;wm5xzrybty0&quot;</span></span><br></pre></td></tr></table></figure><h4 id="底层的实现原理Zset"><a href="#底层的实现原理Zset" class="headerlink" title="底层的实现原理Zset"></a>底层的实现原理Zset</h4><p>可以使用Zset命令来操作Geo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1 <span class="comment"># 查看地图中全部的元素</span></span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span> </span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">5) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">6) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem china:city beijing <span class="comment"># 移除beijing</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">5) <span class="string">&quot;shanghai&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><p>什么是基数？</p><p>A{1,3,5,7,8,7}</p><p>B{1,3,5,7,8}</p><p>基数（不重复的元素的数量）：A的基数：4；B的基数：5</p><p>Redis Hyperloglog 用于基数统计</p><p>优点：占用的内存是固定的，2^64不同的元素，只需要12KB内存。如果要从内存的角度来比较，Hyperloglog就是首选。</p><p>有0.81%的错误率。</p><p>使用场景：</p><p>网页的UV（unique visitor）：一个人访问一个网站多次，但还是只算做一个访问者。传统的方式中，用set保存用户的id，然后可以统计set中的元素数量作为判断标准。这个方式如果保存大量的用户id，就会占用较大的存储。我们的目的是计数，而不是保存用户id。</p><h4 id="PFadd、PFcount、PFmerge"><a href="#PFadd、PFcount、PFmerge" class="headerlink" title="PFadd、PFcount、PFmerge"></a>PFadd、PFcount、PFmerge</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PFadd  创建一组元素</span></span><br><span class="line"><span class="comment"># PFcount 统计一组元素中的基数</span></span><br><span class="line"><span class="comment"># PFmerge 合并几组元素到指定组中</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; PFadd mykey a b c d e f g h i j</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFcount mykey</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; PFadd mykey2 i j z x c v b n m</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFcount mykey2</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE mykeys mykey mykey2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFcount mykeys</span><br><span class="line">(<span class="built_in">integer</span>) 15</span><br></pre></td></tr></table></figure><h3 id="Bitmaps：位存储"><a href="#Bitmaps：位存储" class="headerlink" title="Bitmaps：位存储"></a>Bitmaps：位存储</h3><h4 id="setbit"><a href="#setbit" class="headerlink" title="setbit"></a>setbit</h4><p>使用bitmaps记录周一到周日的打卡情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 7 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h4 id="getbit"><a href="#getbit" class="headerlink" title="getbit"></a>getbit</h4><p>查看某一天是否打卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 4</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h4 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a>bitcount</h4><p>统计打卡的天数</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>原子性：要么同时成功，要么同时失败！</p><p>关系型数据库保证了原子性，Redis的单条命令是保证原子性的，但是事务不保证原子性。</p><p>Redis事务的本质：一组命令的集合。一个事务中的所有命令都会被序列化，在事务的执行过程中，会按照顺序执行。一次性、顺序性、排他性。Redis事务没有隔离级别的概念，所有的命令在事务中，没有直接执行，只有发起执行命令的时候才会执行。</p><p>Redis的事务：</p><ul><li>开启事务（Multi）</li><li>命令入队（…）</li><li>执行事务（exec）</li></ul><p>锁：Redis可以实现乐观锁</p><p>正常执行事务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br><span class="line">4) OK</span><br></pre></td></tr></table></figure><p>放弃事务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k4<span class="comment"># 事务队列中的命令不会被执行</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>编译性错误：命令有错，事务中的所有命令都不会被执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; getset k3 <span class="comment"># 错误的命令</span></span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;getset&#x27;</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k5 v5</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span><span class="comment"># 执行事务时报错，所有的命令都不会被执行</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; get k5</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>运行时异常，如果事务队列中存在语法性错误，那么执行命令的时候，其他命令还可以正常执行，错误的命令会抛出异常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 <span class="string">&quot;v1&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line"><span class="comment"># 虽然第一条命令报错了，但是事务依旧执行成功了</span></span><br><span class="line">1) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p><strong>悲观锁：</strong></p><ul><li>悲观锁：很悲观，什么时候都会出问题，无论做什么都加锁</li></ul><p><strong>乐观锁：</strong></p><ul><li>乐观锁：很乐观，认为什么时候都不会出现问题，所以不会上锁。更新数据的时候判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money  <span class="comment"># 监视money对象</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI<span class="comment"># 事务正常结束，数据期间没有发生变动，这个时候就正常执行</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure><p>正常执行成功</p><p>测试多线程修改完值，使用watch可以当作redis的乐观锁操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线程2</span></span><br><span class="line">127.0.0.1:6379&gt; get money</span><br><span class="line"><span class="string">&quot;80&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 1000</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线程1</span></span><br><span class="line">127.0.0.1:6379&gt; watch money<span class="comment"># 监视money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; DECRBY money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY out 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC<span class="comment"># 执行之前，另外一个县城修改了money的值，会导致事务执行失败</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; UNWATCH <span class="comment"># 解锁</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money<span class="comment"># 重新加锁</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI<span class="comment"># 开启新事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; DECRBY money 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY money 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC<span class="comment"># 比对监视的值是否发生了变化，如果没有发生变化，可以执行成功</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 999</span><br><span class="line">2) (<span class="built_in">integer</span>) 1000</span><br></pre></td></tr></table></figure><p>如果修改失败，获取最新的值就好。</p><h2 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h2><p>1、配置文件 unit单位，对大小写不敏感</p><p>2、包含</p><p>3、网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1  <span class="comment"># 绑定的ip</span></span><br><span class="line">protected-mode yes<span class="comment"># 保护模式</span></span><br><span class="line">port 6379<span class="comment"># 端口设置</span></span><br></pre></td></tr></table></figure><p>4、通用设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes<span class="comment"># 以守护进程的方式运行，默认是no，需要自己开启为yes</span></span><br><span class="line">pidfile /var/run/redis_6379.pid  <span class="comment"># 如果以后台的方式运行，需要指定一个进程文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="comment"># Specify the server verbosity level.</span></span><br><span class="line"><span class="comment"># This can be one of:</span></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably)</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel notice<span class="comment"># 启动记录日志的级别</span></span><br><span class="line">logfile <span class="string">&quot;&quot;</span><span class="comment"># 生成的日志文件位置及文件名</span></span><br><span class="line">databases 16<span class="comment"># 数据库的数量：16个</span></span><br><span class="line">always-show-logo no  <span class="comment"># 是否总是显示logo</span></span><br></pre></td></tr></table></figure><p>5、快照</p><p>redis是内存数据库，如果没有持久化，那么数据断电即失</p><p>持久化：在规定的时间内执行了多少次操作后，会持久化到 .rdb  .aof</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果3600内，如果至少有一个key进行了修改，就进行持久化操作</span></span><br><span class="line">save 3600 1</span><br><span class="line"><span class="comment"># 如果300内，如果至少有100个key进行了修改，就进行持久化操作</span></span><br><span class="line">save 300 100</span><br><span class="line"><span class="comment"># 如果60内，如果至少有10000个key进行了修改，就进行持久化操作</span></span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes  <span class="comment"># 持久化如果出错，是否还要持续工作</span></span><br><span class="line">rdbcompression yes<span class="comment"># 是否压缩.rdb文件，需要消耗一些cpu资源</span></span><br><span class="line">rdbchecksum yes<span class="comment"># 保存.rdb文件时进行错误校验</span></span><br><span class="line"></span><br><span class="line">dir /usr/<span class="built_in">local</span>/var/db/redis/   <span class="comment"># .rdb文件保存的目录</span></span><br></pre></td></tr></table></figure><p>6、REPLICATION（主从复制）</p><p>7、安全</p><p>可以设置redis的密码，默认是没有密码的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass <span class="string">&quot;hjh1314lvwxy&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;hjh1314lvwxy&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务后</span></span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth hjh1314lvwxy</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;hjh1314lvwxy&quot;</span></span><br></pre></td></tr></table></figure><p>8、CLIENTS限制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000 <span class="comment"># 设置能连接上redis的最大客户端的数量</span></span><br><span class="line">maxmemory &lt;bytes&gt;<span class="comment"># redis配置最大的内存容量</span></span><br><span class="line">maxmemory-policy noeviction<span class="comment"># 内存大道上限之后的处理策略</span></span><br></pre></td></tr></table></figure><p>9、APPEND ONLY MODE  aof配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly no<span class="comment"># 默认不开启aof模式，默认使用rdb方式持久化</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span><span class="comment"># 持久化文件的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always# 每次修改都会sync，消耗性能</span></span><br><span class="line">appendfsync everysec<span class="comment"># 每秒执行一次sync，可能会丢失这一秒的数据</span></span><br><span class="line"><span class="comment"># appendfsync no# 不执行sync，这时候操作系统自己同步数据，速度最快</span></span><br></pre></td></tr></table></figure><h2 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h2><h3 id="RDB（Redis-Database）"><a href="#RDB（Redis-Database）" class="headerlink" title="RDB（Redis Database）"></a>RDB（Redis Database）</h3><p>&emsp;&emsp;Redis是内存数据库，如果不将内存中的数据库状态保存在磁盘，一旦服务器退出进程，服务器中的数据库状态也会消失。所以Redis提供了持久化功能。</p><p>&emsp;&emsp;在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是Snapshot快照，它会腐蚀是将快照文件直接读到内存当中。</p><p>&emsp;&emsp;Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入一个临时文件中，待持久化过程都结束了，再用这个临时文件替换掉上次持久化好的文件。整个过程中，主进程不进行任何OI操作。这就确保了极高的性能。如果需进行大规模的数据恢复，且对于数据恢复的完整性不是特别敏感，那RDB方式要比AOF更加高效。RDB的缺点是最后一次持久化的数据可能丢失。</p><p>&emsp;&emsp;rdb保存的文件是dump.rdb，可以在配置文件的快照项下修改。修改持久化的频率为：每60秒进行了5次操作就保存一次。</p><p><img lazyload src="/images/loading.svg" data-src="8.jpg" alt="avatar"></p><p>&emsp;&emsp;下图设置了dump.rdb的保存地址。</p><p><img lazyload src="/images/loading.svg" data-src="9.jpg" alt="avatar"></p><h4 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h4><p>1、save的规则满足的情况下，会自动触发rdb规则</p><p>2、执行flushall命令，会触发rdb规则</p><p>3、退出redis，会产生rdb文件</p><h4 id="恢复rdb文件"><a href="#恢复rdb文件" class="headerlink" title="恢复rdb文件"></a>恢复rdb文件</h4><p>1、只需将rdb文件放到redis的启动项中</p><p>2、查看需要存放的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir  <span class="comment"># 查看rdb文件的启动地址</span></span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/usr/local/var/db/redis&quot;</span> <span class="comment"># 如果在这个目录下存在rdb文件，启动时就会自动恢复其中的数据</span></span><br></pre></td></tr></table></figure><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1、适合大规模的数据恢复</p><p>2、对数据的完整性要求不高</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1、需要一定的时间间隔进行自动化保存，如果redis意外宕机了，最后一次修改的数据就没了</p><p>2、fork进程的时候，会占用一定的内存空间</p><h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><p>&emsp;&emsp;将我们的所有命令记录下来（history），恢复的时候再重新执行记录的命令。</p><p>&emsp;&emsp;以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据结构，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p>&emsp;&emsp;AOF保存的是appendonly.aof文件。AOF模式默认是不开启的，需要手动设置开启。只需要将appendonly改为yes就可以开启aof。</p><p> <img lazyload src="/images/loading.svg" data-src="10.jpg" alt="avatar"></p><p>&emsp;&emsp;appendonly.aof的保存路径如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir  <span class="comment"># 查看rdb文件的启动地址</span></span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/usr/local/var/db/redis&quot;</span> <span class="comment"># 如果在这个目录下存在rdb文件，启动时就会自动恢复其中的数据</span></span><br></pre></td></tr></table></figure><p>写入的频率</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><p>如果aof文件的大小大雨64mB，会fork一个新的进程来讲文件进行重写。aof默认文件无限追加，文件会越来越大。</p><p>&emsp;&emsp;如果appendonly.aof文件有错误，此时redis是启动不起来的，需要先修复这个aof文件。redis为我们提供了一个工具：<code>redis-check-aof</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure><p>如果文件正常，重启即可直接恢复了。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>1、每一次修改都同步，文件的完整性会更加好</p><p>2、每秒同步一次，可能只会丢失一秒的数据</p><p>3、从不同步，效率最高</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>1、相对于数据文件来说，aof远远大于rdb，恢复的速度也比rdb慢</p><p>2、aof运行效率也要比rdb慢，所以redis默认采用rdb持久化</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li>RDb持久化方式能够在指定的时间间隔内对数据进行快照存储</li><li>AOF持久化方式记录每次对服务器的写操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis协议追加每次写的操作到文件末尾，Redis还能对后台进行重写，是的AOF文件的体积不至于过大</li><li>只做缓存，如果你希望你的数据只在服务器端存在，可以不使用任何持久化</li><li>同时开启两种持久化方式<ul><li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要更完整</li><li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。但RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的bug。</li></ul></li><li>性能建议<ul><li>因为RDB文件只用做后备用途，见一直在slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1 这条规则</li><li>如果Enable AOF，好处是在最恶劣的情况下也只会丢失不超多2秒的数据，启动脚本较简单，只需要load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的，只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写默认64mB太小了，可以设到5GB以上，默认超过原大小100%大小重写可以改到适当的数值。</li><li>如果不Enable AOF，仅靠 Mater-Slave Replication 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。</li></ul></li></ul><h2 id="Redis订阅发布"><a href="#Redis订阅发布" class="headerlink" title="Redis订阅发布"></a>Redis订阅发布</h2><p>订阅端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe JiahaoHong1997  <span class="comment"># 订阅一个频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;JiahaoHong1997&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 等待读取推送的消息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span><span class="comment"># 消息</span></span><br><span class="line">2) <span class="string">&quot;JiahaoHong1997&quot;</span><span class="comment"># 来自的频道</span></span><br><span class="line">3) <span class="string">&quot;hello,jiahao&quot;</span><span class="comment"># 消息的具体内容</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;JiahaoHong1997&quot;</span></span><br><span class="line">3) <span class="string">&quot;ganbadie&quot;</span></span><br></pre></td></tr></table></figure><p>发送端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish JiahaoHong1997 <span class="string">&quot;hello,jiahao&quot;</span> <span class="comment"># 发布者发布消息到频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; publish JiahaoHong1997 <span class="string">&quot;ganbadie&quot;</span><span class="comment"># 发布者发布消息到频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><blockquote><p>原理</p></blockquote><p>&emsp;&emsp;Redis是用C实现的，通过分析Redis源码里的pubsub.c文件，了解发布和订阅机制的底层实现，借此加深对Redis的理解。</p><p>&emsp;&emsp;Redis通过publish、subscribe和psubscribe等命令实现发布和订阅功能。通过subscribe命令订阅某频道后，redis-server里维护了一个字典，字典的关键词是一个个channel，而字典的值则是一个链表，链表中保存了所有订阅这个channel的客户端。subscribe命令的关键，就是将客户端添加到给定的channel的订阅列表中。</p><p>&emsp;&emsp;通过publish命令向订阅者发送消息，redis-server会使用给定的频道作为键，在它所维护的channel字典中朝着记录了订阅这个频道的所有客户端的链表，链里这个链表，将消息发布给订阅者。</p><p>&emsp;&emsp;在Redis中，可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有的订阅它的客户端会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p><p>使用场景：</p><p>1、实时消息系统</p><p>2、实时聊天（频道当作聊天室，将信息回给所有人即可）</p><p>3、订阅、关注系统</p><p>稍微复杂的场景通常使用消息队列。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;学习视频地址：&lt;a class=&quot;link&quot; href=&quot;https://www.bilibili.com/video/BV1S54y1R7SB?p=4&amp;spm_id_from=pageDriver&quot;&gt;【狂神说Java】Redis最新超详细版教程通俗</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiahaohong1997.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Redis" scheme="http://jiahaohong1997.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Union-Find(并查集)</title>
    <link href="http://jiahaohong1997.github.io/2021/09/15/Union-Find(%E5%B9%B6%E6%9F%A5%E9%9B%86)/"/>
    <id>http://jiahaohong1997.github.io/2021/09/15/Union-Find(%E5%B9%B6%E6%9F%A5%E9%9B%86)/</id>
    <published>2021-09-15T08:02:00.000Z</published>
    <updated>2021-09-15T17:21:06.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并查集介绍"><a href="#并查集介绍" class="headerlink" title="并查集介绍"></a>并查集介绍</h2><h3 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h3><p>&emsp;&emsp;对于无向图，对其进行遍历时：</p><ul><li>若是连通图，仅需从图中任一顶点出发，就能访问图中的所有顶点。</li><li>若是非连通图，需从图中多个顶点出发。每次从一个新顶点出发所访问的顶点集序列恰好是各个连通分量的顶点集。</li></ul><p>&emsp;&emsp;比如下面这幅图，总共有 10 个节点，他们互不相连，分别用 0~9 标记：</p><p><img lazyload src="/images/loading.svg" data-src="1.jpg" alt="avatar"></p><p>&emsp;&emsp;「连通」是一种等价关系，也就是说具有如下三个性质：</p><ol><li>自反性：节点 <code>p</code> 和 <code>p</code> 是连通的。</li><li>对称性：如果节点 <code>p</code> 和 <code>q</code> 连通，那么 <code>q</code> 和 <code>p</code> 也连通。</li><li>传递性：如果节点 <code>p</code> 和 <code>q</code> 连通，<code>q</code> 和 <code>r</code> 连通，那么 <code>p</code> 和 <code>r</code> 也连通。</li></ol><h3 id="函数签名-基本模型"><a href="#函数签名-基本模型" class="headerlink" title="函数签名(基本模型)"></a>函数签名(基本模型)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">union</span><span class="params">(p,q <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 将p，q节点连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connected</span><span class="params">(p,q <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="comment">// 判断p，q节点是否连通</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countUF</span><span class="params">(graph *Vertax)</span> <span class="title">int</span></span> &#123; <span class="comment">// 返回途中有多少个连通分量 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>比如说之前那幅图，0～9 任意两个<strong>不同</strong>的点都不连通，调用 <code>connected</code> 都会返回 false，连通分量为 10 个。</li><li>如果现在调用 <code>union(0, 1)</code>，那么 0 和 1 被连通，连通分量降为 9 个。</li><li>再调用 <code>union(1, 2)</code>，这时 0,1,2 都被连通，调用 <code>connected(0, 2)</code> 也会返回 true，连通分量变为 8 个。</li></ul><p><img lazyload src="/images/loading.svg" data-src="2.jpg" alt="avatar"></p><p>&emsp;&emsp;判断这种「等价关系」非常实用，比如说编译器判断同一个变量的不同引用，比如社交网络中的朋友圈计算等等。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>&emsp;&emsp;我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。比如说刚才那幅 10 个节点的图，一开始的时候没有相互连通，就是这样：</p><p><img lazyload src="/images/loading.svg" data-src="3.jpg" alt="avatar"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UF <span class="keyword">struct</span> &#123;</span><br><span class="line">  count<span class="keyword">int</span><span class="comment">// 记录连通分量</span></span><br><span class="line">  parent[]<span class="keyword">int</span><span class="comment">// 节点x的父节点是parent[x]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">construct</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">UF</span></span> &#123;</span><br><span class="line">  p := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">    p[i] = i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> UF&#123;</span><br><span class="line">      count : n<span class="comment">// 一开始互不连通</span></span><br><span class="line">      parent : p<span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上</strong>：</p><p><img lazyload src="/images/loading.svg" data-src="4.jpg" alt="avatar"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">union</span><span class="params">(p,q <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  rootP := u.find(p)</span><br><span class="line">  rootQ := u.find(q)</span><br><span class="line">  <span class="keyword">if</span> rootP == rootQ &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将两棵树合为一棵树</span></span><br><span class="line">  u.parent[rootP] = rootQ</span><br><span class="line">  <span class="comment">// u.parent[rootQ] = rootP也一样</span></span><br><span class="line">  u.count--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">find</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根节点的u.parent[x]=x</span></span><br><span class="line">  <span class="keyword">for</span> u.parent[x] != x &#123;</span><br><span class="line">    x = u.parent[x]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样，如果节点</strong> <strong><code>p</code></strong> <strong>和</strong> <strong><code>q</code></strong> <strong>连通的话，它们一定拥有相同的根节点</strong>：</p><p><img lazyload src="/images/loading.svg" data-src="5.jpg" alt="avatar"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">connected</span><span class="params">(p,q <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  rootP := u.find(p)</span><br><span class="line">  rootQ := u.find(q)</span><br><span class="line">  <span class="keyword">return</span> rootP == rootQ</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;主要 API <code>connected</code> 和 <code>union</code> 中的复杂度都是 <code>find</code> 函数造成的，所以说它们的复杂度和 <code>find</code> 一样。<code>find</code> 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是 <code>logN</code>，但这并不一定。<code>logN</code> 的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度最坏情况下可能变成 <code>N</code>。所以说上面这种解法，<code>find</code> , <code>union</code> , <code>connected</code> 的时间复杂度都是 O(N)。这个复杂度很不理想的，你想图论解决的都是诸如社交网络这样数据规模巨大的问题，对于 <code>union</code> 和 <code>connected</code> 的调用非常频繁，每次调用需要线性时间完全不可忍受。<strong>问题的关键在于，如何想办法避免树的不平衡呢</strong>？</p><h2 id="平衡性优化"><a href="#平衡性优化" class="headerlink" title="平衡性优化"></a>平衡性优化</h2><p>&emsp;&emsp;我们要知道哪种情况下可能出现不平衡现象，关键在于 <code>union</code> 过程：我们一开始就是简单粗暴的把 <code>p</code> 所在的树接到 <code>q</code> 所在的树的根节点下面，那么这里就可能出现「头重脚轻」的不平衡状况，比如下面这种局面：</p><p><img lazyload src="/images/loading.svg" data-src="7.jpg" alt="avatar"></p><p>&emsp;&emsp;长此以往，树可能生长得很不平衡。<strong>我们其实是希望，小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些</strong>。解决方法是额外使用一个 <code>size</code> 数组，记录每棵树包含的节点数，我们不妨称为「重量」：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UF <span class="keyword">struct</span> &#123;</span><br><span class="line">  count<span class="keyword">int</span><span class="comment">// 记录连通分量</span></span><br><span class="line">  parent[]<span class="keyword">int</span><span class="comment">// 节点x的父节点是parent[x]</span></span><br><span class="line">  size[]<span class="keyword">int</span><span class="comment">// 新增一个数组用于记录树的“重量”,这个数组只对根节点有意义，在使用前需要先判别是否是根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">construct</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">UF</span></span> &#123;</span><br><span class="line">  p := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  s := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">    p[i] = i<span class="comment">// 最初每棵树只有一个节点</span></span><br><span class="line">      s[i] = <span class="number">1</span><span class="comment">// 重量应该初始化为1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> UF&#123;</span><br><span class="line">      count : n<span class="comment">// 一开始互不连通</span></span><br><span class="line">      parent : p<span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">      size : s<span class="comment">// 每个节点的重量应该初始化为1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;比如说 <code>size[3] = 5</code> 表示，以节点 <code>3</code> 为根的那棵树，总共有 <code>5</code> 个节点。这样我们可以修改一下 <code>union</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">union</span><span class="params">(p,q <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  rootP := u.find(p)</span><br><span class="line">  rootQ := u.find(q)</span><br><span class="line">  <span class="keyword">if</span> rootP == rootQ &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 小树接到大树下面，较平衡</span></span><br><span class="line">  <span class="keyword">if</span> u.size[rootP] &gt; u.size[rootQ] &#123;</span><br><span class="line">    u.parent[rootQ] = rootP</span><br><span class="line">    u.size[rootP] += u.size[rootQ]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    u.parent[rootP] = rootQ</span><br><span class="line">    u.size[rootQ] += u.size[rootP]</span><br><span class="line">  &#125;</span><br><span class="line">  u.count--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在 <code>logN</code> 这个数量级，极大提升执行效率。此时，<code>find</code> , <code>union</code> , <code>connected</code> 的时间复杂度都下降为 O(logN)，即便数据规模上亿，所需时间也非常少。</p><h2 id="路经压缩"><a href="#路经压缩" class="headerlink" title="路经压缩"></a>路经压缩</h2><p>&emsp;&emsp;这步优化特别简单，所以非常巧妙。我们能不能进一步压缩每棵树的高度，使树高始终保持为常数？</p><p><img lazyload src="/images/loading.svg" data-src="8.jpg" alt="avatar"></p><p>&emsp;&emsp;这样 <code>find</code> 就能以 O(1) 的时间找到某一节点的根节点，相应的，<code>connected</code> 和 <code>union</code> 复杂度都下降为 O(1)。要做到这一点，非常简单，只需要在 <code>find</code> 中加一行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">find</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> u.parent[x] != x &#123;</span><br><span class="line">    u.parent[x] = u.parent[u.parent[x]]<span class="comment">// 指向爷爷节点 </span></span><br><span class="line">    x = u.parent[x]<span class="comment">// 定位到爷爷节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个操作有点匪夷所思，看个 GIF 就明白它的作用了（为清晰起见，这棵树比较极端）：</p><p><img lazyload src="/images/loading.svg" data-src="9.gif" alt="avatar"></p><p>&emsp;&emsp;可见，调用 <code>find</code> 函数每次向树根遍历的同时，顺手将树高缩短了，最终所有树高都不会超过 3（<code>union</code> 的时候树高可能达到 3）。PS：读者可能会问，这个 GIF 图的find过程完成之后，树高恰好等于 3 了，但是如果更高的树，压缩后高度依然会大于 3 呀？不能这么想。这个 GIF 的情景是我编出来方便大家理解路径压缩的，但是实际中，每次find都会进行路径压缩，所以树本来就不可能增长到这么高，你的这种担心应该是多余的。</p><h2 id="算法模板总结"><a href="#算法模板总结" class="headerlink" title="算法模板总结"></a>算法模板总结</h2><p>&emsp;&emsp;先看一下完整代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UF <span class="keyword">struct</span> &#123;</span><br><span class="line">  count<span class="keyword">int</span></span><br><span class="line">  parent[]<span class="keyword">int</span></span><br><span class="line">  size[]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">construct</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">UF</span></span> &#123; <span class="comment">// 初始化UF</span></span><br><span class="line">  p := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  s := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">    p[i] = i</span><br><span class="line">    size[i] = <span class="number">1</span></span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> UF&#123;</span><br><span class="line">      count : n,</span><br><span class="line">      parent : p,</span><br><span class="line">      size : s</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">find</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;<span class="comment">// 查找两节点是否连通</span></span><br><span class="line">  <span class="keyword">for</span> u.parent[x] != x &#123;</span><br><span class="line">    u.parent[x] = u.parent[u.parent[x]]</span><br><span class="line">    x = u.parent[x]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">union</span><span class="params">(p,q <span class="keyword">int</span>)</span></span> &#123;<span class="comment">// 使p，q节点连通</span></span><br><span class="line">  rootP := u.find(p)</span><br><span class="line">  rootQ := u.find(q)</span><br><span class="line">  <span class="keyword">if</span> rootP == rootQ &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> u.size[rootP] &gt; u.size[rootQ] &#123;</span><br><span class="line">    u.paremt[rootQ] = rootP</span><br><span class="line">    u.size[rootP] += u.size[rootQ]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    u.parent[rootP] = rootQ</span><br><span class="line">    u.size[rootQ] += u.size[rootP]</span><br><span class="line">  &#125;</span><br><span class="line">  u.count--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">connected</span><span class="params">(p,q <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;<span class="comment">// 查看p，q节点是否连通</span></span><br><span class="line">  rootP := u.find(p)</span><br><span class="line">  rootQ := u.find(q)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> rootP == rootQ</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">countUF</span><span class="params">()</span> <span class="title">int</span></span> &#123;<span class="comment">// 查看连通分量</span></span><br><span class="line">  <span class="keyword">return</span> u.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Union-Find 算法的复杂度可以这样分析：构造函数初始化数据结构需要 O(N) 的时间和空间复杂度；连通两个节点 <code>union</code>、判断两个节点的连通性 <code>connected</code>、计算连通分量 <code>count</code> 所需的时间复杂度均为 O(1)。</p><h2 id="并查集相关题目"><a href="#并查集相关题目" class="headerlink" title="并查集相关题目"></a>并查集相关题目</h2><h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a class="link" href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域<i class="fas fa-external-link-alt"></i></a></h3><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="10.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">输出：[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 &#39;O&#39; 都不会被填充为 &#39;X&#39;。 任何不在边界上，或不与边界上的 &#39;O&#39; 相连的 &#39;O&#39; 最终都会被填充为 &#39;X&#39;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;X&quot;]]</span><br><span class="line">输出：[[&quot;X&quot;]]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>m == board.length</li><li>n == board[i].length</li><li>1 &lt;= m, n &lt;= 200</li><li>board[i] [j]为 ‘X’ 或 ‘O’</li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;必须是四面被围的 <code>O</code> 才能被换成 <code>X</code>，也就是说边角上的 <code>O</code> 一定不会被围，进一步，与边角上的 <code>O</code> 相连的 <code>O</code> 也不会被 <code>X</code> 围四面，也不会被替换。解决这个问题的传统方法也不困难，先用 for 循环遍历棋盘的<strong>四边</strong>，用 DFS 算法把那些与边界相连的 <code>O</code> 换成一个特殊字符，比如 <code>#</code>；然后再遍历整个棋盘，把剩下的 <code>O</code> 换成 <code>X</code>，把 <code>#</code> 恢复成 <code>O</code>。这样就能完成题目的要求，时间复杂度 O(MN)。这个问题也可以用 Union-Find 算法解决。</p><p>&emsp;&emsp;<strong>你可以把那些不需要被替换的</strong> <strong><code>O</code></strong> <strong>看成一个拥有独门绝技的门派，它们有一个共同祖师爷叫</strong> **<code>dummy</code>**<strong>，这些</strong> <strong><code>O</code></strong> <strong>和</strong> <strong><code>dummy</code></strong> <strong>互相连通，而那些需要被替换的</strong> <strong><code>O</code></strong> <strong>与</strong> <strong><code>dummy</code></strong> <strong>不连通</strong>。</p><p><img lazyload src="/images/loading.svg" data-src="11.jpg" alt="avatar"></p><p>&emsp;&emsp;这就是 Union-Find 的核心思路，明白这个图，就很容易看懂代码了。首先要解决的是，根据我们的实现，Union-Find 底层用的是一维数组，构造函数需要传入这个数组的大小，而题目给的是一个二维棋盘。</p><p>&emsp;&emsp;这个很简单，二维坐标 <code>(x,y)</code> 可以转换成 <code>x * n + y</code> 这个数（<code>m</code> 是棋盘的行数，<code>n</code> 是棋盘的列数）。敲黑板，<strong>这是将二维坐标映射到一维的常用技巧</strong>。</p><p>&emsp;&emsp;其次，我们之前描述的「祖师爷」是虚构的，需要给他老人家留个位置。索引 <code>[0.. m*n-1]</code> 都是棋盘内坐标的一维映射，那就让这个虚拟的 <code>dummy</code> 节点占据索引 <code>m * n</code> 好了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UF <span class="keyword">struct</span> &#123;</span><br><span class="line">    count   <span class="keyword">int</span></span><br><span class="line">    parent  []<span class="keyword">int</span></span><br><span class="line">    size    []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">construct</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">UF</span></span> &#123; <span class="comment">// 初始化UF结构体</span></span><br><span class="line">    p := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        p[i] = i</span><br><span class="line">        s[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UF&#123;</span><br><span class="line">        count:n,</span><br><span class="line">        parent:p,</span><br><span class="line">        size:s,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">find</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">// 查找根节点的方法</span></span><br><span class="line">    <span class="keyword">for</span> u.parent[x] != x &#123;</span><br><span class="line">        u.parent[x] = u.parent[u.parent[x]]</span><br><span class="line">        x = u.parent[x]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">union</span><span class="params">(p,q <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 连通两节点的方法</span></span><br><span class="line">    rootP := u.find(p)</span><br><span class="line">    rootQ := u.find(q)</span><br><span class="line">    <span class="keyword">if</span> rootP == rootQ &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> u.size[rootP] &gt; u.size[rootQ] &#123;</span><br><span class="line">        u.parent[rootQ] = rootP</span><br><span class="line">        u.size[rootP] += u.size[rootQ]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        u.parent[rootP] = rootQ</span><br><span class="line">        u.size[rootQ] += u.size[rootP]</span><br><span class="line">    &#125;</span><br><span class="line">    u.count--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">connected</span><span class="params">(p,q <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;  <span class="comment">// 查看是否连通的方法</span></span><br><span class="line">    rootP := u.find(p)</span><br><span class="line">    rootQ := u.find(q)</span><br><span class="line">    <span class="keyword">return</span> rootP == rootQ</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solve</span><span class="params">(board [][]<span class="keyword">byte</span>)</span></span>  &#123; <span class="comment">// 函数主题</span></span><br><span class="line">    m := <span class="built_in">len</span>(board)</span><br><span class="line">    n := <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">    u := construct(m*n+<span class="number">1</span>)  <span class="comment">// 初始化并查集，多将一位数加入并查集，作为dummy节点（边缘&#x27;O&#x27;的根节点）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;m; i++ &#123; <span class="comment">// 将第一列和最后一列的&#x27;O&#x27;元素与位于m*n处的dummy连通</span></span><br><span class="line">        <span class="keyword">if</span> board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">            u.union(i*n, m*n)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> board[i][n<span class="number">-1</span>] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">            u.union(i*n+(n<span class="number">-1</span>), m*n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;n<span class="number">-1</span>; j++ &#123; <span class="comment">// 将第一行和最后一行的&#x27;O&#x27;元素与位于m*n处的dummy连通</span></span><br><span class="line">        <span class="keyword">if</span> board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">            u.union(j, m*n)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> board[m<span class="number">-1</span>][j] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">            u.union((m<span class="number">-1</span>)*n+j, m*n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d := [][]<span class="keyword">int</span>&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125; <span class="comment">// 方向数组 d 是上下左右搜索的常用手法</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;m<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;n<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">              <span class="comment">// 将此 O 与上下左右的 O 连通</span></span><br><span class="line">                <span class="keyword">for</span> k:=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++ &#123;</span><br><span class="line">                    x := i+d[k][<span class="number">0</span>]</span><br><span class="line">                    y := j+d[k][<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> board[x][y] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">                        u.union(i*n+j, x*n+y)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有不和 dummy 连通的 O，都要被替换</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;m<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;n<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (!u.connected(i*n+j, m*n)) &#123;</span><br><span class="line">                board[i][j] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;并查集介绍&quot;&gt;&lt;a href=&quot;#并查集介绍&quot; class=&quot;headerlink&quot; title=&quot;并查集介绍&quot;&gt;&lt;/a&gt;并查集介绍&lt;/h2&gt;&lt;h3 id=&quot;连通性&quot;&gt;&lt;a href=&quot;#连通性&quot; class=&quot;headerlink&quot; title=&quot;连通性&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="并查集" scheme="http://jiahaohong1997.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>图算法</title>
    <link href="http://jiahaohong1997.github.io/2021/09/14/%E5%9B%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://jiahaohong1997.github.io/2021/09/14/%E5%9B%BE%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-14T07:08:00.000Z</published>
    <updated>2021-09-14T09:02:23.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图论基础"><a href="#图论基础" class="headerlink" title="图论基础"></a>图论基础</h1><h2 id="图的逻辑结构和具体实现"><a href="#图的逻辑结构和具体实现" class="headerlink" title="图的逻辑结构和具体实现"></a>图的逻辑结构和具体实现</h2><ol><li>图的逻辑结构</li></ol><p><img lazyload src="/images/loading.svg" data-src="1.jpg" alt="avatar"></p><p>&emsp;&emsp;为了方便研究图，我们将图可以抽象为下面的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">  id<span class="keyword">int</span></span><br><span class="line">  neighbors[]*Vertex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可见，这个结构和多叉树节点是一样的。所以可以认为图是比较特殊的多叉树。不过呢，上面的这种实现是「逻辑上的」，实际上我们很少用这个 <code>Vertex</code> 类实现图，而是用常说的<strong>邻接表和邻接矩阵</strong>来实现。</p><ol start="2"><li>具体实现方式</li></ol><p><img lazyload src="/images/loading.svg" data-src="2.jpg" alt="avatar"></p><ul><li>邻接表：邻接表很直观，我把每个节点 <code>x</code> 的邻居都存到一个列表里，然后把 <code>x</code> 和这个列表关联起来，这样就可以通过一个节点 <code>x</code> 找到它的所有相邻节点。</li><li>邻接矩阵：邻接矩阵是一个二维布尔数组，将其称为<code>matrix</code>，如果节点 <code>x</code> 和 <code>y</code> 是相连的，那么就把 <code>matrix[x][y]</code> 设为 <code>true</code>（上图中绿色的方格代表 <code>true</code>）。如果想找节点 <code>x</code>的邻居，去扫一圈 <code>matrix[x][..]</code> 就行了。</li></ul><ol start="3"><li>邻接表和邻接矩阵的优劣</li></ol><ul><li>邻接表<ul><li>好处是占用的空间少。</li><li>坏处是邻接表无法快速判断两个节点是否相邻。</li></ul></li><li>邻接矩阵<ul><li>好处是可以快速判断两个节点是否相邻。</li><li>坏处是占用空间大。</li></ul></li></ul><h2 id="更复杂的图"><a href="#更复杂的图" class="headerlink" title="更复杂的图"></a>更复杂的图</h2><ul><li>有向加权图<ul><li>如果使用邻接表，我们不仅仅存储某个节点 <code>x</code> 的所有邻居节点，还存储 <code>x</code> 到每个邻居的权重。</li><li>如果使用邻接矩阵，<code>matrix[x][y]</code> 不再是布尔值，而是一个 int 值，0 表示没有连接，其他值表示权重。</li></ul></li><li>无向图<ul><li>所谓的「无向」，也等同于「双向」。</li><li>如果连接无向图中的节点 <code>x</code> 和 <code>y</code>，把 <code>matrix[x][y]</code> 和 <code>matrix[y][x]</code> 都变成 <code>true</code>。</li><li>如果使用邻接表，则<code>list[x]</code>和<code>list[y]</code>中各自填入<code>y</code> 和<code>x</code>。</li></ul></li></ul><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>&emsp;&emsp;图和多叉树最大的区别是，图是可能包含环的，你从图的某一个节点开始遍历，有可能走了一圈又回到这个节点。所以，如果图包含环，遍历框架就要一个 <code>visited</code> 数组进行辅助：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graph *Vertex</span><br><span class="line">visited <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(graph *Vertex, s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> visited[s] == <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="comment">// 经过节点s</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  visited[s] = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span> _,v := <span class="keyword">range</span> s.neighbor &#123;</span><br><span class="line">    traverse(graph, s)</span><br><span class="line">  &#125;</span><br><span class="line">  visited[s] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个 <code>visited</code> 数组的操作很像回溯算法做「做选择」和「撤销选择」，区别在于位置，回溯算法的「做选择」和「撤销选择」在 for 循环里面，而对 <code>visited</code> 数组的操作在 for 循环外面。在 for 循环里面和外面唯一的区别就是对根节点的处理。对于这里「图」的遍历，我们应该把 <code>visited</code> 的操作放到 for 循环外面，否则会漏掉起始点的遍历。</p><h2 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797. 所有可能的路径"></a><a class="link" href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径<i class="fas fa-external-link-alt"></i></a></h2><p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p><p>二维数组的第 <code>i</code> 个数组中的单元都表示有向图中 <code>i</code> 号节点所能到达的下一些节点，空就是没有下一个结点了。</p><p><strong>示例 1</strong></p><p><img lazyload src="/images/loading.svg" data-src="3.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：graph &#x3D; [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img lazyload src="/images/loading.svg" data-src="1.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph &#x3D; [[4,3,1],[3,2,4],[3],[4],[]]</span><br><span class="line">输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph &#x3D; [[1],[]]</span><br><span class="line">输出：[[0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph &#x3D; [[1,2,3],[2],[3],[]]</span><br><span class="line">输出：[[0,1,2,3],[0,2,3],[0,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph &#x3D; [[1,3],[2],[3],[]]</span><br><span class="line">输出：[[0,1,2,3],[0,3]]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">n &#x3D;&#x3D; graph.length</span><br><span class="line">2 &lt;&#x3D; n &lt;&#x3D; 15</span><br><span class="line">0 &lt;&#x3D; graph[i][j] &lt; n</span><br><span class="line">graph[i][j] !&#x3D; i（即，不存在自环）</span><br><span class="line">graph[i] 中的所有元素 互不相同</span><br><span class="line">保证输入为 有向无环图（DAG）</span><br></pre></td></tr></table></figure><p><strong>解题思路：</strong></p><p>&emsp;&emsp;从0为起点开始遍历图，将遍历到的每个节点加入到辅助数组<code>path</code>中，当遍历到节点值为n-1时停止遍历，将<code>path</code>保存的路径拷贝到输出结构<code>res</code>中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allPathsSourceTarget</span><span class="params">(graph [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([][]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    travel(path, graph, &amp;res, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(path []<span class="keyword">int</span>, graph [][]<span class="keyword">int</span>, res *[][]<span class="keyword">int</span>, start <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    path = <span class="built_in">append</span>(path,start)</span><br><span class="line">    n := <span class="built_in">len</span>(graph)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> start == n &#123;</span><br><span class="line">        dst := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>(path))</span><br><span class="line">        <span class="built_in">copy</span>(dst,path) <span class="comment">// 由于在回溯的时候path会动态变化，所以要重新拷贝后传入res</span></span><br><span class="line">        *res = <span class="built_in">append</span>(*res,dst)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> graph[start] &#123;</span><br><span class="line">        travel(path, graph, res, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有向图的环检测"><a href="#有向图的环检测" class="headerlink" title="有向图的环检测"></a>有向图的环检测</h1><h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a class="link" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表<i class="fas fa-external-link-alt"></i></a></h2><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code>。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 必须 先学习课程  <code>bi</code> 。</p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; numCourses &lt;&#x3D; 105</span><br><span class="line">0 &lt;&#x3D; prerequisites.length &lt;&#x3D; 5000</span><br><span class="line">prerequisites[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; ai, bi &lt; numCourses</span><br><span class="line">prerequisites[i] 中的所有课程对 互不相同</span><br></pre></td></tr></table></figure><p><strong>解题思路：</strong></p><p>&emsp;&emsp;什么时候无法修完所有课程？当存在循环依赖的时候。其实这种场景在现实生活中也十分常见，比如我们写代码 import 包也是一个例子，必须合理设计代码目录结构，否则会出现循环依赖，编译器会报错，所以编译器实际上也使用了类似算法来判断你的代码是否能够成功编译。</p><p>&emsp;&emsp;<strong>看到依赖问题，首先想到的就是把问题转化成「有向图」这种数据结构，只要图中存在环，那就说明存在循环依赖</strong>。具体来说，我们首先可以把课程看成「有向图」中的节点，节点编号分别是 <code>0, 1, ..., numCourses-1</code>，把课程之间的依赖关系看做节点之间的有向边。</p><p>&emsp;&emsp;比如说必须修完课程 <code>1</code> 才能去修课程 <code>3</code>，那么就有一条有向边从节点 <code>1</code> 指向 <code>3</code>。所以我们可以根据题目输入的 <code>prerequisites</code> 数组生成一幅类似这样的图：</p><p><img lazyload src="/images/loading.svg" data-src="4.jpg" alt="avatar"></p><p>&emsp;&emsp;<strong>如果发现这幅有向图中存在环，那就说明课程之间存在循环依赖，肯定没办法全部上完；反之，如果没有环，那么肯定能上完全部课程</strong>。所以第一步，我们要讲本题的这种依赖关系转换成图。</p><ul><li>先写一个建图函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildGraph</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    graph := <span class="built_in">make</span>([][]<span class="keyword">int</span>,numCourses)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        from := v[<span class="number">1</span>]</span><br><span class="line">        to := v[<span class="number">0</span>]</span><br><span class="line">        graph[from] = <span class="built_in">append</span>(graph[from], to)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以把 <code>traverse</code> 看做在图中节点上游走的指针，只需要再添加一个布尔数组 <code>onPath</code> 记录当前 <code>traverse</code> 经过的路径。完整代码如下：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    graph := buildGraph(numCourses, prerequisites)</span><br><span class="line">    onPath := <span class="built_in">make</span>([]<span class="keyword">bool</span>,numCourses)</span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="keyword">bool</span>,numCourses)</span><br><span class="line">    isCycle := <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    traverse = <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> onPath[s] == <span class="literal">true</span> &#123; <span class="comment">// 发现环</span></span><br><span class="line">            isCycle = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> visited[s] || onPath[s] &#123; <span class="comment">// 若是遍历过的节点或是存在于环内的节点，直接回溯</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历代码</span></span><br><span class="line">        visited[s] = <span class="literal">true</span></span><br><span class="line">        onPath[s] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _,v := <span class="keyword">range</span> graph[s] &#123;</span><br><span class="line">            traverse(v)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历代码</span></span><br><span class="line">        onPath[s] = <span class="literal">false</span> <span class="comment">// 在回溯的过程中将遍历过的节点标记为无环状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123;  <span class="comment">// 遍历图中所有节点</span></span><br><span class="line">        traverse(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !isCycle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildGraph</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    graph := <span class="built_in">make</span>([][]<span class="keyword">int</span>,numCourses)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        from := v[<span class="number">1</span>]</span><br><span class="line">        to := v[<span class="number">0</span>]</span><br><span class="line">        graph[from] = <span class="built_in">append</span>(graph[from], to)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拓扑排序（无环图的后续遍历的反转）"><a href="#拓扑排序（无环图的后续遍历的反转）" class="headerlink" title="拓扑排序（无环图的后续遍历的反转）"></a>拓扑排序（<font color="red">无环图的后续遍历的反转</font>）</h1><h3 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a class="link" href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II<i class="fas fa-external-link-alt"></i></a></h3><p>现在你总共有 <em>n</em> 门课需要选，记为 <code>0</code> 到 <code>n-1</code>。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: <code>[0,1]</code></p><p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p><p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: [0,1]</span><br><span class="line">解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3]。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>输入的先决条件是由<strong>边缘列表</strong>表示的图形，而不是邻接矩阵。详情请参见<a class="link" href="http://blog.csdn.net/woaidapaopao/article/details/51732947">图的表示法<i class="fas fa-external-link-alt"></i></a>。</li><li>你可以假定输入的先决条件中没有重复的边。</li></ol><p>提示:</p><ul><li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li><li>拓扑排序也可以通过 BFS 完成。</li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;这道题就是上道题的进阶版，不是仅仅让你判断是否可以完成所有课程，而是进一步让你返回一个合理的上课顺序，保证开始修每个课程时，前置的课程都已经修完。<strong>如果把课程抽象成节点，课程之间的依赖关系抽象成有向边，那么这幅图的拓扑排序结果就是上课顺序</strong>。首先，我们先判断一下题目输入的课程依赖是否成环，成环的话是无法进行拓扑排序的，所以我们可以复用上一道题的主函数。<strong>将后序遍历的结果进行反转，就是拓扑排序的结果</strong>。<strong>为什么后序遍历的反转结果就是拓扑排序呢</strong>？<strong>后序遍历的这一特点很重要，之所以拓扑排序的基础是后序遍历，是因为一个任务必须在等到所有的依赖任务都完成之后才能开始开始执行</strong>。你把每个任务理解成二叉树里面的节点，这个任务所依赖的任务理解成子节点，那你是不是应该先把所有子节点处理完再处理父节点？这是不是就是后序遍历？所以只需要在遍历节点的时候使用一个<code>postorder</code>数组存储后续遍历结果即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOrder</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    postorder := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> canFinish(numCourses, prerequisites, &amp;postorder) == <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125; <span class="comment">// 先判断是否有环，有环的话直接输出空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>,numCourses)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123; <span class="comment">// 无环的话将后续遍历的结果反转即可</span></span><br><span class="line">        res[i] = postorder[numCourses-i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>, postorder *[]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    graph := buildGraph(numCourses, prerequisites)</span><br><span class="line">    onPath := <span class="built_in">make</span>([]<span class="keyword">bool</span>,numCourses)</span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="keyword">bool</span>,numCourses)</span><br><span class="line">    isCycle := <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    traverse = <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> onPath[s] == <span class="literal">true</span> &#123; <span class="comment">// 发现环</span></span><br><span class="line">            isCycle = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> visited[s] || onPath[s] &#123; <span class="comment">// 若是遍历过的节点或是存在于环内的节点，直接回溯</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历代码</span></span><br><span class="line">        visited[s] = <span class="literal">true</span></span><br><span class="line">        onPath[s] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _,v := <span class="keyword">range</span> graph[s] &#123;</span><br><span class="line">            traverse(v)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历代码</span></span><br><span class="line">        onPath[s] = <span class="literal">false</span> <span class="comment">// 在回溯的过程中将遍历过的节点标记为无环状态</span></span><br><span class="line">        *postorder = <span class="built_in">append</span>(*postorder,s) <span class="comment">// 存储后续遍历的结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123;  <span class="comment">// 遍历图中所有节点</span></span><br><span class="line">        traverse(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !isCycle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildGraph</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123; <span class="comment">// 生成图结构</span></span><br><span class="line">    graph := <span class="built_in">make</span>([][]<span class="keyword">int</span>,numCourses)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        from := v[<span class="number">1</span>]</span><br><span class="line">        to := v[<span class="number">0</span>]</span><br><span class="line">        graph[from] = <span class="built_in">append</span>(graph[from], to)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图论基础&quot;&gt;&lt;a href=&quot;#图论基础&quot; class=&quot;headerlink&quot; title=&quot;图论基础&quot;&gt;&lt;/a&gt;图论基础&lt;/h1&gt;&lt;h2 id=&quot;图的逻辑结构和具体实现&quot;&gt;&lt;a href=&quot;#图的逻辑结构和具体实现&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="图" scheme="http://jiahaohong1997.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据库三大范式</title>
    <link href="http://jiahaohong1997.github.io/2021/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/"/>
    <id>http://jiahaohong1997.github.io/2021/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/</id>
    <published>2021-09-13T12:03:00.000Z</published>
    <updated>2021-09-13T12:25:19.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><h2 id="为什么需要数据库规范化？"><a href="#为什么需要数据库规范化？" class="headerlink" title="为什么需要数据库规范化？"></a>为什么需要数据库规范化？</h2><ul><li>信息重复</li><li>更新异常</li><li>插入异常<ul><li>无法正常显示信息</li></ul></li><li>删除异常<ul><li>丢失有效信息</li></ul></li></ul><h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h3><p>&emsp;&emsp;第一范式是最基本的范式。如果数据库表中的<font color="red">所有字段值都是不可分解的原子值</font>，就说明该数据库表满足了第一范式。</p><p>&emsp;&emsp;第一范式的合理遵循需要根据系统的<strong>实际需求</strong>来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。</p><p><img lazyload src="/images/loading.svg" data-src="1.png" alt="avatar"></p><p>&emsp;&emsp;上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p><h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h3><p>&emsp;&emsp;前提：满足第一范式</p><p>&emsp;&emsp;第二范式在第一范式的基础之上更进一层。第二范式需要<strong>确保表中的每列都和主键相关</strong>，而不能只与主键的某一部分相关（主要针对联合主键而言）。<font color="red">也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</font>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。</p><p> <strong>订单信息表</strong></p><p><img lazyload src="/images/loading.svg" data-src="2.png" alt="avatar"></p><p>&emsp;&emsp;这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。</p><p><img lazyload src="/images/loading.svg" data-src="3.png" alt="avatar"></p><p>&emsp;&emsp;这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。</p><h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h3><p>&emsp;&emsp;前提：满足第一和第二范式</p><p>&emsp;&emsp;第三范式需要确保数据表中的<font color="red">每一列数据都和主键直接相关，而不能间接相关</font>。</p><p>&emsp;&ensp;比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。</p><p><img lazyload src="/images/loading.svg" data-src="4.png" alt="avatar"></p><p>&emsp;&emsp;这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。</p><h2 id="规范性和性能的问题"><a href="#规范性和性能的问题" class="headerlink" title="规范性和性能的问题"></a>规范性和性能的问题</h2><p>关联查询的表不得超过三张表（阿里的规则）</p><ul><li>考虑商业化的需求和目标（成本，用户体验），数据库的性能更加重要</li><li>在规范性能的问题的时候，适当的考虑规范性</li><li>有时候会故意给某些表增加一下冗余的字段（从多表查询变为单表查询）</li><li>有时候会故意增加一些计算列（从大数据量降低为小数据量的查询：索引）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库三大范式&quot;&gt;&lt;a href=&quot;#数据库三大范式&quot; class=&quot;headerlink&quot; title=&quot;数据库三大范式&quot;&gt;&lt;/a&gt;数据库三大范式&lt;/h1&gt;&lt;h2 id=&quot;为什么需要数据库规范化？&quot;&gt;&lt;a href=&quot;#为什么需要数据库规范化？&quot; class=&quot;</summary>
      
    
    
    
    <category term="中间件" scheme="http://jiahaohong1997.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="SQL数据库" scheme="http://jiahaohong1997.github.io/tags/SQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>循转数组相关题目</title>
    <link href="http://jiahaohong1997.github.io/2021/09/12/%E5%BE%AA%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
    <id>http://jiahaohong1997.github.io/2021/09/12/%E5%BE%AA%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</id>
    <published>2021-09-12T10:30:00.000Z</published>
    <updated>2021-09-13T10:46:22.445Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本文是对旋转数组类型的题目的总结，一共6道，基本都是二分法的套路。</p><h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a class="link" href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组<i class="fas fa-external-link-alt"></i></a></h2><p>给定一个数组，将数组中的元素向右移动 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p>进阶：</p><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2</span><br><span class="line">输出：[3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= k &lt;= 105</code></li></ul><p><strong>解题思路：</strong></p><p>方法一：使用额外的数组</p><p>&emsp;&emsp;可以使用额外的数组来将每个元素放至正确的位置。用 <code>n</code> 表示数组的长度，我们遍历原数组，将原数组下标为 <code>i</code> 的元素放至新数组下标为 <code>(i+k)%n</code> 的位置，最后将新数组拷贝至原数组即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    newNums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        newNums[(i+k)%<span class="built_in">len</span>(nums)] = v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(nums, newNums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：环状替换</p><p>&emsp;&emsp;从另一个角度，我们可以将被替换的元素保存在变量 <code>temp</code> 中，从而避免了额外数组的开销。我们从位置 0 开始，最初令 <code>temp=nums[0]</code>。根据规则，位置 0 的元素会放至 <code>(0+k)%n</code>的位置，令 <code>x=(0+k)%n</code>，此时交换 <code>temp </code>和 <code>nums[x]</code>，完成位置 x 的更新。然后，我们考察位置 x，并交换 <code>temp</code> 和 <code>nums[(x+k)%n]</code>，从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置 0。</p><p>&emsp;&emsp;容易发现，当回到初始位置 0 时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？我们不妨先考虑这样一个问题：从 0 开始不断遍历，最终回到起点 0 的过程中，我们遍历了多少个元素？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    k %= n</span><br><span class="line">    <span class="keyword">for</span> start, count := <span class="number">0</span>, gcd(k, n); start &lt; count; start++ &#123;</span><br><span class="line">        pre, cur := nums[start], start</span><br><span class="line">        <span class="keyword">for</span> ok := <span class="literal">true</span>; ok; ok = cur != start &#123;</span><br><span class="line">            next := (cur + k) % n</span><br><span class="line">            nums[next], pre, cur = pre, nums[next], next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">// 需要遍历的次数是n和k的最大公约数</span></span><br><span class="line">    <span class="keyword">for</span> a != <span class="number">0</span> &#123;</span><br><span class="line">        a, b = b%a, a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：数组翻转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums &#x3D; &quot;-----&gt;--&gt;&quot;; k &#x3D;3</span><br><span class="line">result &#x3D; &quot;--&gt;-----&gt;&quot;;</span><br><span class="line"></span><br><span class="line">reverse &quot;-----&gt;--&gt;&quot; we can get &quot;&lt;--&lt;-----&quot;</span><br><span class="line">reverse &quot;&lt;--&quot; we can get &quot;--&gt;&lt;-----&quot;</span><br><span class="line">reverse &quot;&lt;-----&quot; we can get &quot;--&gt;-----&gt;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    k %= <span class="built_in">len</span>(nums)</span><br><span class="line">    reverse(nums)</span><br><span class="line">    reverse(nums[:k])</span><br><span class="line">    reverse(nums[k:])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(a []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n/<span class="number">2</span>; i++ &#123;</span><br><span class="line">        a[i], a[n-i<span class="number">-1</span>] = a[n-i<span class="number">-1</span>], a[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在旋转数组里寻找最小值"><a href="#在旋转数组里寻找最小值" class="headerlink" title="在旋转数组里寻找最小值"></a>在旋转数组里寻找最小值</h1><p>&emsp;&emsp;可以看作寻找最小值左边界问题(直接解决又重复元素的情况)。</p><h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a class="link" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值<i class="fas fa-external-link-alt"></i></a></h2><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组<code> [a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组<code> [a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>n == nums.length</li><li>1 &lt;= n &lt;= 5000</li><li>-5000 &lt;= nums[i] &lt;= 5000</li><li>nums 中的所有整数 互不相同</li><li>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;本题可以看作是找数组中的最小数。如果更改一下题目条件，数组中的元素是可以重复的，那么可以看作找最小数的左边界即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] &gt; nums[mid] &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[right] &lt; nums[mid] &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 可能因为重复元素使得两者相等，缩小查找范围</span></span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a class="link" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II<i class="fas fa-external-link-alt"></i></a></h2><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,4]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,4,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,5]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>n == nums.length</li><li>1 &lt;= n &lt;= 5000</li><li>-5000 &lt;= nums[i] &lt;= 5000</li><li>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;同上题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] &gt; nums[mid] &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[right] &lt; nums[mid] &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在旋转数组里寻找指定的值"><a href="#在旋转数组里寻找指定的值" class="headerlink" title="在旋转数组里寻找指定的值"></a>在旋转数组里寻找指定的值</h1><p>&emsp;&emsp;上面两道题是在旋转数组里寻找最小值，下面两道题是在旋转数组里寻找指定的值，这两道题的区别也是存不存在重复值。</p><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a class="link" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组<i class="fas fa-external-link-alt"></i></a></h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k（0 &lt;= k &lt; nums.length）</code>上进行了 旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 3 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code>。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;= nums.length &lt;= 5000</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>nums 中的每个值都 独一无二</li><li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li><li>-10^4 &lt;= target &lt;= 10^4</li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;其实方法还是类似于上题，不过对于寻找特定的数，需要判断该数可能存在于什么区间内。</p><ul><li>如果 <code>[l, mid - 1]</code> 是有序数组，且 <code>target</code> 的大小满足 <code>[nums[l],nums[mid])</code>，则我们应该将搜索范围缩小至 <code>[l, mid - 1]</code>，否则在 <code>[mid + 1, r]</code> 中寻找。</li><li>如果 <code>[mid, r]</code> 是有序数组，且 <code>target</code> 的大小满足 <code>(nums[mid+1],nums[r]]</code>，则我们应该将搜索范围缩小至 <code>[mid + 1, r]</code>，否则在<code>[l, mid - 1]</code> 中寻找。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[right] &gt;= nums[mid] &#123; <span class="comment">// 右半部分是有序的</span></span><br><span class="line">          <span class="comment">// 此处若出现nums[right] = nums[mid]的情况，说明mid=right，因为数组不重复</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[right] &lt;= nums[mid] &#123; <span class="comment">// 左半部分是有序的</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target &#123;</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a class="link" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II<i class="fas fa-external-link-alt"></i></a></h2><p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p><p>在传递给函数之前，nums 在预先未知的某个下标 <code>k（0 &lt;= k &lt; nums.length</code>）上进行了 旋转 ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 5 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p><p>给你 旋转后 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;= nums.length &lt;= 5000</li><li>-104 &lt;= nums[i] &lt;= 104</li><li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li><li>-104 &lt;= target &lt;= 104</li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;大体上同上题思路是一致的，只需要在遇到<code>nums[mid]==nums[right]</code>时缩小查找范围即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] == nums[right] || nums[left] == nums[right] &#123;</span><br><span class="line">          <span class="comment">// 当收尾元素相等或中值与末尾元素相等时，缩小查找范围</span></span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; nums[right] &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; nums[right] &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target &#123;</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题-10-03-搜索旋转数组"><a href="#面试题-10-03-搜索旋转数组" class="headerlink" title="面试题 10.03. 搜索旋转数组"></a><a class="link" href="https://leetcode-cn.com/problems/search-rotate-array-lcci/">面试题 10.03. 搜索旋转数组<i class="fas fa-external-link-alt"></i></a></h2><p>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。</p><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: arr &#x3D; [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target &#x3D; 5</span><br><span class="line">输出: 8（元素5在该数组中的索引）</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target &#x3D; 11</span><br><span class="line"> 输出：-1 （没有找到）</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ol><li>arr 长度范围在[1, 1000000]之间</li></ol><p><strong>解题思路：</strong></p><p>&emsp;&emsp;本题是上一题的一个小进阶，不仅要确认是否有<code>target</code>值，还要输出其左边界，在上一题的基础上套用二分法查找左边界的方法即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(arr []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(arr)<span class="number">-1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target &#123; <span class="comment">// 找到目标后用右边界锁定住</span></span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[left] == arr[right] || arr[mid] == arr[right] &#123; <span class="comment">// 排除重复数，缩小搜索范围</span></span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[right] &gt; arr[mid] &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[mid] &lt; target &amp;&amp; arr[right] &gt;= target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[right] &lt; arr[mid] &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[left] &lt;= target &amp;&amp; arr[mid] &gt; target &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> arr[left] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;本文是对旋转数组类型的题目的总结，一共6道，基本都是二分法的套路。&lt;/p&gt;
&lt;h2 id=&quot;189-旋转数组&quot;&gt;&lt;a href=&quot;#189-旋转数组&quot; class=&quot;headerlink&quot; title=&quot;189. 旋转数组&quot;&gt;&lt;/a&gt;&lt;a class</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数组" scheme="http://jiahaohong1997.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>前缀树(Trie)</title>
    <link href="http://jiahaohong1997.github.io/2021/09/02/%E5%89%8D%E7%BC%80%E6%A0%91(Trie)/"/>
    <id>http://jiahaohong1997.github.io/2021/09/02/%E5%89%8D%E7%BC%80%E6%A0%91(Trie)/</id>
    <published>2021-09-02T07:46:00.000Z</published>
    <updated>2021-09-14T06:12:44.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a class="link" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)<i class="fas fa-external-link-alt"></i></a></h2><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p><img lazyload src="/images/loading.svg" data-src="500px-Trie_example.svg.png" alt="avatar"></p><p>请你实现 Trie 类：</p><ul><li>Trie() 初始化前缀树对象。</li><li>void insert(String word) 向前缀树中插入字符串 word 。</li><li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li><li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</li></ul><p><strong>示例：</strong></p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 True</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;= word.length, prefix.length &lt;= 2000</li><li>word 和 prefix 仅由小写英文字母组成</li><li>insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次</li></ul><p><strong>解题思路：</strong>（来源于<a class="link" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/">实现 Trie (前缀树)<i class="fas fa-external-link-alt"></i></a>）</p><p>Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：</p><ul><li>指向子节点的指针数组 <code>child</code>。对于本题而言，数组长度为 26，即小写英文字母的数量。此时 <code>child[0]</code> 对应小写字母 a，<code>child[1]</code> 对应小写字母 b，…，<code>child[25]</code> 对应小写字母 z。</li><li>布尔字段 <code>isEnd</code>，表示该节点是否为字符串的结尾。</li></ul><p><strong>插入字符串</strong></p><p>我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：</p><ul><li>子节点存在。沿着指针移动到子节点，继续处理下一个字符。</li><li>子节点不存在。创建一个新的子节点，记录在 <code>child</code> 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。</li><li>重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。</li></ul><p><strong>查找前缀</strong></p><p>我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：</p><ul><li>子节点存在。沿着指针移动到子节点，继续搜索下一个字符。</li><li>子节点不存在。说明字典树中不包含该前缀，返回空指针。</li><li>重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。</li></ul><p>若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的 <code>isEnd</code>为真，则说明字典树中存在该字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    child   [<span class="number">26</span>]*Trie</span><br><span class="line">    isEnd   <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">Trie</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Trie&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">Insert</span><span class="params">(word <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> this.child[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">            this.child[ch] = &amp;Trie&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this = this.child[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    this.isEnd = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">Search</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> this.child[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;  </span><br><span class="line">        this = this.child[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> this.isEnd == <span class="literal">false</span> &#123; <span class="comment">// 上述for循环结束只能表明存在该前缀，还要判断有没有结束符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">StartsWith</span><span class="params">(prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> prefix &#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> this.child[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        this = this.child[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Insert(word);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Search(word);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.StartsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;208-实现-Trie-前缀树&quot;&gt;&lt;a href=&quot;#208-实现-Trie-前缀树&quot; class=&quot;headerlink&quot; title=&quot;208. 实现 Trie (前缀树)&quot;&gt;&lt;/a&gt;&lt;a class=&quot;link&quot; href=&quot;https://leetcode</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="一些有趣的算法题" scheme="http://jiahaohong1997.github.io/tags/%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>递归算法解决二叉树问题</title>
    <link href="http://jiahaohong1997.github.io/2021/08/18/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/"/>
    <id>http://jiahaohong1997.github.io/2021/08/18/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/</id>
    <published>2021-08-18T10:00:00.000Z</published>
    <updated>2021-09-19T09:36:46.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归算法的原理"><a href="#递归算法的原理" class="headerlink" title="递归算法的原理"></a>递归算法的原理</h1><p>&emsp;&emsp;一个递归函数的调用类似于多个函数的嵌套调用，只不过调用函数和被调函数都是同一个函数。在解决递归问题时，最重要的是不要陷入递归的逻辑中去，视角要以一个节点为根基来考虑整个问题。递归调用时内部的执行过程如下:</p><ol><li>首先为递归调用建立一个<font color="blue">工作栈</font>，其结构包括值参、局部变量和返回地址；</li><li>每次执行递归调用前，把<font color="red">递归函数的值参、局部变量的当前值</font>以及<font color="red">调用后的返回地址</font>压栈；</li><li>每次递归调用结束后，将栈顶元素推出，使相应的<font color="red">值参</font>和<font color="red">局部变量</font>恢复为<font color="blue">调用前的值</font>，然后转向返回地址的位置继续执行。</li></ol><p>&emsp;&emsp;在明确了递归函数的执行过程后，只要把握好如下3个步骤即可：</p><ol><li>明确递归函数的作用；</li><li>明确终止条件和相应的解决办法；</li><li>找出函数的等价关系式，提取重复的逻辑缩小问题规模。</li></ol><h1 id="递归三步走"><a href="#递归三步走" class="headerlink" title="递归三步走"></a>递归三步走</h1><h2 id="1-明确函数功能"><a href="#1-明确函数功能" class="headerlink" title="1.明确函数功能"></a>1.明确函数功能</h2><p>&emsp;&emsp;首先要确定这个函数的具体功能是什么？它的参数有哪些？它的全局变量是什么？递归的时候要根据题目的要求设置函数功能，再根据函数功能来设置函数的参数。</p><p>&emsp;&emsp;<font color="red">方法参数：</font>这个方法的参数最好由当前阶段的状态决定。</p><p>&emsp;&emsp;<font color="red">返回数据：</font>返回数据是我们遇到递归出口之后，需要告诉前一步递归的信息数据。</p><p>注意：</p><ul><li>递归函数的<strong>返回值</strong>最好设置为<strong>单个元素</strong>，比如说<strong>一个节点</strong>或者<strong>一个数值</strong>，告诉前一步递归我们现在的结果数据即可；</li><li>如果返回值是<strong>数组</strong>的话，我们将无法从中提取到任何有效信息来进行操作；</li><li>如果结果需要<strong>数组</strong>的话，我们可以将数组作为公共变量返回值为void，我们在方法体里面操作数组即可。</li></ul><h2 id="2-寻找递归出口"><a href="#2-寻找递归出口" class="headerlink" title="2.寻找递归出口"></a>2.寻找递归出口</h2><p>&emsp;&emsp;在递归函数的一开始，我们应该思考什么时候该结束递归。因此，递归一定要有结束条件，不然会永远的递归下去。<font color="red">递归出口</font>一般为某深度或叶子结点，或非叶子结点（包括根节点）、所有节点等。决定递归出去后要执行的操作。由于我们的节点状态可能需要多个参数来表示，所以我们的递归出口可能并不唯一，可能需要为每一个转台参数安排一个递归出口，确保我们的递归能够确实有效地出去。</p><p><font color="blue">特别注意的：</font>每次提交数组的集合（即<code>list(dst())</code>）的时候，要创建一个新的数组<code>copy()</code>来存放结果数组<code>dst()</code>，不然后面操作的都是加入集合<code>list()</code>的那个数组<code>dst()</code>。</p><p>&emsp;&emsp;我们的递归出口并不一定都是在最开头的位置，我们一般在最开头设置递归出口是希望递归能以最快的速度出去；但是<strong>有时候我们在对当前节点进行一些相关处理操作之后我们就希望判断一下能不能递归出口</strong>，所以<strong>递归出口有可能是在代码中间的</strong>，大家需要灵活应用。在这一步，我们需要思考题目需要的解在哪里？是<strong>在某一具体的深度</strong>、还是在<strong>叶子结点</strong>、还是在<strong>非叶子结点</strong>（包括<strong>根节点</strong>）、还是在<strong>每个节点</strong>、还是<strong>在从跟结点到叶子结点的路径</strong>？</p><ul><li>在某一具体深度：<code>if depth &gt;= n</code></li><li>在每个节点：<code>if root != nil </code></li></ul><h2 id="3-找出递推关系"><a href="#3-找出递推关系" class="headerlink" title="3.找出递推关系"></a>3.找出递推关系</h2><p>&emsp;&emsp;类比于数学归纳法。算n的阶乘：</p><ul><li>初始条件：<code>f(1) = 1</code></li><li>递推关系式：<code>f(n) = f(n-1) * n</code></li></ul><p>递归关系：</p><ul><li>递：<code>f(n) = n * f(n-1)</code>，将<strong>f(n)→f(n-1)<strong>了。这样，</strong>问题就由n缩小为了n-1</strong>，并且为了原函数<code>f(n)</code>不变，我们需要让<code>f(n-1)</code>乘以<code>n</code>。就这样慢慢从<code>f(n)</code>,<code>f(n-1)</code><strong>“递”</strong>到<code>f(1)</code>。</li><li>归：这样就可以从<code>n=1</code>，一步一步<strong>“归”</strong>到<code>n=2,n=3,...</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span> &#123; <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> f(n<span class="number">-1</span>)*n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运用递归的二叉树算法题"><a href="#运用递归的二叉树算法题" class="headerlink" title="运用递归的二叉树算法题"></a>运用递归的二叉树算法题</h1><p>&emsp;&emsp;二叉树的递归框架无外乎二叉树的三种遍历方式：前序遍历、中序遍历、后序遍历。在想好递归出口后，就要考虑采用何种方式来遍历整个二叉树有助于我们解决问题。解决这类问题的核心难点是不要深入进递归细节中，不要把自己的大脑当计算机来用！只要着眼于根节点，在设置好递归出口的前提下就能顺利地解题。</p><h2 id="1-直接递归遍历整个二叉树后返回根节点"><a href="#1-直接递归遍历整个二叉树后返回根节点" class="headerlink" title="1.直接递归遍历整个二叉树后返回根节点"></a>1.直接递归遍历整个二叉树后返回根节点</h2><p>&emsp;&emsp;此类问题不需要引入一个用于记录和更新极值结果的中间全局变量，只需要对二叉树本身进行操作，所以在传入的方法参数上比较简单，只需要关注于节点本身（以根节点为视角和着眼点）。大多数题目都是针对树结构进行性重建，查找或删除等操作。</p><h3 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><strong>示例 1:</strong></p><p><img lazyload src="/images/loading.svg" data-src="tree.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder &#x3D; [-1], inorder &#x3D; [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure><p><strong>解题思路：</strong></p><p>对于任意一颗树而言，前序遍历的形式总是：</p><p><code>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</code><br>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是：</p><p><code>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</code></p><p>&emsp;&emsp;只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;  <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  root := &amp;TreeNode&#123;preorder[<span class="number">0</span>],<span class="literal">nil</span>,<span class="literal">nil</span>&#125; <span class="comment">// 着眼于根节点</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(inorder); i++ &#123;  <span class="comment">// 找到在中序遍历数组中根节点的位置</span></span><br><span class="line">  <span class="keyword">if</span> inorder[i] == preorder[<span class="number">0</span>] &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  root.Left = buildTree(preorder[<span class="number">1</span>:i+<span class="number">1</span>], inorder[:i])  <span class="comment">// 构建左子树</span></span><br><span class="line">  root.Right = buildTree(preorder[i+<span class="number">1</span>:], inorder[i+<span class="number">1</span>:])  <span class="comment">// 构建右子树</span></span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(inorder []<span class="keyword">int</span>, postorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(postorder) == <span class="number">0</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  root := &amp;TreeNode&#123;postorder[<span class="built_in">len</span>(postorder)<span class="number">-1</span>],<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">  i:=<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> ; i&lt;<span class="built_in">len</span>(inorder); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> inorder[i] == postorder[<span class="built_in">len</span>(postorder)<span class="number">-1</span>] &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  root.Left = build(inorder[:i],postorder[:i])</span><br><span class="line">  root.Right = build(inorder[i+<span class="number">1</span>:],postorder[i:<span class="built_in">len</span>(postorder)<span class="number">-1</span>])</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>翻转一棵二叉树。</p><p><strong>示例：</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><p>废话少说，直接看代码吧，简单题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  left := invertTree(root.Left)</span><br><span class="line">  right := invertTree(root.Right)  <span class="comment">// 后序遍历</span></span><br><span class="line">  root.Left = right</span><br><span class="line">  root.Right = left</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p>简单题，直接上代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  <span class="comment">// 递归出口，空节点返回深度0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  left := maxDepth(root.Left)  <span class="comment">// 左子树深度</span></span><br><span class="line">  right := maxDepth(root.Right)  <span class="comment">// 右子树深度</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>+max(left,right)  <span class="comment">// 返回最终深度=左右子树最大深度+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> a&gt;=b &#123;</span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>    1   / \  2   2 / \ / \3  4 4  3</code></pre><p> 但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p><strong>解题思路：</strong></p><p>&emsp;&emsp;如果同时满足下面的条件，两个树互为镜像：</p><ul><li>它们的两个根结点具有相同的值；</li><li>每个树的右子树都与另一个树的左子树镜像对称。</li></ul><p>&emsp;&emsp;我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移；p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> check(root, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(q,p *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> q == <span class="literal">nil</span> &amp;&amp; p == <span class="literal">nil</span> &#123;  <span class="comment">// p，q均为空节点，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> q == <span class="literal">nil</span> || p == <span class="literal">nil</span> &#123; <span class="comment">// p，q只有其中一者为空节点，返回false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 1.p，q节点的值相等；2.q的左节点与p的右节点相等；3.q的右节点与p的左节点相等。</span></span><br><span class="line">  <span class="keyword">return</span> q.Val == p.Val &amp;&amp; check(q.Left,p.Right) &amp;&amp; check(q.Right,p.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a class="link" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="binarytree.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img lazyload src="/images/loading.svg" data-src="binarytree2.png" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">树中节点数目在范围 [2, 105] 内。</span><br><span class="line">-109 &lt;&#x3D; Node.val &lt;&#x3D; 109</span><br><span class="line">所有 Node.val 互不相同 。</span><br><span class="line">p !&#x3D; q</span><br><span class="line">p 和 q 均存在于给定的二叉树中。</span><br></pre></td></tr></table></figure><p><strong>解题思路：</strong></p><p>&emsp;&emsp;我们递归遍历整棵二叉树，定义 $f_{x}$ 表示 $x$ 节点的子树中是否包含 $p$ 节点或 $q$ 节点，如果包含为<code>true</code>,否则为<code>false</code>。那么符合条件的最近公共祖先 $x$ 一定满足如下条件：</p><p>$\left(f_{\text {lson }} &amp; &amp; f_{\text {rson }}\right) |\left((x=p | x=q) &amp; &amp;\left(f_{\text {lson }} | f_{\text {rson }}\right)\right)$</p><p>其中 $<em>{\text{lson}}$ 和 $</em>{\text{rson}}$ 分别代表 $x$ 节点的左孩子和右孩子。$\left(f_{\text {lson }} &amp; &amp; f_{\text {rson }}\right)$ 说明左子树和右子树均包含 $p$ 节点或 $q$ 节点，如果左子树包含的是 $p$ 节点，那么右子树只能包含 $q$ 节点，反之亦然，因为 $p$ 节点和 $q$ 节点都是不同且唯一的节点，因此如果满足这个判断条件即可说明 $x$ 就是我们要找的最近公共祖先。再来看第二条判断条件，这个判断条件即是考虑了 $x$ 恰好是 $p$ 节点或 $q$ 节点且它的左子树或右子树有一个包含了另一个节点的情况，因此如果满足这个判断条件亦可说明 $x$ 就是我们要找的最近公共祖先。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> root == p || root == q &#123; <span class="comment">// 当遇到p或q节点时剪枝，不再向下递，开始归</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  left := lowestCommonAncestor(root.Left,p,q)</span><br><span class="line">  right := lowestCommonAncestor(root.Right,p,q) <span class="comment">// 后序遍历的框架</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123; <span class="comment">// p,q节点分别在左右子树，当前节点即是共同祖先</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> left == <span class="literal">nil</span> &#123; <span class="comment">// 左子树中不包含p，q节点，右子树包含其中之一，该节点本身是p，q中的另一个</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> left <span class="comment">// 右子树中不包含p，q节点，左子树包含其中之一，该节点本身是p，q中的另一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \   \ </span><br><span class="line"> 5   4   7</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 合并必须从两个树的根节点开始。</p><p><strong>解题思路：</strong></p><p>方法一：深度优先搜索</p><p>可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。</p><p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。</p><ul><li>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</li><li>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</li><li>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。<br>  对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(root1 *TreeNode, root2 *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root1 == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> root2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> root2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  root1.Val += root2.Val</span><br><span class="line">  root1.Left = mergeTrees(root1.Left, root2.Left)</span><br><span class="line">  root1.Right = mergeTrees(root1.Right, root2.Right)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：广度优先搜索</p><p>也可以使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。</p><p>如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。</p><p>使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。</p><p>如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：</p><ul><li>如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；</li><li>如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。</li></ul><p>对于右子节点和右子树，处理方法与左子节点和左子树相同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(root1 *TreeNode, root2 *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">q1 := []*TreeNode&#123;root1&#125;</span><br><span class="line"> q2 := []*TreeNode&#123;root2&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root1 == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> root2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> root2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  root3 := &amp;TreeNode&#123;root1.Val+root2.Val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">  q3 := []*TreeNode&#123;root3&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(q1)&gt;<span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(q2)&gt;<span class="number">0</span> &#123;</span><br><span class="line">    node1 := q1[<span class="number">0</span>]</span><br><span class="line">    q1 = q1[<span class="number">1</span>:]</span><br><span class="line">    node2 := q2[<span class="number">0</span>]</span><br><span class="line">    q2 = q2[<span class="number">1</span>:]</span><br><span class="line">    node3 := q3[<span class="number">0</span>]</span><br><span class="line">    q3 = q3[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node1.Left != <span class="literal">nil</span> &amp;&amp; node2.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">    q1 = <span class="built_in">append</span>(q1, node1.Left)</span><br><span class="line">      q2 = <span class="built_in">append</span>(q2, node2.Left)</span><br><span class="line">      node3.Left = &amp;TreeNode&#123;node1.Left.Val+node2.Left.Val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">      q3 = <span class="built_in">append</span>(q3, node3.Left)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> node1.Left == <span class="literal">nil</span> &amp;&amp; node2.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">      node3.Left = node2.Left <span class="comment">// node1没有左子树，直接用node2的左子树接到新树上</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> node1.Left != <span class="literal">nil</span> &amp;&amp; node2.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">        node3.Left = node1.Left <span class="comment">// node2没有左子树，直接用node1的左子树接到新树上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node1.Right != <span class="literal">nil</span> &amp;&amp; node2.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">    q1 = <span class="built_in">append</span>(q1, node1.Right)</span><br><span class="line">      q2 = <span class="built_in">append</span>(q2, node2.Right)</span><br><span class="line">      node3.Right = &amp;TreeNode&#123;node1.Right.Val+node2.Right.Val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">      q3 = <span class="built_in">append</span>(q3, node3.Right)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> node1.Right == <span class="literal">nil</span> &amp;&amp; node2.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">      node3.Right = node2.Right <span class="comment">// node1没有右子树，直接用node2的右子树接到新树上</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> node1.Right != <span class="literal">nil</span> &amp;&amp; node2.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">      node3.Right = node1.Right <span class="comment">// node2没有右子树，直接用node1的右子树接到新树上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-返回bool类型的结果-一般要求对二叉树是否符合某种性质做判别"><a href="#2-返回bool类型的结果-一般要求对二叉树是否符合某种性质做判别" class="headerlink" title="2.返回bool类型的结果(一般要求对二叉树是否符合某种性质做判别)"></a>2.返回bool类型的结果(一般要求对二叉树是否符合某种性质做判别)</h2><p>&emsp;&emsp;此类问题一般只在递归出口处可能返回<code>true</code>，而在一般节点的判别时只返回<code>false</code>的情形。返回<code>true</code>表明递的过程结束，然而后续的节点不一定判别完了，会出现不应该的剪枝的情况。可以直接返回<code>false</code>的情形是因为遇到了不符合要求的情况，下面的节点不用继续判断了，就直接返回<code>false</code>。一般而言有下面这样的模板：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="comment">// 递归出口</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">if</span> [判别情形<span class="number">1</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> [判别情形<span class="number">2</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> helper(root.Left) &amp;&amp; helper(root.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a class="link" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列<i class="fas fa-external-link-alt"></i></a></h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   6</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>数组长度 &lt;= 1000</code></li></ol><p><strong>解题思路：</strong></p><p>&emsp;&emsp;二叉搜索树的后续遍历数组满足如下定义：</p><ul><li>后序遍历： <code>[ 左子树 | 右子树 | 根节点 ]</code> ，即遍历顺序为 “左、右、根” 。</li><li><strong>二叉搜索树定义：</strong> 左子树中所有节点的值 &lt; 根节点的值；右子树中所有节点的值 &gt; 根节点的值；其左、右子树也分别为二叉搜索树。</li></ul><p><img lazyload src="/images/loading.svg" data-src="11.png" alt="avatar"></p><p><strong>递归解析：</strong></p><ul><li>递归出口：<code>len(postorder)==0</code>时，返回<code>true</code>。</li><li>递：</li></ul><ol><li><p><strong>划分左右子树</strong>： 遍历后序遍历的元素，寻找 <strong>第一个大于根节点</strong> 的节点，索引记为 <code>flag</code>。此时，可划分出左子树区间 <code>[:flag]</code> 、右子树区间 <code>[flag,len(postorder)−1]</code> 、根节点索引为<code>len(postorder)-1</code> 。</p></li><li><p><strong>判断是否为二叉搜索树：</strong> 左子树区间 <code>[0,flag−1]</code> 内的所有节点都应 &lt; <code>postorder[len(postorder)-1]</code>。而第 <code>1.划分左右子树</code> 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。</p><p> 右子树区间<code>[flag,len(postorder)-1]</code>内所有节点都应 &gt; <code>postorder[len(postorder)-1]</code>。实现方式为遍历，当遇到 &lt; <code>postorder[len(postorder)-1]</code>的节点则跳出。</p></li></ol><ul><li>归： 所有子树都需正确才可判定正确，因此使用 <strong>与逻辑符</strong> <code>&amp;&amp;</code> 连接。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyPostorder</span><span class="params">(postorder []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(postorder) == <span class="number">0</span> &#123; <span class="comment">// 递归出口</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  i := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> ; i&lt;<span class="built_in">len</span>(postorder); i++ &#123;</span><br><span class="line">  <span class="keyword">if</span> postorder[i] &gt;= postorder[<span class="built_in">len</span>(postorder)<span class="number">-1</span>] &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  flag := i  <span class="comment">// 用于记录左右子树分界处的索引号</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ; i&lt;<span class="built_in">len</span>(postorder); i++ &#123;</span><br><span class="line">  <span class="keyword">if</span> postorder[i] &lt; postorder[<span class="built_in">len</span>(postorder)<span class="number">-1</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>  <span class="comment">// 右子树出现小于根节点的数，直接返回false跳出递的过程</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 左右子树分别满足上述条件才返回true</span></span><br><span class="line">  <span class="keyword">return</span> verifyPostorder(postorder[:flag]) &amp;&amp; verifyPostorder(postorder[flag:<span class="built_in">len</span>(postorder)<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a class="link" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构<i class="fas fa-external-link-alt"></i></a></h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>给定的树 B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F;</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;&#x3D; 节点个数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure><p><strong>解题思路：</strong></p><ul><li><p>两个函数</p><ul><li><strong>isSubStructure()</strong><ul><li>用于递归遍历 A 中的所有节点，并判断当前节点 A 是否与 B 的根节点相同，相同则调用 helper( ) 进一步校验</li></ul></li><li><strong>helper()</strong><ul><li>用于校验 B 是否与 A 的一个子树拥有相同的结构和节点值</li></ul></li></ul></li><li><p>函数内容</p><ul><li><p><strong>isSubStructure()</strong></p><ul><li>如果当前节点 A == nil &amp;&amp; B == nil ，返回true。</li><li>如果当前节点 A == nil | | B == nil ，返回 false。（由题目可知，空树不是任意一个树的子结构）</li><li>当在当前结点 A 中找到 B 的根节点时，进入helper () 递归校验</li><li>ret == false，说明 B 的根节点不在当前 A 中，进入 A 的左子树进行递归查找</li><li>ret 仍等于 false，则说明 B 的根节点不在当前 A 和左子树中，进入 A 的右子树进行递归查找。</li></ul></li><li><p><strong>helper()</strong></p><ul><li><p>如果 B == nil ，说明 B 已遍历完，返回 true</p></li><li><p>在 B != nil 的情况下，如果 A == nil ,说明 A 中节点不足以构成子结构 B ，返回 false</p></li><li><p>如果 A.Val != B.Val，不满足节点值相等条件，返回 false</p></li><li><p>A.Val == B.Val 继续递归校验 A B 左子树和右子树的结构和节点是否相同</p></li></ul></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubStructure</span><span class="params">(A *TreeNode, B *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> A == <span class="literal">nil</span> || B == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> A.Val == B.Val &#123;</span><br><span class="line">        ret = helper(A, B)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ret &#123; <span class="comment">// B 的根节点不在当前 A 中，进入 A 的左子树进行递归查找</span></span><br><span class="line">        ret = isSubStructure(A.Left, B)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ret &#123; <span class="comment">// ret 仍等于 false，则说明 B 的根节点不在当前 A 和左子树中，进入 A 的右子树进行递归查找。</span></span><br><span class="line">        ret = isSubStructure(A.Right, B)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(A *TreeNode, B *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> B == <span class="literal">nil</span> &#123; <span class="comment">// 如果 B == nil ，说明 B 已遍历完，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> A == <span class="literal">nil</span> &#123; <span class="comment">// 在 B != nil 的情况下，如果 A == nil ,说明 A 中节点不足以构成子结构 B ，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> A.Val != B.Val &#123; <span class="comment">//  A.Val != B.Val，不满足节点值相等条件，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(A.Left, B.Left) &amp;&amp; helper(A.Right, B.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="331-验证二叉树的前序序列化"><a href="#331-验证二叉树的前序序列化" class="headerlink" title="331. 验证二叉树的前序序列化"></a><a class="link" href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/">331. 验证二叉树的前序序列化<i class="fas fa-external-link-alt"></i></a></h3><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     2</span><br><span class="line">  &#x2F; \   &#x2F; \</span><br><span class="line"> 4   1  #  6</span><br><span class="line">&#x2F; \ &#x2F; \   &#x2F; \</span><br><span class="line"># # # #   # #</span><br></pre></td></tr></table></figure><p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 # 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p>每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的<code>&#39;#&#39;</code>。</p><p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;1,#&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;9,#,#,1&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>解题思路：</strong></p><p>&emsp;&emsp;我们可以定义一个概念，叫做槽位。一个槽位可以被看作「当前二叉树中正在等待被节点填充」的那些位置。</p><p>二叉树的建立也伴随着槽位数量的变化。每当遇到一个节点时：</p><ul><li>如果遇到了空节点，则要消耗一个槽位；</li><li>如果遇到了非空节点，则除了消耗一个槽位外，还要再补充两个槽位。</li></ul><p>此外，还需要将根节点作为特殊情况处理。</p><p>&emsp;&emsp;我们使用栈来维护槽位的变化。栈中的每个元素，代表了对应节点处剩余槽位的数量，而栈顶元素就对应着下一步可用的槽位数量。当遇到空节点时，仅将栈顶元素减 1；当遇到非空节点时，将栈顶元素减 1 后，再向栈中压入一个 2。无论何时，如果栈顶元素变为 0，就立刻将栈顶弹出。遍历结束后，若栈为空，说明没有待填充的槽位，因此是一个合法序列；否则若栈不为空，则序列不合法。此外，在遍历的过程中，若槽位数量不足，则序列不合法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidSerialization</span><span class="params">(preorder <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(preorder)</span><br><span class="line">    stk := []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125; <span class="comment">// 初始化一个槽位给根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stk) == <span class="number">0</span> &#123; <span class="comment">// 已经没有足够的槽位，但序列还未结束，说明序列不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> preorder[i] == <span class="string">&#x27;,&#x27;</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> preorder[i] == <span class="string">&#x27;#&#x27;</span> &#123; <span class="comment">// 出现空节点</span></span><br><span class="line">            stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>]--  <span class="comment">// 消耗栈顶一个槽位</span></span><br><span class="line">            <span class="keyword">if</span> stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>] == <span class="number">0</span> &#123; <span class="comment">// 若栈顶槽位置零，则出栈</span></span><br><span class="line">                stk = stk[:<span class="built_in">len</span>(stk)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i&lt;n &amp;&amp; preorder[i] != <span class="string">&#x27;,&#x27;</span> &#123; <span class="comment">// 读取数字</span></span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>]-- <span class="comment">// 消耗栈顶一个槽位</span></span><br><span class="line">            <span class="keyword">if</span> stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>] == <span class="number">0</span> &#123; <span class="comment">// 若栈顶槽位置零，则出栈</span></span><br><span class="line">                stk = stk[:<span class="built_in">len</span>(stk)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            stk = <span class="built_in">append</span>(stk,<span class="number">2</span>) <span class="comment">// 每出现一个新非空节点，入栈一个有2个槽位的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stk) == <span class="number">0</span>  <span class="comment">// 遍历结束后，没有空槽位说明序列合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-设置全局变量实时记录并更新递归过程中的极值"><a href="#3-设置全局变量实时记录并更新递归过程中的极值" class="headerlink" title="3.设置全局变量实时记录并更新递归过程中的极值"></a>3.设置全局变量实时记录并更新递归过程中的极值</h2><p>&emsp;&emsp;此类题目最终的输出是一个单一的值，我们需要维护一个全局变量来记录这一个单一值，并在递归遍历二叉树的过程中实时地更新这个值。用于递归的辅助函数的返回结果不必与这个值直接联系，要着眼于构建二叉树的节点间的关系。</p><h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a class="link" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和<i class="fas fa-external-link-alt"></i></a></h3><p><strong>路径</strong>被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p><strong>路径和</strong>是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="exx1.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img lazyload src="/images/loading.svg" data-src="exx2.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <code>[1, 3 * 104]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p><strong>解题思路：</strong></p><ol><li>首先考虑辅助函数的功能。考虑实现一个简化的函数 <code>maxGain(node)</code>，该函数计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。具体而言，该函数的计算如下:</li></ol><ul><li>空节点的最大贡献值等于 0。</li><li>非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）。</li></ul><p>例如，考虑如下二叉树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> -10</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;叶节点 9、15、7 的最大贡献值分别为 9、15、7。得到叶节点的最大贡献值之后，再计算非叶节点的最大贡献值。节点 20 的最大贡献值等于 <code>20+max⁡(15,7)=35</code>。节点 −10 的最大贡献值等于 <code>−10+max⁡(9,35)=25</code>。上述计算过程是递归的过程，因此，对根节点调用函数 <code>maxGain</code>，即可得到每个节点的最大贡献值。</p><p>&emsp;&emsp;根据函数 <code>maxGain</code> 得到每个节点的最大贡献值之后，如何得到二叉树的最大路径和？对于二叉树中的一个节点，该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。维护一个全局变量 <code>maxSum</code> 存储最大路径和，在递归过程中更新 <code>maxSum</code> 的值，最后得到的 <code>maxSum</code> 的值即为二叉树中的最大路径和。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">maxPathSum</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  maxSum := math.MinInt32  <span class="comment">// 设置全局变量用于实时比较及更新每个节点作为根节点时的最大路径</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> gotMax <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span></span><br><span class="line">  gotMax = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      left := max(gotMax(root.Left),<span class="number">0</span>)  <span class="comment">// 当前节点的左子树的最大贡献值（如果小于0则置0）</span></span><br><span class="line">      right := max(gotMax(root.Right),<span class="number">0</span>)  <span class="comment">// 当前节点右子树的最大贡献值（如果小于0则置0）</span></span><br><span class="line">      now := root.Val + left + right  <span class="comment">// 记录以当前节点作为根节点的最大路径</span></span><br><span class="line">      maxSum = max(maxSum,now) <span class="comment">// 更新最大值</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> root.Val+max(left,right)  <span class="comment">// 返回当前节点的最大贡献值</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gotMax(root)</span><br><span class="line">  <span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> a&gt;=b &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a class="link" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径<i class="fas fa-external-link-alt"></i></a></h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>示例 :</strong><br>给定二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5   </span><br></pre></td></tr></table></figure><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p><p><strong>解题思路：</strong></p><p>&emsp;&emsp;任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。假设我们知道对于某节点的左儿子向下遍历经过最多的节点数 $L$ （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 $R$ （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 $L+R+1$ 。</p><p>&emsp;&emsp;最后的算法流程为：我们定义一个递归函数 <code>depth(node)</code> 计算 $d_{node}$，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 $L$ 和 $R$ ，则该节点为根的子树的深度即为 $\max (L, R)+1$, 该节点的 $d_{node}$ 值为$L+R+1$。递归搜索每个节点并设一个全局变量 <code>maxSum</code> 来记录并随时更新最大直径。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxSum <span class="keyword">int</span>  <span class="comment">// 全局变量用于记录最大直径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">diameterOfBinaryTree</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  naxSum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  depth(root)</span><br><span class="line">  <span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">depth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123; <span class="comment">// 该辅助函数用于返回每个节点的深度</span></span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  left := depth(root.Left)</span><br><span class="line">  right := depth(root.Right)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> left+right+<span class="number">1</span> &gt; maxSum &#123; <span class="comment">// 更新最大直径的值</span></span><br><span class="line">    maxSum = left + right + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>+max(left,right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-结果要求返回数组"><a href="#4-结果要求返回数组" class="headerlink" title="4.结果要求返回数组"></a>4.结果要求返回数组</h2><p>&emsp;&emsp;由于递归算法本身在递归的过程中没法返回数组，所以可以通过设置全局变量的方式，在递归过程中动态的更新数组。</p><h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a class="link" href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II<i class="fas fa-external-link-alt"></i></a></h3><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="pathsumii1.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img lazyload src="/images/loading.svg" data-src="pathsumii2.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], targetSum &#x3D; 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">树中节点总数在范围 [0, 5000] 内</span><br><span class="line">-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</span><br><span class="line">-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSym</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">  ret := <span class="built_in">make</span>([][]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">  path := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  helper(root,targetSum,&amp;ret,path)</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>, ret *[][]<span class="keyword">int</span>, path []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  sum := targetSum - root.Val</span><br><span class="line">  path = <span class="built_in">append</span>(path,root.Val)</span><br><span class="line">  <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; sum == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// / 创建一个辅助数组用于保存path的当前值，否则path会随递归操作而回溯</span></span><br><span class="line">    dst := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>(path))  </span><br><span class="line">    <span class="built_in">copy</span>(dst,path)</span><br><span class="line">    *ret = <span class="built_in">append</span>(*ret, dst)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  helper(root.Left, targetSum-root.Val, ret, path)</span><br><span class="line">  helper(root.Right, targetSum-root.Val, ret, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a><a class="link" href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和<i class="fas fa-external-link-alt"></i></a></h3><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p><p>每条从根节点到叶节点的路径都代表一个数字：</p><ul><li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li></ul><p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p><p><strong>叶节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="num1tree.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3]</span><br><span class="line">输出：25</span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13</span><br><span class="line">因此，数字总和 &#x3D; 12 + 13 &#x3D; 25</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong>：</p><p><img lazyload src="/images/loading.svg" data-src="num2tree.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [4,9,0,5,1]</span><br><span class="line">输出：1026</span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40</span><br><span class="line">因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>树的深度不超过 <code>10</code></li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;深度优先搜索是很直观的做法。从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumNumbers</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    nodeArray := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    helper(root, &amp;nodeArray, path)</span><br><span class="line"></span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> nodeArray &#123;</span><br><span class="line">        ret += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, array *[]<span class="keyword">int</span>, path []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path = <span class="built_in">append</span>(path, root.Val)</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        node := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i:=<span class="built_in">len</span>(path)<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">            node += path[i]* <span class="keyword">int</span>(math.Pow10(<span class="built_in">len</span>(path)-i<span class="number">-1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        *array = <span class="built_in">append</span>(*array,node)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    helper(root.Left, array, path)</span><br><span class="line">    helper(root.Right, array, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a class="link" href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径<i class="fas fa-external-link-alt"></i></a></h3><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="paths-tree.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,null,5]</span><br><span class="line">输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[&quot;1&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>解题思路：</strong></p><ul><li>当遍历到根节点时，将根节点的值转化成字符串后贴到路径串中，并将该条路径存入<code>ret</code>中；</li><li>当不是根节点时，将根节点的值转化成字符串后贴到路径串中，并在其后加入符号<code>-&gt;</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binaryTreePaths</span><span class="params">(root *TreeNode)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    ret := <span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">0</span>)</span><br><span class="line">    path := <span class="string">&quot;&quot;</span></span><br><span class="line">    helper(root,&amp;ret,path)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, ret *[]<span class="keyword">string</span>, path <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123; <span class="comment">// 当是根节点时，该条路径遍历结束，存入ret</span></span><br><span class="line">        path = path + strconv.Itoa(root.Val)</span><br><span class="line">        dst := <span class="string">&quot;&quot;</span></span><br><span class="line">        dst = path        </span><br><span class="line">        *ret = <span class="built_in">append</span>(*ret, dst)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        path = path + strconv.Itoa(root.Val) + <span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    helper(root.Left, ret, path)</span><br><span class="line">    helper(root.Right, ret, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="863-二叉树中所有距离为-K-的结点"><a href="#863-二叉树中所有距离为-K-的结点" class="headerlink" title="863. 二叉树中所有距离为 K 的结点"></a><a class="link" href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树（具有根结点 <code>root</code>）， 一个目标结点 <code>target</code> ，和一个整数值 <code>K</code> 。</p><p>返回到目标结点 <code>target</code> 距离为 <code>K</code> 的所有结点的值的列表。 答案可以以任何顺序返回。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], target &#x3D; 5, K &#x3D; 2</span><br><span class="line">输出：[7,4,1]</span><br><span class="line">解释：</span><br><span class="line">所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1</span><br><span class="line"></span><br><span class="line">注意，输入的 &quot;root&quot; 和 &quot;target&quot; 实际上是树上的结点。</span><br><span class="line">上面的输入仅仅是对这些对象进行了序列化描述。</span><br></pre></td></tr></table></figure><p><img lazyload src="/images/loading.svg" data-src="sketch0.png" alt="avatar"></p><p>提示：</p><ul><li>给定的树是非空的。</li><li>树上的每个结点都具有唯一的值 0 &lt;= node.val &lt;= 500 。</li><li>目标结点 target 是树上的结点。</li><li>0 &lt;= K &lt;= 1000.</li></ul><p><strong>解题思路：</strong></p><p>若将 <code>target</code> 当作树的根结点，我们就能从 <code>target</code> 出发，使用深度优先搜索去寻找与 <code>target</code> 距离为 <code>k</code> 的所有结点，即深度为 <code>k</code> 的所有结点。</p><p>由于输入的二叉树没有记录父结点，为此，我们从根结点 <code>root</code> 出发，使用深度优先搜索遍历整棵树，同时用一个哈希表记录每个结点的父结点。</p><p>然后从 <code>target</code> 出发，使用深度优先搜索遍历整棵树，除了搜索左右儿子外，还可以顺着父结点向上搜索。</p><p>代码实现时，由于每个结点值都是唯一的，哈希表的键可以用结点值代替。此外，为避免在深度优先搜索时重复访问结点，递归时额外传入来源结点 <code>from</code>，在递归前比较目标结点是否与来源结点相同，不同的情况下才进行递归。通过标记源结点，如图结点2遍历到7时，由于存在7-&gt;2的边，可能会重复遍历。由于存在我们预先标记的源节点只有当<code>cur != from</code>的时候才能继续遍历。</p><p><img lazyload src="/images/loading.svg" data-src="1627477357-OBWKQM-image.png" alt="avatar"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distanceK</span><span class="params">(root *TreeNode, target *TreeNode, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*TreeNode,<span class="number">0</span>) <span class="comment">// 初始化map用于存储父节点</span></span><br><span class="line">    <span class="keyword">var</span> parent <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span> </span><br><span class="line">    parent = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123; <span class="comment">// 递归存储每个节点的父节点</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            m[root.Left.Val] = root</span><br><span class="line">            parent(root.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            m[root.Right.Val] = root</span><br><span class="line">            parent(root.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parent(root)</span><br><span class="line"></span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> disK <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode,*TreeNode,<span class="keyword">int</span>)</span> // // 从 <span class="title">target</span> 出发 <span class="title">DFS</span>，寻找所有深度为 <span class="title">k</span> 的结点</span></span><br><span class="line">    disK = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, from *TreeNode, depth <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> depth == k &#123; <span class="comment">// 距离等于k，存入ret并剪枝</span></span><br><span class="line">            ret = <span class="built_in">append</span>(ret, root.Val)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Left != from &#123; <span class="comment">// 左节点</span></span><br><span class="line">            disK(root.Left, root, depth+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Right != from &#123; <span class="comment">// 右节点</span></span><br><span class="line">            disK(root.Right, root, depth+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> m[root.Val] != from &#123; <span class="comment">// 父节点</span></span><br><span class="line">            disK(m[root.Val], root, depth+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    disK(target,<span class="literal">nil</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树(BST)"></a>二叉搜索树(BST)</h1><h2 id="二叉搜索树-BST-的特性"><a href="#二叉搜索树-BST-的特性" class="headerlink" title="二叉搜索树(BST)的特性"></a>二叉搜索树(BST)的特性</h2><ol><li>对于 BST 的每一个节点 <code>node</code>，左子树节点的值都比 <code>node</code> 的值要小，右子树节点的值都比 <code>node</code> 的值大。</li><li>对于 BST 的每一个节点 <code>node</code>，它的左侧子树和右侧子树都是 BST。</li><li><strong>从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）</strong>。</li></ol><h2 id="BST必知必会题"><a href="#BST必知必会题" class="headerlink" title="BST必知必会题"></a>BST必知必会题</h2><h3 id="1-判断BST的合法性-98-验证二叉搜索树"><a href="#1-判断BST的合法性-98-验证二叉搜索树" class="headerlink" title="1. 判断BST的合法性(98. 验证二叉搜索树)"></a>1. 判断BST的合法性(<a class="link" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树<i class="fas fa-external-link-alt"></i></a>)</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。   </li></ul><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><p><strong>解题思路：</strong></p><p>对于每一个节点 **<code>root</code><strong>，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，</strong><code>root</code>**的整个左子树都要小于 **<code>root.val</code>**，整个右子树都要大于 **<code>root.val</code>**。</p><p>问题是，对于某一个节点 <code>root</code>，他只能管得了自己的左右子节点，怎么把 <code>root</code> 的约束传递给左右子树呢？<strong>我们通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉树算法的一个小技巧吧</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span> <span class="title">boll</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> helper(root, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, max *TreeNode, min *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> min != <span class="literal">nil</span> &amp;&amp; root.Val &lt;= min.Val &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> max != <span class="literal">nil</span> &amp;&amp; root.Val &gt;= max.Val &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> helper(root.Left, root, min) &amp;&amp; helper(root.Right, max, root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-在BST中搜索一个数"><a href="#2-在BST中搜索一个数" class="headerlink" title="2. 在BST中搜索一个数"></a>2. 在BST中搜索一个数</h3><p>&emsp;&emsp;直接利用BST的性质前序遍历二叉搜索树，当当前节点值等于<code>target</code>，直接返回<code>true</code>，如果当前节点值大于<code>target</code>，则在其左子树中寻找；如果小于<code>target</code>，在其右子树中寻找。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isInBST</span><span class="params">(root *TreeNode, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> root.Val == target &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> root.Val &gt; target &#123;</span><br><span class="line">    <span class="keyword">return</span> isInBST(root.Left, target)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> root.Val &lt; target &#123;</span><br><span class="line">    <span class="keyword">return</span> isInBST(root.Right, target)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-在BST中插入一个数"><a href="#3-在BST中插入一个数" class="headerlink" title="3. 在BST中插入一个数"></a>3. 在BST中插入一个数</h3><p>&emsp;&emsp;涉及到“改”这一操作，就要返回<code>TreeNode</code>类型了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  <span class="comment">// 找到空位置插入新节点</span></span><br><span class="line">    node := &amp;TreeNode&#123;val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> root.Val &lt; val &#123; <span class="comment">// 在右子树的叶节点中插入val</span></span><br><span class="line">    root.Right = insertIntoBST(root.Right,val)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> root.Val &gt; val &#123; <span class="comment">// 在左子树的叶节点中插入val</span></span><br><span class="line">    root.Left = insertIntoBST(root.Left,val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-在BST中删除一个数"><a href="#4-在BST中删除一个数" class="headerlink" title="4. 在BST中删除一个数"></a>4. 在BST中删除一个数</h3><p>&emsp;&emsp;这个问题稍微复杂，跟插入操作类似，先「找」再「改」。找到目标节点了，比方说是节点 <code>A</code>，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。</p><ul><li>情况1: <code>A</code> 恰好是末端节点，两个子节点都为空，那么可以直接将其删除。</li></ul><p><img lazyload src="/images/loading.svg" data-src="case1.png" alt="avatar"></p><ul><li>情况2: <code>A</code> 只有一个非空子节点，那么它要让这个孩子接替自己的位置。</li></ul><p><img lazyload src="/images/loading.svg" data-src="case2.png" alt="avatar"></p><ul><li>情况 3：<code>A</code> 有两个子节点，麻烦了，为了不破坏 BST 的性质，<code>A</code> 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。</li></ul><p><img lazyload src="/images/loading.svg" data-src="case3.png" alt="avatar"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> root.Val == key &#123;</span><br><span class="line">    <span class="comment">// 下面两个if把case1和case2都处理了</span></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> root.Right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> root.Left</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// case3</span></span><br><span class="line">    minNode := getNode(root.Right)</span><br><span class="line">      root.Val = minNode.Val <span class="comment">// 将当前根节点的值用右子树最小值(一定是叶节点)替换</span></span><br><span class="line">    root.Right = deletNode(root.Right, minNode.Val) <span class="comment">// 删除掉被替换后的叶节点</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &gt; key &#123;</span><br><span class="line">    root.Left = deleteNode(root.Left,key)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &lt; key &#123;</span><br><span class="line">    root.Right = deleteNode(root.Left,key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMin</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">    root = root.Left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BST高频题"><a href="#BST高频题" class="headerlink" title="BST高频题"></a>BST高频题</h2><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a class="link" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="uniquebstn3.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><p><strong>解题思路：</strong>(搬运自<a class="link" href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/">不同的二叉搜索树<i class="fas fa-external-link-alt"></i></a>)</p><p>&emsp;&emsp;给定一个有序序列 $1⋯n$，为了构建出一棵二叉搜索树，我们可以遍历每个数字 $i$，将该数字作为树根，将 $1⋯(i−1)$ 序列作为左子树，将 $(i+1)⋯n$ 序列作为右子树。接着我们可以按照同样的方式递归构建左子树和右子树。</p><p>&emsp;&emsp;在上述构建的过程中，由于根的值不同，因此我们能保证每棵二叉搜索树是唯一的。由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用。因此，我们可以想到使用动态规划来求解本题。</p><p>&emsp;&emsp;题目要求是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：</p><ol><li>$G(n)$: 长度为 $n$ 的序列能构成的不同二叉搜索树的个数。</li><li>$F(i,n)$: 以 $i$ 为根、序列长度为 $n$ 的不同二叉搜索树个数 $(1≤i≤n)$。</li></ol><p>&emsp;&emsp;可见，$G(n)$ 是我们求解需要的函数。稍后我们将看到，$G(n)$ 可以从 $F(i,n)$ 得到，而 $F(i,n)$ 又会递归地依赖于 $G(n)$。</p><p>&emsp;&emsp;首先，根据上一节中的思路，不同的二叉搜索树的总数 $G(n)$，是对遍历所有 $(1≤i≤n)$ 的 $F(i,n)$ 之和。换言之：</p><p>$G(n)=\sum_{i=1}^{n} F(i, n)$</p><p>&emsp;&emsp;对于边界情况，当序列长度为 11（只有根）或为 00（空树）时，只有一种情况，即：</p><p>$G(0)=1, \quad G(1)=1$</p><p>&emsp;&emsp;给定序列 $1⋯n$，我们选择数字 $i$ 作为根，则根为 $i$ 的所有二叉搜索树的集合是左子树集合和右子树集合的笛卡尔积，对于笛卡尔积中的每个元素，加上根节点之后形成完整的二叉搜索树，如下图所示：</p><p><img lazyload src="/images/loading.svg" data-src="96_fig1.png" alt="avatar"></p><p>&emsp;&emsp;举例而言，创建以 3 为根、长度为 7 的不同二叉搜索树，整个序列是 $[1,2,3,4,5,6,7]$，我们需要从左子序列 $[1,2]$ 构建左子树，从右子序列 $[4,5,6,7]$ 构建右子树，然后将它们组合（即笛卡尔积）。对于这个例子，不同二叉搜索树的个数为 $F(3,7)$。我们将 $[1,2]$ 构建不同左子树的数量表示为 $G(2)$, 从 $[4,5,6,7]$ 构建不同右子树的数量表示为 $G(4)$，注意到 $G(n)$ 和序列的内容无关，只和序列的长度有关。于是，$F(3,7)=G(2)⋅G(4)$。 因此，我们可以得到以下公式：</p><p>$F(i, n)=G(i-1) \cdot G(n-i)$</p><p>将公式结合，可以得到 $G(n)$ 的递归表达式：</p><p>$G(n)=\sum_{i=1}^{n} G(i-1) \cdot G(n-i)$</p><p>至此，我们从小到大计算 $G$ 函数即可，因为 $G(n)$ 的值依赖于 $G(0)⋯G(n−1)$。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numTrees</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  m := <span class="built_in">make</span>([][]<span class="keyword">int</span>,n)  <span class="comment">// 初始化一个二维数组充当记事本</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">    m[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count(<span class="number">1</span>,n,m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(l <span class="keyword">int</span>, r <span class="keyword">int</span>, m [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> l &gt; r &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> m[l<span class="number">-1</span>][r<span class="number">-1</span>] != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m[l<span class="number">-1</span>][r<span class="number">-1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> i:=l; i&lt;=r; i++ &#123;</span><br><span class="line">    left := count(l,i<span class="number">-1</span>,m)</span><br><span class="line">    right := count(i+<span class="number">1</span>,r,m)</span><br><span class="line">ret += left*right  <span class="comment">// 笛卡尔乘积</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  m[l<span class="number">-1</span>][r<span class="number">-1</span>] = ret</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a class="link" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II<i class="fas fa-external-link-alt"></i></a></h3><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code>互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="uniquebstn.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><p><strong>解题思路：</strong></p><p>二叉搜索树关键的性质是根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。因此在生成所有可行的二叉搜索树的时候，假设当前序列长度为 n，如果我们枚举根节点的值为 i，那么根据二叉搜索树的性质我们可以知道左子树的节点值的集合为 [1…i−1]，右子树的节点值的集合为 [i+1…n]。而左子树和右子树的生成相较于原问题是一个序列长度缩小的子问题，因此我们可以想到用回溯的方法来解决这道题目。</p><p>我们定义 <code>generateTrees(start, end)</code> 函数表示当前值的集合为 <code>[start,end]</code>，返回序列 <code>[start,end]</code> 生成的所有可行的二叉搜索树。按照上文的思路，我们考虑枚举 <code>[start,end]</code> 中的值 i 为当前二叉搜索树的根，那么序列划分为了 <code>[start,i−1]</code> 和 <code>[i+1,end]</code> 两部分。我们递归调用这两部分，即 <code>generateTrees(start, i - 1)</code> 和 <code>generateTrees(i + 1, end)</code>，获得所有可行的左子树和可行的右子树，那么最后一步我们只要从可行左子树集合中选一棵，再从可行右子树集合中选一棵拼接到根节点上，并将生成的二叉搜索树放入答案数组即可。</p><p>递归的入口即为 <code>generateTrees(1, n)</code>，出口为当 start&gt;end 的时候，当前二叉搜索树为空，返回空节点即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateTrees</span><span class="params">(n <span class="keyword">int</span>)</span> []*<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getBST(<span class="number">1</span>,n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBST</span><span class="params">(l <span class="keyword">int</span>, r <span class="keyword">int</span>)</span> []*<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> l &gt; r &#123;</span><br><span class="line">      <span class="keyword">return</span> []*TreeNode&#123;<span class="literal">nil</span>&#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ret := <span class="built_in">make</span>([]*TrrNode,<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 枚举可行根节点</span></span><br><span class="line">  <span class="keyword">for</span> i:=l; i&lt;=r; i++ &#123;</span><br><span class="line">      <span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">    leftTree := getBST(l,i<span class="number">-1</span>)</span><br><span class="line">      <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">    tightTree := getBST(i+<span class="number">1</span>,r)</span><br><span class="line">    <span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">    <span class="keyword">for</span> _,left := <span class="keyword">range</span> leftTree &#123;</span><br><span class="line">      <span class="keyword">for</span> _,right := <span class="keyword">range</span> rightTree &#123;</span><br><span class="line">        root := &amp;TreeNode&#123;i,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">        root.Left = left</span><br><span class="line">        root.Right = right</span><br><span class="line">        ret = <span class="built_in">append</span>(ret,root)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a><a class="link" href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树<i class="fas fa-external-link-alt"></i></a></h3><p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p><p>进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？</p><p><strong>示例 1：</strong></p><p><img lazyload src="/images/loading.svg" data-src="recover1.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,3,null,null,2]</span><br><span class="line">输出：[3,1,null,null,2]</span><br><span class="line">解释：3 不能是 1 左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img lazyload src="/images/loading.svg" data-src="recover2.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,1,4,null,null,2]</span><br><span class="line">输出：[2,1,4,null,null,3]</span><br><span class="line">解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树上节点的数目在范围 <code>[2, 1000]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><p><strong>解题思路：</strong></p><p>&emsp;&emsp;我们需要考虑两个节点被错误地交换后对原二叉搜索树造成了什么影响。对于二叉搜索树，我们知道如果对其进行中序遍历，得到的值序列是递增有序的，而如果我们错误地交换了两个节点，等价于在这个值序列中交换了两个值，破坏了值序列的递增性。</p><p>&emsp;&emsp;我们来看下如果在一个递增的序列中交换两个值会造成什么影响。假设有一个递增序列 <code>a=[1,2,3,4,5,6,7]</code>。如果我们交换两个不相邻的数字，例如 2 和 6，原序列变成了 <code>a=[1,6,3,4,5,2,7]</code>，那么显然序列中有两个位置不满足 $a_{i}$&lt;$a_{i+1}$，在这个序列中体现为6&gt;3，5&gt;2，因此只要我们找到这两个位置，即可找到被错误交换的两个节点。如果我们交换两个相邻的数字，例如 2 和 3，此时交换后的序列只有一个位置不满足  $a_{i}$&lt;$a_{i+1}$。因此整个值序列中不满足条件的位置或者有两个，或者有一个。</p><p>&emsp;&emsp;至此，解题方法已经呼之欲出了：</p><ol><li>找到二叉搜索树中序遍历得到值序列的不满足条件的位置。</li><li>如果有两个，我们记为 i 和 j（i&lt;j 且  $a_{i}$&gt;$a_{i+1}$ &amp;&amp;  $a_{j}$&gt;$a_{j+1}$，那么对应被错误交换的节点即为$a_{i}$对应的节点和$a_{i+1}$对应的节点，我们分别记为 x 和 y。</li><li>如果有一个，我们记为 i，那么对应被错误交换的节点即为$a_{i}$对应的节点和$a_{i+1}$对应的节点，我们分别记为 x 和 y。</li><li>交换 x 和 y 两个节点即可。</li></ol><p>&emsp;&emsp;实现部分，本方法开辟一个新数组 <code>nums</code> 来记录中序遍历得到的值序列，然后线性遍历找到两个位置 i 和 j，并重新遍历原二叉搜索树修改对应节点的值完成修复，具体实现可以看下面的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverTree</span><span class="params">(root *TreeNode)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    nums := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> inorder <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span> // 中序遍历保存序列</span></span><br><span class="line">    inorder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.Left)</span><br><span class="line">        nums = <span class="built_in">append</span>(nums,root.Val)</span><br><span class="line">        inorder(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root)</span><br><span class="line">    A, B := helper(nums)</span><br><span class="line">    fmt.Println(A,B)</span><br><span class="line">    <span class="built_in">recover</span>(A, B, <span class="number">2</span>, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 返回两个顺序错误的节点的值</span></span><br><span class="line">    x,y := math.MinInt32, <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i+<span class="number">1</span>] &lt; nums[i] &#123;</span><br><span class="line">            y = nums[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> x == math.MinInt32 &#123;</span><br><span class="line">                x = nums[i]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x,y</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">(A <span class="keyword">int</span>, B <span class="keyword">int</span>, count <span class="keyword">int</span>, root *TreeNode)</span></span> &#123; <span class="comment">// 遍历二叉树，改变这两个节点值</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val == A || root.Val == B &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val == A &#123;</span><br><span class="line">            root.Val = B </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.Val = A</span><br><span class="line">        &#125;</span><br><span class="line">        count-- <span class="comment">// 用于计数，当两个节点都被改变后，直接跳出递的过程，剪枝</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">recover</span>(A, B, count, root.Left)</span><br><span class="line">    <span class="built_in">recover</span>(A, B, count, root.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;递归算法的原理&quot;&gt;&lt;a href=&quot;#递归算法的原理&quot; class=&quot;headerlink&quot; title=&quot;递归算法的原理&quot;&gt;&lt;/a&gt;递归算法的原理&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;一个递归函数的调用类似于多个函数的嵌套调用，只不过调用函数和被调函数都是同一</summary>
      
    
    
    
    <category term="算法和数据结构" scheme="http://jiahaohong1997.github.io/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="递归" scheme="http://jiahaohong1997.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
</feed>
