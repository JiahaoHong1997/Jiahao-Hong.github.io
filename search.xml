<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>滑动窗口(Sliding Window)算法框架</title>
    <url>/2021/04/28/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(Sliding-Window)%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>&emsp;&emsp;滑动窗口主要应用于子串问题，遇到这类问题不要犹豫，直接考虑使用滑动窗口。作为双指针类问题最难掌握的技巧，其设计思路其实非常简单，就是通过两个指针维护一个窗口，通过前后指针的不断向前滑动，然后更新答案。该算法的大致逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">left := <span class="number">0</span></span><br><span class="line">right := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> right &lt; s.size() &#123;</span><br><span class="line">  <span class="comment">// 增大窗口</span></span><br><span class="line">  window.add(s[right])</span><br><span class="line">  right++</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> window needs shrink &#123;</span><br><span class="line">    <span class="comment">// 缩小窗口</span></span><br><span class="line">    window.remove(s[left])</span><br><span class="line">    left++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。其实困扰大家的，不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。</p>
<h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><h3 id="滑动窗口算法代码框架"><a href="#滑动窗口算法代码框架" class="headerlink" title="滑动窗口算法代码框架"></a>滑动窗口算法代码框架</h3><p>&emsp;&emsp;废话少说，直接上代码。下面的框架很适合给出了具体t，要求找出其在主串s中的排列或包含t的子串的问题，可以直接套用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slidingwindow</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span></span> &#123; <span class="comment">// s是主串，t是子串</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据题目条件灵活选择数据结构，其主要作用和目的是判断左边界是否要右移</span></span><br><span class="line">  need := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(t))  <span class="comment">// need用于记录t子串对字符的实际要求</span></span><br><span class="line">  window := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(t)) <span class="comment">// window用于检测当前窗口内满足t子串的要求字符的实际情况</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">    need[t[i]] = <span class="number">1</span>  <span class="comment">// 数量可以是任意数字，根据题目实际需求</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">  	left = <span class="number">0</span> <span class="comment">// 窗口左边界</span></span><br><span class="line">    right = <span class="number">0</span> <span class="comment">// 窗口右边界</span></span><br><span class="line">    valid = <span class="number">0</span> <span class="comment">// 满足条件的字符个数</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">    <span class="comment">// c是要移入窗口的字符</span></span><br><span class="line">    c := s[right]</span><br><span class="line">    <span class="comment">// 右移窗口</span></span><br><span class="line">    right++</span><br><span class="line">    <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">    <span class="comment">/********************/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">    <span class="keyword">for</span> window needs shrink &#123;</span><br><span class="line">      <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">      d := s[left]</span><br><span class="line">      <span class="comment">// 左移窗口</span></span><br><span class="line">      left++</span><br><span class="line">      <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串<i class="fas fa-external-link-alt"></i></a></h3><p><img lazyload src="/images/loading.svg" data-src="https://gblobscdn.gitbook.com/assets%2F-MZLBWp7285NJbpNV7Kv%2Fsync%2F3d5d2bc76cee1f2190a7dd4fcd17445164dc7273.png?alt=media" alt="avatar"></p>
<p>就是说要在 <code>S</code>(source) 中找到包含 <code>T</code>(target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。</p>
<p>如果我们使用暴力解法，代码大概是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">  <span class="keyword">for</span> j:=i+<span class="number">1</span>; j&lt;<span class="built_in">len</span>(s); j++ &#123;</span><br><span class="line">    <span class="keyword">if</span> s[i:j] 包含t中的所有字母 &#123;</span><br><span class="line">      更新答案</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路很直接，但是显然，这个算法的复杂度肯定大于 O(N^2) 了。</p>
<p><strong>滑动窗口算法的思路是这样</strong>：</p>
<p>1、我们在字符串 <code>S</code> 中使用双指针中的左右指针技巧，初始化 <code>left = right = 0</code>，把索引<strong>左闭右开</strong>区间 <code>[left, right)</code> 称为一个「窗口」。</p>
<p>2、我们先不断地增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code>，直到窗口中的字符串符合要求（包含了 <code>T</code> 中的所有字符）。</p>
<p>3、此时，我们停止增加 <code>right</code>，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含 <code>T</code> 中的所有字符了）。同时，每次增加 <code>left</code>，我们都要更新一轮结果。</p>
<p>4、重复第 2 和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</p>
<p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，</strong>也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p>
<p>下面画图理解一下，<code>needs</code> 和 <code>window</code> 相当于计数器，分别记录 <code>T</code> 中字符出现次数和「窗口」中的相应字符的出现次数。</p>
<p>初始状态：</p>
<p><img lazyload src="/images/loading.svg" data-src="image-20210429193510364.png" alt="image-20210429193510364"></p>
<p>增加 <code>right</code>，直到窗口 <code>[left, right]</code> 包含了 <code>T</code> 中所有字符：</p>
<p><img lazyload src="/images/loading.svg" data-src="image-20210429193608894.png" alt="image-20210429193608894"></p>
<p>现在开始增加 <code>left</code>，缩小窗口 <code>[left, right]</code>。</p>
<p><img lazyload src="/images/loading.svg" data-src="image-20210429193630917.png" alt="image-20210429193630917"></p>
<p>直到窗口中的字符串不再符合要求，<code>left</code> 不再继续移动。</p>
<p><img lazyload src="/images/loading.svg" data-src="image-20210429194033697.png" alt="image-20210429194033697"></p>
<p>之后重复上述过程，先移动 <code>right</code>，再移动 <code>left</code>…… 直到 <code>right</code> 指针到达字符串 <code>S</code> 的末端，算法结束。</p>
<p><strong>现在开始套模板，只需要思考以下四个问题</strong>：</p>
<p>1、当移动 <code>right</code> 扩大窗口，即加入字符时，应该更新哪些数据？</p>
<p>2、什么条件下，窗口应该暂停扩大，开始移动 <code>left</code> 缩小窗口？</p>
<p>3、当移动 <code>left</code> 缩小窗口，即移出字符时，应该更新哪些数据？</p>
<p>4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p>
<p>如果一个字符进入窗口，应该增加 <code>window</code> 计数器；如果一个字符将移出窗口的时候，应该减少 <code>window</code> 计数器；当 <code>valid</code> 满足 <code>need</code> 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    need := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125; <span class="comment">// 根据t子串记录实际的需求</span></span><br><span class="line">    window := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125; <span class="comment">// 记录窗口内满足要求的字符的情况</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(t); i++ &#123; <span class="comment">// 将子串t中字符的实际需求用need来记录</span></span><br><span class="line">        need[t[i]]++</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">  	    left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        valid = <span class="number">0</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 本题要求返回子串，所以引入start和length来记录子串的起始和长度</span></span><br><span class="line">        start = <span class="number">0</span> <span class="comment">// 记录最小覆盖子串的起始索引</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)+<span class="number">1</span> <span class="comment">//记录最小覆盖子串的长度</span></span><br><span class="line">    )</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="comment">// 加入窗口</span></span><br><span class="line">        c := s[right]</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 检查c是否在need的需求中，若在则加入window(进行窗口内数据的一系列更新)</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := need[c]; ok &#123;</span><br><span class="line">          window[c]++     </span><br><span class="line">          <span class="comment">// 若字符c的个数已经满足了need中的要求</span></span><br><span class="line">    	    <span class="keyword">if</span> window[c] == need[c] &#123;</span><br><span class="line">      	        valid++</span><br><span class="line">    	    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fmt.Printf(&quot;window1: [%d, %d)\n&quot;, left, right)  // debug专用</span></span><br><span class="line">        <span class="comment">// 当window内的所有字符都满足了需求，判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">for</span> valid == <span class="built_in">len</span>(need) &#123;</span><br><span class="line">            <span class="keyword">if</span> right - left &lt; length &#123;</span><br><span class="line">                start = left</span><br><span class="line">                length = right - left</span><br><span class="line">            &#125;</span><br><span class="line">      </span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            d := s[left]</span><br><span class="line">            <span class="comment">// 左边界右移缩小窗口</span></span><br><span class="line">            left++</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> _, ok := need[d]; ok &#123;</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d] &#123;</span><br><span class="line">                    valid--</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fmt.Printf(&quot;window2: [%d, %d)\n&quot;, left, right)  // debug专用      </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> length == <span class="built_in">len</span>(s)+<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s[start:start+length]</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a><a class="link" href="https://leetcode-cn.com/problems/permutation-in-string/">字符串的排列<i class="fas fa-external-link-alt"></i></a></h3><p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的 <strong>子串</strong> 。</p>
<p>示例 1：</p>
<p>输入: s1 = “ab” s2 = “eidbaooo”<br>输出: True<br>解释: s2 包含 s1 的排列之一 (“ba”).</p>
<p>示例 2：</p>
<p>输入: s1= “ab” s2 = “eidboaoo”<br>输出: False</p>
<p><strong>提示：</strong></p>
<ul>
<li>输入的字符串只包含小写字母</li>
<li>两个字符串的长度都在 <code>[1, 10,000]</code> 之间</li>
</ul>
<p>这种题目，是明显的滑动窗口算法，<strong>相当给你一个</strong> <strong><code>S1</code></strong> <strong>和一个</strong> **<code>S2</code>**，请问你 <strong><code>S2</code></strong> <strong>中是否存在一个子串，包含</strong> <strong><code>S1</code></strong> <strong>中所有字符且不包含其他字符</strong>？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkInclusion</span><span class="params">(s1 <span class="keyword">string</span>, s2 <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    need := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    window := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s1); i++ &#123;</span><br><span class="line">        need[s1[i]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        valid = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s2) &#123;</span><br><span class="line">        window[s2[right]]++</span><br><span class="line">				</span><br><span class="line">      	<span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := need[s2[right]]; ok &#123;</span><br><span class="line">            <span class="keyword">if</span> window[s2[right]] == need[s2[right]] &#123;</span><br><span class="line">                valid++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right++</span><br><span class="line">        </span><br><span class="line">      	<span class="comment">// 在这里判断是否找到了合法的子串</span></span><br><span class="line">        <span class="keyword">if</span> valid == <span class="built_in">len</span>(need) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right &gt;= <span class="built_in">len</span>(s1) &#123;</span><br><span class="line">            <span class="keyword">if</span> _, ok := need[s2[left]]; ok &#123;</span><br><span class="line">                <span class="keyword">if</span> window[s2[left]] == need[s2[left]] &#123;</span><br><span class="line">                    valid--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            window[s2[left]]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：</p>
<p>1、本题移动 <code>left</code> 缩小窗口的时机是窗口大小大于 <code>S1.size()</code> 时，应为排列嘛，显然长度应该是一样的。</p>
<p>2、当发现 <code>valid == len(need)</code> 时，就说明窗口中就是一个合法的排列，所以立即返回 <code>true</code>。</p>
<p>至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。</p>
<h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a><a class="link" href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p>
<p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p>
<p>说明：</p>
<p>字母异位词指字母相同，但排列不同的字符串。<br>不考虑答案输出的顺序。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br></pre></td></tr></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br></pre></td></tr></table></figure>

<p>和上一个示例几乎一模一样，只不过函数返回的东西不同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findAnagrams</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    need := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    window := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line">        need[p[i]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        valid = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        c := s[right]</span><br><span class="line">        window[c]++</span><br><span class="line">        right++</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> _,ok := need[c]; ok&#123;</span><br><span class="line">            <span class="keyword">if</span> window[c] == need[c] &#123;</span><br><span class="line">                valid++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> valid == <span class="built_in">len</span>(need) &#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, left)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right &gt;= <span class="built_in">len</span>(p) &#123;</span><br><span class="line">            d := s[left]</span><br><span class="line">            <span class="keyword">if</span> _,ok := need[d]; ok &#123;</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d] &#123;</span><br><span class="line">                    valid--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            window[d]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a class="link" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<p>&emsp;&emsp;这个题终于有了点新意，不是一套框架就出答案，不过反而更简单了，稍微改一改框架就行了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    window := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        c := s[right]</span><br><span class="line">        window[c]++</span><br><span class="line">        right++</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 每当新进入窗口的字符出现多次，窗口左边界便开始右移，知道窗口内没有重复字符</span></span><br><span class="line">        <span class="keyword">for</span> window[c]&gt;<span class="number">1</span> &#123; </span><br><span class="line">            d := s[left]</span><br><span class="line">            window[d]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        ret = max(ret, right-left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a&gt;b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS算法框架</title>
    <url>/2021/04/08/BFS%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>&emsp;&emsp;本系列文章是我在阅读<a class="link" href="https://labuladong.gitbook.io/algo/">《labuladong的算法小抄》<i class="fas fa-external-link-alt"></i></a>一书，再结合自己在Leetcode上刷题后的一些体会和总结。本系列文章的所有代码均由Golang语言实现，使用别的语言的读者不妨尝试转换成自己熟悉的语言实现。不过如果你选择用Python来刷算法题，有一个问题需要注意，Python的效率降低，在机试过程中可能出现同一道题，用C/C++或者Golang的人能暴力AC，而用Python却可能会运行超时，会吃不小的亏，还请结合自身情况来考虑选择哪门语言来实现。读者若需要了解更多的细节，还请阅读此书并结合实际多刷刷题。</p>
<h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><h3 id="BFS的应用场景"><a href="#BFS的应用场景" class="headerlink" title="BFS的应用场景"></a>BFS的应用场景</h3><p>&emsp;&emsp;此类问题的本质就是在一幅「图」(树是特殊的图)中找到起始点(start)到终点(target)的最近距离。实际上，此类问题利用DFS也能做到，但是DFS实质上就是回溯算法，时间复杂度很高。BFS的时间代价是O(N)，其代价就是空间复杂度很高。在二叉树中，BFS对应的就是二叉树的层序遍历。</p>
<p>&emsp;&emsp;这类问题可以有各种各样的变体，比如：1.走迷宫，迷宫中有的格子是围墙，不能通过，要求从起点到终点的最短距离是多少？2.两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？3.连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？这些问题都没啥奇技淫巧，本质上就是一幅「图」，让你从一个起点，走到终点，问最短路径。这就是 BFS 的本质，框架搞清楚了直接默写就好。</p>
<h3 id="算法思路-Golang"><a href="#算法思路-Golang" class="headerlink" title="算法思路(Golang)"></a>算法思路(Golang)</h3><p>&emsp;&emsp;所有的BFS问题的核心数据结构：队列q用于存储节点。用node指向当前要出队的节点，当该节点出队时，其相邻节点入队。对于非二叉树这种结构(没有子节点到父节点的指针，不会走回头路)的数据形式，还需要一个建立一个map类型来保存已经走过的节点，防止走回头路。</p>
<p>&emsp;&emsp;BFS最常见于二叉树中，先给一个二叉树的BFS(层序遍历)框架。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">二叉树：[3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层序遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFS</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ret := [][]<span class="keyword">int</span>&#123;&#125;  <span class="comment">// 因为该示例要按每层返回遍历结果，所以要初始化一个二维切片</span></span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  <span class="comment">// 如果根节点为空，返回空切片</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  q := []*TreeNode&#123;root&#125;  <span class="comment">// 初始化队列用于存储节点</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; <span class="built_in">len</span>(q)&gt;<span class="number">0</span>; i++ &#123;  <span class="comment">// 当队列不为空，说明还有节点没有遍历完，继续循环</span></span><br><span class="line">    ret = <span class="built_in">append</span>(ret, []<span class="keyword">int</span>&#123;&#125;)  <span class="comment">// 初始化用于存储树的每一层的切片</span></span><br><span class="line">    p := []*TreeNode&#123;&#125;  <span class="comment">// 切片p用于记录树的每一层节点</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(q); j++ &#123;</span><br><span class="line">      node := q[j]  <span class="comment">// 某一层的节点顺序出队</span></span><br><span class="line">      ret[i] = <span class="built_in">append</span>(ret[i], node.Val) <span class="comment">// 存入当前节点</span></span><br><span class="line">      <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123; <span class="comment">// 如果左节点不为空，左节点入队</span></span><br><span class="line">        p = <span class="built_in">append</span>(p, node.Left) </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123; <span class="comment">// 如果右节点不为空，右节点入队</span></span><br><span class="line">        p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    q = p; <span class="comment">// 更新队列q，保存下一层的节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果不要求用二维数组分别保存每一层的节点，可以不需要切片p，直接在每个节点出队时将其左右节点送入队列p即可。</p>
<p>&emsp;&emsp;通用框架，主要区别在于多了一个map类型用来记录已经遍历过的节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define num is the number of node</span></span><br><span class="line"><span class="comment"> * Define the Type of node if NodeType</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFS</span><span class="params">(start NodeType, target NodeType)</span></span> &#123;</span><br><span class="line">  q := []NodeType&#123;start&#125; <span class="comment">// 起始节点入队</span></span><br><span class="line">  m := <span class="built_in">make</span>(<span class="keyword">map</span>[NodeType]<span class="keyword">int</span>, num) <span class="comment">// 避免走回头路</span></span><br><span class="line">  m[start] = <span class="number">1</span> <span class="comment">// 记录起始节点</span></span><br><span class="line">  step := <span class="number">0</span>  <span class="comment">// 记录扩散的步数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(q)</span><br><span class="line">    p := []NodeType&#123;&#125;</span><br><span class="line">    <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">      node := q[i]</span><br><span class="line">      <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">      <span class="keyword">if</span> node = target &#123;</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 将 node 的相邻节点加入队列 */</span></span><br><span class="line">      <span class="keyword">for</span> Node x : node.adj() &#123; <span class="comment">// 判断node是否有相邻节点，根据数据形式自行更改</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := m[x]; !ok &#123; <span class="comment">// 如果节点没有被记录过，则可以入队</span></span><br><span class="line">          p = <span class="built_in">append</span>(p, x)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">    step++</span><br><span class="line">    q = p <span class="comment">// 该层所有节点遍历介绍，q保存下一层节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实际案例-二叉树"><a href="#实际案例-二叉树" class="headerlink" title="实际案例(二叉树)"></a>实际案例(二叉树)</h2><p>我们来看几道Leetcode上的题目。</p>
<h3 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a class="link" href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<pre><code>        3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回锯齿形层序遍历如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>​        怎么套到 BFS 的框架里呢？首先明确一下起点 start 和终点 target 是什么，怎么判断到达了终点？</p>
<p><strong>显然起点就是</strong> <strong>root</strong> <strong>根节点，终点就是最后一个叶子节点。</strong>不过在存储的过程中要注意，奇数行要倒序排列，偶数行正序排列。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    ret := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; <span class="built_in">len</span>(q)&gt;<span class="number">0</span>; i++ &#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">        p := []*TreeNode&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(q) ; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span> &#123; <span class="comment">// 如果是偶数行，则正序排列</span></span><br><span class="line">                node := q[j]</span><br><span class="line">                ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是奇数行，则倒叙排列</span></span><br><span class="line">                node := q[<span class="built_in">len</span>(q)<span class="number">-1</span>-j]</span><br><span class="line">                ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line">            &#125;</span><br><span class="line">            nodeInP := q[j]</span><br><span class="line">            <span class="keyword">if</span> nodeInP.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, nodeInP.Left)</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> nodeInP.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, nodeInP.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [2,null,3,null,4,null,5,null,6]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数的范围在 <code>[0, 105]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p><strong>显然起点就是</strong> <strong><code>root</code></strong> <strong>根节点，终点就是最靠近根节点的那个「叶子节点」</strong>，叶子节点就是两个子节点都是 <code>nil</code> 的节点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    step := <span class="number">1</span>  <span class="comment">// 记录层数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        p := []*TreeNode&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">            node := q[i]</span><br><span class="line">            <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123; <span class="comment">// 当遇到第一个子节点，就返回该节点所在层数</span></span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p>
<p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的<code>null</code>节点也计入长度）之间的长度。</p>
<p><strong>示例 1:</strong></p>
<p>输入: </p>
<pre><code>       1
     /   \
    3     2
   / \     \  
  5   3     9 
  
输出: 4
解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。
</code></pre>
<p><strong>示例 2:</strong></p>
<p>输入: </p>
<pre><code>      1
     /  
    3    
   / \       
  5   3     
  
输出: 2
解释: 最大值出现在树的第 3 层，宽度为 2 (5,3)。
</code></pre>
<p>示例 3:</p>
<p>输入: </p>
<pre><code>      1
     / \
    3   2 
   /        
  5      
  
输出: 2
解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。
</code></pre>
<p><strong>示例 4:</strong></p>
<p>输入: </p>
<pre><code>      1
     / \
    3   2
   /     \  
  5       9 
 /         \
6           7

输出: 8
解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。
</code></pre>
<p><strong>注意:</strong> 答案在32位有符号整数的表示范围内。</p>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;一开始很自然的想到利用层序遍历，遍历的节点存在以下情况：</p>
<ul>
<li>当前节点是空节点，则将两个空节点推入下一层的队列；</li>
<li>当前节点不是空节点：<ul>
<li>当前节点的左节点为空，则将一个空节点推入下一层的队列；左节点不为空，则将左节点推入下一层的队列；</li>
<li>当前节点的右节点为空，则将一个空节点推入下一层的队列；右节点不为空，则将右节点推入下一层的队列。</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;当一层遍历完之后，分别从收尾收缩下一层的队列，直到队首和队尾元素均不是空节点为止。然后将此时的队列长度和返回值做比较。</p>
<p>可是，在实际的测试过程中发现内存溢出了。这种方式对内存的占用时巨大的。</p>
<p>&emsp;&emsp;然后考虑到完全二叉树的性质，若按层序遍历的顺序给所有的节点编号，则对于每个节点<code>i</code>的左子树，其编号为<code>2*i</code>；其右子树编号为<code>2*i+1</code>，这样就可以为每一个节点编号，直接用每一层的最后一个节点的编号减去第一个节点的编号并加1就是每一层的宽度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> pair <span class="keyword">struct</span> &#123;</span><br><span class="line">    node        *TreeNode</span><br><span class="line">    position    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a&gt;=b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">widthOfBinaryTree</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    q := <span class="built_in">make</span>([]*pair,<span class="number">0</span>)</span><br><span class="line">    q = <span class="built_in">append</span>(q, &amp;pair&#123;root,<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; <span class="built_in">len</span>(q)&gt;<span class="number">0</span>; i++ &#123;</span><br><span class="line">        p := <span class="built_in">make</span>([]*pair,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        l := <span class="built_in">len</span>(q)</span><br><span class="line">        ret = max(ret, q[l<span class="number">-1</span>].position-q[<span class="number">0</span>].position+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;l; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> q[j].node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, &amp;pair&#123;q[j].node.Left,q[j].position*<span class="number">2</span>&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> q[j].node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, &amp;pair&#123;q[j].node.Right,q[j].position*<span class="number">2</span>+<span class="number">1</span>&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实际案例-其他数据结构方式"><a href="#实际案例-其他数据结构方式" class="headerlink" title="实际案例(其他数据结构方式)"></a>实际案例(其他数据结构方式)</h2><h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a class="link" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D;&#x3D; grid.length</span><br><span class="line">n &#x3D;&#x3D; grid[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 300</span><br><span class="line">grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39;</span><br></pre></td></tr></table></figure>

<p>算法思路：</p>
<p>&emsp;&emsp;遍历整个二维网格，当节点值为1时，以这个节点为起始进行广度优先搜索，当其相邻节点值为1时，进入队列，并将这些入队的节点值置为0。当不再有节点入队，说明已经达到了岛屿的边界，返回原始的循环。同时可以初始化一个map用于记录已经遍历过的节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>  <span class="comment">// 初始化map类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">len</span>(grid) <span class="comment">// 行数</span></span><br><span class="line">    c := <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="comment">// 列数</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, r*c) <span class="comment">// 用于记录已经遍历过的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;r; i++ &#123; <span class="comment">// 遍历整个二维网格</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;c; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;0&#x27;</span> || m[i*c+j] == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当节点值为&#x27;1&#x27;时以该节点为起始进行广度优先搜索</span></span><br><span class="line">                count++                </span><br><span class="line">                BFS(grid, i, j)</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span> <span class="comment">// 将当前遍历节点置&#x27;0&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFS</span><span class="params">(grid [][]<span class="keyword">byte</span>, i <span class="keyword">int</span>, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">len</span>(grid)</span><br><span class="line">    c := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    q := []<span class="keyword">int</span>&#123;i*c+j&#125; <span class="comment">// 队列中保存的是节点编号，以行优先的方式对所有节点编号</span></span><br><span class="line">    m[i*c+j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        p := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k:=<span class="number">0</span>; k&lt;<span class="built_in">len</span>(q); k++ &#123;</span><br><span class="line">            node := q[k]</span><br><span class="line">            nodeR := node/c <span class="comment">// 当前节点的行号</span></span><br><span class="line">            nodeC := node%c <span class="comment">// 当前节点的列号</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nodeR&gt;<span class="number">0</span> &amp;&amp; grid[nodeR<span class="number">-1</span>][nodeC] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的上方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[(nodeR<span class="number">-1</span>)*c+nodeC]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, (nodeR<span class="number">-1</span>)*c+nodeC)</span><br><span class="line">                    grid[nodeR<span class="number">-1</span>][nodeC] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[(nodeR<span class="number">-1</span>)*c+nodeC] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nodeR&lt;r<span class="number">-1</span> &amp;&amp; grid[nodeR+<span class="number">1</span>][nodeC] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的下方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[(nodeR+<span class="number">1</span>)*c+nodeC]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, (nodeR+<span class="number">1</span>)*c+nodeC)</span><br><span class="line">                    grid[nodeR+<span class="number">1</span>][nodeC] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[(nodeR+<span class="number">1</span>)*c+nodeC] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nodeC&gt;<span class="number">0</span> &amp;&amp; grid[nodeR][nodeC<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的左方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[nodeR*c+(nodeC<span class="number">-1</span>)]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, nodeR*c+(nodeC<span class="number">-1</span>))</span><br><span class="line">                    grid[nodeR][nodeC<span class="number">-1</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[nodeR*c+(nodeC<span class="number">-1</span>)] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nodeC&lt;c<span class="number">-1</span> &amp;&amp; grid[nodeR][nodeC+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的右方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[nodeR*c+(nodeC+<span class="number">1</span>)]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, nodeR*c+(nodeC+<span class="number">1</span>))</span><br><span class="line">                    grid[nodeR][nodeC+<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[nodeR*c+(nodeC+<span class="number">1</span>)] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p <span class="comment">// 进入下一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a class="link" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表<i class="fas fa-external-link-alt"></i></a></h3><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p>
<p>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p>
<p><strong>示例 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; numCourses &lt;&#x3D; 105</span><br><span class="line">0 &lt;&#x3D; prerequisites.length &lt;&#x3D; 5000</span><br><span class="line">prerequisites[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; ai, bi &lt; numCourses</span><br><span class="line">prerequisites[i] 中的所有课程对 互不相同</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;算法思路：我们使用一个队列来进行广度优先搜索。初始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。并初始化一个长度为numCourses的切片precourse，用于记录每个节点(课程)的入度。在广度优先搜索的每一步中，我们取出队首的节点 ，将该节点的相邻边(也就是将本课程作为预修课程的其他课程)减1(precource对应索引的值减1)。当节点入度为0时，将其作为下一层节点加入队列中。最后遍历precourse切片，若切片中所有元素为0，说明找到了一种拓扑排序，返回true，否则返回false。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    precourse := <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(prerequisites); i++ &#123; <span class="comment">// 初始化所有节点的入度(记录所有课程的预修课程数)</span></span><br><span class="line">        precourse[prerequisites[i][<span class="number">0</span>]]++</span><br><span class="line">    &#125;</span><br><span class="line">    q := []<span class="keyword">int</span>&#123;&#125; <span class="comment">// 初始化队列用于存储入度为0的节点(不需要预修课程的课)</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> precourse[i] == <span class="number">0</span> &#123; <span class="comment">// 将入度为0的节点入队</span></span><br><span class="line">            q = <span class="built_in">append</span>(q, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        p := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">            node := q[i]</span><br><span class="line">            <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(prerequisites); j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> prerequisites[j][<span class="number">1</span>] == node &#123; <span class="comment">// 查看所有以当前课程为预修课程的课</span></span><br><span class="line">                    precourse[prerequisites[j][<span class="number">0</span>]]-- <span class="comment">// 入度减1</span></span><br><span class="line">                    <span class="keyword">if</span> precourse[prerequisites[j][<span class="number">0</span>]] == <span class="number">0</span> &#123; <span class="comment">// 当入度为0，入队</span></span><br><span class="line">                        p = <span class="built_in">append</span>(p, prerequisites[j][<span class="number">0</span>])</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123; <span class="comment">// 查看是否所有节点入度为0</span></span><br><span class="line">        <span class="keyword">if</span> precourse[i] != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a class="link" href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 &#x3D; 4 + 4 + 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 &#x3D; 4 + 9</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 104</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;算法思路：本题可以采用贪心+BFS的策略，实际上是从上到下逐层构造 N 元树。我们以 BFS（广度优先搜索）的方式遍历它。在 N 元树的每一级，我们都在枚举相同大小的组合。其中每个节点表示数字 n 的余数减去一个完全平方数的组合，我们的任务是在树中找到一个节点，该节点满足两个条件：</p>
<p>(1) 节点的值（即余数）也是一个完全平方数。<br>(2) 在满足条件（1）的所有节点中，节点和根之间的距离应该最小。</p>
<p>下面是这棵树的样子：</p>
<p><img lazyload src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjc5LzI3OV9ncmVlZHlfdHJlZS5wbmc?x-oss-process=image/format,png" alt="avatar"></p>
<ul>
<li>首先，我们准备小于给定数字 n 的完全平方数列表（即 powlist）。</li>
<li>然后创建 q队列 遍历，该变量将保存所有剩余项在每个级别的枚举。在主循环中，我们迭代 q 变量。在每次迭代中，我们检查余数是否是一个完全平方数。如果余数不是一个完全平方数，就用其中一个完全平方数减去它，得到一个新余数，然后将新余数添加到 p 中，以进行下一级的迭代。一旦遇到一个完全平方数的余数，我们就会跳出循环，这也意味着我们找到了解。</li>
<li>注意：这里我们使用 set ，以消除同一级别中的剩余项的冗余。</li>
</ul>
<p>&emsp;&emsp;如果看文字难以理解，最好以n=12为例，画一画整个树的层级结构，能有更深的理解。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSquares</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    powlist := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i*i&lt;=n; i++ &#123; <span class="comment">// 完全平方数表</span></span><br><span class="line">        powlist = <span class="built_in">append</span>(powlist, i*i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">10000</span>) <span class="comment">// 用于记录冗余项，只需要在每层中第一次出现时保存，就能保证层数最少</span></span><br><span class="line">    level := <span class="number">0</span> <span class="comment">// 记录层级</span></span><br><span class="line">    q := []<span class="keyword">int</span>&#123;n&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        level++</span><br><span class="line">        p := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">            node := q[i] <span class="comment">// 当前节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _,value := <span class="keyword">range</span> powlist &#123; <span class="comment">// 贪心算法，构造树</span></span><br><span class="line">                <span class="keyword">if</span> value == node &#123; <span class="comment">// 第一次出现完全平方数，说明在这一层级就能解决问题，直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> level</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; node &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> set[node-value] == <span class="literal">false</span> &#123; <span class="comment">// 相当于剪枝操作</span></span><br><span class="line">                        p = <span class="built_in">append</span>(p, node-value) <span class="comment">// 记录下一层级的节点</span></span><br><span class="line">                        set[node-value] = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a class="link" href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/bfs-suan-fa/bfs-kuang-jia">BFS 算法解题套路框架<i class="fas fa-external-link-alt"></i></a></p>
<p>2.<a class="link" href="https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/">完全平方数<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>广度优先搜索(BFS)</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划(Dynamic Programming)算法框架</title>
    <url>/2021/04/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92(Dynamic-Programming)%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>&emsp;&emsp;在一开始学习算法的时候，我对动态规划和贪心算法一直都只有个模糊的概念，不明白两者到底有什么区别，感觉思路都差不太多。于是在本文的开头，我想对比一下贪心算法和动态规划的区别和联系。动态规划和贪心算法都是用来求最优化问题，且二者都必须具有最有子结构。动态规划的整体策略是一种自底向上的结构，贪心算法是自顶向下的结构。贪心算法可以解决的问题，动态规划都能解决，可以说，贪心算法是动态规划的一个特例。贪心算法和动态规划<strong>最大的不同</strong>在于，它并不是首先寻找子问题的最优解，然后在其中进行选择，而是首先做一次贪心选择——在当时（局部）看来最有选择——然后求解选出的子问题，从而不必费心求解所有可能相关的子问题。</p>
<p>&emsp;&emsp;动态规划具有两个性质：1）重叠子问题；2）<em><em><em>最优子结构*<strong>。贪心算法具有的两个性质：1）贪心选择性质；2）</strong></em>最优子结构</em>*</em>。动态规划就是为了消除其重叠子问题而设计的。<strong>其实贪心算法是一种特殊的动态规划，由于其具有贪心选择性质，保证了子问题只会被计算一次，不会被多次计算，因此贪心算法其实是最简单的动态规划。</strong></p>
<h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><h3 id="动态规划-DP-思维框架"><a href="#动态规划-DP-思维框架" class="headerlink" title="动态规划(DP)思维框架"></a>动态规划(DP)思维框架</h3><p>&emsp;&emsp;首先引用<a class="link" href="https://labuladong.gitbook.io/algo/">📋《labuladong的算法小抄》<i class="fas fa-external-link-alt"></i></a>中对动态规划问题的分析。</p>
<p>&emsp;&emsp;<strong>动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离等等。既然目标是求最值，那么<strong>DP的核心问题就是穷举</strong>。动态规划的穷举是很特别的，它存在以下三要素：</p>
<ul>
<li><strong>重叠子问题</strong>：如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</li>
<li><strong>最优子结构</strong>：动态规划问题一定具备最优子结构，才能通过子问题的最值得到原问题的最值。</li>
<li><strong>状态转移方程</strong>：动态规划问题的难点和关键，找到正确的状态转移方程，问题基本就能得到解决。</li>
</ul>
<p>&emsp;&emsp;由此可以得到一个基本的思维框架用于解决这类问题：<strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p>
<p>&emsp;&emsp;按上面的套路走，最后的结果就可以套这个框架：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"><span class="comment">// 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。</p>
<h3 id="动态规划杀手锏"><a href="#动态规划杀手锏" class="headerlink" title="动态规划杀手锏"></a>动态规划杀手锏</h3><h4 id="动态规划需要注意的要点："><a href="#动态规划需要注意的要点：" class="headerlink" title="动态规划需要注意的要点："></a>动态规划需要注意的要点：</h4><ul>
<li><p>“问5”法则判断问题是否是动态规划，例如最优解，最小或者最大等等；</p>
</li>
<li><p>如果判断属于动态规划的话，接下来我们可以根据“问4”法则求解：</p>
</li>
<li><ul>
<li>状态（小规模问题的数学表示）</li>
<li>状态转移方程（大规模问题如何转化为更小的问题）</li>
<li>最小状态（最小规模的问题）</li>
<li>要求的返回值是什么</li>
</ul>
</li>
</ul>
<h4 id="杀手锏"><a href="#杀手锏" class="headerlink" title="杀手锏"></a>杀手锏</h4><p><strong>1）建模：</strong></p>
<ul>
<li><p><strong>最优子结构</strong></p>
</li>
<li><p><strong>状态转移方程</strong></p>
</li>
<li><p><strong>边界</strong></p>
</li>
</ul>
<p><strong>2）实现：</strong></p>
<ul>
<li><p><strong>暴力递归</strong></p>
</li>
<li><p><strong>备忘录法（从上倒下，非全二叉树，hash保存！）</strong></p>
</li>
<li><p><strong>自底而上（迭代实现）</strong></p>
</li>
</ul>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>1.暴力递归</p>
<p>斐波那契数列的数学形式就是递归的，写成代码就是这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(N <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> N == <span class="number">1</span> || N==<span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fib(N<span class="number">-1</span>)+fib(N<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-24-30.jpg" alt="avatar"></p>
<p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p>
<p>&emsp;&emsp;这个递归树怎么理解？就是说想要计算原问题 <code>f(20)</code>，我就得先计算出子问题 <code>f(19)</code> 和 <code>f(18)</code>，然后要计算 <code>f(19)</code>，我就要先算出子问题 <code>f(18)</code> 和 <code>f(17)</code>，以此类推。最后遇到 <code>f(1)</code> 或者 <code>f(2)</code> 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。<strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p>
<p>&emsp;&emsp;观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p>
<p>&emsp;&emsp;这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p>
<p>2.带备忘录的递归解法</p>
<p>&emsp;&emsp;即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(N <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> N &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">  mem := <span class="built_in">make</span>([]<span class="keyword">int</span>, N+<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 进行带备忘录的递归</span></span><br><span class="line">  <span class="keyword">return</span> helper(mem, N)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(mem []<span class="keyword">int</span>, N <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">// base case</span></span><br><span class="line">  <span class="keyword">if</span> N == <span class="number">1</span> || N == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 已经计算过</span></span><br><span class="line">  <span class="keyword">if</span> mem[N] != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mem[N]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新备忘录</span></span><br><span class="line">  mem[N] = help(N<span class="number">-1</span>)+help[N<span class="number">-2</span>]</span><br><span class="line">  <span class="keyword">return</span> mem[N]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-25-26.jpg" alt="avatar"></p>
<p>&emsp;&emsp;实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p>
<p>&emsp;&emsp;至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p>
<p>&emsp;&emsp;啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-26-03.jpg" alt="avatar"></p>
<p>&emsp;&emsp;啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 <code>f(1)</code> 和 <code>f(2)</code> 开始往上推，直到推到我们想要的答案 <code>f(20)</code>，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p>
<p>3.DP数组的迭代解法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(N <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> N &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> N == <span class="number">1</span> || N == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, N+<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化base case</span></span><br><span class="line">  dp[<span class="number">1</span>], dp[<span class="number">2</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">3</span>; i&lt;=N; i++ &#123;</span><br><span class="line">    dp[i] = dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]  <span class="comment">// 状态转移方程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[N]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-26-32.jpg" alt="avatar"></p>
<p>&emsp;&emsp;画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p>
<p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-27-29.jpg" alt="avatar"></p>
<p>&emsp;&emsp;为啥叫「状态转移方程」？其实就是为了听起来高端。你把 <code>f(n)</code> 想做一个状态 <code>n</code>，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 相加转移而来，这就叫状态转移，仅此而已。</p>
<p>&emsp;&emsp;你会发现，上面的几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着暴力解法。</p>
<p>&emsp;&emsp;<strong>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong>。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p>
<p>&emsp;&emsp;这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(N <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> N &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> N == <span class="number">1</span> || N == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; </span><br><span class="line">  prev := <span class="number">1</span></span><br><span class="line">  curr := <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">3</span>; i&lt;=N; i++ &#123;</span><br><span class="line">    sum := prev + curr <span class="comment">// 新状态由前两个状态之和求得</span></span><br><span class="line">    prev = curr  <span class="comment">// 保存当前状态</span></span><br><span class="line">    curr = sum   <span class="comment">// 保存前一个状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> curr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个技巧就是所谓的「<strong>状态压缩</strong>」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 <code>n</code> 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。</p>
<p>&emsp;&emsp;至于动态规划的另一个重要特性「最优子结构」，下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。</p>
<h3 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h3><p>&emsp;&emsp;给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// coins 中是可选硬币面值，amount 是目标金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;这个问题是动态规划问题，因为它具有「最优子结构」的。<strong>要符合「最优子结构」，子问题间必须互相独立</strong>。为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p>
<p>1.暴力递归</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> dp(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dp</span><span class="params">(coins []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  res := n+<span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> _,value := <span class="keyword">range</span> coins &#123;</span><br><span class="line">    subproblem := dp [n-value]</span><br><span class="line">    <span class="keyword">if</span> subproblem == <span class="number">-1</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 <code>amount = 11, coins = &#123;1,2,5&#125;</code> 时画出递归树看看:</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-28-04.jpg" alt="avatar"></p>
<p><strong>递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间</strong>。</p>
<p>子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p>
<p>2.带备忘录的递归</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  mem := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(mem); i++ &#123;</span><br><span class="line">    mem[i] = amount+<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp(coins, amount, mem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dp</span><span class="params">(coins []<span class="keyword">int</span>, n <span class="keyword">int</span>, mem []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> mem[n] &lt; n+<span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mem[n]</span><br><span class="line">  &#125;</span><br><span class="line">  res := n+<span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> _,value := <span class="keyword">range</span> coins &#123;</span><br><span class="line">    subproblem := dp [coins, n-value, mem]</span><br><span class="line">    <span class="keyword">if</span> subproblem == <span class="number">-1</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line">  &#125;</span><br><span class="line">  mem[n] = res</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 <code>n</code>，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p>
<p>3.dp 数组的迭代解法(推荐)</p>
<p>&emsp;&emsp;迭代就是将递归转化成for循环。</p>
<p>&emsp;&emsp;<strong><code>dp</code></strong> <strong>数组的定义：当目标金额为</strong> <strong><code>i</code></strong> <strong>时，至少需要</strong> <strong><code>dp[i]</code></strong> <strong>枚硬币凑出</strong>。</p>
<p>根据我们文章开头给出的动态规划代码框架可以写出如下解法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> amount &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">  dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">    dp[i] = amount+<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// base case</span></span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 外层 for 循环在遍历所有状态的所有取值</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=amount; i++ &#123;</span><br><span class="line">    <span class="comment">// 内层 for 循环在求所有选择的最小值</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> coins &#123;</span><br><span class="line">      <span class="keyword">if</span> i-value &lt; <span class="number">0</span> &#123; <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      dp[i] = min(dp[i], <span class="number">1</span>+dp[i-value])  <span class="comment">// 状态转移方程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> dp[amount] == amount+<span class="number">1</span> &#123; <span class="comment">// 说明没有合适的方案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> a&lt;b &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;PS：为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。</p>
<h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定一个包含非负整数的 <code>m*n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-30-08.jpeg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[1,2,3],[4,5,6]]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D;&#x3D; grid.length</span><br><span class="line">n &#x3D;&#x3D; grid[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 200</span><br><span class="line">0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p>算法思路：由于路径的方向只能是向下或向右，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。</p>
<p>对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。</p>
<p>创建二维数组<em>dp</em>，与原始网格的大小相同，*dp[i] [j]<em>表示从左上角出发到(i,j)位置的最小路径和。显然，</em>dp[0] [0]=grid[0] [0]*。对于 <em>dp</em> 中的其余元素，通过以下状态转移方程计算元素值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当 i&gt;0 且 j&#x3D;0 时，dp[i][0]&#x3D;dp[i−1][0]+grid[i][0]。</span><br><span class="line">当 i&#x3D;0 且 j&gt;0 时，dp[0][j]&#x3D;dp[0][j−1]+grid[0][j]。</span><br><span class="line">当 i&gt;0 且 j&gt;0 时，dp[i][j]&#x3D;min(dp[i−1][j],dp[i][j−1])+grid[i][j]。</span><br></pre></td></tr></table></figure>

<p>最后得到 *dp[m−1] [n−1]*的值即为从网格左上角到网格右下角的最小路径和。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minPathSum</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(grid)) <span class="comment">// 初始化切片的行</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(grid); i++ &#123; <span class="comment">// 初始化切片的列</span></span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>] <span class="comment">// 初始化起始点值</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(grid[<span class="number">0</span>]); i++ &#123; <span class="comment">// 初始化第一行的值</span></span><br><span class="line">        dp[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i]+dp[<span class="number">0</span>][i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(grid); i++ &#123; <span class="comment">//初始化第一列的值</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">1</span> &amp;&amp; <span class="built_in">len</span>(grid[<span class="number">0</span>]) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="built_in">len</span>(grid[<span class="number">0</span>])<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid[<span class="number">0</span>]) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(grid)<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(grid); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;<span class="built_in">len</span>(grid[<span class="number">0</span>]); j++ &#123;</span><br><span class="line">            dp[i][j] = min(dp[i<span class="number">-1</span>][j]+grid[i][j],dp[i][j<span class="number">-1</span>]+grid[i][j]) <span class="comment">// 状态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(grid)<span class="number">-1</span>][<span class="built_in">len</span>(grid[<span class="number">0</span>])<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a&lt;b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a class="link" href="https://leetcode-cn.com/problems/trapping-rain-water/">接雨水<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="rainwatertrap.png" alt="rainwatertrap"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</span><br></pre></td></tr></table></figure>

<p>算法思路：对于下标 <em>i</em>，下雨后水能到达的最大高度等于下标 <em>i</em> 两边的最大高度的最小值，下标 <em>i</em> 处能接的雨水量等于下标 <em>i</em> 处的水能到达的最大高度减去 *height[i]*。</p>
<p>朴素的做法是对于数组 <em>height</em> 中的每个元素，分别向左和向右扫描并记录左边和右边的最大高度，然后计算每个下标位置能接的雨水量。假设数组 <em>height</em> 的长度为 <em>n</em>，该做法需要对每个下标位置使用 <em>O(n)</em> 的时间向两边扫描并得到最大高度，因此总时间复杂度是 *O(n<sup>2</sup>)*。</p>
<p>上述做法的时间复杂度较高是因为需要对每个下标位置都向两边扫描。如果已经知道每个位置两边的最大高度，则可以在 <em>O(n)</em> 的时间内得到能接的雨水总量。使用动态规划的方法，可以在 <em>O(n)</em> 的时间内预处理得到每个位置两边的最大高度。</p>
<p>创建两个长度为 <em>n</em> 的数组 <em>leftMax</em> 和 <em>rightMax</em>。对于 <em>0≤i&lt;n</em>，<em>leftMax[i]</em> 表示下标 <em>i</em> 及其左边的位置中，<em>height</em> 的最大高度，<em>rightMax[i]</em> 表示下标 <em>i</em> 及其右边的位置中，<em>height</em> 的最大高度。显然，*leftMax[0]=height[0]*，<br>*rightMax[n−1]=height[n−1]*。两个数组的其余元素的计算如下：</p>
<ul>
<li>当 <em>1≤i≤n−1</em> 时，*leftMax[i]=max(leftMax[i−1],height[i])*；</li>
<li>当 <em>0≤i≤n−2</em> 时，*rightMax[i]=max(rightMax[i+1],height[i])*。</li>
</ul>
<p>因此可以正向遍历数组 <em>height</em> 得到数组 <em>leftMax</em> 的每个元素值，反向遍历数组 <em>height</em> 得到数组 <em>rightMax</em> 的每个元素值。在得到数组 <em>leftMax</em> 和 <em>rightMax</em> 的每个元素值之后，对于 <em>0≤i&lt;n</em>，下标 <em>i</em> 处能接的雨水量等于<br>*min(leftMax[i],rightMax[i])−height[i]*。遍历每个下标位置即可得到能接的雨水总量。动态规划做法可以由下图体现。</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-29-30.jpg" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l := <span class="built_in">len</span>(height)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftMax := <span class="built_in">make</span>([]<span class="keyword">int</span>, l)</span><br><span class="line">    rightMax := <span class="built_in">make</span>([]<span class="keyword">int</span>, l)</span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">    rightMax[l<span class="number">-1</span>] = height[l<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;l; i++ &#123;  <span class="comment">// 从左向右遍历，得到i位置处左边的最高值</span></span><br><span class="line">        leftMax[i] = max(leftMax[i<span class="number">-1</span>],height[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=l<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i-- &#123; <span class="comment">// 从右向左遍历，得到i位置处右边的最高值</span></span><br><span class="line">        rightMax[i] = max(rightMax[i+<span class="number">1</span>],height[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;l; i++ &#123;</span><br><span class="line">        ret += min(leftMax[i],rightMax[i])-height[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a&lt;b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a&gt;b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最长回文子串【字节每日一题】"><a href="#最长回文子串【字节每日一题】" class="headerlink" title="最长回文子串【字节每日一题】"></a><a class="link" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串<i class="fas fa-external-link-alt"></i></a>【字节每日一题】</h3><p>&emsp;&emsp;给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 “ababa”，如果我们已经知道 “bab” 是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是 “a”。据这样的思路，我们就可以用动态规划的方法解决本题。我们用 <code>dp(i,j)</code> 表示字符串 s 的第 i 到 j 个字母组成的串（下文表示成 <code>s[i:j]</code>）是否为回文串：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph1.jpg" alt="avatar"></p>
<p>这里的「其它情况」包含两种可能性：</p>
<ul>
<li><p><code>s[i,j]</code> 本身不是一个回文串；</p>
</li>
<li><p><em>i</em>&gt;<em>j</em>，此时 <code>s[i,j]</code>本身不合法。</p>
</li>
</ul>
<p>那么我们就可以写出动态规划的状态转移方程：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph2.jpg" alt="avatar"></p>
<p>也就是说，只有 s[i+1:j−1] 是回文串，并且 s 的第 i 和 j 个字母相同时，s[i:j] 才会是回文串。上文的所有讨论是建立在子串长度大于 2 的前提之上的，我们还需要考虑动态规划中的边界条件，即子串的长度为 1 或 2。对于长度为 1 的子串，它显然是个回文串；对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串。因此我们就可以写出动态规划的边界条件：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph3.jpg" alt="avatar"><br><strong>注意：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">bool</span>,n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>,n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    length := <span class="number">0</span></span><br><span class="line">    subStr := s[:<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> L:=<span class="number">2</span>; L&lt;=n; L++ &#123;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=n-L; i++ &#123;</span><br><span class="line">            j := i+L<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">false</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> L == <span class="number">2</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt; length &#123;</span><br><span class="line">                length = j-i+<span class="number">1</span></span><br><span class="line">                subStr = s[i:j+<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="32-最长有效括号【字节每日一题】"><a href="#32-最长有效括号【字节每日一题】" class="headerlink" title="32. 最长有效括号【字节每日一题】"></a><a class="link" href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号<i class="fas fa-external-link-alt"></i></a>【字节每日一题】</h3><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;)()())&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最长有效括号子串是 &quot;()()&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 3 * 104</code></li>
<li><code>s[i]</code> 为 <code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;结合题目，有<strong>最长</strong>这个字眼，可以考虑尝试使用 <strong>动态规划</strong> 进行分析。这是一个 <strong>最值型</strong> 动态规划的题目。</p>
<p>动态规划题目分析的 4 个步骤：</p>
<ul>
<li>确定状态<ul>
<li>研究最优策略的最后一步</li>
<li>化为子问题</li>
</ul>
</li>
<li>转移方程<ul>
<li>根据子问题定义得到</li>
</ul>
</li>
<li>初始条件和边界情况</li>
<li>计算顺序</li>
</ul>
<p>&emsp;&emsp;首先，我们定义一个 <code>dp</code> 数组，其中第 i<em>i</em> 个元素表示以下标为 i 的字符结尾的最长有效子字符串的长度。</p>
<ul>
<li><strong>确定状态：</strong></li>
</ul>
<p>最后一步：</p>
<p>对于最优的策略，一定有最后一个元素 s[i]。所以，我们先看第 i 个位置，这个位置的元素 s[i]可能有如下两种情况：</p>
<ul>
<li><p><code>s[i]==&#39;(&#39;</code> :  这时，s[i]<em>s</em>[<em>i</em>] 无法和其之前的元素组成有效的括号对，所以，<code>dp[i] = 0</code></p>
</li>
<li><p><code>s[i]==&#39;)&#39;</code>：这时，需要看其前面对元素来判断是否有有效括号对。</p>
<ul>
<li><p>情况1:<code>s[i−1]==&#39;(&#39;</code></p>
<p>即 <code>s[i]</code> 和 <code>s[i−1]</code> 组成一对有效括号，有效括号长度新增长度2，i位置对最长有效括号长度为 其之前2个位置的最长括号长度加上当前位置新增的2，我们无需知道 <code>i−2</code> 位置对字符是否可以组成有效括号对。那么有：<code>dp[i]=dp[i−2]+2</code></p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph4.jpg" alt="avatar"></p>
</li>
<li><p>情况2:<code>s[i-1]==&#39;)&#39;</code></p>
<p>这种情况下，如果前面有和 <code>s[i]</code> 组成有效括号对的字符，即形如 <code>((....))</code>，这样的话，就要求 <code>s[i−1]</code>位置必然是有效的括号对，否则 <code>s[i]</code> 无法和前面对字符组成有效括号对。这时，我们只需要找到和 <code>s[i]</code> 配对对位置，并判断其是否是 <code>(</code> 即可。和其配对对位置为：<code>i−dp[i−1]−1</code>。</p>
<p>如果：<code>s[i−dp[i−1]−1]==&#39;(&#39;</code> :</p>
<p>有效括号长度新增长度2，i<em>i</em>位置对最长有效括号长度为 <strong>i-1位置的最长括号长度加上当前位置新增的2</strong>，那么有：<code>dp[i]=dp[i−1]+2</code>。值得注意的是，<code>i−dp[i−1]−1</code> 和 i 组成了有效括号对，这将是一段独立的有效括号序列，如果之前的子序列是形如 <code>(...)</code> 这种序列，那么当前位置的最长有效括号长度还需要加上这一段。所以：<code>dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2</code></p>
<p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/5.jpg" alt="avatar"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="子问题：设dp数组，其中第-i-个元素表示以下标为-i-的字符结尾的最长有效子字符串的长度。"><a href="#子问题：设dp数组，其中第-i-个元素表示以下标为-i-的字符结尾的最长有效子字符串的长度。" class="headerlink" title="子问题：设dp数组，其中第 i 个元素表示以下标为 i 的字符结尾的最长有效子字符串的长度。"></a>子问题：设dp数组，其中第 i 个元素表示以下标为 i 的字符结尾的最长有效子字符串的长度。</h4></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestValidParentheses</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">            dp[i] = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> i&lt;=<span class="number">2</span> &#123;</span><br><span class="line">                    dp[i] = <span class="number">2</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = dp[i<span class="number">-2</span>] + <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> i-dp[i<span class="number">-1</span>]<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> i-dp[i<span class="number">-1</span>]<span class="number">-2</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">                        dp[i] = dp[i<span class="number">-1</span>]+dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]+<span class="number">2</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i] = dp[i<span class="number">-1</span>]+<span class="number">2</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dp[i] &gt; max &#123;</span><br><span class="line">            max = dp[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;<strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a class="link" href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-ji-ben-ji-qiao/dong-tai-gui-hua-xiang-jie-jin-jie">动态规划解题套路框架<i class="fas fa-external-link-alt"></i></a></p>
<p>2.<a href="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB">动态规划和贪心算法的区别</a></p>
<p>3.<a class="link" href="https://www.jianshu.com/p/99327f542c8a">【数据结构】贪心算法和动态规划<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>动态规划(DP)</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针算法总结</title>
    <url>/2021/05/08/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="双指针算法类型"><a href="#双指针算法类型" class="headerlink" title="双指针算法类型"></a>双指针算法类型</h1><p>&emsp;&emsp;双指针的问题主要可以归为两类，一类是「快慢指针」，主要解决链表中的问题，比如典型的判定链表中是否包含环；另一类是「左右指针」，主要解决数组（或者字符串）中的问题，比如二分查找。</p>
<h2 id="快慢指针的常见算法"><a href="#快慢指针的常见算法" class="headerlink" title="快慢指针的常见算法"></a>快慢指针的常见算法</h2><p>&emsp;&emsp;快慢指针一般都初始化指向链表的头结点 <code>head</code>，前进时快指针 <code>fast</code> 在前，慢指针 <code>slow</code> 在后，巧妙解决一些链表中的问题。</p>
<h3 id="判断链表中是否有环"><a href="#判断链表中是否有环" class="headerlink" title="判断链表中是否有环"></a>判断链表中是否有环</h3><p>&emsp;&emsp;单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。如果链表中不含环，那么这个指针最终会遇到空指针 <code>nil</code> 表示链表到头了，这还好说，可以判断该链表不含环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">    head = head.Next</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 <code>nil</code> 指针作为尾部节点。经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 <code>nil</code>，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。</p>
<p><a class="link" href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="已知链表中含有环，返回这个环的起始位置"><a href="#已知链表中含有环，返回这个环的起始位置" class="headerlink" title="已知链表中含有环，返回这个环的起始位置"></a>已知链表中含有环，返回这个环的起始位置</h3><p><a class="link" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表 II<i class="fas fa-external-link-alt"></i></a></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-21-26.jpg" alt="avatar"></p>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<p>进阶：你是否可以使用 O(1) 空间解决此题？</p>
<p>&emsp;&emsp;当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？</p>
<p>第一次相遇时，假设慢指针 <code>slow</code> 走了 <code>k</code> 步，那么快指针 <code>fast</code> 一定走了 <code>2k</code> 步：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-56-07.jpg" alt="avatar"></p>
<p><strong><code>fast</code></strong> <strong>一定比</strong> <strong><code>slow</code></strong> <strong>多走了</strong> <strong><code>k</code></strong> <strong>步，这多走的</strong> <strong><code>k</code></strong> <strong>步其实就是</strong> <strong><code>fast</code></strong> <strong>指针在环里转圈圈，所以</strong> <strong><code>k</code></strong> <strong>的值就是环长度的「整数倍」</strong>。</p>
<p>说句题外话，之前还有读者争论为什么是环长度整数倍，我举个简单的例子你就明白了，我们想一想极端情况，假设环长度就是 1，如下图：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-57-52.jpg" alt="avatar"></p>
<p>那么 <code>fast</code> 肯定早早就进环里转圈圈了，而且肯定会转好多圈，这不就是环长度的整数倍嘛。</p>
<p>言归正传，设相遇点距环的起点的距离为 <code>m</code>，那么环的起点距头结点 <code>head</code> 的距离为 <code>k - m</code>，也就是说如果从 <code>head</code> 前进 <code>k - m</code> 步就能到达环起点。</p>
<p>巧的是，如果从相遇点继续前进 <code>k - m</code> 步，也恰好到达环起点。你甭管 <code>fast</code> 在环里到底转了几圈，反正走 <code>k</code> 步可以到相遇点，那走 <code>k - m</code> 步一定就是走到环起点了：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-59-23.jpg" alt="avatar"></p>
<p>所以，只要我们把快慢指针中的任一个重新指向 <code>head</code>，然后两个指针同速前进，<code>k - m</code> 步后就会相遇，相遇之处就是环的起点了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            slow = head</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 上面的代码类似 hasCycle 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="keyword">return</span> fast</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="链表的中间结点"><a href="#链表的中间结点" class="headerlink" title=" 链表的中间结点"></a><a class="link" href="https://leetcode-cn.com/problems/middle-of-the-linked-list/"> 链表的中间结点<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;类似上面的思路，我们可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleNode</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当链表的长度是奇数时，<code>slow</code> 恰巧停在中点位置；如果长度是偶数，<code>slow</code> 最终的位置是中间偏右：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-10_21-30-59.jpg" alt="avatar"></p>
<h3 id="查找链表的倒数第-N-个结点"><a href="#查找链表的倒数第-N-个结点" class="headerlink" title="查找链表的倒数第 N 个结点"></a><a class="link" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">查找链表的倒数第 N 个结点<i class="fas fa-external-link-alt"></i></a></h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-10_21-35-57.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1], n &#x3D; 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], n &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;还是使用快慢指针，让快指针先走 <code>n</code> 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 <code>nil</code> 时，慢指针所在的位置就是倒数第 <code>n</code> 个链表节点（<code>n</code> 不会超过链表长度）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123; <span class="comment">// 快指针先走n步</span></span><br><span class="line">        fast = fast.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;</span><br><span class="line">        head = head.Next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    slow.Next = slow.Next.Next  <span class="comment">// 删除这个节点</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a class="link" href="https://leetcode-cn.com/problems/palindrome-linked-list/">回文链表<i class="fas fa-external-link-alt"></i></a></h3><p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<p>&emsp;&emsp;这道题看似很简单，只需要将链表存到数组中，从数组两端开始向中间依次比较，只要有两端的数字不同，立即返回false。可是这样做的空间复杂度为O(n)，有什么办法能将空间复杂度控制为O(1)呢？</p>
<p>&emsp;&emsp;这道题集成了快慢指针，反转链表的操作，很具有代表性。我们要避免使用O(n)的额外空间，就要改变输入，我们可以通过反转后半部分链表，然后将前半部分与后半部分进行比较。该方法可以将空间复杂度降到O(1)，但是在并发环境下，该方法也有缺点，在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。</p>
<p><strong>算法流程：</strong></p>
<p>1.找到前半部分链表的尾节点：可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。若链表有奇数个节点，则中间的节点应该看作是前半部分。</p>
<p>2.反转后半部分链表：同<a class="link" href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表<i class="fas fa-external-link-alt"></i></a>的解决方案。</p>
<p>3.判断是否回文：比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。</p>
<p>4.返回结果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    fast, slow := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123; <span class="comment">// 快慢指针找到中间节点</span></span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123; <span class="comment">// 该链表有偶数个节点</span></span><br><span class="line">        s := reverse(slow)          </span><br><span class="line">        <span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> head.Val != s.Val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            s = s.Next</span><br><span class="line">            head = head.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 该链表有奇数个节点</span></span><br><span class="line">        s := reverse(slow.Next)</span><br><span class="line">        <span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> head.Val != s.Val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            s = s.Next</span><br><span class="line">            head = head.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(p *ListNode)</span> *<span class="title">ListNode</span></span> &#123;  <span class="comment">// 反转链表</span></span><br><span class="line">    h := p</span><br><span class="line">    q := p.Next</span><br><span class="line">    <span class="keyword">for</span> q != <span class="literal">nil</span> &#123;</span><br><span class="line">        temp := q.Next</span><br><span class="line">        q.Next = p</span><br><span class="line">        p = q</span><br><span class="line">        q = temp</span><br><span class="line">    &#125;</span><br><span class="line">    h.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="左右指针的常见算法"><a href="#左右指针的常见算法" class="headerlink" title="左右指针的常见算法"></a>左右指针的常见算法</h2><p>&emsp;&emsp;左右指针在数组中实际是指两个索引值，一般初始化为left:=0, right:=len(array)-1。常见的左右指针算法通常分为四类：1.二分查找；2.两数之和；3.反转数组；4.滑动窗口。其中以滑动窗口最为困难，已经有专门的专题<a href="https://jiahaohong1997.github.io/2021/04/28/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(Sliding-Window)%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/">滑动窗口(Sliding Window)算法框架</a>来介绍。其他三类只要掌握了基本框架，基本都能解决。</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h4 id="二分查找的三种基本框架"><a href="#二分查找的三种基本框架" class="headerlink" title="二分查找的三种基本框架"></a>二分查找的三种基本框架</h4><p>1.寻找某一个特定的数(最基本的二分查找)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	left := <span class="number">0</span></span><br><span class="line">  	right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">for</span> left &lt;= right &#123;  <span class="comment">// 注意符号</span></span><br><span class="line">  			mid := left + (right-left)/<span class="number">2</span>  <span class="comment">// 如果使用(left+right)/2的方式，可能导致溢出</span></span><br><span class="line">    		<span class="keyword">if</span> nums[mid] == target &#123;  <span class="comment">// 一旦找到。立即返回</span></span><br><span class="line">      			<span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">          	left = mid + <span class="number">1</span>  <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	right = mid - <span class="number">1</span>  <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的地方(也是区分于其他框架的地方)：</p>
<ul>
<li>循环中符号是&lt;=</li>
<li>一旦nums[mid]查找到，立即返回mid</li>
<li>left = mid + 1   right = mid - 1</li>
</ul>
<p>2.寻找左侧边界的二分查找</p>
<p>&emsp;&emsp;这个左边界不仅限于target存在于数组中，也可以找到其不在数组时的左边界。举例如下：</p>
<p>nums[] = {2,3,4,5,5,5,6,9,17} , target=5, 其左边界为索引3</p>
<p>nums[] = {2,2,3,4,4,4,6,7,7,8,9,456}, target=5, 其左边界索引为5</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">left_bound</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">-1</span> </span><br><span class="line">  	&#125;</span><br><span class="line">  	left := <span class="number">0</span></span><br><span class="line">  	right := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">for</span> left &lt; right &#123;  <span class="comment">// 注意符号</span></span><br><span class="line">      	mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">      	<span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">        		right = mid <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">          	left = mid + <span class="number">1</span> <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	right = mid <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">  	&#125; </span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> nums[left] == target &#123; <span class="comment">// 等于target，直接返回左边界</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>] &lt; target &#123; <span class="comment">// 如果最后一个数都小于target，此时left指向的是最后一个数，此时将其最为左边界的话直接返回left。如果在一开始就对边界情况做了判断，就不需要对这一条件做判断</span></span><br><span class="line">        <span class="keyword">return</span> left  <span class="comment">// left=len(nums)-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> left<span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的地方:</p>
<ul>
<li>循环中符号是&lt;，所以当数组只有一个元素时，不会进入for循环，要单独判断；因为是小于符号，所以出循环，left和right都不可能越界，这就意味着如果数组最后一个数 &lt; target，按理说要返回前一个数的索引，但是由于right卡在了数组末尾元素上，循环结束的条件是left=right，所以此时左边界直接返回left，而不需要left-1</li>
<li>查找到nums[mid]=target，不直接返回，让right=mid，锁定住</li>
<li>left = mid+1    right = mid</li>
<li>最终判断一下nums[left]是否等于target，等于说明target在数组中，直接返回left，否则返回left-1</li>
<li>找左边界的时候记得优先判断一下有序数组中最后一个数是否大于target，若最大的数都小于target，说明整个数组的左边界只能由最后一位数来担任，left=len(nums)-1</li>
</ul>
<p>3.寻找右侧边界的二分查找</p>
<p>&emsp;&emsp;这个右边界不仅限于target存在于数组中，也可以找到其不在数组时的右边界。举例如下：</p>
<p>nums[] = {2,3,4,5,5,5,6,9,17} , target=5, 其右边界为索引5</p>
<p>nums[] = {2,2,3,4,4,4,6,7,7,8,9,456}, target=5, 其右边界索引为6</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">right_bound</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span> </span><br><span class="line">  	&#125;</span><br><span class="line">  	left := <span class="number">0</span></span><br><span class="line">  	right := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">for</span> left &lt; right &#123;  <span class="comment">// 注意符号</span></span><br><span class="line">      	mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">      	<span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">        		left = mid + <span class="number">1</span> <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">          	left = mid + <span class="number">1</span> <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	right = mid <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">  	&#125; </span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">if</span> nums[left] == target &#123; <span class="comment">// 第一位数或最后一位数作为右边界，如果在一开始就对边界情况做了判断，可以不需要对这一个条件做判断</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  	&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[left<span class="number">-1</span>] == target &#123;  <span class="comment">// 注意</span></span><br><span class="line">    	<span class="keyword">return</span> left<span class="number">-1</span></span><br><span class="line">  	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> left</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的地方:</p>
<ul>
<li>循环中符号是&lt;，所以当数组只有一个元素时，不会进入for循环，要单独判断；因为是小于符号，所以出循环，left和right都不可能越界，这就意味着如果数组第一个数 &gt; target，left一定会一直卡在索引0位置上，循环结束的条件是left=right，所以此时left=0，要判断nums[left-1]是否等于target，显然发生了越界，所以直接使用left(=0)作为右边界</li>
<li>查找到nums[mid]=target，不直接返回，让left = mid + 1，锁定住</li>
<li>left = mid + 1   right = mid</li>
<li>最终判断一下nums[left-1]是否等于target，等于说明target在数组中，直接返回left-1，否则返回left</li>
</ul>
<p>&emsp;&emsp;寻找左右边界这两个框架出来的left其实可以看成是一个永远指向target右侧的一个指针(不管这个target是否在数组中)，见下面示意：</p>
<p>··· ···, a,  a, a, [b, b, b, b,] c, c, c, ··· ···</p>
<ul>
<li><p>b是target，[]表示其可能存在在数组中，当找其左边界时，left指针所在位置如下：</p>
<p>  ··· ···, a,  a, a, [b(<em>left</em>), b, b, b,] c, c, c, ··· ···</p>
<p>  当b存在在数组中，则直接输出left，当b不在数组中，则a是其左边界，输出left-1</p>
</li>
<li><p>b是target，[]表示其可能存在在数组中，当找其右边界时，left指针所在位置如下：</p>
<p>  ··· ···, a,  a, a, [b, b, b, b,] c(<em>left</em>), c, c, ··· ···</p>
<p>  当b存在在数组中，则输出left-1，当b不在数组中，则c是其有边界，输出left</p>
</li>
</ul>
<table><tr><td bgcolor="yellow">&emsp;&emsp;总而言之，首先考虑数组只有一个元素或没有元素的情况。之后将target和首位元素做比较，看首位元素是否是其左右边界，或者target可能干脆就不在这个数组的范围内。之后再正式套用上述框架来找左右边界。</td></tr></table>

<h4 id="寻找旋转排序数组中的最小值-II"><a href="#寻找旋转排序数组中的最小值-II" class="headerlink" title="寻找旋转排序数组中的最小值 II"></a><a class="link" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">寻找旋转排序数组中的最小值 II<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]<br>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,5]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p>n == nums.length<br>1 &lt;= n &lt;= 5000<br>-5000 &lt;= nums[i] &lt;= 5000<br>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</p>
<p>&emsp;&emsp;该题相当于要找到数组中最小值的左边界(最小值可能不止一个)。left指针移动的条件是当mid指针所指的数大于right指针所指数，那么mid所指的数一定不可能是边界区域，left=mid+1。当出现nums[mid]&lt;nums[right]时，说明nums[mid]已经在最小值左边界的右方，此时固定住right指针，继续二分查找。有区别的是当出现nums[mid]=nums[right]的情况时，原先的二分查找是严格的赠序数组，可以直接让right=mid，锁定住右边界。但是如出现下面的情况：nums数组为**[3,3,1,3]**，直接让right=mid会跳过中间的小值，所以只需要让right指针减一，缩小搜索范围即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left&lt;right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[right] &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; nums[right] &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="搜索旋转排序数组-II"><a href="#搜索旋转排序数组-II" class="headerlink" title="搜索旋转排序数组 II"></a><a class="link" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组 II<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p>
<p>&emsp;&emsp;在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k（0 &lt;= k &lt; nums.length）</code>上进行了 旋转 ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如，<code> [0,1,2,4,4,4,5,6,6,7]</code> 在下标 5 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p>
<p>&emsp;&emsp;给你 旋转后 的数组 <code>nums</code> 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 5000</span><br><span class="line">-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</span><br><span class="line">题目数据保证 nums 在预先未知的某个下标上进行了旋转</span><br><span class="line">-104 &lt;&#x3D; target &lt;&#x3D; 104</span><br></pre></td></tr></table></figure>



<p>解题思路：</p>
<p>&emsp;&emsp;    找目标数，首先考虑二分查找。但是本题的数组在<code>[left,mid]</code>和<code>[mid,right]</code>两段区间内只有一段是有序的。要用二分查找找target，就必须在有序的区间查找。所以要理清可能出现的三种情况：</p>
<ul>
<li>第一类</li>
</ul>
<p>&emsp;&emsp;对于数组中有重复元素的情况，二分查找时可能会有 <code>nums[lelf]=nums[mid]=nums[right]</code>，此时无法判断区间 <code>[left,mid]</code> 和区间<code>[mid+1,right]</code>哪个是有序的。例如 <code>nums=[3,1,2,3,3,3,3]</code>，<code>target=2</code>，首次二分时无法判断区间 <code>[0,3]</code> 和区间 <code>[4,6] </code>哪个是有序的。对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。</p>
<ul>
<li>第二类</li>
</ul>
<p>&emsp;&emsp;<code>nums=[2,3,4,5,6,7,1]</code> 这种，也就是<code> nums[left] &lt; nums[mid]</code>。此例子中就是 2 &lt; 5；这种情况下，前半部分有序。因此如果 <code>nums[left]&lt;=target&lt;nums[mid]</code>，则在前半部分找，否则去后半部分找。</p>
<ul>
<li>第三类</li>
</ul>
<p>&emsp;&emsp;<code>nums=[6,7,1,2,3,4,5]</code>这种，也就是 <code>nums[left] &gt; nums[mid]</code>。此例子中就是 6 &gt; 2；这种情况下，后半部分有序。因此如果 <code>nums[mid]&lt;target&lt;=nums[right]</code>。则在后半部分找，否则去前半部分找。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;  <span class="comment">// 找具体的数，用&lt;=</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[left] == nums[mid] &amp;&amp; nums[mid] == nums[right] &#123;  <span class="comment">//第一类情况</span></span><br><span class="line">            left++</span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[left] &lt;= nums[mid] &#123;  <span class="comment">// 左边有序</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target &#123;</span><br><span class="line">                right = mid<span class="number">-1</span>  <span class="comment">// 在前半部分找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>   <span class="comment">// 在后半部分找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右边有序 </span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>   <span class="comment">// 在后半部分找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid<span class="number">-1</span>  <span class="comment">// 在前半部分找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="在-D-天内送达包裹的能力"><a href="#在-D-天内送达包裹的能力" class="headerlink" title="在 D 天内送达包裹的能力"></a><a class="link" href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">在 D 天内送达包裹的能力<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</p>
<p>&emsp;&emsp;传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>
<p>&emsp;&emsp;返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：weights &#x3D; [3,2,2,4,1,4], D &#x3D; 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：3, 2</span><br><span class="line">第 2 天：2, 4</span><br><span class="line">第 3 天：1, 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：weights &#x3D; [1,2,3,1,1], D &#x3D; 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第 1 天：1</span><br><span class="line">第 2 天：2</span><br><span class="line">第 3 天：3</span><br><span class="line">第 4 天：1, 1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; D &lt;&#x3D; weights.length &lt;&#x3D; 5 * 104</span><br><span class="line">1 &lt;&#x3D; weights[i] &lt;&#x3D; 500</span><br></pre></td></tr></table></figure>

<p>算法思路：</p>
<p>&emsp;&emsp;假设当船的运载能力为 <code>x</code> 时，我们可以在 <code>days</code> 天内运送完所有包裹，那么只要运载能力大于 <code>x</code>，我们同样可以在 <code>days</code> 天内运送完所有包裹：我们只需要使用运载能力为 <code>x</code> 时的运送方法即可。</p>
<p>&emsp;&emsp;这样一来，我们就得到了一个非常重要的结论：</p>
<p>存在一个运载能力的「下限」$$x _\text { ans }$$，使得当 <code>x</code> ≥ $$x _\text { ans }$$时，我们可以在 <code>days</code> 天内运送完所有包裹；当 <code>x</code>&lt;<br>$$x _\text { ans }$$时，我们无法在 <code>days</code> 天内运送完所有包裹。</p>
<p>&emsp;&emsp;同时，$$x _\text { ans }$$即为我们需要求出的答案。因此，我们就可以使用二分查找的方法找出 $$x _\text { ans }$$的值。在二分查找的每一步中，我们实际上需要解决一个判定问题：给定船的运载能力 <code>x</code>，我们是否可以在 <code>days</code> 天内运送完所有包裹呢？这个判定问题可以通过贪心的方法来解决：</p>
<p>&emsp;&emsp;由于我们必须按照数组 <code>weights</code> 中包裹的顺序进行运送，因此我们从数组 <code>weights</code> 的首元素开始遍历，将连续的包裹都安排在同一天进行运送。当这批包裹的重量大于运载能力 <code>x</code> 时，我们就需要将最后一个包裹拿出来，安排在新的一天，并继续往下遍历。当我们遍历完整个数组后，就得到了最少需要运送的天数。</p>
<p>&emsp;&emsp;我们将「最少需要运送的天数」与 <code>days</code> 进行比较，就可以解决这个判定问题。当其小于等于 <code>days</code> 时，我们就忽略二分的右半部分区间；当其大于 <code>days</code> 时，我们就忽略二分的左半部分区间。</p>
<p><strong>细节</strong></p>
<p>二分查找的初始左右边界应当如何计算呢？</p>
<p>对于左边界而言，由于我们不能「拆分」一个包裹，因此船的运载能力不能小于所有包裹中最重的那个的重量，即左边界为数组 <code>weights</code> 中元素的最大值。</p>
<p>对于右边界而言，船的运载能力也不会大于所有包裹的重量之和，即右边界为数组 <code>weights</code> 中元素的和。</p>
<p>我们从上述左右边界开始进行二分查找，就可以保证找到最终的答案。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shipWithinDays</span><span class="params">(weights []<span class="keyword">int</span>, days <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := weights[<span class="number">0</span>]</span><br><span class="line">    right := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(weights); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> weights[i] &gt; left &#123;  <span class="comment">// 设置运载能力左边界为货物中最大重量</span></span><br><span class="line">            left = weights[i]</span><br><span class="line">        &#125;</span><br><span class="line">        right += weights[i]			<span class="comment">// 设置运载能力有边界为货物总重量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> check <span class="function"><span class="keyword">func</span><span class="params">(<span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">    check = <span class="function"><span class="keyword">func</span><span class="params">(<span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        temp := <span class="number">0</span> <span class="comment">// 一天内运送货物重量的累积</span></span><br><span class="line">        day := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> weights &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">cap</span> &lt; temp+v &#123;  <span class="comment">// 超过🚢的运载能力，天数+1</span></span><br><span class="line">                day++</span><br><span class="line">                temp = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            temp += v</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> temp != <span class="number">0</span> &#123;</span><br><span class="line">            day++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> day&lt;=days &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123; <span class="comment">// 二分查找满足运送天数的🚢运载能力的左边界</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> check(mid) &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a><a class="link" href="https://leetcode-cn.com/problems/search-a-2d-matrix/">搜索二维矩阵<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-02_20-29-44.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-02_20-31-06.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D;&#x3D; matrix.length</span><br><span class="line">n &#x3D;&#x3D; matrix[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 100</span><br><span class="line">-104 &lt;&#x3D; matrix[i][j], target &lt;&#x3D; 104</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;对于本题，主要的思路就是先通过对每行的首个数字组成的序列进行二分查找，首先要判断target是否在最后一行中，如果是的话，直接在最后一行进行二分查找。这么做的目的是如果直接二分查找target的左边界，如果最后一行的首位数小于target，此时不能将接下来继续二分查找的行数定位left-1，要直接在left行(也就是最后一行)进行查找。简单来说，left的最大值只可能是<code>len(matrix)-1</code>，然而要找的左边界是<code>left-1</code>，这样最后一行永远都无法被选中。读者可以自己找一个实际的例子来看一看。</p>
<p>&emsp;&emsp;若不在最后一行，那么就进行二分查找找到target的左边界，这时会出现两种情况：</p>
<ul>
<li>左边界恰好是要找的target，直接返回true</li>
<li>左边界位于非最后一行，定位到target可能出现的那一行<code>row=left-1</code></li>
</ul>
<p>&emsp;&emsp;最后再在找到的行进行二分查找。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(matrix)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    r := <span class="built_in">len</span>(matrix) <span class="comment">// 行数</span></span><br><span class="line">    c := <span class="built_in">len</span>(matrix[<span class="number">0</span>])  <span class="comment">// 列数</span></span><br><span class="line">    <span class="keyword">var</span> row <span class="keyword">int</span></span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 边界情况：target超出了二维数组的范围，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[r<span class="number">-1</span>][c<span class="number">-1</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">1</span> &amp;&amp; matrix[r<span class="number">-1</span>][<span class="number">0</span>] &gt; target &#123; <span class="comment">// 当不止有一行并且target不在最后一行时</span></span><br><span class="line">        <span class="keyword">for</span> left &lt; right &#123; <span class="comment">// 找左边界，可以参考模板2</span></span><br><span class="line">            mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] == target &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] &lt; target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> matrix[left][<span class="number">0</span>] == target &#123; <span class="comment">// 如果left指向的数等于target，直接返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则可以定位target可能出现的行号</span></span><br><span class="line">            row = left<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> r == <span class="number">1</span> &#123;  <span class="comment">// 如果只有一行，则无需二分查找</span></span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果target可能出现在最后一行</span></span><br><span class="line">        row = r<span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leftRow := <span class="number">0</span></span><br><span class="line">    rightRow := c<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> leftRow &lt;= rightRow &#123; <span class="comment">// 使用二分查找在确定的行上查找</span></span><br><span class="line">        mid := leftRow + (rightRow-leftRow)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> matrix[row][mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[row][mid] &gt; target &#123;</span><br><span class="line">            rightRow = mid<span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftRow = mid+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="搜索二维矩阵-II"><a href="#搜索二维矩阵-II" class="headerlink" title="搜索二维矩阵 II"></a><a class="link" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">搜索二维矩阵 II<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-17_16-40-38.jpg" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">19</span>],[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">22</span>],[<span class="number">10</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">17</span>,<span class="number">24</span>],[<span class="number">18</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">26</span>,<span class="number">30</span>]], target = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-17_16-42-30.jpg" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">19</span>],[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">22</span>],[<span class="number">10</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">17</span>,<span class="number">24</span>],[<span class="number">18</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">26</span>,<span class="number">30</span>]], target = <span class="number">20</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m == matrix.length</span><br><span class="line">n == matrix[i].length</span><br><span class="line"><span class="number">1</span> &lt;= n, m &lt;= <span class="number">300</span></span><br><span class="line"><span class="number">-109</span> &lt;= matix[i][j] &lt;= <span class="number">109</span></span><br><span class="line">每行的所有元素从左到右升序排列</span><br><span class="line">每列的所有元素从上到下升序排列</span><br><span class="line"><span class="number">-109</span> &lt;= target &lt;= <span class="number">109</span></span><br></pre></td></tr></table></figure>

<p>算法思路：</p>
<p>&emsp;&emsp;不同于上一题每一行的第一个元素大于前一行的第一个元素，本题要暴力搜索的话需要对每一行进行二分查找。可以考虑先确定目标数可能存在于哪几行内，对这几行进行搜索即可。</p>
<ul>
<li>对每行的最后一个元素进行二分查找，寻找<code>target</code>的左边界，可以确定起始行号</li>
<li>对每一行第一个元素进行二分查找，寻找<code>target</code>的左边界，可以确定终止行号</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    r, c := <span class="built_in">len</span>(matrix)<span class="number">-1</span>,<span class="built_in">len</span>(matrix[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    row1 := <span class="number">0</span></span><br><span class="line">    row2 := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> matrix[r][c] &lt; target &#123; <span class="comment">// 如果最后一个元素小于target，直接返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[r][c] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left,right := <span class="number">0</span>,r</span><br><span class="line">        <span class="keyword">for</span> left&lt;right &#123;</span><br><span class="line">            mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[mid][c] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[mid][c] &gt; target &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        row2 = left <span class="comment">// 起始行号=左边界+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> matrix[r][<span class="number">0</span>] &lt; target &#123;</span><br><span class="line">        row1 = r</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[r][<span class="number">0</span>] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left,right := <span class="number">0</span>,r</span><br><span class="line">        <span class="keyword">for</span> left&lt;right &#123;</span><br><span class="line">            mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] &gt; target &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        row1 = left<span class="number">-1</span> <span class="comment">// 终止行号=左边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fmt.Println(row2)</span></span><br><span class="line">    <span class="comment">// fmt.Println(row1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> row2&gt;row1 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> row2 &lt;= row1 &#123;  <span class="comment">// 对可能的行内进行二分查找</span></span><br><span class="line">        left,right := <span class="number">0</span>,c</span><br><span class="line">        <span class="keyword">for</span> left&lt;=right &#123;</span><br><span class="line">            mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[row2][mid] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[row2][mid] &lt; target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 right = mid<span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        row2++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><a class="link" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p><strong>进阶：</strong></p>
<p>你可以设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题吗?</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [], target &#x3D; 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>&emsp;&emsp;本题直接找左右边界即可，首先判断边界情况：</p>
<ul>
<li>数组为空，直接返回<code>[-1,-1]</code></li>
<li>数组只有一个元素，若该元素=target，返回<code>[0,0]</code>；否则，返回<code>[-1,-1]</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">len</span>(nums) == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] != target) || <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123; <span class="comment">// 找左边界</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nums[left] == target &#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, left)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 找不到target，其左边界是数组中最大的比它小的数</span></span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;    <span class="comment">// 找右边界</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 因为在找左边界的时候已经判断过该数组中是否存在target，能到这一步肯定是存在的。不用顾虑第一个数大 于target的情况</span></span><br><span class="line">    <span class="keyword">if</span> nums[left] == target &#123; <span class="comment">// 右边界是数组第一个数</span></span><br><span class="line">        ret = <span class="built_in">append</span>(ret,left)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右边界是其他数</span></span><br><span class="line">        ret = <span class="built_in">append</span>(ret, left<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="两数之和类题目"><a href="#两数之和类题目" class="headerlink" title="两数之和类题目"></a>两数之和类题目</h3><h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a class="link" href="https://leetcode-cn.com/problems/two-sum/">两数之和<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target  的那两个整数，并返回它们的数组下标。</p>
<p>&emsp;&emsp;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>&emsp;&emsp;你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 &lt;&#x3D; nums.length &lt;&#x3D; 104</span><br><span class="line">-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</span><br><span class="line">-109 &lt;&#x3D; target &lt;&#x3D; 109</span><br><span class="line">只会存在一个有效答案</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	  sort.Ints(nums)  <span class="comment">// 给数组排序</span></span><br><span class="line">  	l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">  	ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;<span class="number">2</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> ret</span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">     		<span class="keyword">if</span> nums[l]&gt;target &#123;</span><br><span class="line">        		<span class="keyword">break</span></span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="keyword">if</span> nums[l]+nums[r] == target &#123;</span><br><span class="line">        		ret = <span class="built_in">append</span>(ret,l,r)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[l]+nums[r] &gt; target &#123;</span><br><span class="line">          	r--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	l++</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>本题也可使用map来做</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        another := target - value</span><br><span class="line">        _, ok := m[another]</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;index, m[another]&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m[value] = index      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a class="link" href="https://leetcode-cn.com/problems/3sum/">三数之和<i class="fas fa-external-link-alt"></i></a></h4><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; nums.length &lt;&#x3D; 3000</span><br><span class="line">-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</span><br></pre></td></tr></table></figure>



<p>算法思路：</p>
<p>&emsp;&emsp;整体思路和两数之和非常像，不过是通过遍历数组固定第一个数，后两个数使用双指针的方式进行查找。注意的是不能输出重复的三元组，所以在遍历的要判断一下是否和之前的数相等，相等则跳过该数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>]==<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;nums&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort.Ints(nums)  <span class="comment">// 排序数组</span></span><br><span class="line">    res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k:=<span class="number">0</span>; k&lt;<span class="built_in">len</span>(nums)<span class="number">-2</span>; k++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[k] &gt; <span class="number">0</span> &#123; <span class="comment">// 如果最小的数都大于0，直接结束循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> k&gt;<span class="number">0</span> &amp;&amp; nums[k] == nums[k<span class="number">-1</span>] &#123; <span class="comment">// 为避免重复，跳过已经出现的数</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tmp := nums[k]</span><br><span class="line">        i,j := k+<span class="number">1</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i&lt;j &#123;</span><br><span class="line">            <span class="keyword">if</span> tmp+nums[i]+nums[j] == <span class="number">0</span> &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res,[]<span class="keyword">int</span>&#123;tmp,nums[i],nums[j]&#125;)</span><br><span class="line">                i++</span><br><span class="line">                j--</span><br><span class="line">                <span class="keyword">for</span> i&lt;j &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123; <span class="comment">// 为避免重复，跳过已经出现的数</span></span><br><span class="line">                    i++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> i&lt;j &amp;&amp; nums[j] == nums[j+<span class="number">1</span>] &#123; <span class="comment">// 为避免重复，跳过已经出现的数</span></span><br><span class="line">                    j--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> tmp+nums[i]+nums[j] &gt; <span class="number">0</span> &#123;</span><br><span class="line">                j--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a><a class="link" href="https://leetcode-cn.com/problems/4sum/">四数之和<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的四元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [], target &#x3D; 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; nums.length &lt;&#x3D; 200</span><br><span class="line">-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</span><br><span class="line">-109 &lt;&#x3D; target &lt;&#x3D; 109</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;类似于三数之和，不过是在三数之和最外层再套一个for循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>]+nums[<span class="number">3</span>] == target&#123;</span><br><span class="line">            <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">3</span>]&#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    sort.Ints(nums)  <span class="comment">// 首先进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums)<span class="number">-3</span>; i++ &#123; <span class="comment">// 最外层循环，固定四元组的第一位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &#123; <span class="comment">// 过滤掉可能出现相同四元组的情况</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span>; j&lt;<span class="built_in">len</span>(nums)<span class="number">-2</span>; j++ &#123; <span class="comment">// 中层循环，遍历数组选择住四元组的第二位</span></span><br><span class="line">            <span class="keyword">if</span> j&gt;i+<span class="number">1</span> &amp;&amp; nums[j]==nums[j<span class="number">-1</span>] &#123; <span class="comment">// 过滤掉可能出现相同四元组的情况</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            l,r := j+<span class="number">1</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> l&lt;r &#123; <span class="comment">// 内层循环，双指针选择四元组的最后两位</span></span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j]+nums[l]+nums[r] == target &#123;</span><br><span class="line">                    res = <span class="built_in">append</span>(res,[]<span class="keyword">int</span>&#123;nums[i],nums[j],nums[l],nums[r]&#125;)</span><br><span class="line">                    l++</span><br><span class="line">                    r--</span><br><span class="line">                    <span class="keyword">for</span> l&lt;r &amp;&amp; nums[l]==nums[l<span class="number">-1</span>] &#123; <span class="comment">// 过滤掉可能出现相同四元组的情况</span></span><br><span class="line">                        l++</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> l&lt;r &amp;&amp; nums[r]==nums[r+<span class="number">1</span>] &#123; <span class="comment">//过滤掉可能出现相同四元组的情况</span></span><br><span class="line">                        r--</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j]+nums[l]+nums[r] &lt; target &#123;</span><br><span class="line">                    l++</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h3><h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a><a class="link" href="https://leetcode-cn.com/problems/reverse-string/">反转字符串<i class="fas fa-external-link-alt"></i></a></h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseString</span><span class="params">(s []<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">    l,r := <span class="number">0</span>,<span class="built_in">len</span>(s)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l&lt;r &#123;</span><br><span class="line">        s[l],s[r] = s[r],s[l]</span><br><span class="line">        l++</span><br><span class="line">        r--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="补充：剑指-Offer-24-反转链表"><a href="#补充：剑指-Offer-24-反转链表" class="headerlink" title="补充：剑指 Offer 24. 反转链表"></a>补充：<a class="link" href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。</p>
<p>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head.Next.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        p := head.Next</span><br><span class="line">        p.Next = head</span><br><span class="line">        head.Next = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line">    first,second,third := head,head.Next,head.Next.Next</span><br><span class="line">    first.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> third.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        second.Next = first</span><br><span class="line">        first = second</span><br><span class="line">        second = third</span><br><span class="line">        third = third.Next</span><br><span class="line">    &#125;</span><br><span class="line">    third.Next = second</span><br><span class="line">    second.Next = first</span><br><span class="line">    <span class="keyword">return</span> third</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><p>&emsp;&emsp;这个类型的题目是很有难度的，有专门的文章进行介绍。<a href="https://jiahaohong1997.github.io/2021/04/28/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(Sliding-Window)%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/">滑动窗口(Sliding Window)算法框架</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a class="link" href="https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-3/shuang-zhi-zhen-ji-qiao">双指针技巧总结<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Uniform Resource Locator (URL)</title>
    <url>/2021/06/09/Uniform%20Resource%20Locator(URL)/</url>
    <content><![CDATA[<h1 id="什么是URL？"><a href="#什么是URL？" class="headerlink" title="什么是URL？"></a>什么是URL？</h1><p>&emsp;&emsp;<strong>URL 代表着是统一资源定位符（*</strong>Uniform Resource Locator*<strong>）</strong>。URL 无非就是一个给定的独特资源在 Web 上的地址。理论上说，每个有效的 URL 都指向一个唯一的资源。这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像，等等。而在实际中，也有一些例外，最常见的情况就是一个 URL 指向了不存在的或是被移动过的资源。由于通过 URL 呈现的资源和 URL 本身由 Web 服务器处理，因此 web 服务器的拥有者需要认真地维护资源以及与它关联的URL。其基本格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">scheme:<span class="comment">//host[:port#]/path/.../[?query-string][#anchor]</span></span><br><span class="line">scheme         指定底层使用的协议(例如：http, https, ftp)</span><br><span class="line">host           HTTP 服务器的 IP 地址或者域名</span><br><span class="line">port#          HTTP 服务器的默认端口是 <span class="number">80</span>，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http:<span class="comment">//www.cnblogs.com:8080/</span></span><br><span class="line">path           访问资源的路径</span><br><span class="line">query-string   发送给 http 服务器的数据</span><br><span class="line">anchor         锚</span><br></pre></td></tr></table></figure>



<h1 id="深入探究"><a href="#深入探究" class="headerlink" title="深入探究"></a>深入探究</h1><p>下面是一些URL的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;developer.mozilla.org</span><br><span class="line">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Learn&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;search?q&#x3D;URL</span><br></pre></td></tr></table></figure>

<p>您可以将上面的这些网址输进您的浏览器地址栏来告诉浏览器加载相关联的页面（或资源）。</p>
<p>&emsp;&emsp;一个URL由不同的部分组成，其中一些是必须的，而另一些是可选的。让我们以下面这个URL为例看看其中最重要的部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.example.com:80&#x2F;path&#x2F;to&#x2F;myfile.html?key1&#x3D;value1&amp;key2&#x3D;value2#SomewhereInTheDocument</span><br></pre></td></tr></table></figure>

<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-14-08.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>http</code> 是协议。浏览器必须使用的协议通常都是<code>HTTP</code>协议或是<code>HTTP</code>协议的安全版，即<code>HTTPS</code>。Web需要它们二者之一，但浏览器也知道如何处理其他协议，比如<code>mailto</code>:（打开邮件客户端）或者<code>ftp</code>:（处理文件传输），所以当你看到这些协议时，不必惊讶。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-18-06.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>www.example.com</code> 是域名。 它表明正在请求哪个Web服务器。或者，可以直接使用<a class="link" href="https://developer.mozilla.org/zh-CN/docs/Glossary/IP_Address">IP address<i class="fas fa-external-link-alt"></i></a>, 但是因为它不太方便，所以它不经常在网络上使用。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-36-49.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>:80</code> 是端口。 它表示用于访问Web服务器上的资源的技术“门”。如果Web服务器使用HTTP协议的标准端口（HTTP为80，HTTPS为443）来授予其资源的访问权限，则通常会被忽略。否则是强制性的。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-52-10.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>/path/to/myfile.html</code> 是网络服务器上资源的路径。在Web的早期阶段，像这样的路径表示Web服务器上的物理文件位置。如今，它主要是由没有任何物理现实的Web服务器处理的抽象。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-53-21.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>?key1=value1&amp;key2=value2</code> 是提供给网络服务器的额外参数。 这些参数是用 <code>&amp; </code>符号分隔的键/值对列表。在返回资源之前，Web服务器可以使用这些参数来执行额外的操作。每个Web服务器都有自己关于参数的规则，唯一可靠的方式来知道特定Web服务器是否处理参数是通过询问Web服务器所有者。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-55-04.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>#SomewhereInTheDocument</code> 是资源本身的另一部分的锚点. 锚点表示资源中的一种“书签”，给浏览器显示位于该“加书签”位置的内容的方向。例如，在HTML文档上，浏览器将滚动到定义锚点的位置;在视频或音频文档上，浏览器将尝试转到锚代表的时间。值得注意的是，＃后面的部分（也称为片段标识符）从来没有发送到请求的服务器。</p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议详解</title>
    <url>/2021/06/17/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>本文主要参考来源<a class="link" href="https://learnku.com/docs/build-web-application-with-golang/031-web-working-mode/3168">《Go Web编程》<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="HTTP协议介绍"><a href="#HTTP协议介绍" class="headerlink" title="HTTP协议介绍"></a>HTTP协议介绍</h2><p>&emsp;&emsp;HTTP协议是一种让web服务器与浏览器(客户端)通过网络发送和接收数据的协议。它建立在TCP之上，默认采用TCP的80端口。浏览器(客户端)每发出一个请求，服务器响应这个请求。在HTTP中，浏览器(客户端)总是通过建立连接并发送一个HTTP请求来发起一个事务，服务端不能主动去和客户端联系，也不能给客户端发送一个回调连接。客户端与服务器端都可以提前终结一个连接。例如，当浏览器下载一个文件时，可以通过“停止键”来中断文件的下载，关闭与服务器的TCP连接。</p>
<p>&emsp;&emsp;HTTP协议是无状态的，同一个客户端的这次请求和上次请求是没有关系的，对于HTTP服务器来说，它并不知道这两个请求是否来自同一个客户端。为了解决这个问题，web程序引入了cookie机制来维护连接的可持续状态。</p>
<h2 id="HTTP请求包-浏览器信息"><a href="#HTTP请求包-浏览器信息" class="headerlink" title="HTTP请求包(浏览器信息)"></a>HTTP请求包(浏览器信息)</h2><p>&emsp;&emsp;请求包(Request)的结构包含3个部分：Request line(请求行)、Request header(请求头)、body(主体)。header 和 body 之间有个空行，请求包的例子所示:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">GET /domains/example/ HTTP/<span class="number">1.1</span>      <span class="comment">// 请求行: 请求方法 请求 URI HTTP 协议/协议版本</span></span><br><span class="line">Host：www.iana.org               <span class="comment">// 服务端的主机名</span></span><br><span class="line">User-Agent：Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.1</span>) AppleWebKit/<span class="number">537.4</span> (KHTML, like Gecko) Chrome/<span class="number">22.0</span><span class="number">.1229</span><span class="number">.94</span> Safari/<span class="number">537.4</span>          <span class="comment">// 浏览器信息</span></span><br><span class="line">Accept：text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*<span class="comment">/*;q=0.8  // 客户端能接收的 mine</span></span><br><span class="line"><span class="comment">Accept-Encoding：gzip,deflate,sdch       // 是否支持流压缩</span></span><br><span class="line"><span class="comment">Accept-Charset：UTF-8,*;q=0.5        // 客户端字符编码集</span></span><br><span class="line"><span class="comment">// 空行,用于分割请求头和消息体</span></span><br><span class="line"><span class="comment">// 消息体,请求资源参数,例如 POST 传递的参数</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;HTTP 协议定义了很多与服务器交互的请求方法，最基本的有 4 种，分别是 GET, POST, PUT, DELETE。一个 URL 地址用于描述一个网络上的资源，而 HTTP 中的 GET, POST, PUT, DELETE 就对应着对这个资源的查，增，改，删 4 个操作。我们最常见的就是 GET 和 POST 了。GET 一般用于获取 / 查询资源信息，而 POST 一般用于更新资源信息。</p>
<p>&emsp;&emsp;通过 fiddler 抓包可以看到如下请求信息:</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-17_10-48-21.jpg" width="70%" height="70%"></div>

<p>&emsp;&emsp;fiddler 抓取的 GET 信息:</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-17_11-05-48.jpg" width="70%" height="70%"></div>

<p>&emsp;&emsp;GET 和 POST 的区别:</p>
<ol>
<li>我们可以看到 GET 请求消息体为空，POST 请求带有消息体。</li>
<li>GET 提交的数据会放在 URL 之后，以 <code>?</code> 分割 URL 和传输数据，参数之间以 <code>&amp;</code>相连，如 <code>EditPosts.aspx?name=test1&amp;id=123456</code>。POST 方法是把提交的数据放在 HTTP 包的 body 中。</li>
<li>GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制。</li>
<li>GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li>
</ol>
<h2 id="HTTP-响应包（服务器信息）"><a href="#HTTP-响应包（服务器信息）" class="headerlink" title="HTTP 响应包（服务器信息）"></a>HTTP 响应包（服务器信息）</h2><p>&emsp;&emsp;我们再来看看 HTTP 的 response 包，他的结构如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK                     <span class="comment">// 状态行</span></span><br><span class="line">Server: nginx/<span class="number">1.0</span><span class="number">.8</span>                 <span class="comment">// 服务器使用的 WEB 软件名及版本</span></span><br><span class="line">Date: Tue, <span class="number">30</span> Oct <span class="number">2012</span> <span class="number">04</span>:<span class="number">14</span>:<span class="number">25</span> GMT     <span class="comment">// 发送时间</span></span><br><span class="line">Content-Type: text/html             <span class="comment">// 服务器发送信息的类型</span></span><br><span class="line">Transfer-Encoding: chunked          <span class="comment">// 表示发送 HTTP 包是分段发的</span></span><br><span class="line">Connection: keep-alive              <span class="comment">// 保持连接状态</span></span><br><span class="line">Content-Length: <span class="number">90</span>                  <span class="comment">// 主体内容长度</span></span><br><span class="line"><span class="comment">// 空行 用来分割消息头和主体</span></span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>... <span class="comment">// 消息体</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Response 包中的第一行叫做状态行，由 HTTP 协议版本号， 状态码， 状态消息三部分组成。</p>
<p>&emsp;&emsp;状态码用来告诉 HTTP 客户端，HTTP 服务器是否产生了预期的 Response。HTTP/1.1 协议中定义了 5 类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别:</p>
<ul>
<li>1XX 提示信息 - 表示请求已被成功接收，继续处理</li>
<li>2XX 成功 - 表示请求已被成功接收，理解，接受</li>
<li>3XX 重定向 - 要完成请求必须进行更进一步的处理</li>
<li>4XX 客户端错误 - 请求有语法错误或请求无法实现</li>
<li>5XX 服务器端错误 - 服务器未能实现合法的请求</li>
</ul>
<p>&emsp;&emsp;我们看下面这个图展示了详细的返回信息，左边可以看到有很多的资源返回码，200 是常用的，表示正常信息，302 表示跳转。response header 里面展示了详细的信息。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-17_11-23-14.jpg" width="70%" height="70%"></div>



<h2 id="HTTP-协议是无状态的和-Connection-keep-alive-的区别"><a href="#HTTP-协议是无状态的和-Connection-keep-alive-的区别" class="headerlink" title="HTTP 协议是无状态的和 Connection: keep-alive 的区别"></a>HTTP 协议是无状态的和 Connection: keep-alive 的区别</h2><p>&emsp;&emsp;无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。</p>
<p>&emsp;&emsp;&emsp;&emsp;HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（面对无连接）。</p>
<p>&emsp;&emsp;&emsp;&emsp;从 HTTP/1.1 起，默认都开启了 Keep-Alive 保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的 TCP 连接。</p>
<p>&emsp;&emsp;&emsp;&emsp;Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同服务器软件（如 Apache）中设置这个时间。</p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中自定义sort函数</title>
    <url>/2021/06/10/%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89sort%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="sort库基本介绍"><a href="#sort库基本介绍" class="headerlink" title="sort库基本介绍"></a>sort库基本介绍</h2><p>&emsp;&emsp;该包实现了四种基本的排序算法：插入排序、归并排序、堆排序和快速排序。 但是这四种排序方法是不公开的，它们只被用于 sort 包内部使用。所以在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了 sort.Interface 定义的三个方法：获取数据集合长度的 Len() 方法、比较两个元素大小的 Less() 方法和交换两个元素位置的 Swap() 方法，就可以顺利对数据集合进行排序。sort 包会根据实际数据自动选择高效的排序算法。  除此之外，为了方便对常用数据类型的操作，sort 包提供了对[]int 切片、[]float64 切片和[]string 切片完整支持，主要包括：</p>
<ul>
<li>对基本数据类型切片的排序支持</li>
<li>基本数据元素查找</li>
<li>判断基本数据类型切片是否已经排好序</li>
<li>对排好序的数据集合逆序</li>
</ul>
<h2 id="数据集合排序"><a href="#数据集合排序" class="headerlink" title="数据集合排序"></a>数据集合排序</h2><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="Sort-方法的实现方式"><a href="#Sort-方法的实现方式" class="headerlink" title="Sort()方法的实现方式"></a>Sort()方法的实现方式</h4><p>&emsp;&emsp;前面已经提到过，对数据集合（包括自定义数据类型的集合）排序需要实现 sort.Interface 接口的三个方法，我们看以下该接口的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A type, typically a collection, that satisfies sort.Interface can be</span></span><br><span class="line"><span class="comment">// sorted by the routines in this package. The methods require that the</span></span><br><span class="line"><span class="comment">// elements of the collection be enumerated by an integer index.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// Less reports whether the element with</span></span><br><span class="line">    <span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>&emsp;&emsp;当数据集合实现了上面三种方法后，即可调用该包的Sort()方法进行排序。Sort()方法的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sort sorts data.</span></span><br><span class="line"><span class="comment">// It makes one call to data.Len to determine n, and O(n*log(n)) calls to</span></span><br><span class="line"><span class="comment">// data.Less and data.Swap. The sort is not guaranteed to be stable.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span> &#123;</span><br><span class="line">    n := data.Len()</span><br><span class="line">    quickSort(data, <span class="number">0</span>, n, maxDepth(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>&emsp;&emsp;从注释中可以知道Sort()方法不能保证排序结果是稳定的。其唯一的参数就是带排序的数据集合。该包还提供了一个方法IsSorted()来判断数据集合是否已经排好顺序，该方法的内部实现依赖于我们自己实现的 Len() 和 Less() 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IsSorted reports whether data is sorted.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSorted</span><span class="params">(data Interface)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := data.Len()</span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> data.Less(i, i<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="Reverse-方法的实现方式"><a href="#Reverse-方法的实现方式" class="headerlink" title="Reverse()方法的实现方式"></a>Reverse()方法的实现方式</h4><p>&emsp;&emsp;此外，<em>sort</em>包提供了 Reverse() 方法，可以允许将数据按 Less() 定义的排序方式逆序排序，而不必修改 Less() 代码。方法定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span> <span class="title">Interface</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们可以看到 Reverse() 返回的一个 sort.Interface 接口类型，整个 Reverse() 的内部实现比较有趣：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> reverse <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// This embedded Interface permits Reverse to use the methods of</span></span><br><span class="line">    <span class="comment">// another Interface implementation.</span></span><br><span class="line">    Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Less returns the opposite of the embedded implementation&#x27;s Less method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.Interface.Less(j, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reverse returns the reverse order for data.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span> <span class="title">Interface</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;reverse&#123;data&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>Search()方法的实现方式</p>
<p>&emsp;&emsp;该方法会使用“二分查找”算法来找出能使 f(x)(0&lt;=x&lt;n) 返回 ture 的最小值 i。 前提条件 : f(x)(0&lt;=x&lt;i) 均返回 false, f(x)(i&lt;=x&lt;n) 均返回 ture。<font color="red"> 如果不存在 i 可以使 f(i) 返回 ture, 则返回 n</font>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// Define f(-1) == false and f(n) == true.</span></span><br><span class="line">    <span class="comment">// Invariant: f(i-1) == false, f(j) == true.</span></span><br><span class="line">    i, j := <span class="number">0</span>, n</span><br><span class="line">    <span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">        h := <span class="keyword">int</span>(<span class="keyword">uint</span>(i+j) &gt;&gt; <span class="number">1</span>) <span class="comment">// avoid overflow when computing h</span></span><br><span class="line">        <span class="comment">// i ≤ h &lt; j</span></span><br><span class="line">        <span class="keyword">if</span> !f(h) &#123;</span><br><span class="line">            i = h + <span class="number">1</span> <span class="comment">// preserves f(i-1) == false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = h <span class="comment">// preserves f(j) == true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;可以发现，其内部就是通过二分查找搜索元素是否在已经升序排好的切片中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">11</span></span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">45</span>&#125; <span class="comment">// 注意已经升序排序</span></span><br><span class="line">pos := sort.Search(<span class="built_in">len</span>(s), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s[i] &gt;= x &#125;)</span><br><span class="line"><span class="keyword">if</span> pos &lt; <span class="built_in">len</span>(s) &amp;&amp; s[pos] == x &#123;</span><br><span class="line">    fmt.Println(x, <span class="string">&quot; 在 s 中的位置为：&quot;</span>, pos)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;s 不包含元素 &quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;官方文档还给出了一个猜数字的小程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GuessingGame</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Pick an integer from 0 to 100.\n&quot;</span>)</span><br><span class="line">    answer := sort.Search(<span class="number">100</span>, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Is your number &lt;= %d? &quot;</span>, i)</span><br><span class="line">        fmt.Scanf(<span class="string">&quot;%s&quot;</span>, &amp;s)</span><br><span class="line">        <span class="keyword">return</span> s != <span class="string">&quot;&quot;</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">&#x27;y&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Your number is %d.\n&quot;</span>, answer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="使用示例I"><a href="#使用示例I" class="headerlink" title="使用示例I"></a>使用示例I</h3><p>&emsp;&emsp;下面是一个使用 sort 包对学生成绩排序的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学生成绩结构体</span></span><br><span class="line"><span class="keyword">type</span> StuScore <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span>    <span class="comment">// 姓名</span></span><br><span class="line">    score <span class="keyword">int</span>   <span class="comment">// 成绩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StuScore []StuScore</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScore)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swap()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScore)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s[i],s[j] = s[j],s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Less():成绩从低到高排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScore)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s[i].score &lt; s[j].score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stus := StuScores&#123;</span><br><span class="line">        &#123;<span class="string">&quot;alan&quot;</span>, <span class="number">95</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;hikerell&quot;</span>, <span class="number">91</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;acmfly&quot;</span>, <span class="number">96</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;leao&quot;</span>, <span class="number">90</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">				</span><br><span class="line">    <span class="comment">// 打印未排序的 stus 数据</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Default:\n\t&quot;</span>,stus)</span><br><span class="line">    <span class="comment">//StuScores 已经实现了 sort.Interface 接口 , 所以可以调用 Sort 函数进行排序</span></span><br><span class="line">    sort.Sort(stus)</span><br><span class="line">    <span class="comment">// 判断是否已经排好顺序，将会打印 true</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;IS Sorted?\n\t&quot;</span>, sort.IsSorted(stus))</span><br><span class="line">    <span class="comment">// 打印排序后的 stus 数据</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Sorted:\n\t&quot;</span>,stus)		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;该示例程序的自定义类型 StuScores 实现了 sort.Interface 接口，所以可以将其对象作为 sort.Sort() 和 sort.IsSorted() 的参数传入。运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Default:</span><br><span class="line">     [&#123;alan <span class="number">95</span>&#125; &#123;hikerell <span class="number">91</span>&#125; &#123;acmfly <span class="number">96</span>&#125; &#123;leao <span class="number">90</span>&#125;]</span><br><span class="line">IS Sorted?</span><br><span class="line">     <span class="literal">true</span></span><br><span class="line">Sorted:</span><br><span class="line">     [&#123;leao <span class="number">90</span>&#125; &#123;hikerell <span class="number">91</span>&#125; &#123;alan <span class="number">95</span>&#125; &#123;acmfly <span class="number">96</span>&#125;]</span><br></pre></td></tr></table></figure>





<p>&emsp;&emsp;可以在学生成绩排序示例中使用 Reverse() 来实现成绩降序排序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sort.Sort(sort.Reverse(stus))</span><br><span class="line">fmt.Println(stus)</span><br></pre></td></tr></table></figure>



<h3 id="使用示例II"><a href="#使用示例II" class="headerlink" title="使用示例II"></a>使用示例II</h3><p>&emsp;&emsp;下面是一个根据文件元信息中文件上传时间顺序进行排序的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baseFormate = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FileMetas <span class="keyword">struct</span> &#123;</span><br><span class="line">    FileSha1	<span class="keyword">string</span>	<span class="comment">// 文件的哈希值</span></span><br><span class="line">    FileNames 	<span class="keyword">string</span></span><br><span class="line">    FileSize	<span class="keyword">int64</span></span><br><span class="line">    Location	<span class="keyword">string</span></span><br><span class="line">    UploadAt	<span class="keyword">string</span>  <span class="comment">// 文件的上传时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByUploadTime []FileMetas</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b ByUploadTime)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b ByUploadTime)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    b[i],b[j] = b[j],b[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b ByUploadTime)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    iTime,_ := time.Parse(baseFormate,b[i].UploadAt)</span><br><span class="line">    jTime,_ := time.Parse(baseFormate,b[j].UploadAt)</span><br><span class="line">    <span class="keyword">return</span> iTime.UnixNano() &gt; jTime.UnixNano()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fMetaArray := <span class="built_in">make</span>([]FileMetas,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> fileMetas &#123;  <span class="comment">// 假设fileMetas是一个已经给定储存的文件元信息的map</span></span><br><span class="line">        fMetaArray = <span class="built_in">append</span>(fMetaArray, v)</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">    <span class="comment">// 将文件元信息列表按上传时间排序</span></span><br><span class="line">    sort.Sort(ByUploadAt(fMetaArray))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="sort包已经支持的内部数据类型排序"><a href="#sort包已经支持的内部数据类型排序" class="headerlink" title="sort包已经支持的内部数据类型排序"></a>sort包已经支持的内部数据类型排序</h2><p>&emsp;&emsp;<em>sort</em>包原生支持[]int、[]float64 和[]string 三种内建数据类型切片的排序操作，即不必我们自己实现相关的 Len()、Less() 和 Swap() 方法。</p>
<h3 id="IntSlice-类型及-int-排序"><a href="#IntSlice-类型及-int-排序" class="headerlink" title="IntSlice 类型及[]int 排序"></a><strong>IntSlice 类型及[]int 排序</strong></h3><p>&emsp;&emsp;由于[]int 切片排序内部实现及使用方法与[]float64 和[]string 类似，所以只详细描述该部分。<em>sort</em>包定义了一个 IntSlice 类型，并且实现了 sort.Interface 接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sort sorts data.</span></span><br><span class="line"><span class="comment">// It makes one call to data.Len to determine n, and O(n*log(n)) calls to</span></span><br><span class="line"><span class="comment">// data.Less and data.Swap. The sort is not guaranteed to be stable.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span> &#123;</span><br><span class="line">    n := data.Len()</span><br><span class="line">    quickSort(data, <span class="number">0</span>, n, maxDepth(n))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// IntSlice attaches the methods of Interface to []int, sorting in increasing order.</span></span><br><span class="line"><span class="keyword">type</span> IntSlice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort is a convenience method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123; Sort(p) &#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;并且提供的 sort.Ints() 方法使用了该 IntSlice 类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ints sorts a slice of ints in increasing order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ints</span><span class="params">(a []<span class="keyword">int</span>)</span></span> &#123; Sort(IntSlice(a)) &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;所以，对[]int 切片排序更常使用 sort.Ints()，而不是直接使用 IntSlice 类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125; <span class="comment">// 未排序的切片数据</span></span><br><span class="line">sort.Ints(s)</span><br><span class="line">fmt.Println(s) <span class="comment">// 将会输出[1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果要使用降序排序，可以用前面提到的 Reverse() 方法(当然也可以自己实现Len()、Swap()、Less()三个方法，使用sort.Sort()排序)。这里的Reverse()方法中的参数只能是sort.IntSlice()，而不能是sort.Ints()。因为sort.IntSlice()是将s强制类型转换成IntSlice类型，sort.Reverse()实质上改变了其内部的reverse结构存储的IntSlice类型(参考前面的Reverse方法源码)的Less方法，实现反向排序；而sort.Ints()则是实现升序排序的方法，二者有本质区别：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125; <span class="comment">// 未排序的切片数据</span></span><br><span class="line">sort.Sort(sort.Reverse(sort.IntSlice(s)))</span><br><span class="line">fmt.Println(s) <span class="comment">// 将会输出[6 5 4 3 2 1]</span></span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;与IsSorted()对应的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IntsAreSorted tests whether a slice of ints is sorted in increasing order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntsAreSorted</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> IsSorted(IntSlice(a)) &#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;如果要查找整数 x 在切片 a 中的位置，相对于前面提到的 Search() 方法，<em>sort</em>包提供了 SearchInts(),注意，SearchInts() 的使用条件为：<font color="red"><strong>切片 a 已经升序排序</strong></font>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SearchInts searches for x in a sorted slice of ints and returns the index</span></span><br><span class="line"><span class="comment">// as specified by Search. The return value is the index to insert x if x is</span></span><br><span class="line"><span class="comment">// not present (it could be len(a)).</span></span><br><span class="line"><span class="comment">// The slice must be sorted in ascending order.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchInts</span><span class="params">(a []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= x &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Float64Slice-类型及-float64-排序"><a href="#Float64Slice-类型及-float64-排序" class="headerlink" title="Float64Slice 类型及[]float64 排序"></a><strong>Float64Slice 类型及[]float64 排序</strong></h3><p>&emsp;&emsp;实现与 Ints 类似，只看一下其内部实现，要说明一下的是，在上面 Float64Slice 类型定义的 Less 方法中，有一个内部函数 isNaN()。 isNaN() 与<em>math</em>包中 IsNaN() 实现完全相同，<em>sort</em>包之所以不使用 math.IsNaN()，完全是基于包依赖性的考虑，应当看到，<em>sort</em>包的实现不依赖与其他任何包。：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Float64Slice []<span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] || isNaN(p[i]) &amp;&amp; !isNaN(p[j]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123; Sort(p) &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;与 Sort()、IsSorted()、Search() 对应的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64s</span><span class="params">(a []<span class="keyword">float64</span>)</span></span> &#123; Sort(Float64Slice(a)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64sAreSorted</span><span class="params">(a []<span class="keyword">float64</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> IsSorted(Float64Slice(a)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchFloat64s</span><span class="params">(a []<span class="keyword">float64</span>, x <span class="keyword">float64</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= x &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="StringSlice-类型及-string-排序"><a href="#StringSlice-类型及-string-排序" class="headerlink" title="StringSlice 类型及[]string 排序"></a><strong>StringSlice 类型及[]string 排序</strong></h3><p>&emsp;&emsp;两个 string 对象之间的大小比较是基于“字典序”的。实现与 Ints 类似，只看一下其内部实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123; Sort(p) &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;与 Sort()、IsSorted()、Search()对应的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Strings</span><span class="params">(a []<span class="keyword">string</span>)</span></span> &#123; Sort(StringSlice(a)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringsAreSorted</span><span class="params">(a []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> IsSorted(StringSlice(a)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchStrings</span><span class="params">(a []<span class="keyword">string</span>, x <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= x &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="interface-排序与查找"><a href="#interface-排序与查找" class="headerlink" title="[]interface 排序与查找"></a>[]interface 排序与查找</h2><p>&emsp;&emsp;通过前面的内容我们可以知道，只要实现了 <code>sort.Interface</code> 接口，即可通过 sort 包内的函数完成排序，查找等操作。并且 sort 包已经帮我们把<code>[]int</code>,<code>[]float64</code>,<code>[]string</code> 三种类型都实现了该接口，我们可以方便的调用。但是这种用法对于其它数据类型的 slice 不友好，可能我们需要为大量的 struct 定义一个单独的 []struct 类型，再为其实现 <code>sort.Interface</code> 接口，类似这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Persons []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persons)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persons)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persons)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;这里可以引申一个问题，为什么 sort 包可以完成 <code>[]int</code> 的排序，而不能完成 <code>[]struct</code> 的排序？因为排序涉及到比较两个变量的值，而 struct 可能包含多个属性，程序并不知道你想以哪一个属性或哪几个属性作为衡量大小的标准。如果你能帮助程序完成比较，并将结果返回， sort 包内的方法就可以完成排序，判断，查找等。sort 包提供了以下函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">(slice <span class="keyword">interface</span>&#123;&#125;, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceStable</span><span class="params">(slice <span class="keyword">interface</span>&#123;&#125;, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceIsSorted</span><span class="params">(slice <span class="keyword">interface</span>&#123;&#125;, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">bool</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;通过函数签名可以看到，排序相关的三个函数都接收 <code>[]interface</code>，并且需要传入一个比较函数，用于为程序比较两个变量的大小，因为函数签名和作用域的原因，这个函数只能是 <code>匿名函数</code>。</p>
<h3 id="sort-Slice"><a href="#sort-Slice" class="headerlink" title="sort.Slice"></a><strong>sort.Slice</strong></h3><p>该函数完成 []interface 的排序，举个栗子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">people := []<span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">	&#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">55</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Age &lt; people[j].Age &#125;) <span class="comment">// 按年龄升序排序</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Sort by age:&quot;</span>, people)</span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Sort by age: [&#123;Gopher <span class="number">7</span>&#125; &#123;Vera <span class="number">24</span>&#125; &#123;Alice <span class="number">55</span>&#125; &#123;Bob <span class="number">75</span>&#125;]</span><br></pre></td></tr></table></figure>



<h3 id="sort-SliceStable"><a href="#sort-SliceStable" class="headerlink" title="sort.SliceStable"></a><strong>sort.SliceStable</strong></h3><p>该函数完成 []interface 的稳定排序，举个栗子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">people := []<span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.SliceStable(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Age &gt; people[j].Age &#125;) <span class="comment">// 按年龄降序排序</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Sort by age:&quot;</span>, people)</span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Sort by age: [&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">75</span>&#125;	&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>&#125;	&#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;	&#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">7</span>&#125;]</span><br></pre></td></tr></table></figure>



<h3 id="sort-SliceIsSorted"><a href="#sort-SliceIsSorted" class="headerlink" title="sort.SliceIsSorted"></a><strong>sort.SliceIsSorted</strong></h3><p>该函数判断 []interface 是否为有序，举个栗子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">people := []<span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">55</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Age &gt; people[j].Age &#125;) <span class="comment">// 按年龄降序排序</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Sort by age:&quot;</span>, people)</span><br><span class="line">fmt.Println(<span class="string">&quot;Sorted:&quot;</span>,sort.SliceIsSorted(people,<span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Age &lt; people[j].Age &#125;))</span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Sort by age: [&#123;Bob <span class="number">75</span>&#125; &#123;Alice <span class="number">55</span>&#125; &#123;Vera <span class="number">24</span>&#125; &#123;Gopher <span class="number">7</span>&#125;]</span><br><span class="line">Sorted: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;sort 包没有为 []interface 提供反序函数，但是从 1 和 2 可以看出，我们传入的比较函数已经决定了排序结果是升序还是降序。</p>
<p>&emsp;&emsp;判断 slice 是否为有序，同样取决于我们传入的比较函数，从 3 可以看出，虽然 slice 已经按年龄降序排序，但我们在判断 slice 是否为有序时给的比较函数是判断其是否为升序有序，所以最终得到的结果为 false。</p>
<h3 id="sort-Search"><a href="#sort-Search" class="headerlink" title="sort.Search"></a><strong>sort.Search</strong></h3><p>该函数判断 []interface 是否存在指定元素，举个栗子：</p>
<ul>
<li>升序 slice</li>
</ul>
<p>&emsp;&emsp;sort 包为 <code>[]int</code>,<code>[]float64</code>,<code>[]string</code> 提供的 Search 函数其实也是调用的该函数，因为该函数是使用的二分查找法，所以要求 slice 为升序排序状态。并且判断条件必须为 <code>&gt;=</code>，这也是官方库提供的三个查找相关函数的的写法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">21</span>, <span class="number">234</span>, <span class="number">56</span>&#125;</span><br><span class="line">x := <span class="number">21</span></span><br><span class="line"></span><br><span class="line">sort.Slice(a, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &lt; a[j] &#125;)   <span class="comment">// 升序排序</span></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= x &#125;) <span class="comment">// 查找元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span>(a) &amp;&amp; a[index] == x &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;found %d at index %d in %v\n&quot;</span>, x, index, a)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d not found in %v,index:%d\n&quot;</span>, x, a, index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">found <span class="number">21</span> at index <span class="number">3</span> in [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">21</span> <span class="number">56</span> <span class="number">100</span> <span class="number">200</span> <span class="number">234</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>降序 slice</li>
</ul>
<p>&emsp;&emsp;如果 slice 是降序状态，而我们又不想将其变为升序，只需将判断条件由 <code>&gt;=</code> 变更为 <code>&lt;=</code> 即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a class="link" href="https://github.com/golang/go">golang/go<i class="fas fa-external-link-alt"></i></a></p>
<p>2.<a class="link" href="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example/blob/master/chapter03/03.1.md">sort—排序算法<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Go语言标准库</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>在O(1)时间内删除或查找任意元素</title>
    <url>/2021/06/20/%E5%9C%A8O(1)%E6%97%B6%E9%97%B4%E5%86%85%E5%88%A0%E9%99%A4%E6%88%96%E6%9F%A5%E6%89%BE%E4%BB%BB%E6%84%8F%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>&emsp;&emsp;本文会介绍两道比较有技巧性的算法与数据结构题，都是和随机读取元素相关的。这些问题的技巧性子阿宇如何将哈希表和数组结合起来，使得数组的删除操作时间复杂度变成O(1)。</p>
<h2 id="实现随机集合"><a href="#实现随机集合" class="headerlink" title="实现随机集合"></a>实现随机集合</h2><p><a class="link" href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/">O(1) 时间插入、删除和获取随机元素<i class="fas fa-external-link-alt"></i></a></p>
<p>设计一个支持在<em>平均</em> 时间复杂度 <strong>O(1)</strong> 下，执行以下操作的数据结构。</p>
<ol>
<li>insert(val)：当元素 val 不存在时，向集合中插入该项。</li>
<li>remove(val)：元素 val 存在时，从集合中移除该项。</li>
<li>getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。</li>
</ol>
<p><strong>示例 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化一个空的集合。</span><br><span class="line">RandomizedSet randomSet &#x3D; new RandomizedSet();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span><br><span class="line">randomSet.insert(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回 false ，表示集合中不存在 2 。</span><br><span class="line">randomSet.remove(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom 应随机返回 1 或 2 。</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span><br><span class="line">randomSet.remove(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2 已在集合中，所以返回 false 。</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure>



<p>本题的难点在于两点：</p>
<p>**1、插入，删除，获取随机元素这三个操作的时间复杂度必须都是 O(1)**。</p>
<p><strong>2、**</strong><code>getRandom</code>** <strong>方法返回的元素必须等概率返回随机元素</strong>，也就是说，如果集合里面有 <code>n</code> 个元素，每个元素被返回的概率必须是 <code>1/n</code>。</p>
<p>我们先来分析一下：对于插入，删除，查找这几个操作，哪种数据结构的时间复杂度是 O(1)？</p>
<p><code>HashSet</code> 肯定算一个对吧。哈希集合的底层原理就是一个大数组，我们把元素通过哈希函数映射到一个索引上；如果用拉链法解决哈希冲突，那么这个索引可能连着一个链表或者红黑树。</p>
<p>那么请问对于这样一个标准的 <code>HashSet</code>，你能否在 O(1) 的时间内实现 <code>getRandom</code> 函数？</p>
<p>其实是不能的，因为根据刚才说到的底层实现，元素是被哈希函数「分散」到整个数组里面的，更别说还有拉链法等等解决哈希冲突的机制，基本做不到 O(1) 时间等概率随机获取元素。</p>
<p>根据上面的分析，对于 <code>getRandom</code> 方法，如果想「等概率」且「在 O(1) 的时间」取出元素，一定要满足：<strong>底层用数组实现，且数组必须是紧凑的</strong>。</p>
<p>这样我们就可以直接生成随机数作为索引，从数组中取出该随机索引对应的元素，作为随机元素。</p>
<p><strong>但如果用数组存储元素的话，插入，删除的时间复杂度怎么可能是 O(1) 呢</strong>？</p>
<p>可以做到！对数组尾部进行插入和删除操作不会涉及数据搬移，时间复杂度是 O(1)。</p>
<p><strong>所以，如果我们想在 O(1) 的时间删除数组中的某一个元素</strong> **<code>val</code>**<strong>，可以先把这个元素交换到数组的尾部，然后再</strong> <strong><code>pop</code></strong> <strong>掉</strong>。</p>
<p>交换两个元素必须通过索引进行交换对吧，那么我们需要一个哈希表 <code>m</code> 来记录每个元素值对应的索引。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RandomizedSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    nums []<span class="keyword">int</span></span><br><span class="line">    m    <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">RandomizedSet</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> RandomizedSet&#123;<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>),<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">0</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span> <span class="title">Insert</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.m[val];ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.nums = <span class="built_in">append</span>(this.nums,val) <span class="comment">// 在数组末尾插入val</span></span><br><span class="line">    this.m[val] = <span class="built_in">len</span>(this.nums)<span class="number">-1</span>    <span class="comment">// 将val作为key加入到map中，其value是其在数组中的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span> <span class="title">Remove</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.m[val];!ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    index := this.m[val]</span><br><span class="line">    this.nums[index] = this.nums[<span class="built_in">len</span>(this.nums)<span class="number">-1</span>]  <span class="comment">// 将数组最后一个元素移动到index的位置</span></span><br><span class="line">    this.m[this.nums[index]] = index                <span class="comment">// 更新移动后元素在map中的value值</span></span><br><span class="line">    <span class="built_in">delete</span>(this.m, val)															<span class="comment">// 删除val健值对</span></span><br><span class="line">    this.nums = this.nums[:<span class="built_in">len</span>(this.nums)<span class="number">-1</span>]        <span class="comment">// pop数组最后一个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get a random element from the set. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span> <span class="title">GetRandom</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	i := rand.Intn(<span class="built_in">len</span>(this.nums))    <span class="comment">// i取从0到len(this.nums)-1的随机数</span></span><br><span class="line">    <span class="keyword">return</span> this.nums[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Insert(val);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Remove(val);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.GetRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>用Go语言实现栈</title>
    <url>/2021/08/05/%E7%94%A8Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<h2 id="自定义栈的功能"><a href="#自定义栈的功能" class="headerlink" title="自定义栈的功能"></a>自定义栈的功能</h2><p>&emsp;&emsp;本文旨在通过Go语言来实现一个自定义的栈，其功能包括入栈、出栈、栈容量查询、栈内元素个数查询、栈顶元素查询、是否空栈查询。</p>
<h2 id="栈的初始化"><a href="#栈的初始化" class="headerlink" title="栈的初始化"></a>栈的初始化</h2><p>首先创建一个能保存数据的结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack []<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里声明Stack为空接口类型的切片（Go语言之中的切片可以理解为一个长度可变的数组）。由于Go语言所有类型都实现了空接口，因此任意类型的值都可以存储在Stack之中。</p>
<h2 id="栈的长度及容量"><a href="#栈的长度及容量" class="headerlink" title="栈的长度及容量"></a>栈的长度及容量</h2><p>&emsp;&emsp;由于Stack的底层数据类型是一个切片，我们可以为其实现<code>Len()</code>和<code>Cap()</code>方法用来获取其长度和容量（Go语言之中首字母大写的方法为包外可访问的，类似于Java或者C++之中类的public方法）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;  <span class="comment">// 栈的长度</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(stack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span></span> &#123;  <span class="comment">// 栈的容量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">cap</span>(stack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="查询是否是空栈"><a href="#查询是否是空栈" class="headerlink" title="查询是否是空栈"></a>查询是否是空栈</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="栈的关键方法的实现（Push-、Pop-、Top-）"><a href="#栈的关键方法的实现（Push-、Pop-、Top-）" class="headerlink" title="栈的关键方法的实现（Push()、Pop()、Top()）"></a>栈的关键方法的实现（Push()、Pop()、Top()）</h2><p>&emsp;&emsp;<code>Push()</code>方法的接收器为一个Stack类型的指针（Go指针的写法与C/C++类似，类型前面加上*号）。Go语言的所有方法参数都是值传递，接收器实际也是作为方法的一个参数传递进入方法的。如果传递一切片或者数组进方法，实际是将切片或数组的值拷贝了一份传入了方法之中，此时在方法之中对该切片或数组做的操作都不会影响方法之外的原始值。如果想要方法之中的操作影响到方法外的原始值，则应该使用指针作为参数，对指针的操作会直接反应到内存之中的原始值上去。在这里我们希望更改原始值（往原始的<code>stack</code>之中添加数据）， 所以接收器是一个指针。方法的参数是一个<code>interface&#123;&#125;</code>类型的值，也就是说该方法可以接受任意类型作为参数。方法的实现使用了内建函数<code>append()</code>，往切片对尾部中添加新值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Push</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  *stack = <span class="built_in">append</span>(*stack, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;<code>Top()</code>方法返回一个任意类型的值以及一个<code>error</code>（是的没错，Go语言的方法可以返回多个值）。当stack为空时，返回一个空值和一个<code>error</code>类型的值（这里使用<code>errors</code>包的<code>New()</code>函数创建）。当stack不为空时，返回底层切片的最后一个值和一个空的<code>error</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">Top</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;,error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;Out of index, len is 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>], <span class="literal">nil</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;<code>Pop()</code>方法的接收器同样是一个Stack的指针。其中<code>theStack[:len(theStack) - 1]</code>这种写法，是Go中取子切片的方法，<code>:</code>两边是起始index和结束index。起始index为0时可以省略。结束的index也可以省略，省略时结束index为切片的<code>len()</code>值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;,error)</span></span> &#123;</span><br><span class="line">  theStack := *stack</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(theStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, error.New(<span class="string">&quot;Out of index, len is 0&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  value := theStack[<span class="built_in">len</span>(theStack)<span class="number">-1</span>]</span><br><span class="line">  *stack = theStack[:<span class="built_in">len</span>(theStack)<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Go语言数据结构</category>
      </categories>
      <tags>
        <tag>自定义栈</tag>
      </tags>
  </entry>
  <entry>
    <title>递归算法解决二叉树问题</title>
    <url>/2021/08/18/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="递归算法的原理"><a href="#递归算法的原理" class="headerlink" title="递归算法的原理"></a>递归算法的原理</h1><p>&emsp;&emsp;一个递归函数的调用类似于多个函数的嵌套调用，只不过调用函数和被调函数都是同一个函数。在解决递归问题时，最重要的是不要陷入递归的逻辑中去，视角要以一个节点为根基来考虑整个问题。递归调用时内部的执行过程如下:</p>
<ol>
<li>首先为递归调用建立一个<font color="blue">工作栈</font>，其结构包括值参、局部变量和返回地址；</li>
<li>每次执行递归调用前，把<font color="red">递归函数的值参、局部变量的当前值</font>以及<font color="red">调用后的返回地址</font>压栈；</li>
<li>每次递归调用结束后，将栈顶元素推出，使相应的<font color="red">值参</font>和<font color="red">局部变量</font>恢复为<font color="blue">调用前的值</font>，然后转向返回地址的位置继续执行。</li>
</ol>
<p>&emsp;&emsp;在明确了递归函数的执行过程后，只要把握好如下3个步骤即可：</p>
<ol>
<li>明确递归函数的作用；</li>
<li>明确终止条件和相应的解决办法；</li>
<li>找出函数的等价关系式，提取重复的逻辑缩小问题规模。</li>
</ol>
<h1 id="递归三步走"><a href="#递归三步走" class="headerlink" title="递归三步走"></a>递归三步走</h1><h2 id="1-明确函数功能"><a href="#1-明确函数功能" class="headerlink" title="1.明确函数功能"></a>1.明确函数功能</h2><p>&emsp;&emsp;首先要确定这个函数的具体功能是什么？它的参数有哪些？它的全局变量是什么？递归的时候要根据题目的要求设置函数功能，再根据函数功能来设置函数的参数。</p>
<p>&emsp;&emsp;<font color="red">方法参数：</font>这个方法的参数最好由当前阶段的状态决定。</p>
<p>&emsp;&emsp;<font color="red">返回数据：</font>返回数据是我们遇到递归出口之后，需要告诉前一步递归的信息数据。</p>
<p>注意：</p>
<ul>
<li>递归函数的<strong>返回值</strong>最好设置为<strong>单个元素</strong>，比如说<strong>一个节点</strong>或者<strong>一个数值</strong>，告诉前一步递归我们现在的结果数据即可；</li>
<li>如果返回值是<strong>数组</strong>的话，我们将无法从中提取到任何有效信息来进行操作；</li>
<li>如果结果需要<strong>数组</strong>的话，我们可以将数组作为公共变量返回值为void，我们在方法体里面操作数组即可。</li>
</ul>
<h2 id="2-寻找递归出口"><a href="#2-寻找递归出口" class="headerlink" title="2.寻找递归出口"></a>2.寻找递归出口</h2><p>&emsp;&emsp;在递归函数的一开始，我们应该思考什么时候该结束递归。因此，递归一定要有结束条件，不然会永远的递归下去。<font color="red">递归出口</font>一般为某深度或叶子结点，或非叶子结点（包括根节点）、所有节点等。决定递归出去后要执行的操作。由于我们的节点状态可能需要多个参数来表示，所以我们的递归出口可能并不唯一，可能需要为每一个转台参数安排一个递归出口，确保我们的递归能够确实有效地出去。</p>
<p><font color="blue">特别注意的：</font>每次提交数组的集合（即<code>list(dst())</code>）的时候，要创建一个新的数组<code>copy()</code>来存放结果数组<code>dst()</code>，不然后面操作的都是加入集合<code>list()</code>的那个数组<code>dst()</code>。</p>
<p>&emsp;&emsp;我们的递归出口并不一定都是在最开头的位置，我们一般在最开头设置递归出口是希望递归能以最快的速度出去；但是<strong>有时候我们在对当前节点进行一些相关处理操作之后我们就希望判断一下能不能递归出口</strong>，所以<strong>递归出口有可能是在代码中间的</strong>，大家需要灵活应用。在这一步，我们需要思考题目需要的解在哪里？是<strong>在某一具体的深度</strong>、还是在<strong>叶子结点</strong>、还是在<strong>非叶子结点</strong>（包括<strong>根节点</strong>）、还是在<strong>每个节点</strong>、还是<strong>在从跟结点到叶子结点的路径</strong>？</p>
<ul>
<li>在某一具体深度：<code>if depth &gt;= n</code></li>
<li>在每个节点：<code>if root != nil </code></li>
</ul>
<h2 id="3-找出递推关系"><a href="#3-找出递推关系" class="headerlink" title="3.找出递推关系"></a>3.找出递推关系</h2><p>&emsp;&emsp;类比于数学归纳法。算n的阶乘：</p>
<ul>
<li>初始条件：<code>f(1) = 1</code></li>
<li>递推关系式：<code>f(n) = f(n-1) * n</code></li>
</ul>
<p>递归关系：</p>
<ul>
<li>递：<code>f(n) = n * f(n-1)</code>，将<strong>f(n)→f(n-1)<strong>了。这样，</strong>问题就由n缩小为了n-1</strong>，并且为了原函数<code>f(n)</code>不变，我们需要让<code>f(n-1)</code>乘以<code>n</code>。就这样慢慢从<code>f(n)</code>,<code>f(n-1)</code><strong>“递”</strong>到<code>f(1)</code>。</li>
<li>归：这样就可以从<code>n=1</code>，一步一步<strong>“归”</strong>到<code>n=2,n=3,...</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span> &#123; <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> f(n<span class="number">-1</span>)*n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="运用递归的二叉树算法题"><a href="#运用递归的二叉树算法题" class="headerlink" title="运用递归的二叉树算法题"></a>运用递归的二叉树算法题</h1><p>&emsp;&emsp;二叉树的递归框架无外乎二叉树的三种遍历方式：前序遍历、中序遍历、后序遍历。在想好递归出口后，就要考虑采用何种方式来遍历整个二叉树有助于我们解决问题。解决这类问题的核心难点是不要深入进递归细节中，不要把自己的大脑当计算机来用！只要着眼于根节点，在设置好递归出口的前提下就能顺利地解题。</p>
<h2 id="1-直接递归遍历整个二叉树后返回根节点"><a href="#1-直接递归遍历整个二叉树后返回根节点" class="headerlink" title="1.直接递归遍历整个二叉树后返回根节点"></a>1.直接递归遍历整个二叉树后返回根节点</h2><p>&emsp;&emsp;此类问题不需要引入一个用于记录和更新极值结果的中间全局变量，只需要对二叉树本身进行操作，所以在传入的方法参数上比较简单，只需要关注于节点本身（以根节点为视角和着眼点）。大多数题目都是针对树结构进行性重建，查找或删除等操作。</p>
<h3 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p><strong>示例 1:</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="tree.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: preorder &#x3D; [-1], inorder &#x3D; [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<p>对于任意一颗树而言，前序遍历的形式总是：</p>
<p><code>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</code><br>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是：</p>
<p><code>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</code></p>
<p>&emsp;&emsp;只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;  <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">		</span><br><span class="line">  root := &amp;TreeNode&#123;preorder[<span class="number">0</span>],<span class="literal">nil</span>,<span class="literal">nil</span>&#125; <span class="comment">// 着眼于根节点</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(inorder); i++ &#123;  <span class="comment">// 找到在中序遍历数组中根节点的位置</span></span><br><span class="line">  	<span class="keyword">if</span> inorder[i] == preorder[<span class="number">0</span>] &#123;</span><br><span class="line">    	<span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  	</span><br><span class="line">  root.Left = buildTree(preorder[<span class="number">1</span>:i+<span class="number">1</span>], inorder[:i])  <span class="comment">// 构建左子树</span></span><br><span class="line">  root.Right = buildTree(preorder[i+<span class="number">1</span>:], inorder[i+<span class="number">1</span>:])  <span class="comment">// 构建右子树</span></span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(inorder []<span class="keyword">int</span>, postorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(postorder) == <span class="number">0</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  	</span><br><span class="line">  root := &amp;TreeNode&#123;postorder[<span class="built_in">len</span>(postorder)<span class="number">-1</span>],<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">  i:=<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> ; i&lt;<span class="built_in">len</span>(inorder); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> inorder[i] == postorder[<span class="built_in">len</span>(postorder)<span class="number">-1</span>] &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  root.Left = build(inorder[:i],postorder[:i])</span><br><span class="line">  root.Right = build(inorder[i+<span class="number">1</span>:],postorder[i:<span class="built_in">len</span>(postorder)<span class="number">-1</span>])</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>翻转一棵二叉树。</p>
<p><strong>示例：</strong></p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<p>废话少说，直接看代码吧，简单题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  left := invertTree(root.Left)</span><br><span class="line">  right := invertTree(root.Right)  <span class="comment">// 后序遍历</span></span><br><span class="line">  root.Left = right</span><br><span class="line">  root.Right = left</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<p>简单题，直接上代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  <span class="comment">// 递归出口，空节点返回深度0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  left := maxDepth(root.Left)  <span class="comment">// 左子树深度</span></span><br><span class="line">  right := maxDepth(root.Right)  <span class="comment">// 右子树深度</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>+max(left,right)  <span class="comment">// 返回最终深度=左右子树最大深度+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> a&gt;=b &#123;</span><br><span class="line">  	<span class="keyword">return</span> a</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre>
<p> 但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;如果同时满足下面的条件，两个树互为镜像：</p>
<ul>
<li>它们的两个根结点具有相同的值；</li>
<li>每个树的右子树都与另一个树的左子树镜像对称。</li>
</ul>
<p>&emsp;&emsp;我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移；p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> check(root, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(q,p *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> q == <span class="literal">nil</span> &amp;&amp; p == <span class="literal">nil</span> &#123;  <span class="comment">// p，q均为空节点，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> q == <span class="literal">nil</span> || p == <span class="literal">nil</span> &#123; <span class="comment">// p，q只有其中一者为空节点，返回false</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 1.p，q节点的值相等；2.q的左节点与p的右节点相等；3.q的右节点与p的左节点相等。</span></span><br><span class="line">  <span class="keyword">return</span> q.Val == p.Val &amp;&amp; check(q.Left,p.Right) &amp;&amp; check(q.Right,p.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a class="link" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="binarytree.png" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="binarytree2.png" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">树中节点数目在范围 [2, 105] 内。</span><br><span class="line">-109 &lt;&#x3D; Node.val &lt;&#x3D; 109</span><br><span class="line">所有 Node.val 互不相同 。</span><br><span class="line">p !&#x3D; q</span><br><span class="line">p 和 q 均存在于给定的二叉树中。</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;我们递归遍历整棵二叉树，定义 $f_{x}$ 表示 $x$ 节点的子树中是否包含 $p$ 节点或 $q$ 节点，如果包含为<code>true</code>,否则为<code>false</code>。那么符合条件的最近公共祖先 $x$ 一定满足如下条件：</p>
<p>$\left(f_{\text {lson }} &amp; &amp; f_{\text {rson }}\right) |\left((x=p | x=q) &amp; &amp;\left(f_{\text {lson }} | f_{\text {rson }}\right)\right)$</p>
<p>其中 $<em>{\text{lson}}$ 和 $</em>{\text{rson}}$ 分别代表 $x$ 节点的左孩子和右孩子。$\left(f_{\text {lson }} &amp; &amp; f_{\text {rson }}\right)$ 说明左子树和右子树均包含 $p$ 节点或 $q$ 节点，如果左子树包含的是 $p$ 节点，那么右子树只能包含 $q$ 节点，反之亦然，因为 $p$ 节点和 $q$ 节点都是不同且唯一的节点，因此如果满足这个判断条件即可说明 $x$ 就是我们要找的最近公共祖先。再来看第二条判断条件，这个判断条件即是考虑了 $x$ 恰好是 $p$ 节点或 $q$ 节点且它的左子树或右子树有一个包含了另一个节点的情况，因此如果满足这个判断条件亦可说明 $x$ 就是我们要找的最近公共祖先。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> root == p || root == q &#123; <span class="comment">// 当遇到p或q节点时剪枝，不再向下递，开始归</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  left := lowestCommonAncestor(root.Left,p,q)</span><br><span class="line">  right := lowestCommonAncestor(root.Right,p,q) <span class="comment">// 后序遍历的框架</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123; <span class="comment">// p,q节点分别在左右子树，当前节点即是共同祖先</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> left == <span class="literal">nil</span> &#123; <span class="comment">// 左子树中不包含p，q节点，右子树包含其中之一，该节点本身是p，q中的另一个</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> left <span class="comment">// 右子树中不包含p，q节点，左子树包含其中之一，该节点本身是p，q中的另一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 合并必须从两个树的根节点开始。</p>
<p><strong>解题思路：</strong></p>
<p>方法一：深度优先搜索</p>
<p>可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。</p>
<p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。</p>
<ul>
<li>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</li>
<li>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</li>
<li>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。<br>  对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(root1 *TreeNode, root2 *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root1 == <span class="literal">nil</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> root2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> root2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  root1.Val += root2.Val</span><br><span class="line">  root1.Left = mergeTrees(root1.Left, root2.Left)</span><br><span class="line">  root1.Right = mergeTrees(root1.Right, root2.Right)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：广度优先搜索</p>
<p>也可以使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。</p>
<p>如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。</p>
<p>使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。</p>
<p>如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：</p>
<ul>
<li>如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；</li>
<li>如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。</li>
</ul>
<p>对于右子节点和右子树，处理方法与左子节点和左子树相同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(root1 *TreeNode, root2 *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">	q1 := []*TreeNode&#123;root1&#125;</span><br><span class="line"> 	q2 := []*TreeNode&#123;root2&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root1 == <span class="literal">nil</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> root2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> root2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  root3 := &amp;TreeNode&#123;root1.Val+root2.Val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">  q3 := []*TreeNode&#123;root3&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(q1)&gt;<span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(q2)&gt;<span class="number">0</span> &#123;</span><br><span class="line">    node1 := q1[<span class="number">0</span>]</span><br><span class="line">    q1 = q1[<span class="number">1</span>:]</span><br><span class="line">    node2 := q2[<span class="number">0</span>]</span><br><span class="line">    q2 = q2[<span class="number">1</span>:]</span><br><span class="line">    node3 := q3[<span class="number">0</span>]</span><br><span class="line">    q3 = q3[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node1.Left != <span class="literal">nil</span> &amp;&amp; node2.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">    	q1 = <span class="built_in">append</span>(q1, node1.Left)</span><br><span class="line">      q2 = <span class="built_in">append</span>(q2, node2.Left)</span><br><span class="line">      node3.Left = &amp;TreeNode&#123;node1.Left.Val+node2.Left.Val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">      q3 = <span class="built_in">append</span>(q3, node3.Left)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> node1.Left == <span class="literal">nil</span> &amp;&amp; node2.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">      	node3.Left = node2.Left <span class="comment">// node1没有左子树，直接用node2的左子树接到新树上</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> node1.Left != <span class="literal">nil</span> &amp;&amp; node2.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">        node3.Left = node1.Left <span class="comment">// node2没有左子树，直接用node1的左子树接到新树上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node1.Right != <span class="literal">nil</span> &amp;&amp; node2.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">    	q1 = <span class="built_in">append</span>(q1, node1.Right)</span><br><span class="line">      q2 = <span class="built_in">append</span>(q2, node2.Right)</span><br><span class="line">      node3.Right = &amp;TreeNode&#123;node1.Right.Val+node2.Right.Val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">      q3 = <span class="built_in">append</span>(q3, node3.Right)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> node1.Right == <span class="literal">nil</span> &amp;&amp; node2.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">      node3.Right = node2.Right <span class="comment">// node1没有右子树，直接用node2的右子树接到新树上</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> node1.Right != <span class="literal">nil</span> &amp;&amp; node2.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">      node3.Right = node1.Right <span class="comment">// node2没有右子树，直接用node1的右子树接到新树上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-返回bool类型的结果-一般要求对二叉树是否符合某种性质做判别"><a href="#2-返回bool类型的结果-一般要求对二叉树是否符合某种性质做判别" class="headerlink" title="2.返回bool类型的结果(一般要求对二叉树是否符合某种性质做判别)"></a>2.返回bool类型的结果(一般要求对二叉树是否符合某种性质做判别)</h2><p>&emsp;&emsp;此类问题一般只在递归出口处可能返回<code>true</code>，而在一般节点的判别时只返回<code>false</code>的情形。返回<code>true</code>表明递的过程结束，然而后续的节点不一定判别完了，会出现不应该的剪枝的情况。可以直接返回<code>false</code>的情形是因为遇到了不符合要求的情况，下面的节点不用继续判断了，就直接返回<code>false</code>。一般而言有下面这样的模板：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="comment">// 递归出口</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"> 	&#125;</span><br><span class="line">  <span class="keyword">if</span> [判别情形<span class="number">1</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> [判别情形<span class="number">2</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> helper(root.Left) &amp;&amp; helper(root.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a class="link" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列<i class="fas fa-external-link-alt"></i></a></h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<p>参考以下这颗二叉搜索树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   6</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>数组长度 &lt;= 1000</code></li>
</ol>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;二叉搜索树的后续遍历数组满足如下定义：</p>
<ul>
<li>后序遍历： <code>[ 左子树 | 右子树 | 根节点 ]</code> ，即遍历顺序为 “左、右、根” 。</li>
<li><strong>二叉搜索树定义：</strong> 左子树中所有节点的值 &lt; 根节点的值；右子树中所有节点的值 &gt; 根节点的值；其左、右子树也分别为二叉搜索树。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="11.png" alt="avatar"></p>
<p><strong>递归解析：</strong></p>
<ul>
<li>递归出口：<code>len(postorder)==0</code>时，返回<code>true</code>。</li>
<li>递：</li>
</ul>
<ol>
<li><p><strong>划分左右子树</strong>： 遍历后序遍历的元素，寻找 <strong>第一个大于根节点</strong> 的节点，索引记为 <code>flag</code>。此时，可划分出左子树区间 <code>[:flag]</code> 、右子树区间 <code>[flag,len(postorder)−1]</code> 、根节点索引为<code>len(postorder)-1</code> 。</p>
</li>
<li><p><strong>判断是否为二叉搜索树：</strong> 左子树区间 <code>[0,flag−1]</code> 内的所有节点都应 &lt; <code>postorder[len(postorder)-1]</code>。而第 <code>1.划分左右子树</code> 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。</p>
<p> 右子树区间<code>[flag,len(postorder)-1]</code>内所有节点都应 &gt; <code>postorder[len(postorder)-1]</code>。实现方式为遍历，当遇到 &lt; <code>postorder[len(postorder)-1]</code>的节点则跳出。</p>
</li>
</ol>
<ul>
<li>归： 所有子树都需正确才可判定正确，因此使用 <strong>与逻辑符</strong> <code>&amp;&amp;</code> 连接。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyPostorder</span><span class="params">(postorder []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(postorder) == <span class="number">0</span> &#123; <span class="comment">// 递归出口</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  i := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> ; i&lt;<span class="built_in">len</span>(postorder); i++ &#123;</span><br><span class="line">  	<span class="keyword">if</span> postorder[i] &gt;= postorder[<span class="built_in">len</span>(postorder)<span class="number">-1</span>] &#123;</span><br><span class="line">    	<span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  flag := i  <span class="comment">// 用于记录左右子树分界处的索引号</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ; i&lt;<span class="built_in">len</span>(postorder); i++ &#123;</span><br><span class="line">  	<span class="keyword">if</span> postorder[i] &lt; postorder[<span class="built_in">len</span>(postorder)<span class="number">-1</span>] &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>  <span class="comment">// 右子树出现小于根节点的数，直接返回false跳出递的过程</span></span><br><span class="line">    &#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 左右子树分别满足上述条件才返回true</span></span><br><span class="line">  <span class="keyword">return</span> verifyPostorder(postorder[:flag]) &amp;&amp; verifyPostorder(postorder[flag:<span class="built_in">len</span>(postorder)<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a class="link" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构<i class="fas fa-external-link-alt"></i></a></h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:<br>给定的树 A:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>

<p>给定的树 B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; 节点个数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<ul>
<li><p>两个函数</p>
<ul>
<li><strong>isSubStructure()</strong><ul>
<li>用于递归遍历 A 中的所有节点，并判断当前节点 A 是否与 B 的根节点相同，相同则调用 helper( ) 进一步校验</li>
</ul>
</li>
<li><strong>helper()</strong><ul>
<li>用于校验 B 是否与 A 的一个子树拥有相同的结构和节点值</li>
</ul>
</li>
</ul>
</li>
<li><p>函数内容</p>
<ul>
<li><p><strong>isSubStructure()</strong></p>
<ul>
<li>如果当前节点 A == nil &amp;&amp; B == nil ，返回true。</li>
<li>如果当前节点 A == nil | | B == nil ，返回 false。（由题目可知，空树不是任意一个树的子结构）</li>
<li>当在当前结点 A 中找到 B 的根节点时，进入helper () 递归校验</li>
<li>ret == false，说明 B 的根节点不在当前 A 中，进入 A 的左子树进行递归查找</li>
<li>ret 仍等于 false，则说明 B 的根节点不在当前 A 和左子树中，进入 A 的右子树进行递归查找。</li>
</ul>
</li>
<li><p><strong>helper()</strong></p>
<ul>
<li><p>如果 B == nil ，说明 B 已遍历完，返回 true</p>
</li>
<li><p>在 B != nil 的情况下，如果 A == nil ,说明 A 中节点不足以构成子结构 B ，返回 false</p>
</li>
<li><p>如果 A.Val != B.Val，不满足节点值相等条件，返回 false</p>
</li>
<li><p>A.Val == B.Val 继续递归校验 A B 左子树和右子树的结构和节点是否相同</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubStructure</span><span class="params">(A *TreeNode, B *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> A == <span class="literal">nil</span> || B == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> A.Val == B.Val &#123;</span><br><span class="line">        ret = helper(A, B)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ret &#123; <span class="comment">// B 的根节点不在当前 A 中，进入 A 的左子树进行递归查找</span></span><br><span class="line">        ret = isSubStructure(A.Left, B)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ret &#123; <span class="comment">// ret 仍等于 false，则说明 B 的根节点不在当前 A 和左子树中，进入 A 的右子树进行递归查找。</span></span><br><span class="line">        ret = isSubStructure(A.Right, B)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(A *TreeNode, B *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> B == <span class="literal">nil</span> &#123; <span class="comment">// 如果 B == nil ，说明 B 已遍历完，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> A == <span class="literal">nil</span> &#123; <span class="comment">// 在 B != nil 的情况下，如果 A == nil ,说明 A 中节点不足以构成子结构 B ，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> A.Val != B.Val &#123; <span class="comment">//  A.Val != B.Val，不满足节点值相等条件，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(A.Left, B.Left) &amp;&amp; helper(A.Right, B.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="331-验证二叉树的前序序列化"><a href="#331-验证二叉树的前序序列化" class="headerlink" title="331. 验证二叉树的前序序列化"></a><a class="link" href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/">331. 验证二叉树的前序序列化<i class="fas fa-external-link-alt"></i></a></h3><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     2</span><br><span class="line">  &#x2F; \   &#x2F; \</span><br><span class="line"> 4   1  #  6</span><br><span class="line">&#x2F; \ &#x2F; \   &#x2F; \</span><br><span class="line"># # # #   # #</span><br></pre></td></tr></table></figure>

<p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 # 代表一个空节点。</p>
<p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p>
<p>每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的<code>&#39;#&#39;</code>。</p>
<p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;1,#&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;9,#,#,1&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;我们可以定义一个概念，叫做槽位。一个槽位可以被看作「当前二叉树中正在等待被节点填充」的那些位置。</p>
<p>二叉树的建立也伴随着槽位数量的变化。每当遇到一个节点时：</p>
<ul>
<li>如果遇到了空节点，则要消耗一个槽位；</li>
<li>如果遇到了非空节点，则除了消耗一个槽位外，还要再补充两个槽位。</li>
</ul>
<p>此外，还需要将根节点作为特殊情况处理。</p>
<p>&emsp;&emsp;我们使用栈来维护槽位的变化。栈中的每个元素，代表了对应节点处剩余槽位的数量，而栈顶元素就对应着下一步可用的槽位数量。当遇到空节点时，仅将栈顶元素减 1；当遇到非空节点时，将栈顶元素减 1 后，再向栈中压入一个 2。无论何时，如果栈顶元素变为 0，就立刻将栈顶弹出。遍历结束后，若栈为空，说明没有待填充的槽位，因此是一个合法序列；否则若栈不为空，则序列不合法。此外，在遍历的过程中，若槽位数量不足，则序列不合法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidSerialization</span><span class="params">(preorder <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(preorder)</span><br><span class="line">    stk := []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125; <span class="comment">// 初始化一个槽位给根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stk) == <span class="number">0</span> &#123; <span class="comment">// 已经没有足够的槽位，但序列还未结束，说明序列不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> preorder[i] == <span class="string">&#x27;,&#x27;</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> preorder[i] == <span class="string">&#x27;#&#x27;</span> &#123; <span class="comment">// 出现空节点</span></span><br><span class="line">            stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>]--  <span class="comment">// 消耗栈顶一个槽位</span></span><br><span class="line">            <span class="keyword">if</span> stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>] == <span class="number">0</span> &#123; <span class="comment">// 若栈顶槽位置零，则出栈</span></span><br><span class="line">                stk = stk[:<span class="built_in">len</span>(stk)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i&lt;n &amp;&amp; preorder[i] != <span class="string">&#x27;,&#x27;</span> &#123; <span class="comment">// 读取数字</span></span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>]-- <span class="comment">// 消耗栈顶一个槽位</span></span><br><span class="line">            <span class="keyword">if</span> stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>] == <span class="number">0</span> &#123; <span class="comment">// 若栈顶槽位置零，则出栈</span></span><br><span class="line">                stk = stk[:<span class="built_in">len</span>(stk)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            stk = <span class="built_in">append</span>(stk,<span class="number">2</span>) <span class="comment">// 每出现一个新非空节点，入栈一个有2个槽位的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stk) == <span class="number">0</span>  <span class="comment">// 遍历结束后，没有空槽位说明序列合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-设置全局变量实时记录并更新递归过程中的极值"><a href="#3-设置全局变量实时记录并更新递归过程中的极值" class="headerlink" title="3.设置全局变量实时记录并更新递归过程中的极值"></a>3.设置全局变量实时记录并更新递归过程中的极值</h2><p>&emsp;&emsp;此类题目最终的输出是一个单一的值，我们需要维护一个全局变量来记录这一个单一值，并在递归遍历二叉树的过程中实时地更新这个值。用于递归的辅助函数的返回结果不必与这个值直接联系，要着眼于构建二叉树的节点间的关系。</p>
<h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a class="link" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和<i class="fas fa-external-link-alt"></i></a></h3><p><strong>路径</strong>被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p><strong>路径和</strong>是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="exx1.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="exx2.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[1, 3 * 104]</code></li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<ol>
<li>首先考虑辅助函数的功能。考虑实现一个简化的函数 <code>maxGain(node)</code>，该函数计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。具体而言，该函数的计算如下:</li>
</ol>
<ul>
<li>空节点的最大贡献值等于 0。</li>
<li>非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）。</li>
</ul>
<p>例如，考虑如下二叉树。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> -10</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;叶节点 9、15、7 的最大贡献值分别为 9、15、7。得到叶节点的最大贡献值之后，再计算非叶节点的最大贡献值。节点 20 的最大贡献值等于 <code>20+max⁡(15,7)=35</code>。节点 −10 的最大贡献值等于 <code>−10+max⁡(9,35)=25</code>。上述计算过程是递归的过程，因此，对根节点调用函数 <code>maxGain</code>，即可得到每个节点的最大贡献值。</p>
<p>&emsp;&emsp;根据函数 <code>maxGain</code> 得到每个节点的最大贡献值之后，如何得到二叉树的最大路径和？对于二叉树中的一个节点，该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。维护一个全局变量 <code>maxSum</code> 存储最大路径和，在递归过程中更新 <code>maxSum</code> 的值，最后得到的 <code>maxSum</code> 的值即为二叉树中的最大路径和。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">maxPathSum</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	maxSum := math.MinInt32  <span class="comment">// 设置全局变量用于实时比较及更新每个节点作为根节点时的最大路径</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">var</span> gotMax <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span></span><br><span class="line">  	gotMax = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  <span class="comment">// 递归出口</span></span><br><span class="line">        		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      	&#125;</span><br><span class="line">      	</span><br><span class="line">      	left := max(gotMax(root.Left),<span class="number">0</span>)  <span class="comment">// 当前节点的左子树的最大贡献值（如果小于0则置0）</span></span><br><span class="line">      	right := max(gotMax(root.Right),<span class="number">0</span>)  <span class="comment">// 当前节点右子树的最大贡献值（如果小于0则置0）</span></span><br><span class="line">      	now := root.Val + left + right  <span class="comment">// 记录以当前节点作为根节点的最大路径</span></span><br><span class="line">      	maxSum = max(maxSum,now) <span class="comment">// 更新最大值</span></span><br><span class="line">      </span><br><span class="line">      	<span class="keyword">return</span> root.Val+max(left,right)  <span class="comment">// 返回当前节点的最大贡献值</span></span><br><span class="line">  	&#125;</span><br><span class="line">		</span><br><span class="line">  	gotMax(root)</span><br><span class="line">  	<span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> a&gt;=b &#123;</span><br><span class="line">    	<span class="keyword">return</span> a</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a class="link" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径<i class="fas fa-external-link-alt"></i></a></h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p><strong>示例 :</strong><br>给定二叉树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5   </span><br></pre></td></tr></table></figure>

<p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。假设我们知道对于某节点的左儿子向下遍历经过最多的节点数 $L$ （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 $R$ （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 $L+R+1$ 。</p>
<p>&emsp;&emsp;最后的算法流程为：我们定义一个递归函数 <code>depth(node)</code> 计算 $d_{node}$，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 $L$ 和 $R$ ，则该节点为根的子树的深度即为 $\max (L, R)+1$, 该节点的 $d_{node}$ 值为$L+R+1$。递归搜索每个节点并设一个全局变量 <code>maxSum</code> 来记录并随时更新最大直径。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxSum <span class="keyword">int</span>  <span class="comment">// 全局变量用于记录最大直径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">diameterOfBinaryTree</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	naxSum = <span class="number">0</span></span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	depth(root)</span><br><span class="line">  	<span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">depth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123; <span class="comment">// 该辅助函数用于返回每个节点的深度</span></span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	left := depth(root.Left)</span><br><span class="line">  	right := depth(root.Right)</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> left+right+<span class="number">1</span> &gt; maxSum &#123; <span class="comment">// 更新最大直径的值</span></span><br><span class="line">    		maxSum = left + right + <span class="number">1</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">return</span> <span class="number">1</span>+max(left,right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">    	<span class="keyword">return</span> a</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-结果要求返回数组"><a href="#4-结果要求返回数组" class="headerlink" title="4.结果要求返回数组"></a>4.结果要求返回数组</h2><p>&emsp;&emsp;由于递归算法本身在递归的过程中没法返回数组，所以可以通过设置全局变量的方式，在递归过程中动态的更新数组。</p>
<h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a class="link" href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II<i class="fas fa-external-link-alt"></i></a></h3><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="pathsumii1.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="pathsum2.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], targetSum &#x3D; 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">树中节点总数在范围 [0, 5000] 内</span><br><span class="line">-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</span><br><span class="line">-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSym</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">  	ret := <span class="built_in">make</span>([][]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">  	path := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	helper(root,targetSum,&amp;ret,path)</span><br><span class="line">  	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>, ret *[][]<span class="keyword">int</span>, path []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	sum := targetSum - root.Val</span><br><span class="line">  	path = <span class="built_in">append</span>(path,root.Val)</span><br><span class="line">  	<span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; sum == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// / 创建一个辅助数组用于保存path的当前值，否则path会随递归操作而回溯</span></span><br><span class="line">    	dst := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>(path))  </span><br><span class="line">    	<span class="built_in">copy</span>(dst,path)</span><br><span class="line">    	*ret = <span class="built_in">append</span>(*ret, dst)</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	helper(root.Left, targetSum-root.Val, ret, path)</span><br><span class="line">  	helper(root.Right, targetSum-root.Val, ret, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a><a class="link" href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和<i class="fas fa-external-link-alt"></i></a></h3><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p>
<p>每条从根节点到叶节点的路径都代表一个数字：</p>
<ul>
<li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li>
</ul>
<p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p>
<p><strong>叶节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="num1tree.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3]</span><br><span class="line">输出：25</span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13</span><br><span class="line">因此，数字总和 &#x3D; 12 + 13 &#x3D; 25</span><br></pre></td></tr></table></figure>

<p><strong>示例 2</strong>：</p>
<p><img lazyload src="/images/loading.svg" data-src="num2tree.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,9,0,5,1]</span><br><span class="line">输出：1026</span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40</span><br><span class="line">因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>树的深度不超过 <code>10</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;深度优先搜索是很直观的做法。从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumNumbers</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    nodeArray := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    helper(root, &amp;nodeArray, path)</span><br><span class="line"></span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> nodeArray &#123;</span><br><span class="line">        ret += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, array *[]<span class="keyword">int</span>, path []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path = <span class="built_in">append</span>(path, root.Val)</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        node := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i:=<span class="built_in">len</span>(path)<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">            node += path[i]* <span class="keyword">int</span>(math.Pow10(<span class="built_in">len</span>(path)-i<span class="number">-1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        *array = <span class="built_in">append</span>(*array,node)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    helper(root.Left, array, path)</span><br><span class="line">    helper(root.Right, array, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a class="link" href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径<i class="fas fa-external-link-alt"></i></a></h3><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="paths-tree.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,null,5]</span><br><span class="line">输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[&quot;1&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<ul>
<li>当遍历到根节点时，将根节点的值转化成字符串后贴到路径串中，并将该条路径存入<code>ret</code>中；</li>
<li>当不是根节点时，将根节点的值转化成字符串后贴到路径串中，并在其后加入符号<code>-&gt;</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binaryTreePaths</span><span class="params">(root *TreeNode)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    ret := <span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">0</span>)</span><br><span class="line">    path := <span class="string">&quot;&quot;</span></span><br><span class="line">    helper(root,&amp;ret,path)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, ret *[]<span class="keyword">string</span>, path <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123; <span class="comment">// 当是根节点时，该条路径遍历结束，存入ret</span></span><br><span class="line">        path = path + strconv.Itoa(root.Val)</span><br><span class="line">        dst := <span class="string">&quot;&quot;</span></span><br><span class="line">        dst = path        </span><br><span class="line">        *ret = <span class="built_in">append</span>(*ret, dst)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        path = path + strconv.Itoa(root.Val) + <span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    helper(root.Left, ret, path)</span><br><span class="line">    helper(root.Right, ret, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="863-二叉树中所有距离为-K-的结点"><a href="#863-二叉树中所有距离为-K-的结点" class="headerlink" title="863. 二叉树中所有距离为 K 的结点"></a><a class="link" href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树（具有根结点 <code>root</code>）， 一个目标结点 <code>target</code> ，和一个整数值 <code>K</code> 。</p>
<p>返回到目标结点 <code>target</code> 距离为 <code>K</code> 的所有结点的值的列表。 答案可以以任何顺序返回。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], target &#x3D; 5, K &#x3D; 2</span><br><span class="line">输出：[7,4,1]</span><br><span class="line">解释：</span><br><span class="line">所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1</span><br><span class="line"></span><br><span class="line">注意，输入的 &quot;root&quot; 和 &quot;target&quot; 实际上是树上的结点。</span><br><span class="line">上面的输入仅仅是对这些对象进行了序列化描述。</span><br></pre></td></tr></table></figure>

<p><img lazyload src="/images/loading.svg" data-src="sketch0.png" alt="avatar"></p>
<p>提示：</p>
<ul>
<li>给定的树是非空的。</li>
<li>树上的每个结点都具有唯一的值 0 &lt;= node.val &lt;= 500 。</li>
<li>目标结点 target 是树上的结点。</li>
<li>0 &lt;= K &lt;= 1000.</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>若将 <code>target</code> 当作树的根结点，我们就能从 <code>target</code> 出发，使用深度优先搜索去寻找与 <code>target</code> 距离为 <code>k</code> 的所有结点，即深度为 <code>k</code> 的所有结点。</p>
<p>由于输入的二叉树没有记录父结点，为此，我们从根结点 <code>root</code> 出发，使用深度优先搜索遍历整棵树，同时用一个哈希表记录每个结点的父结点。</p>
<p>然后从 <code>target</code> 出发，使用深度优先搜索遍历整棵树，除了搜索左右儿子外，还可以顺着父结点向上搜索。</p>
<p>代码实现时，由于每个结点值都是唯一的，哈希表的键可以用结点值代替。此外，为避免在深度优先搜索时重复访问结点，递归时额外传入来源结点 <code>from</code>，在递归前比较目标结点是否与来源结点相同，不同的情况下才进行递归。通过标记源结点，如图结点2遍历到7时，由于存在7-&gt;2的边，可能会重复遍历。由于存在我们预先标记的源节点只有当<code>cur != from</code>的时候才能继续遍历。</p>
<p><img lazyload src="/images/loading.svg" data-src="1627477357-OBWKQM-image.png" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distanceK</span><span class="params">(root *TreeNode, target *TreeNode, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*TreeNode,<span class="number">0</span>) <span class="comment">// 初始化map用于存储父节点</span></span><br><span class="line">    <span class="keyword">var</span> parent <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span> </span><br><span class="line">    parent = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123; <span class="comment">// 递归存储每个节点的父节点</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            m[root.Left.Val] = root</span><br><span class="line">            parent(root.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            m[root.Right.Val] = root</span><br><span class="line">            parent(root.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parent(root)</span><br><span class="line"></span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> disK <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode,*TreeNode,<span class="keyword">int</span>)</span> // // 从 <span class="title">target</span> 出发 <span class="title">DFS</span>，寻找所有深度为 <span class="title">k</span> 的结点</span></span><br><span class="line">    disK = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, from *TreeNode, depth <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> depth == k &#123; <span class="comment">// 距离等于k，存入ret并剪枝</span></span><br><span class="line">            ret = <span class="built_in">append</span>(ret, root.Val)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Left != from &#123; <span class="comment">// 左节点</span></span><br><span class="line">            disK(root.Left, root, depth+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Right != from &#123; <span class="comment">// 右节点</span></span><br><span class="line">            disK(root.Right, root, depth+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> m[root.Val] != from &#123; <span class="comment">// 父节点</span></span><br><span class="line">            disK(m[root.Val], root, depth+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    disK(target,<span class="literal">nil</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树(BST)"></a>二叉搜索树(BST)</h1><h2 id="二叉搜索树-BST-的特性"><a href="#二叉搜索树-BST-的特性" class="headerlink" title="二叉搜索树(BST)的特性"></a>二叉搜索树(BST)的特性</h2><ol>
<li>对于 BST 的每一个节点 <code>node</code>，左子树节点的值都比 <code>node</code> 的值要小，右子树节点的值都比 <code>node</code> 的值大。</li>
<li>对于 BST 的每一个节点 <code>node</code>，它的左侧子树和右侧子树都是 BST。</li>
<li><strong>从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）</strong>。</li>
</ol>
<h2 id="BST必知必会题"><a href="#BST必知必会题" class="headerlink" title="BST必知必会题"></a>BST必知必会题</h2><h3 id="1-判断BST的合法性-98-验证二叉搜索树"><a href="#1-判断BST的合法性-98-验证二叉搜索树" class="headerlink" title="1. 判断BST的合法性(98. 验证二叉搜索树)"></a>1. 判断BST的合法性(<a class="link" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树<i class="fas fa-external-link-alt"></i></a>)</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。   </li>
</ul>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>

<p><strong>解题思路：</strong></p>
<p>对于每一个节点 **<code>root</code><strong>，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，</strong><code>root</code>**的整个左子树都要小于 **<code>root.val</code>**，整个右子树都要大于 **<code>root.val</code>**。</p>
<p>问题是，对于某一个节点 <code>root</code>，他只能管得了自己的左右子节点，怎么把 <code>root</code> 的约束传递给左右子树呢？<strong>我们通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉树算法的一个小技巧吧</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span> <span class="title">boll</span></span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> helper(root, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, max *TreeNode, min *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> min != <span class="literal">nil</span> &amp;&amp; root.Val &lt;= min.Val &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">if</span> max != <span class="literal">nil</span> &amp;&amp; root.Val &gt;= max.Val &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">return</span> helper(root.Left, root, min) &amp;&amp; helper(root.Right, max, root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-在BST中搜索一个数"><a href="#2-在BST中搜索一个数" class="headerlink" title="2. 在BST中搜索一个数"></a>2. 在BST中搜索一个数</h3><p>&emsp;&emsp;直接利用BST的性质前序遍历二叉搜索树，当当前节点值等于<code>target</code>，直接返回<code>true</code>，如果当前节点值大于<code>target</code>，则在其左子树中寻找；如果小于<code>target</code>，在其右子树中寻找。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isInBST</span><span class="params">(root *TreeNode, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">if</span> root.Val == target &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">if</span> root.Val &gt; target &#123;</span><br><span class="line">    		<span class="keyword">return</span> isInBST(root.Left, target)</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">if</span> root.Val &lt; target &#123;</span><br><span class="line">    		<span class="keyword">return</span> isInBST(root.Right, target)</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-在BST中插入一个数"><a href="#3-在BST中插入一个数" class="headerlink" title="3. 在BST中插入一个数"></a>3. 在BST中插入一个数</h3><p>&emsp;&emsp;涉及到“改”这一操作，就要返回<code>TreeNode</code>类型了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  <span class="comment">// 找到空位置插入新节点</span></span><br><span class="line">    		node := &amp;TreeNode&#123;val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">    		<span class="keyword">return</span> node</span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> root.Val &lt; val &#123; <span class="comment">// 在右子树的叶节点中插入val</span></span><br><span class="line">    		root.Right = insertIntoBST(root.Right,val)</span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> root.Val &gt; val &#123; <span class="comment">// 在左子树的叶节点中插入val</span></span><br><span class="line">    		root.Left = insertIntoBST(root.Left,val)</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-在BST中删除一个数"><a href="#4-在BST中删除一个数" class="headerlink" title="4. 在BST中删除一个数"></a>4. 在BST中删除一个数</h3><p>&emsp;&emsp;这个问题稍微复杂，跟插入操作类似，先「找」再「改」。找到目标节点了，比方说是节点 <code>A</code>，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。</p>
<ul>
<li>情况1: <code>A</code> 恰好是末端节点，两个子节点都为空，那么可以直接将其删除。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="case1.png" alt="avatar"></p>
<ul>
<li>情况2: <code>A</code> 只有一个非空子节点，那么它要让这个孩子接替自己的位置。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="case2.png" alt="avatar"></p>
<ul>
<li>情况 3：<code>A</code> 有两个子节点，麻烦了，为了不破坏 BST 的性质，<code>A</code> 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="case3.png" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> root.Val == key &#123;</span><br><span class="line">    		<span class="comment">// 下面两个if把case1和case2都处理了</span></span><br><span class="line">    		<span class="keyword">if</span> root.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">      			<span class="keyword">return</span> root.Right</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">      			<span class="keyword">return</span> root.Left</span><br><span class="line">    		&#125;</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">// case3</span></span><br><span class="line">    		minNode := getNode(root.Right)</span><br><span class="line">      	root.Val = minNode.Val <span class="comment">// 将当前根节点的值用右子树最小值(一定是叶节点)替换</span></span><br><span class="line">    		root.Right = deletNode(root.Right, minNode.Val) <span class="comment">// 删除掉被替换后的叶节点</span></span><br><span class="line">  	&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &gt; key &#123;</span><br><span class="line">    		root.Left = deleteNode(root.Left,key)</span><br><span class="line">  	&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &lt; key &#123;</span><br><span class="line">    		root.Right = deleteNode(root.Left,key)</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMin</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  	<span class="keyword">for</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">    		root = root.Left</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BST高频题"><a href="#BST高频题" class="headerlink" title="BST高频题"></a>BST高频题</h2><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a class="link" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="uniquebstn3.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 19</code></li>
</ul>
<p><strong>解题思路：</strong>(搬运自<a class="link" href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/">不同的二叉搜索树<i class="fas fa-external-link-alt"></i></a>)</p>
<p>&emsp;&emsp;给定一个有序序列 $1⋯n$，为了构建出一棵二叉搜索树，我们可以遍历每个数字 $i$，将该数字作为树根，将 $1⋯(i−1)$ 序列作为左子树，将 $(i+1)⋯n$ 序列作为右子树。接着我们可以按照同样的方式递归构建左子树和右子树。</p>
<p>&emsp;&emsp;在上述构建的过程中，由于根的值不同，因此我们能保证每棵二叉搜索树是唯一的。由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用。因此，我们可以想到使用动态规划来求解本题。</p>
<p>&emsp;&emsp;题目要求是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：</p>
<ol>
<li>$G(n)$: 长度为 $n$ 的序列能构成的不同二叉搜索树的个数。</li>
<li>$F(i,n)$: 以 $i$ 为根、序列长度为 $n$ 的不同二叉搜索树个数 $(1≤i≤n)$。</li>
</ol>
<p>&emsp;&emsp;可见，$G(n)$ 是我们求解需要的函数。稍后我们将看到，$G(n)$ 可以从 $F(i,n)$ 得到，而 $F(i,n)$ 又会递归地依赖于 $G(n)$。</p>
<p>&emsp;&emsp;首先，根据上一节中的思路，不同的二叉搜索树的总数 $G(n)$，是对遍历所有 $(1≤i≤n)$ 的 $F(i,n)$ 之和。换言之：</p>
<p>$G(n)=\sum_{i=1}^{n} F(i, n)$</p>
<p>&emsp;&emsp;对于边界情况，当序列长度为 11（只有根）或为 00（空树）时，只有一种情况，即：</p>
<p>$G(0)=1, \quad G(1)=1$</p>
<p>&emsp;&emsp;给定序列 $1⋯n$，我们选择数字 $i$ 作为根，则根为 $i$ 的所有二叉搜索树的集合是左子树集合和右子树集合的笛卡尔积，对于笛卡尔积中的每个元素，加上根节点之后形成完整的二叉搜索树，如下图所示：</p>
<p><img lazyload src="/images/loading.svg" data-src="96_fig1.png" alt="avatar"></p>
<p>&emsp;&emsp;举例而言，创建以 3 为根、长度为 7 的不同二叉搜索树，整个序列是 $[1,2,3,4,5,6,7]$，我们需要从左子序列 $[1,2]$ 构建左子树，从右子序列 $[4,5,6,7]$ 构建右子树，然后将它们组合（即笛卡尔积）。对于这个例子，不同二叉搜索树的个数为 $F(3,7)$。我们将 $[1,2]$ 构建不同左子树的数量表示为 $G(2)$, 从 $[4,5,6,7]$ 构建不同右子树的数量表示为 $G(4)$，注意到 $G(n)$ 和序列的内容无关，只和序列的长度有关。于是，$F(3,7)=G(2)⋅G(4)$。 因此，我们可以得到以下公式：</p>
<p>$F(i, n)=G(i-1) \cdot G(n-i)$</p>
<p>将公式结合，可以得到 $G(n)$ 的递归表达式：</p>
<p>$G(n)=\sum_{i=1}^{n} G(i-1) \cdot G(n-i)$</p>
<p>至此，我们从小到大计算 $G$ 函数即可，因为 $G(n)$ 的值依赖于 $G(0)⋯G(n−1)$。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numTrees</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	m := <span class="built_in">make</span>([][]<span class="keyword">int</span>,n)  <span class="comment">// 初始化一个二维数组充当记事本</span></span><br><span class="line">  	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">    		m[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> count(<span class="number">1</span>,n,m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(l <span class="keyword">int</span>, r <span class="keyword">int</span>, m [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> l &gt; r &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> m[l<span class="number">-1</span>][r<span class="number">-1</span>] != <span class="number">0</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> m[l<span class="number">-1</span>][r<span class="number">-1</span>]</span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">for</span> i:=l; i&lt;=r; i++ &#123;</span><br><span class="line">    		left := count(l,i<span class="number">-1</span>,m)</span><br><span class="line">    		right := count(i+<span class="number">1</span>,r,m)</span><br><span class="line">				ret += left*right  <span class="comment">// 笛卡尔乘积</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	m[l<span class="number">-1</span>][r<span class="number">-1</span>] = ret</span><br><span class="line">  	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a class="link" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II<i class="fas fa-external-link-alt"></i></a></h3><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code>互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="uniquebstn.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>二叉搜索树关键的性质是根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。因此在生成所有可行的二叉搜索树的时候，假设当前序列长度为 n，如果我们枚举根节点的值为 i，那么根据二叉搜索树的性质我们可以知道左子树的节点值的集合为 [1…i−1]，右子树的节点值的集合为 [i+1…n]。而左子树和右子树的生成相较于原问题是一个序列长度缩小的子问题，因此我们可以想到用回溯的方法来解决这道题目。</p>
<p>我们定义 <code>generateTrees(start, end)</code> 函数表示当前值的集合为 <code>[start,end]</code>，返回序列 <code>[start,end]</code> 生成的所有可行的二叉搜索树。按照上文的思路，我们考虑枚举 <code>[start,end]</code> 中的值 i 为当前二叉搜索树的根，那么序列划分为了 <code>[start,i−1]</code> 和 <code>[i+1,end]</code> 两部分。我们递归调用这两部分，即 <code>generateTrees(start, i - 1)</code> 和 <code>generateTrees(i + 1, end)</code>，获得所有可行的左子树和可行的右子树，那么最后一步我们只要从可行左子树集合中选一棵，再从可行右子树集合中选一棵拼接到根节点上，并将生成的二叉搜索树放入答案数组即可。</p>
<p>递归的入口即为 <code>generateTrees(1, n)</code>，出口为当 start&gt;end 的时候，当前二叉搜索树为空，返回空节点即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateTrees</span><span class="params">(n <span class="keyword">int</span>)</span> []*<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getBST(<span class="number">1</span>,n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBST</span><span class="params">(l <span class="keyword">int</span>, r <span class="keyword">int</span>)</span> []*<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> l &gt; r &#123;</span><br><span class="line">      	<span class="keyword">return</span> []*TreeNode&#123;<span class="literal">nil</span>&#125; </span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	ret := <span class="built_in">make</span>([]*TrrNode,<span class="number">0</span>)</span><br><span class="line">  	<span class="comment">// 枚举可行根节点</span></span><br><span class="line">  	<span class="keyword">for</span> i:=l; i&lt;=r; i++ &#123;</span><br><span class="line">      	<span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">    		leftTree := getBST(l,i<span class="number">-1</span>)</span><br><span class="line">      <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">    		tightTree := getBST(i+<span class="number">1</span>,r)</span><br><span class="line">    		<span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">    		<span class="keyword">for</span> _,left := <span class="keyword">range</span> leftTree &#123;</span><br><span class="line">      			<span class="keyword">for</span> _,right := <span class="keyword">range</span> rightTree &#123;</span><br><span class="line">        				root := &amp;TreeNode&#123;i,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">        				root.Left = left</span><br><span class="line">        				root.Right = right</span><br><span class="line">        				ret = <span class="built_in">append</span>(ret,root)</span><br><span class="line">      			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a><a class="link" href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树<i class="fas fa-external-link-alt"></i></a></h3><p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>
<p>进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="recover1.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,3,null,null,2]</span><br><span class="line">输出：[3,1,null,null,2]</span><br><span class="line">解释：3 不能是 1 左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="recover2.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,1,4,null,null,2]</span><br><span class="line">输出：[2,1,4,null,null,3]</span><br><span class="line">解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树上节点的数目在范围 <code>[2, 1000]</code> 内</li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;我们需要考虑两个节点被错误地交换后对原二叉搜索树造成了什么影响。对于二叉搜索树，我们知道如果对其进行中序遍历，得到的值序列是递增有序的，而如果我们错误地交换了两个节点，等价于在这个值序列中交换了两个值，破坏了值序列的递增性。</p>
<p>&emsp;&emsp;我们来看下如果在一个递增的序列中交换两个值会造成什么影响。假设有一个递增序列 <code>a=[1,2,3,4,5,6,7]</code>。如果我们交换两个不相邻的数字，例如 2 和 6，原序列变成了 <code>a=[1,6,3,4,5,2,7]</code>，那么显然序列中有两个位置不满足 $a_{i}$&lt;$a_{i+1}$，在这个序列中体现为6&gt;3，5&gt;2，因此只要我们找到这两个位置，即可找到被错误交换的两个节点。如果我们交换两个相邻的数字，例如 2 和 3，此时交换后的序列只有一个位置不满足  $a_{i}$&lt;$a_{i+1}$。因此整个值序列中不满足条件的位置或者有两个，或者有一个。</p>
<p>&emsp;&emsp;至此，解题方法已经呼之欲出了：</p>
<ol>
<li>找到二叉搜索树中序遍历得到值序列的不满足条件的位置。</li>
<li>如果有两个，我们记为 i 和 j（i&lt;j 且  $a_{i}$&gt;$a_{i+1}$ &amp;&amp;  $a_{j}$&gt;$a_{j+1}$，那么对应被错误交换的节点即为$a_{i}$对应的节点和$a_{i+1}$对应的节点，我们分别记为 x 和 y。</li>
<li>如果有一个，我们记为 i，那么对应被错误交换的节点即为$a_{i}$对应的节点和$a_{i+1}$对应的节点，我们分别记为 x 和 y。</li>
<li>交换 x 和 y 两个节点即可。</li>
</ol>
<p>&emsp;&emsp;实现部分，本方法开辟一个新数组 <code>nums</code> 来记录中序遍历得到的值序列，然后线性遍历找到两个位置 i 和 j，并重新遍历原二叉搜索树修改对应节点的值完成修复，具体实现可以看下面的代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverTree</span><span class="params">(root *TreeNode)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    nums := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> inorder <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span> // 中序遍历保存序列</span></span><br><span class="line">    inorder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.Left)</span><br><span class="line">        nums = <span class="built_in">append</span>(nums,root.Val)</span><br><span class="line">        inorder(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root)</span><br><span class="line">    A, B := helper(nums)</span><br><span class="line">    fmt.Println(A,B)</span><br><span class="line">    <span class="built_in">recover</span>(A, B, <span class="number">2</span>, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 返回两个顺序错误的节点的值</span></span><br><span class="line">    x,y := math.MinInt32, <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i+<span class="number">1</span>] &lt; nums[i] &#123;</span><br><span class="line">            y = nums[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> x == math.MinInt32 &#123;</span><br><span class="line">                x = nums[i]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x,y</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">(A <span class="keyword">int</span>, B <span class="keyword">int</span>, count <span class="keyword">int</span>, root *TreeNode)</span></span> &#123; <span class="comment">// 遍历二叉树，改变这两个节点值</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val == A || root.Val == B &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val == A &#123;</span><br><span class="line">            root.Val = B </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.Val = A</span><br><span class="line">        &#125;</span><br><span class="line">        count-- <span class="comment">// 用于计数，当两个节点都被改变后，直接跳出递的过程，剪枝</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">recover</span>(A, B, count, root.Left)</span><br><span class="line">    <span class="built_in">recover</span>(A, B, count, root.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀树(Trie)</title>
    <url>/2021/09/02/%E5%89%8D%E7%BC%80%E6%A0%91(Trie)/</url>
    <content><![CDATA[<h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a class="link" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)<i class="fas fa-external-link-alt"></i></a></h2><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p><img lazyload src="/images/loading.svg" data-src="500px-Trie_example.svg.png" alt="avatar"></p>
<p>请你实现 Trie 类：</p>
<ul>
<li>Trie() 初始化前缀树对象。</li>
<li>void insert(String word) 向前缀树中插入字符串 word 。</li>
<li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li>
<li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</li>
</ul>
<p><strong>示例：</strong></p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 True</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= word.length, prefix.length &lt;= 2000</li>
<li>word 和 prefix 仅由小写英文字母组成</li>
<li>insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次</li>
</ul>
<p><strong>解题思路：</strong>（来源于<a class="link" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/">实现 Trie (前缀树)<i class="fas fa-external-link-alt"></i></a>）</p>
<p>Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：</p>
<ul>
<li>指向子节点的指针数组 <code>child</code>。对于本题而言，数组长度为 26，即小写英文字母的数量。此时 <code>child[0]</code> 对应小写字母 a，<code>child[1]</code> 对应小写字母 b，…，<code>child[25]</code> 对应小写字母 z。</li>
<li>布尔字段 <code>isEnd</code>，表示该节点是否为字符串的结尾。</li>
</ul>
<p><strong>插入字符串</strong></p>
<p>我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：</p>
<ul>
<li>子节点存在。沿着指针移动到子节点，继续处理下一个字符。</li>
<li>子节点不存在。创建一个新的子节点，记录在 <code>child</code> 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。</li>
<li>重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。</li>
</ul>
<p><strong>查找前缀</strong></p>
<p>我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：</p>
<ul>
<li>子节点存在。沿着指针移动到子节点，继续搜索下一个字符。</li>
<li>子节点不存在。说明字典树中不包含该前缀，返回空指针。</li>
<li>重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。</li>
</ul>
<p>若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的 <code>isEnd</code>为真，则说明字典树中存在该字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    child   [<span class="number">26</span>]*Trie</span><br><span class="line">    isEnd   <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">Trie</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Trie&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">Insert</span><span class="params">(word <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> this.child[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">            this.child[ch] = &amp;Trie&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this = this.child[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    this.isEnd = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">Search</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> this.child[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;  </span><br><span class="line">        this = this.child[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> this.isEnd == <span class="literal">false</span> &#123; <span class="comment">// 上述for循环结束只能表明存在该前缀，还要判断有没有结束符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">StartsWith</span><span class="params">(prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> prefix &#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> this.child[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        this = this.child[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Insert(word);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Search(word);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.StartsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>一些有趣的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>循转数组相关题目</title>
    <url>/2021/09/12/%E5%BE%AA%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是对旋转数组类型的题目的总结，一共6道，基本都是二分法的套路。</p>
<h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a class="link" href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组<i class="fas fa-external-link-alt"></i></a></h2><p>给定一个数组，将数组中的元素向右移动 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<p>进阶：</p>
<ul>
<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>
<li>你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2</span><br><span class="line">输出：[3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= k &lt;= 105</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>方法一：使用额外的数组</p>
<p>&emsp;&emsp;可以使用额外的数组来将每个元素放至正确的位置。用 <code>n</code> 表示数组的长度，我们遍历原数组，将原数组下标为 <code>i</code> 的元素放至新数组下标为 <code>(i+k)%n</code> 的位置，最后将新数组拷贝至原数组即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    newNums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        newNums[(i+k)%<span class="built_in">len</span>(nums)] = v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(nums, newNums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法二：环状替换</p>
<p>&emsp;&emsp;从另一个角度，我们可以将被替换的元素保存在变量 <code>temp</code> 中，从而避免了额外数组的开销。我们从位置 0 开始，最初令 <code>temp=nums[0]</code>。根据规则，位置 0 的元素会放至 <code>(0+k)%n</code>的位置，令 <code>x=(0+k)%n</code>，此时交换 <code>temp </code>和 <code>nums[x]</code>，完成位置 x 的更新。然后，我们考察位置 x，并交换 <code>temp</code> 和 <code>nums[(x+k)%n]</code>，从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置 0。</p>
<p>&emsp;&emsp;容易发现，当回到初始位置 0 时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？我们不妨先考虑这样一个问题：从 0 开始不断遍历，最终回到起点 0 的过程中，我们遍历了多少个元素？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    k %= n</span><br><span class="line">    <span class="keyword">for</span> start, count := <span class="number">0</span>, gcd(k, n); start &lt; count; start++ &#123;</span><br><span class="line">        pre, cur := nums[start], start</span><br><span class="line">        <span class="keyword">for</span> ok := <span class="literal">true</span>; ok; ok = cur != start &#123;</span><br><span class="line">            next := (cur + k) % n</span><br><span class="line">            nums[next], pre, cur = pre, nums[next], next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">// 需要遍历的次数是n和k的最大公约数</span></span><br><span class="line">    <span class="keyword">for</span> a != <span class="number">0</span> &#123;</span><br><span class="line">        a, b = b%a, a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法三：数组翻转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums &#x3D; &quot;-----&gt;--&gt;&quot;; k &#x3D;3</span><br><span class="line">result &#x3D; &quot;--&gt;-----&gt;&quot;;</span><br><span class="line"></span><br><span class="line">reverse &quot;-----&gt;--&gt;&quot; we can get &quot;&lt;--&lt;-----&quot;</span><br><span class="line">reverse &quot;&lt;--&quot; we can get &quot;--&gt;&lt;-----&quot;</span><br><span class="line">reverse &quot;&lt;-----&quot; we can get &quot;--&gt;-----&gt;&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    k %= <span class="built_in">len</span>(nums)</span><br><span class="line">    reverse(nums)</span><br><span class="line">    reverse(nums[:k])</span><br><span class="line">    reverse(nums[k:])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(a []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n/<span class="number">2</span>; i++ &#123;</span><br><span class="line">        a[i], a[n-i<span class="number">-1</span>] = a[n-i<span class="number">-1</span>], a[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="在旋转数组里寻找最小值"><a href="#在旋转数组里寻找最小值" class="headerlink" title="在旋转数组里寻找最小值"></a>在旋转数组里寻找最小值</h1><p>&emsp;&emsp;可以看作寻找最小值左边界问题(直接解决又重复元素的情况)。</p>
<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a class="link" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值<i class="fas fa-external-link-alt"></i></a></h2><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组<code> [a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组<code> [a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>。</p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>n == nums.length</li>
<li>1 &lt;= n &lt;= 5000</li>
<li>-5000 &lt;= nums[i] &lt;= 5000</li>
<li>nums 中的所有整数 互不相同</li>
<li>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;本题可以看作是找数组中的最小数。如果更改一下题目条件，数组中的元素是可以重复的，那么可以看作找最小数的左边界即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] &gt; nums[mid] &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[right] &lt; nums[mid] &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 可能因为重复元素使得两者相等，缩小查找范围</span></span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a class="link" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II<i class="fas fa-external-link-alt"></i></a></h2><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,4]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,4,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,5]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>n == nums.length</li>
<li>1 &lt;= n &lt;= 5000</li>
<li>-5000 &lt;= nums[i] &lt;= 5000</li>
<li>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;同上题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] &gt; nums[mid] &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[right] &lt; nums[mid] &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="在旋转数组里寻找指定的值"><a href="#在旋转数组里寻找指定的值" class="headerlink" title="在旋转数组里寻找指定的值"></a>在旋转数组里寻找指定的值</h1><p>&emsp;&emsp;上面两道题是在旋转数组里寻找最小值，下面两道题是在旋转数组里寻找指定的值，这两道题的区别也是存不存在重复值。</p>
<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a class="link" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组<i class="fas fa-external-link-alt"></i></a></h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k（0 &lt;= k &lt; nums.length）</code>上进行了 旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 3 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code>。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 5000</li>
<li>-10^4 &lt;= nums[i] &lt;= 10^4</li>
<li>nums 中的每个值都 独一无二</li>
<li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li>
<li>-10^4 &lt;= target &lt;= 10^4</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;其实方法还是类似于上题，不过对于寻找特定的数，需要判断该数可能存在于什么区间内。</p>
<ul>
<li>如果 <code>[l, mid - 1]</code> 是有序数组，且 <code>target</code> 的大小满足 <code>[nums[l],nums[mid])</code>，则我们应该将搜索范围缩小至 <code>[l, mid - 1]</code>，否则在 <code>[mid + 1, r]</code> 中寻找。</li>
<li>如果 <code>[mid, r]</code> 是有序数组，且 <code>target</code> 的大小满足 <code>(nums[mid+1],nums[r]]</code>，则我们应该将搜索范围缩小至 <code>[mid + 1, r]</code>，否则在<code>[l, mid - 1]</code> 中寻找。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[right] &gt;= nums[mid] &#123; <span class="comment">// 右半部分是有序的</span></span><br><span class="line">          <span class="comment">// 此处若出现nums[right] = nums[mid]的情况，说明mid=right，因为数组不重复</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[right] &lt;= nums[mid] &#123; <span class="comment">// 左半部分是有序的</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target &#123;</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a class="link" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II<i class="fas fa-external-link-alt"></i></a></h2><p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 <code>k（0 &lt;= k &lt; nums.length</code>）上进行了 旋转 ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 5 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p>
<p>给你 旋转后 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 5000</li>
<li>-104 &lt;= nums[i] &lt;= 104</li>
<li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li>
<li>-104 &lt;= target &lt;= 104</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;大体上同上题思路是一致的，只需要在遇到<code>nums[mid]==nums[right]</code>时缩小查找范围即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] == nums[right] || nums[left] == nums[right] &#123;</span><br><span class="line">          <span class="comment">// 当收尾元素相等或中值与末尾元素相等时，缩小查找范围</span></span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; nums[right] &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; nums[right] &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target &#123;</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="面试题-10-03-搜索旋转数组"><a href="#面试题-10-03-搜索旋转数组" class="headerlink" title="面试题 10.03. 搜索旋转数组"></a><a class="link" href="https://leetcode-cn.com/problems/search-rotate-array-lcci/">面试题 10.03. 搜索旋转数组<i class="fas fa-external-link-alt"></i></a></h2><p>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: arr &#x3D; [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target &#x3D; 5</span><br><span class="line">输出: 8（元素5在该数组中的索引）</span><br></pre></td></tr></table></figure>

<p><strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target &#x3D; 11</span><br><span class="line"> 输出：-1 （没有找到）</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ol>
<li>arr 长度范围在[1, 1000000]之间</li>
</ol>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;本题是上一题的一个小进阶，不仅要确认是否有<code>target</code>值，还要输出其左边界，在上一题的基础上套用二分法查找左边界的方法即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(arr []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(arr)<span class="number">-1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target &#123; <span class="comment">// 找到目标后用右边界锁定住</span></span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[left] == arr[right] || arr[mid] == arr[right] &#123; <span class="comment">// 排除重复数，缩小搜索范围</span></span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[right] &gt; arr[mid] &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[mid] &lt; target &amp;&amp; arr[right] &gt;= target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[right] &lt; arr[mid] &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[left] &lt;= target &amp;&amp; arr[mid] &gt; target &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> arr[left] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库三大范式</title>
    <url>/2021/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><h2 id="为什么需要数据库规范化？"><a href="#为什么需要数据库规范化？" class="headerlink" title="为什么需要数据库规范化？"></a>为什么需要数据库规范化？</h2><ul>
<li>信息重复</li>
<li>更新异常</li>
<li>插入异常<ul>
<li>无法正常显示信息</li>
</ul>
</li>
<li>删除异常<ul>
<li>丢失有效信息</li>
</ul>
</li>
</ul>
<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h3><p>&emsp;&emsp;第一范式是最基本的范式。如果数据库表中的<font color="red">所有字段值都是不可分解的原子值</font>，就说明该数据库表满足了第一范式。</p>
<p>&emsp;&emsp;第一范式的合理遵循需要根据系统的<strong>实际需求</strong>来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。</p>
<p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/1.png" alt="avatar"></p>
<p>&emsp;&emsp;上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p>
<h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h3><p>&emsp;&emsp;前提：满足第一范式</p>
<p>&emsp;&emsp;第二范式在第一范式的基础之上更进一层。第二范式需要<strong>确保表中的每列都和主键相关</strong>，而不能只与主键的某一部分相关（主要针对联合主键而言）。<font color="red">也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</font>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。</p>
<p> <strong>订单信息表</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="2.png" alt="avatar"></p>
<p>&emsp;&emsp;这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。</p>
<p><img lazyload src="/images/loading.svg" data-src="3.png" alt="avatar"></p>
<p>&emsp;&emsp;这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。</p>
<h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h3><p>&emsp;&emsp;前提：满足第一和第二范式</p>
<p>&emsp;&emsp;第三范式需要确保数据表中的<font color="red">每一列数据都和主键直接相关，而不能间接相关</font>。</p>
<p>&emsp;&ensp;比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。</p>
<p><img lazyload src="/images/loading.svg" data-src="4.png" alt="avatar"></p>
<p>&emsp;&emsp;这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。</p>
<h2 id="规范性和性能的问题"><a href="#规范性和性能的问题" class="headerlink" title="规范性和性能的问题"></a>规范性和性能的问题</h2><p>关联查询的表不得超过三张表（阿里的规则）</p>
<ul>
<li>考虑商业化的需求和目标（成本，用户体验），数据库的性能更加重要</li>
<li>在规范性能的问题的时候，适当的考虑规范性</li>
<li>有时候会故意给某些表增加一下冗余的字段（从多表查询变为单表查询）</li>
<li>有时候会故意增加一些计算列（从大数据量降低为小数据量的查询：索引）</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>SQL数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>图算法</title>
    <url>/2021/09/14/%E5%9B%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="图论基础"><a href="#图论基础" class="headerlink" title="图论基础"></a>图论基础</h1><h2 id="图的逻辑结构和具体实现"><a href="#图的逻辑结构和具体实现" class="headerlink" title="图的逻辑结构和具体实现"></a>图的逻辑结构和具体实现</h2><ol>
<li>图的逻辑结构</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph1.jpg" alt="avatar"></p>
<p>&emsp;&emsp;为了方便研究图，我们将图可以抽象为下面的形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">  	id					<span class="keyword">int</span></span><br><span class="line">  	neighbors		[]*Vertex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可见，这个结构和多叉树节点是一样的。所以可以认为图是比较特殊的多叉树。不过呢，上面的这种实现是「逻辑上的」，实际上我们很少用这个 <code>Vertex</code> 类实现图，而是用常说的<strong>邻接表和邻接矩阵</strong>来实现。</p>
<ol start="2">
<li>具体实现方式</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph2.jpg" alt="avatar"></p>
<ul>
<li>邻接表：邻接表很直观，我把每个节点 <code>x</code> 的邻居都存到一个列表里，然后把 <code>x</code> 和这个列表关联起来，这样就可以通过一个节点 <code>x</code> 找到它的所有相邻节点。</li>
<li>邻接矩阵：邻接矩阵是一个二维布尔数组，将其称为<code>matrix</code>，如果节点 <code>x</code> 和 <code>y</code> 是相连的，那么就把 <code>matrix[x][y]</code> 设为 <code>true</code>（上图中绿色的方格代表 <code>true</code>）。如果想找节点 <code>x</code>的邻居，去扫一圈 <code>matrix[x][..]</code> 就行了。</li>
</ul>
<ol start="3">
<li>邻接表和邻接矩阵的优劣</li>
</ol>
<ul>
<li>邻接表<ul>
<li>好处是占用的空间少。</li>
<li>坏处是邻接表无法快速判断两个节点是否相邻。</li>
</ul>
</li>
<li>邻接矩阵<ul>
<li>好处是可以快速判断两个节点是否相邻。</li>
<li>坏处是占用空间大。</li>
</ul>
</li>
</ul>
<h2 id="更复杂的图"><a href="#更复杂的图" class="headerlink" title="更复杂的图"></a>更复杂的图</h2><ul>
<li>有向加权图<ul>
<li>如果使用邻接表，我们不仅仅存储某个节点 <code>x</code> 的所有邻居节点，还存储 <code>x</code> 到每个邻居的权重。</li>
<li>如果使用邻接矩阵，<code>matrix[x][y]</code> 不再是布尔值，而是一个 int 值，0 表示没有连接，其他值表示权重。</li>
</ul>
</li>
<li>无向图<ul>
<li>所谓的「无向」，也等同于「双向」。</li>
<li>如果连接无向图中的节点 <code>x</code> 和 <code>y</code>，把 <code>matrix[x][y]</code> 和 <code>matrix[y][x]</code> 都变成 <code>true</code>。</li>
<li>如果使用邻接表，则<code>list[x]</code>和<code>list[y]</code>中各自填入<code>y</code> 和<code>x</code>。</li>
</ul>
</li>
</ul>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>&emsp;&emsp;图和多叉树最大的区别是，图是可能包含环的，你从图的某一个节点开始遍历，有可能走了一圈又回到这个节点。所以，如果图包含环，遍历框架就要一个 <code>visited</code> 数组进行辅助：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">graph *Vertex</span><br><span class="line">visited <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(graph *Vertex, s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> visited[s] == <span class="literal">true</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span>  <span class="comment">// 经过节点s</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	visited[s] = <span class="literal">true</span></span><br><span class="line">  	<span class="keyword">for</span> _,v := <span class="keyword">range</span> s.neighbor &#123;</span><br><span class="line">    	traverse(graph, s)</span><br><span class="line">  	&#125;</span><br><span class="line">  	visited[s] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;这个 <code>visited</code> 数组的操作很像回溯算法做「做选择」和「撤销选择」，区别在于位置，回溯算法的「做选择」和「撤销选择」在 for 循环里面，而对 <code>visited</code> 数组的操作在 for 循环外面。在 for 循环里面和外面唯一的区别就是对根节点的处理。对于这里「图」的遍历，我们应该把 <code>visited</code> 的操作放到 for 循环外面，否则会漏掉起始点的遍历。</p>
<h2 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797. 所有可能的路径"></a><a class="link" href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径<i class="fas fa-external-link-alt"></i></a></h2><p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p>
<p>二维数组的第 <code>i</code> 个数组中的单元都表示有向图中 <code>i</code> 号节点所能到达的下一些节点，空就是没有下一个结点了。</p>
<p><strong>示例 1</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph3.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：graph &#x3D; [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph1.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：graph &#x3D; [[4,3,1],[3,2,4],[3],[4],[]]</span><br><span class="line">输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：graph &#x3D; [[1],[]]</span><br><span class="line">输出：[[0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：graph &#x3D; [[1,2,3],[2],[3],[]]</span><br><span class="line">输出：[[0,1,2,3],[0,2,3],[0,3]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：graph &#x3D; [[1,3],[2],[3],[]]</span><br><span class="line">输出：[[0,1,2,3],[0,3]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">n &#x3D;&#x3D; graph.length</span><br><span class="line">2 &lt;&#x3D; n &lt;&#x3D; 15</span><br><span class="line">0 &lt;&#x3D; graph[i][j] &lt; n</span><br><span class="line">graph[i][j] !&#x3D; i（即，不存在自环）</span><br><span class="line">graph[i] 中的所有元素 互不相同</span><br><span class="line">保证输入为 有向无环图（DAG）</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;从0为起点开始遍历图，将遍历到的每个节点加入到辅助数组<code>path</code>中，当遍历到节点值为n-1时停止遍历，将<code>path</code>保存的路径拷贝到输出结构<code>res</code>中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allPathsSourceTarget</span><span class="params">(graph [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([][]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    travel(path, graph, &amp;res, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(path []<span class="keyword">int</span>, graph [][]<span class="keyword">int</span>, res *[][]<span class="keyword">int</span>, start <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    path = <span class="built_in">append</span>(path,start)</span><br><span class="line">    n := <span class="built_in">len</span>(graph)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> start == n &#123;</span><br><span class="line">        dst := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>(path))</span><br><span class="line">        <span class="built_in">copy</span>(dst,path) <span class="comment">// 由于在回溯的时候path会动态变化，所以要重新拷贝后传入res</span></span><br><span class="line">        *res = <span class="built_in">append</span>(*res,dst)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> graph[start] &#123;</span><br><span class="line">        travel(path, graph, res, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="有向图的环检测"><a href="#有向图的环检测" class="headerlink" title="有向图的环检测"></a>有向图的环检测</h1><h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a class="link" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表<i class="fas fa-external-link-alt"></i></a></h2><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code>。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 必须 先学习课程  <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; numCourses &lt;&#x3D; 105</span><br><span class="line">0 &lt;&#x3D; prerequisites.length &lt;&#x3D; 5000</span><br><span class="line">prerequisites[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; ai, bi &lt; numCourses</span><br><span class="line">prerequisites[i] 中的所有课程对 互不相同</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;什么时候无法修完所有课程？当存在循环依赖的时候。其实这种场景在现实生活中也十分常见，比如我们写代码 import 包也是一个例子，必须合理设计代码目录结构，否则会出现循环依赖，编译器会报错，所以编译器实际上也使用了类似算法来判断你的代码是否能够成功编译。</p>
<p>&emsp;&emsp;<strong>看到依赖问题，首先想到的就是把问题转化成「有向图」这种数据结构，只要图中存在环，那就说明存在循环依赖</strong>。具体来说，我们首先可以把课程看成「有向图」中的节点，节点编号分别是 <code>0, 1, ..., numCourses-1</code>，把课程之间的依赖关系看做节点之间的有向边。</p>
<p>&emsp;&emsp;比如说必须修完课程 <code>1</code> 才能去修课程 <code>3</code>，那么就有一条有向边从节点 <code>1</code> 指向 <code>3</code>。所以我们可以根据题目输入的 <code>prerequisites</code> 数组生成一幅类似这样的图：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph4.jpg" alt="avatar"></p>
<p>&emsp;&emsp;<strong>如果发现这幅有向图中存在环，那就说明课程之间存在循环依赖，肯定没办法全部上完；反之，如果没有环，那么肯定能上完全部课程</strong>。所以第一步，我们要讲本题的这种依赖关系转换成图。</p>
<ul>
<li>先写一个建图函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildGraph</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    graph := <span class="built_in">make</span>([][]<span class="keyword">int</span>,numCourses)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        from := v[<span class="number">1</span>]</span><br><span class="line">        to := v[<span class="number">0</span>]</span><br><span class="line">        graph[from] = <span class="built_in">append</span>(graph[from], to)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以把 <code>traverse</code> 看做在图中节点上游走的指针，只需要再添加一个布尔数组 <code>onPath</code> 记录当前 <code>traverse</code> 经过的路径。完整代码如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    graph := buildGraph(numCourses, prerequisites)</span><br><span class="line">    onPath := <span class="built_in">make</span>([]<span class="keyword">bool</span>,numCourses)</span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="keyword">bool</span>,numCourses)</span><br><span class="line">    isCycle := <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    traverse = <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> onPath[s] == <span class="literal">true</span> &#123; <span class="comment">// 发现环</span></span><br><span class="line">            isCycle = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> visited[s] || onPath[s] &#123; <span class="comment">// 若是遍历过的节点或是存在于环内的节点，直接回溯</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历代码</span></span><br><span class="line">        visited[s] = <span class="literal">true</span></span><br><span class="line">        onPath[s] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _,v := <span class="keyword">range</span> graph[s] &#123;</span><br><span class="line">            traverse(v)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历代码</span></span><br><span class="line">        onPath[s] = <span class="literal">false</span> <span class="comment">// 在回溯的过程中将遍历过的节点标记为无环状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123;  <span class="comment">// 遍历图中所有节点</span></span><br><span class="line">        traverse(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !isCycle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildGraph</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    graph := <span class="built_in">make</span>([][]<span class="keyword">int</span>,numCourses)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        from := v[<span class="number">1</span>]</span><br><span class="line">        to := v[<span class="number">0</span>]</span><br><span class="line">        graph[from] = <span class="built_in">append</span>(graph[from], to)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="拓扑排序（无环图的后续遍历的反转）"><a href="#拓扑排序（无环图的后续遍历的反转）" class="headerlink" title="拓扑排序（无环图的后续遍历的反转）"></a>拓扑排序（<font color="red">无环图的后续遍历的反转</font>）</h1><h3 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a class="link" href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II<i class="fas fa-external-link-alt"></i></a></h3><p>现在你总共有 <em>n</em> 门课需要选，记为 <code>0</code> 到 <code>n-1</code>。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: <code>[0,1]</code></p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: [0,1]</span><br><span class="line">解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3]。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>输入的先决条件是由<strong>边缘列表</strong>表示的图形，而不是邻接矩阵。详情请参见<a class="link" href="http://blog.csdn.net/woaidapaopao/article/details/51732947">图的表示法<i class="fas fa-external-link-alt"></i></a>。</li>
<li>你可以假定输入的先决条件中没有重复的边。</li>
</ol>
<p>提示:</p>
<ul>
<li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li>
<li>拓扑排序也可以通过 BFS 完成。</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;这道题就是上道题的进阶版，不是仅仅让你判断是否可以完成所有课程，而是进一步让你返回一个合理的上课顺序，保证开始修每个课程时，前置的课程都已经修完。<strong>如果把课程抽象成节点，课程之间的依赖关系抽象成有向边，那么这幅图的拓扑排序结果就是上课顺序</strong>。首先，我们先判断一下题目输入的课程依赖是否成环，成环的话是无法进行拓扑排序的，所以我们可以复用上一道题的主函数。<strong>将后序遍历的结果进行反转，就是拓扑排序的结果</strong>。<strong>为什么后序遍历的反转结果就是拓扑排序呢</strong>？<strong>后序遍历的这一特点很重要，之所以拓扑排序的基础是后序遍历，是因为一个任务必须在等到所有的依赖任务都完成之后才能开始开始执行</strong>。你把每个任务理解成二叉树里面的节点，这个任务所依赖的任务理解成子节点，那你是不是应该先把所有子节点处理完再处理父节点？这是不是就是后序遍历？所以只需要在遍历节点的时候使用一个<code>postorder</code>数组存储后续遍历结果即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOrder</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    postorder := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> canFinish(numCourses, prerequisites, &amp;postorder) == <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125; <span class="comment">// 先判断是否有环，有环的话直接输出空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>,numCourses)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123; <span class="comment">// 无环的话将后续遍历的结果反转即可</span></span><br><span class="line">        res[i] = postorder[numCourses-i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>, postorder *[]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    graph := buildGraph(numCourses, prerequisites)</span><br><span class="line">    onPath := <span class="built_in">make</span>([]<span class="keyword">bool</span>,numCourses)</span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="keyword">bool</span>,numCourses)</span><br><span class="line">    isCycle := <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    traverse = <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> onPath[s] == <span class="literal">true</span> &#123; <span class="comment">// 发现环</span></span><br><span class="line">            isCycle = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> visited[s] || onPath[s] &#123; <span class="comment">// 若是遍历过的节点或是存在于环内的节点，直接回溯</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历代码</span></span><br><span class="line">        visited[s] = <span class="literal">true</span></span><br><span class="line">        onPath[s] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _,v := <span class="keyword">range</span> graph[s] &#123;</span><br><span class="line">            traverse(v)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历代码</span></span><br><span class="line">        onPath[s] = <span class="literal">false</span> <span class="comment">// 在回溯的过程中将遍历过的节点标记为无环状态</span></span><br><span class="line">        *postorder = <span class="built_in">append</span>(*postorder,s) <span class="comment">// 存储后续遍历的结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123;  <span class="comment">// 遍历图中所有节点</span></span><br><span class="line">        traverse(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !isCycle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildGraph</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123; <span class="comment">// 生成图结构</span></span><br><span class="line">    graph := <span class="built_in">make</span>([][]<span class="keyword">int</span>,numCourses)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        from := v[<span class="number">1</span>]</span><br><span class="line">        to := v[<span class="number">0</span>]</span><br><span class="line">        graph[from] = <span class="built_in">append</span>(graph[from], to)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>Union-Find(并查集)</title>
    <url>/2021/09/15/Union-Find(%E5%B9%B6%E6%9F%A5%E9%9B%86)/</url>
    <content><![CDATA[<h2 id="并查集介绍"><a href="#并查集介绍" class="headerlink" title="并查集介绍"></a>并查集介绍</h2><h3 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h3><p>&emsp;&emsp;对于无向图，对其进行遍历时：</p>
<ul>
<li>若是连通图，仅需从图中任一顶点出发，就能访问图中的所有顶点。</li>
<li>若是非连通图，需从图中多个顶点出发。每次从一个新顶点出发所访问的顶点集序列恰好是各个连通分量的顶点集。</li>
</ul>
<p>&emsp;&emsp;比如下面这幅图，总共有 10 个节点，他们互不相连，分别用 0~9 标记：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph1.jpg" alt="avatar"></p>
<p>&emsp;&emsp;「连通」是一种等价关系，也就是说具有如下三个性质：</p>
<ol>
<li>自反性：节点 <code>p</code> 和 <code>p</code> 是连通的。</li>
<li>对称性：如果节点 <code>p</code> 和 <code>q</code> 连通，那么 <code>q</code> 和 <code>p</code> 也连通。</li>
<li>传递性：如果节点 <code>p</code> 和 <code>q</code> 连通，<code>q</code> 和 <code>r</code> 连通，那么 <code>p</code> 和 <code>r</code> 也连通。</li>
</ol>
<h3 id="函数签名-基本模型"><a href="#函数签名-基本模型" class="headerlink" title="函数签名(基本模型)"></a>函数签名(基本模型)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">union</span><span class="params">(p,q <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 将p，q节点连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connected</span><span class="params">(p,q <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="comment">// 判断p，q节点是否连通</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countUF</span><span class="params">(graph *Vertax)</span> <span class="title">int</span></span> &#123; <span class="comment">// 返回途中有多少个连通分量 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>比如说之前那幅图，0～9 任意两个<strong>不同</strong>的点都不连通，调用 <code>connected</code> 都会返回 false，连通分量为 10 个。</li>
<li>如果现在调用 <code>union(0, 1)</code>，那么 0 和 1 被连通，连通分量降为 9 个。</li>
<li>再调用 <code>union(1, 2)</code>，这时 0,1,2 都被连通，调用 <code>connected(0, 2)</code> 也会返回 true，连通分量变为 8 个。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph2.jpg" alt="avatar"></p>
<p>&emsp;&emsp;判断这种「等价关系」非常实用，比如说编译器判断同一个变量的不同引用，比如社交网络中的朋友圈计算等等。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>&emsp;&emsp;我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。比如说刚才那幅 10 个节点的图，一开始的时候没有相互连通，就是这样：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph3.jpg" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UF <span class="keyword">struct</span> &#123;</span><br><span class="line">  	count			<span class="keyword">int</span>		<span class="comment">// 记录连通分量</span></span><br><span class="line">  	parent		[]<span class="keyword">int</span>	<span class="comment">// 节点x的父节点是parent[x]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">construct</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">UF</span></span> &#123;</span><br><span class="line">  	p := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">    	p[i] = i</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> UF&#123;</span><br><span class="line">      count : n		<span class="comment">// 一开始互不连通</span></span><br><span class="line">      parent : p	<span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上</strong>：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph4.jpg" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">union</span><span class="params">(p,q <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  	rootP := u.find(p)</span><br><span class="line">  	rootQ := u.find(q)</span><br><span class="line">  	<span class="keyword">if</span> rootP == rootQ &#123;</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 将两棵树合为一棵树</span></span><br><span class="line">  	u.parent[rootP] = rootQ</span><br><span class="line">  	<span class="comment">// u.parent[rootQ] = rootP也一样</span></span><br><span class="line">  	u.count--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">find</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根节点的u.parent[x]=x</span></span><br><span class="line">  	<span class="keyword">for</span> u.parent[x] != x &#123;</span><br><span class="line">    	x = u.parent[x]</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>这样，如果节点</strong> <strong><code>p</code></strong> <strong>和</strong> <strong><code>q</code></strong> <strong>连通的话，它们一定拥有相同的根节点</strong>：</p>
<p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/5.jpg" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">connected</span><span class="params">(p,q <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  	rootP := u.find(p)</span><br><span class="line">  	rootQ := u.find(q)</span><br><span class="line">  	<span class="keyword">return</span> rootP == rootQ</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;主要 API <code>connected</code> 和 <code>union</code> 中的复杂度都是 <code>find</code> 函数造成的，所以说它们的复杂度和 <code>find</code> 一样。<code>find</code> 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是 <code>logN</code>，但这并不一定。<code>logN</code> 的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度最坏情况下可能变成 <code>N</code>。所以说上面这种解法，<code>find</code> , <code>union</code> , <code>connected</code> 的时间复杂度都是 O(N)。这个复杂度很不理想的，你想图论解决的都是诸如社交网络这样数据规模巨大的问题，对于 <code>union</code> 和 <code>connected</code> 的调用非常频繁，每次调用需要线性时间完全不可忍受。<strong>问题的关键在于，如何想办法避免树的不平衡呢</strong>？</p>
<h2 id="平衡性优化"><a href="#平衡性优化" class="headerlink" title="平衡性优化"></a>平衡性优化</h2><p>&emsp;&emsp;我们要知道哪种情况下可能出现不平衡现象，关键在于 <code>union</code> 过程：我们一开始就是简单粗暴的把 <code>p</code> 所在的树接到 <code>q</code> 所在的树的根节点下面，那么这里就可能出现「头重脚轻」的不平衡状况，比如下面这种局面：</p>
<p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/7.jpg" alt="avatar"></p>
<p>&emsp;&emsp;长此以往，树可能生长得很不平衡。<strong>我们其实是希望，小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些</strong>。解决方法是额外使用一个 <code>size</code> 数组，记录每棵树包含的节点数，我们不妨称为「重量」：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UF <span class="keyword">struct</span> &#123;</span><br><span class="line">  	count			<span class="keyword">int</span>		<span class="comment">// 记录连通分量</span></span><br><span class="line">  	parent		[]<span class="keyword">int</span>	<span class="comment">// 节点x的父节点是parent[x]</span></span><br><span class="line">  	size			[]<span class="keyword">int</span>	<span class="comment">// 新增一个数组用于记录树的“重量”,这个数组只对根节点有意义，在使用前需要先判别是否是根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">construct</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">UF</span></span> &#123;</span><br><span class="line">  	p := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  	s := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">    	p[i] = i	<span class="comment">// 最初每棵树只有一个节点</span></span><br><span class="line">      s[i] = <span class="number">1</span>	<span class="comment">// 重量应该初始化为1</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> UF&#123;</span><br><span class="line">      count : n		<span class="comment">// 一开始互不连通</span></span><br><span class="line">      parent : p	<span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">      size : s		<span class="comment">// 每个节点的重量应该初始化为1</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;比如说 <code>size[3] = 5</code> 表示，以节点 <code>3</code> 为根的那棵树，总共有 <code>5</code> 个节点。这样我们可以修改一下 <code>union</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">union</span><span class="params">(p,q <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  	rootP := u.find(p)</span><br><span class="line">  	rootQ := u.find(q)</span><br><span class="line">  	<span class="keyword">if</span> rootP == rootQ &#123;</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 小树接到大树下面，较平衡</span></span><br><span class="line">  	<span class="keyword">if</span> u.size[rootP] &gt; u.size[rootQ] &#123;</span><br><span class="line">    		u.parent[rootQ] = rootP</span><br><span class="line">    		u.size[rootP] += u.size[rootQ]</span><br><span class="line">  	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		u.parent[rootP] = rootQ</span><br><span class="line">    		u.size[rootQ] += u.size[rootP]</span><br><span class="line">  	&#125;</span><br><span class="line">  	u.count--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在 <code>logN</code> 这个数量级，极大提升执行效率。此时，<code>find</code> , <code>union</code> , <code>connected</code> 的时间复杂度都下降为 O(logN)，即便数据规模上亿，所需时间也非常少。</p>
<h2 id="路经压缩"><a href="#路经压缩" class="headerlink" title="路经压缩"></a>路经压缩</h2><p>&emsp;&emsp;这步优化特别简单，所以非常巧妙。我们能不能进一步压缩每棵树的高度，使树高始终保持为常数？</p>
<p><img lazyload src="/images/loading.svg" data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/8.jpg" alt="avatar"></p>
<p>&emsp;&emsp;这样 <code>find</code> 就能以 O(1) 的时间找到某一节点的根节点，相应的，<code>connected</code> 和 <code>union</code> 复杂度都下降为 O(1)。要做到这一点，非常简单，只需要在 <code>find</code> 中加一行代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">find</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">for</span> u.parent[x] != x &#123;</span><br><span class="line">    	u.parent[x] = u.parent[u.parent[x]]	<span class="comment">// 指向爷爷节点 </span></span><br><span class="line">    	x = u.parent[x]											<span class="comment">// 定位到爷爷节点</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个操作有点匪夷所思，看个 GIF 就明白它的作用了（为清晰起见，这棵树比较极端）：</p>
<p><img lazyload src="/images/loading.svg" data-src="9.gif" alt="avatar"></p>
<p>&emsp;&emsp;可见，调用 <code>find</code> 函数每次向树根遍历的同时，顺手将树高缩短了，最终所有树高都不会超过 3（<code>union</code> 的时候树高可能达到 3）。PS：读者可能会问，这个 GIF 图的find过程完成之后，树高恰好等于 3 了，但是如果更高的树，压缩后高度依然会大于 3 呀？不能这么想。这个 GIF 的情景是我编出来方便大家理解路径压缩的，但是实际中，每次find都会进行路径压缩，所以树本来就不可能增长到这么高，你的这种担心应该是多余的。</p>
<h2 id="算法模板总结"><a href="#算法模板总结" class="headerlink" title="算法模板总结"></a>算法模板总结</h2><p>&emsp;&emsp;先看一下完整代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UF <span class="keyword">struct</span> &#123;</span><br><span class="line">  	count			<span class="keyword">int</span></span><br><span class="line">  	parent		[]<span class="keyword">int</span></span><br><span class="line">  	size			[]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">construct</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">UF</span></span> &#123; <span class="comment">// 初始化UF</span></span><br><span class="line">  	p := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  	s := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">    	p[i] = i</span><br><span class="line">    	size[i] = <span class="number">1</span></span><br><span class="line"> 		&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">return</span> UF&#123;</span><br><span class="line">      count : n,</span><br><span class="line">      parent : p,</span><br><span class="line">      size : s</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">find</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;	<span class="comment">// 查找两节点是否连通</span></span><br><span class="line">  	<span class="keyword">for</span> u.parent[x] != x &#123;</span><br><span class="line">    	u.parent[x] = u.parent[u.parent[x]]</span><br><span class="line">    	x = u.parent[x]</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">union</span><span class="params">(p,q <span class="keyword">int</span>)</span></span> &#123;	<span class="comment">// 使p，q节点连通</span></span><br><span class="line">  	rootP := u.find(p)</span><br><span class="line">  	rootQ := u.find(q)</span><br><span class="line">  	<span class="keyword">if</span> rootP == rootQ &#123;</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> u.size[rootP] &gt; u.size[rootQ] &#123;</span><br><span class="line">    	u.paremt[rootQ] = rootP</span><br><span class="line">    	u.size[rootP] += u.size[rootQ]</span><br><span class="line">  	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	u.parent[rootP] = rootQ</span><br><span class="line">    	u.size[rootQ] += u.size[rootP]</span><br><span class="line">  	&#125;</span><br><span class="line">  	u.count--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">connected</span><span class="params">(p,q <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;	<span class="comment">// 查看p，q节点是否连通</span></span><br><span class="line">  	rootP := u.find(p)</span><br><span class="line">  	rootQ := u.find(q)</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">return</span> rootP == rootQ</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">countUF</span><span class="params">()</span> <span class="title">int</span></span> &#123;	<span class="comment">// 查看连通分量</span></span><br><span class="line">  	<span class="keyword">return</span> u.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Union-Find 算法的复杂度可以这样分析：构造函数初始化数据结构需要 O(N) 的时间和空间复杂度；连通两个节点 <code>union</code>、判断两个节点的连通性 <code>connected</code>、计算连通分量 <code>count</code> 所需的时间复杂度均为 O(1)。</p>
<h2 id="并查集相关题目"><a href="#并查集相关题目" class="headerlink" title="并查集相关题目"></a>并查集相关题目</h2><h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a class="link" href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域<i class="fas fa-external-link-alt"></i></a></h3><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/10.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">输出：[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 &#39;O&#39; 都不会被填充为 &#39;X&#39;。 任何不在边界上，或不与边界上的 &#39;O&#39; 相连的 &#39;O&#39; 最终都会被填充为 &#39;X&#39;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;X&quot;]]</span><br><span class="line">输出：[[&quot;X&quot;]]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>m == board.length</li>
<li>n == board[i].length</li>
<li>1 &lt;= m, n &lt;= 200</li>
<li>board[i] [j]为 ‘X’ 或 ‘O’</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;必须是四面被围的 <code>O</code> 才能被换成 <code>X</code>，也就是说边角上的 <code>O</code> 一定不会被围，进一步，与边角上的 <code>O</code> 相连的 <code>O</code> 也不会被 <code>X</code> 围四面，也不会被替换。解决这个问题的传统方法也不困难，先用 for 循环遍历棋盘的<strong>四边</strong>，用 DFS 算法把那些与边界相连的 <code>O</code> 换成一个特殊字符，比如 <code>#</code>；然后再遍历整个棋盘，把剩下的 <code>O</code> 换成 <code>X</code>，把 <code>#</code> 恢复成 <code>O</code>。这样就能完成题目的要求，时间复杂度 O(MN)。这个问题也可以用 Union-Find 算法解决。</p>
<p>&emsp;&emsp;<strong>你可以把那些不需要被替换的</strong> <strong><code>O</code></strong> <strong>看成一个拥有独门绝技的门派，它们有一个共同祖师爷叫</strong> **<code>dummy</code>**<strong>，这些</strong> <strong><code>O</code></strong> <strong>和</strong> <strong><code>dummy</code></strong> <strong>互相连通，而那些需要被替换的</strong> <strong><code>O</code></strong> <strong>与</strong> <strong><code>dummy</code></strong> <strong>不连通</strong>。</p>
<p><img lazyload src="/images/loading.svg" data-src="11.jpg" alt="avatar"></p>
<p>&emsp;&emsp;这就是 Union-Find 的核心思路，明白这个图，就很容易看懂代码了。首先要解决的是，根据我们的实现，Union-Find 底层用的是一维数组，构造函数需要传入这个数组的大小，而题目给的是一个二维棋盘。</p>
<p>&emsp;&emsp;这个很简单，二维坐标 <code>(x,y)</code> 可以转换成 <code>x * n + y</code> 这个数（<code>m</code> 是棋盘的行数，<code>n</code> 是棋盘的列数）。敲黑板，<strong>这是将二维坐标映射到一维的常用技巧</strong>。</p>
<p>&emsp;&emsp;其次，我们之前描述的「祖师爷」是虚构的，需要给他老人家留个位置。索引 <code>[0.. m*n-1]</code> 都是棋盘内坐标的一维映射，那就让这个虚拟的 <code>dummy</code> 节点占据索引 <code>m * n</code> 好了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UF <span class="keyword">struct</span> &#123;</span><br><span class="line">    count   <span class="keyword">int</span></span><br><span class="line">    parent  []<span class="keyword">int</span></span><br><span class="line">    size    []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">construct</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">UF</span></span> &#123; <span class="comment">// 初始化UF结构体</span></span><br><span class="line">    p := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        p[i] = i</span><br><span class="line">        s[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UF&#123;</span><br><span class="line">        count:n,</span><br><span class="line">        parent:p,</span><br><span class="line">        size:s,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">find</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">// 查找根节点的方法</span></span><br><span class="line">    <span class="keyword">for</span> u.parent[x] != x &#123;</span><br><span class="line">        u.parent[x] = u.parent[u.parent[x]]</span><br><span class="line">        x = u.parent[x]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">union</span><span class="params">(p,q <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 连通两节点的方法</span></span><br><span class="line">    rootP := u.find(p)</span><br><span class="line">    rootQ := u.find(q)</span><br><span class="line">    <span class="keyword">if</span> rootP == rootQ &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> u.size[rootP] &gt; u.size[rootQ] &#123;</span><br><span class="line">        u.parent[rootQ] = rootP</span><br><span class="line">        u.size[rootP] += u.size[rootQ]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        u.parent[rootP] = rootQ</span><br><span class="line">        u.size[rootQ] += u.size[rootP]</span><br><span class="line">    &#125;</span><br><span class="line">    u.count--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">connected</span><span class="params">(p,q <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;  <span class="comment">// 查看是否连通的方法</span></span><br><span class="line">    rootP := u.find(p)</span><br><span class="line">    rootQ := u.find(q)</span><br><span class="line">    <span class="keyword">return</span> rootP == rootQ</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solve</span><span class="params">(board [][]<span class="keyword">byte</span>)</span></span>  &#123; <span class="comment">// 函数主题</span></span><br><span class="line">    m := <span class="built_in">len</span>(board)</span><br><span class="line">    n := <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">    u := construct(m*n+<span class="number">1</span>)  <span class="comment">// 初始化并查集，多将一位数加入并查集，作为dummy节点（边缘&#x27;O&#x27;的根节点）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;m; i++ &#123; <span class="comment">// 将第一列和最后一列的&#x27;O&#x27;元素与位于m*n处的dummy连通</span></span><br><span class="line">        <span class="keyword">if</span> board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">            u.union(i*n, m*n)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> board[i][n<span class="number">-1</span>] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">            u.union(i*n+(n<span class="number">-1</span>), m*n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;n<span class="number">-1</span>; j++ &#123; <span class="comment">// 将第一行和最后一行的&#x27;O&#x27;元素与位于m*n处的dummy连通</span></span><br><span class="line">        <span class="keyword">if</span> board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">            u.union(j, m*n)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> board[m<span class="number">-1</span>][j] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">            u.union((m<span class="number">-1</span>)*n+j, m*n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d := [][]<span class="keyword">int</span>&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125; <span class="comment">// 方向数组 d 是上下左右搜索的常用手法</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;m<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;n<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">              <span class="comment">// 将此 O 与上下左右的 O 连通</span></span><br><span class="line">                <span class="keyword">for</span> k:=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++ &#123;</span><br><span class="line">                    x := i+d[k][<span class="number">0</span>]</span><br><span class="line">                    y := j+d[k][<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> board[x][y] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">                        u.union(i*n+j, x*n+y)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 所有不和 dummy 连通的 O，都要被替换</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;m<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;n<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (!u.connected(i*n+j, m*n)) &#123;</span><br><span class="line">                board[i][j] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU算法</title>
    <url>/2021/09/21/LRU%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="LRU算法介绍"><a href="#LRU算法介绍" class="headerlink" title="LRU算法介绍"></a>LRU算法介绍</h1><p>&emsp;&emsp;LRU算法(Least Recently Used)算法实质上是一种缓存机制，常用于操作系统的缓存。计算机的缓存容量是有限的，如果缓存满了就要给新的内容腾位置。那淘汰哪些缓存，哪些继续以何种方式留在缓存中就是一个策略性的问题。LRU算法就是其中一种淘汰策略。其内核就是<strong>认为最近使用过的数据是最有用的，很久都没使用的数据是无用的，内存满了就应该优先淘汰很久没用过的数据</strong>。</p>
<p>&emsp;&emsp;举一个实际例子，安卓手机都可以把软件放到后台运行，比如我先后打开了「设置」「手机管家」「日历」，那么现在他们在后台排列的顺序是这样的：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph1.jpg#pic_center" alt="avatar"></p>
<p>&emsp;&emsp;但是这时候如果我访问了一下「设置」界面，那么「设置」就会被提前到第一个，变成这样：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph2.jpg#pic_center" alt="avatar"></p>
<p>&emsp;&emsp;假设我的手机只允许我同时开 3 个应用程序，现在已经满了。那么如果我新开了一个应用「时钟」，就必须关闭一个应用为「时钟」腾出一个位置，关那个呢？按照 LRU 的策略，就关最底下的「手机管家」，因为那是最久未使用的，然后把新开的应用放到最上面：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph3.jpg#pic_center" alt="avatar"></p>
<h1 id="LRU算法的函数签名"><a href="#LRU算法的函数签名" class="headerlink" title="LRU算法的函数签名"></a>LRU算法的函数签名</h1><p>&emsp;&emsp;函数签名可以参考<a class="link" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制<i class="fas fa-external-link-alt"></i></a>的题目要求：</p>
<p>运用你所掌握的数据结构，设计和实现一个 <a class="link" href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存机制<i class="fas fa-external-link-alt"></i></a> 。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity) </code>以正整数作为容量 capacity 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li>
<li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>
</ul>
<p><strong>进阶</strong>：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache &#x3D; new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1&#125;</span><br><span class="line">lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1, 2&#x3D;2&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 1</span><br><span class="line">lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 &#123;1&#x3D;1, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 &#123;4&#x3D;4, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    &#x2F;&#x2F; 返回 3</span><br><span class="line">lRUCache.get(4);    &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>1 &lt;= capacity &lt;= 3000</li>
<li>0 &lt;= key &lt;= 10000</li>
<li>0 &lt;= value &lt;= 105</li>
<li>最多调用 2 * 105 次 get 和 put</li>
</ul>
<h1 id="LRU算法设计"><a href="#LRU算法设计" class="headerlink" title="LRU算法设计"></a>LRU算法设计</h1><p>&emsp;&emsp;分析上面的操作过程，要让 <code>put</code> 和 <code>get</code> 方法的时间复杂度为 O(1)，我们可以总结出 <code>cache</code> 这个数据结构必要的条件：</p>
<ol>
<li>显然 <code>cache</code> 中的元素必须有顺序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。</li>
<li>我们要在 <code>cache</code> 中快速找某个 <code>key</code> 是否已存在并得到对应的 <code>val</code>；</li>
<li>每次访问 <code>cache</code> 中的某个 <code>key</code>，需要将这个元素变为最近使用的，也就是说 <code>cache</code> 要支持在任意位置快速插入和删除元素。</li>
</ol>
<p>&emsp;&emsp;那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表 <code>LinkedHashMap</code>。LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph4.jpg" alt="avatar"></p>
<p>&emsp;&emsp;借助这个结构，我们来逐一分析上面的 3 个条件：</p>
<ol>
<li>如果我们每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。</li>
<li>对于某一个 <code>key</code>，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 <code>val</code>。</li>
<li>链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 <code>key</code> 快速映射到任意一个链表节点，然后进行插入和删除。</li>
</ol>
<p>&emsp;&emsp;这里先引出两个问题：<strong>为什么要是双向链表，单链表行不行？另外，既然哈希表中已经存了</strong> **<code>key</code>**<strong>，为什么链表中还要存</strong> <strong><code>key</code></strong> <strong>和</strong> <strong><code>val</code></strong> <strong>呢，只存</strong> <strong><code>val</code></strong> <strong>不就行了</strong>？</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="双链表的实现"><a href="#双链表的实现" class="headerlink" title="双链表的实现"></a>双链表的实现</h2><p>&emsp;&emsp;首先实现连表的每个节点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key			<span class="keyword">int</span></span><br><span class="line">    value		<span class="keyword">int</span></span><br><span class="line">    prev		*node</span><br><span class="line">    next		*node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后依靠着这些节点实现一个双链表：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DoubleList <span class="keyword">struct</span> &#123;</span><br><span class="line">    head		*node		<span class="comment">// 头部虚节点</span></span><br><span class="line">    tail		*node		<span class="comment">// 尾部虚节点</span></span><br><span class="line">    size		<span class="keyword">int</span>			<span class="comment">// 连表节点数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructDL</span><span class="params">()</span> *<span class="title">DoubleList</span></span> &#123;	<span class="comment">// 初始化双链表</span></span><br><span class="line">    dh := &amp;node&#123;</span><br><span class="line">        key : <span class="number">0</span>,</span><br><span class="line">        value : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dt := &amp;node&#123;</span><br><span class="line">        key : <span class="number">0</span>,</span><br><span class="line">        value : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dh.next,dt.prev = dt,dh <span class="comment">// 收尾虚节点形成双链表</span></span><br><span class="line">    <span class="keyword">return</span> &amp;DoubleList&#123;</span><br><span class="line">        head : dh,</span><br><span class="line">    	tail : dt,</span><br><span class="line">    	size : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="双链表的几个API的实现"><a href="#双链表的几个API的实现" class="headerlink" title="双链表的几个API的实现"></a>双链表的几个API的实现</h2><p>&emsp;&emsp;接下来我们实现操作双链表的几个API:</p>
<ol>
<li><code>addLast(x *node)</code>：将最近使用的节点加入到双链表中（从尾部进入双链表）</li>
<li><code>remove(x *node)</code>：删除双链表中的节点x（节点x一定存在的条件下）</li>
<li><code>removeFirst()</code>：当容量满时，将最久未使用的节点（表首的节点）删除</li>
<li><code>dlSize()</code>：返回双链表的节点数</li>
</ol>
<h3 id="addLast-x-node-方法的实现细节"><a href="#addLast-x-node-方法的实现细节" class="headerlink" title="addLast(x *node)方法的实现细节"></a><code>addLast(x *node)</code>方法的实现细节</h3><p>&emsp;&emsp;在双链表的尾部虚节点之前插入节点，需要注意插入过程中<code>prev</code>和<code>next</code>指针的插入顺序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">addLast</span><span class="params">(x *node)</span></span> &#123; <span class="comment">// 在链表尾部添加节点 x，时间 O(1)</span></span><br><span class="line">    x.prev = dl.tail.prev</span><br><span class="line">    x.next = dl.tail</span><br><span class="line">    dl.tail.prev.next = x</span><br><span class="line">    dl.tail.prev = x</span><br><span class="line">    dl.size++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="remove-x-node-方法的实现细节"><a href="#remove-x-node-方法的实现细节" class="headerlink" title="remove(x *node)方法的实现细节"></a><code>remove(x *node)</code>方法的实现细节</h3><p>&emsp;&emsp;删除连表中的某一节点，x存在时才能使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">remove</span><span class="params">(x *node)</span></span> &#123; <span class="comment">// 由于是双链表且给的是目标 Node 节点，时间 O(1)</span></span><br><span class="line">    x.prev.next = x.next</span><br><span class="line">    x.next.prev = x.prev</span><br><span class="line">    dl.size--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="removeFirst-方法的实现细节"><a href="#removeFirst-方法的实现细节" class="headerlink" title="removeFirst()方法的实现细节"></a><code>removeFirst()</code>方法的实现细节</h3><p>&emsp;&emsp;缓存的空间占满，删除最久不使用节点（首部节点）。返回被删除的节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">removeFirst</span><span class="params">()</span> *<span class="title">node</span></span> &#123; <span class="comment">// 删除链表中第一个节点，并返回该节点，时间 O(1)</span></span><br><span class="line">    <span class="keyword">if</span> dl.head.next == dl.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> dl.head</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    first := dl.head.next</span><br><span class="line">    dl.remove(first)</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="dlSize-返回链表长度"><a href="#dlSize-返回链表长度" class="headerlink" title="dlSize()返回链表长度"></a><code>dlSize()</code>返回链表长度</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">dlSize</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="comment">// 返回链表长度，时间 O(1)</span></span><br><span class="line">    <span class="keyword">return</span> dl.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="LRUCache类的实现"><a href="#LRUCache类的实现" class="headerlink" title="LRUCache类的实现"></a>LRUCache类的实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashMap		<span class="keyword">map</span>[<span class="keyword">int</span>]*node</span><br><span class="line">    cache		*DoubleList</span><br><span class="line">    <span class="built_in">cap</span>			<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity)</span> <span class="title">LRUCache</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node,capacity)</span><br><span class="line">    dl := constructDL()</span><br><span class="line">    <span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">        hashMap	:	m,</span><br><span class="line">        cache	:	dl,</span><br><span class="line">        <span class="built_in">cap</span>		:	capacity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="抽象后的中间层"><a href="#抽象后的中间层" class="headerlink" title="抽象后的中间层"></a>抽象后的中间层</h2><p>&emsp;&emsp;为了避免直接对缓存进行操作时忘记同时对双链表和哈希表同时进行删除和插入操作，所以在具体的LRU的方法和数据结构之间添加一层作为抽象层（直接对数据结构进行操作）。</p>
<h3 id="makeRecently-key-int-将某个节点提升为最近使用"><a href="#makeRecently-key-int-将某个节点提升为最近使用" class="headerlink" title="makeRecently(key int)将某个节点提升为最近使用"></a><code>makeRecently(key int)</code>将某个节点提升为最近使用</h3><p>&emsp;&emsp;当某个节点被使用后，变为最近使用节点，被放到链表尾部。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">makeRecently</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := this.hashMap[key]</span><br><span class="line">    this.cache.remove(x)	<span class="comment">// 现在双链表删除该节点</span></span><br><span class="line">    this.cache.addLast(x)	<span class="comment">// 然后将该节点添加到双链表尾部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="addRecently-key-int-val-将某个新节点提升为最近使用"><a href="#addRecently-key-int-val-将某个新节点提升为最近使用" class="headerlink" title="addRecently(key int, val)将某个新节点提升为最近使用"></a><code>addRecently(key int, val)</code>将某个新节点提升为最近使用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">addRecently</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := node&#123;</span><br><span class="line">        key	:	key,</span><br><span class="line">        value	:	val,</span><br><span class="line">    &#125;</span><br><span class="line">    this.cache.addLast(&amp;x)</span><br><span class="line">    this.hashMap[key] = &amp;x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="deleteKey-key-int-删除某一个节点"><a href="#deleteKey-key-int-删除某一个节点" class="headerlink" title="deleteKey(key int)删除某一个节点"></a><code>deleteKey(key int)</code>删除某一个节点</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">deleteKey</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := this.hashMap[key]</span><br><span class="line">    <span class="built_in">delete</span>(this.hashMap,x)</span><br><span class="line">    this.cache.remove(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="deleteLeastRecently-删除最久未使用节点"><a href="#deleteLeastRecently-删除最久未使用节点" class="headerlink" title="deleteLeastRecently()删除最久未使用节点"></a><code>deleteLeastRecently()</code>删除最久未使用节点</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">deleteLeastRecently</span><span class="params">()</span></span> &#123;</span><br><span class="line">    deleteNode := this.cache.removeFirst()</span><br><span class="line">    deleteKey := deleteNode.key</span><br><span class="line">    <span class="built_in">delete</span>(this.hashMap,deleteKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="LRUCache类的更新Get-和淘汰Put-方法"><a href="#LRUCache类的更新Get-和淘汰Put-方法" class="headerlink" title="LRUCache类的更新Get()和淘汰Put()方法"></a>LRUCache类的更新Get()和淘汰Put()方法</h2><p>&emsp;&emsp;<code>Get(key int)</code>方法：如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.hashMap[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.makeRecently(key)	<span class="comment">// 关键字存在于缓存中，将其置于双链表尾部位置</span></span><br><span class="line">    <span class="keyword">return</span> this.hashMap[key].value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;<code>Put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.hashMap[key]; ok &#123; <span class="comment">// 如果存在与缓存中</span></span><br><span class="line">        this.deleteKey(key)	<span class="comment">// 先删除原来节点（避免出现更新value的情况）</span></span><br><span class="line">        this.addRecently(key)	<span class="comment">// 然后再将该节点重新插入</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> this.<span class="built_in">cap</span> == this.cache.dlSize &#123; <span class="comment">// 缓存容量已经达到上限</span></span><br><span class="line">            this.deleteLeastRecently()	<span class="comment">// 删除最不常使用节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        this.addRecntly(key,val)	<span class="comment">// 然后将该新节点添加到缓存中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key     <span class="keyword">int</span></span><br><span class="line">    value   <span class="keyword">int</span></span><br><span class="line">    prev    *node</span><br><span class="line">    next    *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DoubleList <span class="keyword">struct</span> &#123;</span><br><span class="line">    head    *node</span><br><span class="line">    tail    *node</span><br><span class="line">    size    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructDL</span><span class="params">()</span> *<span class="title">DoubleList</span></span> &#123;</span><br><span class="line">    dh := &amp;node&#123;</span><br><span class="line">        key :   <span class="number">0</span>,</span><br><span class="line">        value : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dt := &amp;node&#123;</span><br><span class="line">        key :   <span class="number">0</span>,</span><br><span class="line">        value : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dh.next,dt.prev = dt,dh</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;DoubleList&#123;</span><br><span class="line">        head    :   dh,</span><br><span class="line">        tail    :   dt,</span><br><span class="line">        size    :   <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">addLast</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev = dl.tail.prev</span><br><span class="line">    x.next = dl.tail</span><br><span class="line">    dl.tail.prev.next = x</span><br><span class="line">    dl.tail.prev = x</span><br><span class="line">    dl.size++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">remove</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev.next = x.next</span><br><span class="line">    x.next.prev = x.prev</span><br><span class="line">    dl.size--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">removeFirst</span><span class="params">()</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dl.head.next == dl.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> dl.head</span><br><span class="line">    &#125;</span><br><span class="line">    first := dl.head.next</span><br><span class="line">    dl.remove(first)</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">dlSize</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dl.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashMap     <span class="keyword">map</span>[<span class="keyword">int</span>]*node</span><br><span class="line">    cache       *DoubleList</span><br><span class="line">    <span class="built_in">cap</span>         <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LRUCache</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node,capacity)</span><br><span class="line">    dl := constructDL()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">        hashMap :   m,</span><br><span class="line">        cache   :   dl,</span><br><span class="line">        <span class="built_in">cap</span>     :   capacity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.hashMap[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.makeRecently(key)</span><br><span class="line">    <span class="keyword">return</span> this.hashMap[key].value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.hashMap[key]; ok &#123;</span><br><span class="line">        this.deleteKey(key)</span><br><span class="line">        this.addRecently(key,value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> this.<span class="built_in">cap</span> == this.cache.dlSize() &#123;</span><br><span class="line">            this.deleteLeastRecently()</span><br><span class="line">        &#125;</span><br><span class="line">        this.addRecently(key,value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">makeRecently</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := this.hashMap[key]</span><br><span class="line">    this.cache.remove(x)</span><br><span class="line">    this.cache.addLast(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">addRecently</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := &amp;node&#123;</span><br><span class="line">        key :   key,</span><br><span class="line">        value : val,</span><br><span class="line">    &#125;</span><br><span class="line">    this.cache.addLast(x)</span><br><span class="line">    this.hashMap[key] = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">deleteKey</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := this.hashMap[key]</span><br><span class="line">    this.cache.remove(x)</span><br><span class="line">    <span class="built_in">delete</span>(this.hashMap,key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">deleteLeastRecently</span><span class="params">()</span></span> &#123;</span><br><span class="line">    deleteNode := this.cache.removeFirst()</span><br><span class="line">    deleteKey := deleteNode.key</span><br><span class="line">    <span class="built_in">delete</span>(this.hashMap, deleteKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>LFU算法</title>
    <url>/2021/09/22/LFU%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="LFU算法介绍"><a href="#LFU算法介绍" class="headerlink" title="LFU算法介绍"></a>LFU算法介绍</h1><h2 id="LFU缓存机制"><a href="#LFU缓存机制" class="headerlink" title="LFU缓存机制"></a>LFU缓存机制</h2><p>&emsp;&emsp;LFU 算法的淘汰策略是 Least Frequently Used，也就是每次淘汰那些使用次数最少的数据。对比于在<a href="https://jiahaohong1997.github.io/2021/09/21/LRU%E7%AE%97%E6%B3%95/">LRU算法</a>中介绍的LRU 缓存淘汰算法，LRU 算法的淘汰策略是 Least Recently Used，也就是每次淘汰那些最久没被使用的数据。LRU 算法的核心数据结构是使用哈希链表 <code>LinkedHashMap</code>，首先借助链表的有序性使得链表元素维持插入顺序，同时借助哈希映射的快速访问能力使得我们可以在 O(1) 时间访问链表的任意元素。</p>
<p>&emsp;&emsp;而 LFU 算法相当于是把数据按照访问频次进行排序，这个需求恐怕没有那么简单，而且还有一种情况，如果多个数据拥有相同的访问频次，我们就得删除最早插入的那个数据。也就是说 LFU 算法是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>&emsp;&emsp;要求你写一个类，接受一个 <code>capacity</code> 参数，实现 <code>get</code> 和 <code>put</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LFUCache</span></span> &#123;&#125; <span class="comment">// 构造容量为 capacity 的缓存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;&#125;  <span class="comment">// 在缓存中查询 key</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;&#125; <span class="comment">// 将 key 和 val 存入缓存</span></span><br></pre></td></tr></table></figure>

<p><code>Get(key)</code> 方法会去缓存中查询键 <code>key</code>，如果 <code>key</code> 存在，则返回 <code>key</code> 对应的 <code>val</code>，否则返回 -1。</p>
<p><code>Put(key, value)</code> 方法插入或修改缓存。如果 <code>key</code> 已存在，则将它对应的值改为 <code>val</code>；如果 <code>key</code> 不存在，则插入键值对 <code>(key, val)</code>。</p>
<p>&emsp;&emsp;当缓存达到容量 <code>capacity</code> 时，则应该在插入新的键值对之前，删除使用频次（后文用 <code>freq</code> 表示）最低的键值对。如果 <code>freq</code> 最低的键值对有多个，则删除其中最旧的那个。</p>
<h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>&emsp;&emsp;首先我们需要理解LFU算法执行过程的几个事实：</p>
<ol>
<li>调用<code>Get(key int)</code>方法时，要返回<code>key</code>对应的<code>val</code>。</li>
<li>只要用到<code>Get</code>或<code>Put</code>方法访问一次某个<code>key</code>，该<code>key</code>的<code>freq</code>就要加一。</li>
<li>如果在容量满了的时候插入，则需要将 <code>freq</code> 最小的 <code>key</code> 删除，如果最小的 <code>freq</code> 对应多个 <code>key</code>，则删除其中最旧的那一个。</li>
</ol>
<p>&emsp;&emsp;现在我们来逐一解决:</p>
<ol>
<li>调用<code>Get(key int)</code>方法时，要返回<code>key</code>对应的<code>val</code>。</li>
</ol>
<p>&emsp;&emsp;使用一个 <code>HashMap</code> 存储 <code>key</code> 到 <code>val</code> 的映射，就可以快速计算 <code>get(key)</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">keyToVal := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>只要用到<code>Get</code>或<code>Put</code>方法访问一次某个<code>key</code>，该<code>key</code>的<code>freq</code>就要加一。</li>
</ol>
<p>&emsp;&emsp;使用一个 <code>HashMap</code> 存储 <code>key</code> 到 <code>freq</code> 的映射，就可以快速操作 <code>key</code> 对应的 <code>freq</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">keyToFreq := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>如果在容量满了的时候插入，则需要将 <code>freq</code> 最小的 <code>key</code> 删除，如果最小的 <code>freq</code> 对应多个 <code>key</code>，则删除其中最旧的那一个。</li>
</ol>
<p>&emsp;&emsp;这个需求应该是 LFU 算法的核心，所以我们分开说。</p>
<ul>
<li>首先，肯定是需要 <code>freq</code> 到 <code>key</code> 的映射，用来找到 <code>freq</code> 最小的 <code>key</code>。</li>
<li>将 <code>freq</code> 最小的 <code>key</code> 删除，那你就得快速得到当前所有 <code>key</code> 最小的 <code>freq</code> 是多少。想要时间复杂度 O(1) 的话，肯定不能遍历一遍去找，那就用一个变量 <code>minFreq</code> 来记录当前最小的 <code>freq</code> 吧。</li>
<li>可能有多个 <code>key</code> 拥有相同的 <code>freq</code>，所以 <strong><code>freq</code></strong> <strong>对</strong> <strong><code>key</code></strong> <strong>是一对多的关系</strong>，即一个 <code>freq</code> 对应一个 <code>key</code> 的列表。</li>
<li>希望 <code>freq</code> 对应的 <code>key</code> 的列表是<strong>存在时序</strong>的，便于快速查找并删除最旧的 <code>key</code>。</li>
<li>希望<strong>能够快速删除</strong> <strong><code>key</code></strong> <strong>列表中的任何一个</strong> **<code>key</code>**，因为如果频次为 <code>freq</code> 的某个 <code>key</code> 被访问，那么它的频次就会变成 <code>freq+1</code>，就应该从 <code>freq</code> 对应的 <code>key</code> 列表中删除，加到 <code>freq+1</code> 对应的 <code>key</code> 的列表中。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">freqToKeys := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet)</span><br><span class="line">minFreq := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key		<span class="keyword">int</span></span><br><span class="line">    prev	*node</span><br><span class="line">    next	*node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DoubleList <span class="keyword">struct</span> &#123;</span><br><span class="line">    head	*node</span><br><span class="line">    tail	*node</span><br><span class="line">    size	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorDL</span><span class="params">()</span> *<span class="title">DoubleList</span></span> &#123;</span><br><span class="line">    dh := &amp;node&#123;</span><br><span class="line">        key		:	<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dt := &amp;node &#123;</span><br><span class="line">        key		:	<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dh.next,dt.prev = dt,dh</span><br><span class="line">    <span class="keyword">return</span> &amp;DoubleList&#123;</span><br><span class="line">        head	:	dh,</span><br><span class="line">        tail	:	dt,</span><br><span class="line">        size	:	<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LinkedHashSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashMap		<span class="keyword">map</span>[<span class="keyword">int</span>]*node</span><br><span class="line">    doubleList	*DoubleList    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorLH</span><span class="params">()</span> *<span class="title">LinkedHashSet</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node)</span><br><span class="line">    dl := constructorDL()</span><br><span class="line">    <span class="keyword">return</span> &amp;LinkedHashSet&#123;</span><br><span class="line">        hashMap		:	m,</span><br><span class="line">        doubleList	:	dl,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>LinkedHashSet</code> 顾名思义，是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插入元素具有时序；哈希集合中的元素无序，但是可以对元素进行快速的访问和删除。那么，它俩结合起来就兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，又可以保持插入的时序。</p>
<p>综上，我们可以写出 LFU 算法的基本数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    keyToVal	<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>				<span class="comment">// key 到 val 的映射，我们后文称为 KV 表</span></span><br><span class="line">    keyToFreq	<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>				<span class="comment">// key 到 freq 的映射，我们后文称为 KF 表</span></span><br><span class="line">    freqToKeys	<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet	<span class="comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span></span><br><span class="line">    minFreq		<span class="keyword">int</span>						<span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="built_in">cap</span>			<span class="keyword">int</span>						<span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity)</span> <span class="title">LFUCache</span></span> &#123;</span><br><span class="line">    kv := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    kf := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    fk := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet)</span><br><span class="line">    <span class="keyword">return</span> LFUCache&#123;</span><br><span class="line">        keyToVal	:	kv,</span><br><span class="line">        keyToFreq	:	kf,</span><br><span class="line">        freqToKeys	:	fk,</span><br><span class="line">        minFreq		:	<span class="number">0</span>,</span><br><span class="line">        <span class="built_in">cap</span>			:	capacity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;&#125;  <span class="comment">// 在缓存中查询 key</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;&#125; <span class="comment">// 将 key 和 val 存入缓存</span></span><br></pre></td></tr></table></figure>



<h1 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h1><h2 id="实现Get-key-int-方法"><a href="#实现Get-key-int-方法" class="headerlink" title="实现Get(key int)方法"></a>实现<code>Get(key int)</code>方法</h2><p>&emsp;&emsp;逻辑很简单，返回 <code>key</code> 对应的 <code>val</code>，然后增加 <code>key</code> 对应的 <code>freq</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.increaseFreq(key)</span><br><span class="line">    <span class="keyword">return</span> this.keyToVal[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;增加<code>key</code>对应的<code>freq</code>是LFU算法的核心，所以我们干脆抽象一个方法<code>increaseFreq</code>，这样<code>Get</code>方法就比较简洁。</p>
<h2 id="实现Put-key-int-val-int-方法"><a href="#实现Put-key-int-val-int-方法" class="headerlink" title="实现Put(key int,val int) 方法"></a>实现<code>Put(key int,val int)</code> 方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; ok &#123;  <span class="comment">// 若key已存在，修改对应的val即可</span></span><br><span class="line">        this.keyToVal[key] = value</span><br><span class="line">        this.increaseFreq(key)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// key不存在，需要插入</span></span><br><span class="line">    <span class="comment">// 容量已满的话需要淘汰一个freq最小的key</span></span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> == <span class="built_in">len</span>(this.keyToVal) &#123;</span><br><span class="line">        this.removeMinFreqKey()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入key和val，对应的freq为1</span></span><br><span class="line">    this.keyToVal[key] = value	<span class="comment">// 插入KV表</span></span><br><span class="line">    this.keyToFreq[key] = <span class="number">1</span>		<span class="comment">// 插入KF表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[<span class="number">1</span>]; !ok &#123;  <span class="comment">// 如果没有freq为1的LinkedHashSet，则生成一个</span></span><br><span class="line">        this.freqToKeys[<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,<span class="number">1</span>)  <span class="comment">// 插入新key后的freq肯定是1</span></span><br><span class="line">    this.minFreq = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实现核心逻辑（中间抽象层）"><a href="#实现核心逻辑（中间抽象层）" class="headerlink" title="实现核心逻辑（中间抽象层）"></a>实现核心逻辑（中间抽象层）</h2><h3 id="实现removeMinFreqKey方法"><a href="#实现removeMinFreqKey方法" class="headerlink" title="实现removeMinFreqKey方法"></a>实现<code>removeMinFreqKey</code>方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">removeMinFreqKey</span><span class="params">()</span></span> &#123;</span><br><span class="line">    keyList := this.freqToKeys[this.minFreq].doubleList	<span class="comment">// 获得最小freq的LinkedHashSet</span></span><br><span class="line">    deleteKey := keyList.removeFirst()	<span class="comment">// 删除LinkedHashSet的双链表头的元素</span></span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[this.minFreq].hashMap,deleteKey.key)		<span class="comment">// 删除LinkedHashSet的哈希表对应元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[this.minFreq].hashMap) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,this.minFreq)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delete</span>(this.keyToVal,deleteKey.key)		<span class="comment">// 更新KV表</span></span><br><span class="line">    <span class="built_in">delete</span>(this.keyToFreq,deleteKey.key)	<span class="comment">// 更新KF表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;删除某个<code>key</code>肯定是要同时映射三个表的，借助<code>minFreq</code>参数可以从<code>FK</code>表中找到<code>freq</code>最小的<code>keyList</code>，删除其表头元素即可，同时删除<code>Fk</code>表中<code>freq</code>最小的<code>hashMap</code>对应的元素。然后根据要被淘汰的<code>deleteKey</code>删除其余两个表中的映射关系。</p>
<p>&emsp;&emsp;这里有个细节问题，如果<code>keyList</code>中只有一个元素，那么删除之后<code>minFreq</code>对应的<code>key</code>列表就为空了，也就是<code>minFreq</code>变量需要更新。实际上没办法快速计算<code>minFreq</code>，只能线性遍历<code>FK</code>表或者<code>KF</code>表来计算，这样肯定不能保证 O(1) 的时间复杂度。<strong>但是，其实这里没必要更新<code>minFreq</code>变量</strong>，因为你想想<code>removeMinFreqKey</code>这个函数是在什么时候调用？在<code>put</code>方法中插入新<code>key</code>时可能调用。而你回头看<code>put</code>的代码，插入新<code>key</code>时一定会把<code>minFreq</code>更新成 1，所以说即便这里<code>minFreq</code>变了，我们也不需要管它。</p>
<h3 id="实现increaseFreq方法"><a href="#实现increaseFreq方法" class="headerlink" title="实现increaseFreq方法"></a>实现<code>increaseFreq</code>方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">increaseFreq</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    freq := this.keyToFreq[key]</span><br><span class="line">    this.keyToFreq[key] = freq+<span class="number">1</span>	<span class="comment">// 更新KF表</span></span><br><span class="line">    <span class="comment">// 将key从freq对应的列表和哈希表中删除</span></span><br><span class="line">    this.freqToKeys[freq].doubleList.remove(this.freqToKeys[freq].hashMap[key])</span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[freq].hashMap,key)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[freq].hashMap) == <span class="number">0</span> &#123; <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,freq)</span><br><span class="line">        <span class="keyword">if</span> freq == this.minFreq &#123;  <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">            this.minFreq++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将key加入到freq+1对应的列表和哈希表中</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[freq+<span class="number">1</span>]; !ok &#123;</span><br><span class="line">        this.freqToKeys[freq+<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,freq+<span class="number">1</span>)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="实现addRecently方法"><a href="#实现addRecently方法" class="headerlink" title="实现addRecently方法"></a>实现<code>addRecently</code>方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">addRecently</span><span class="params">(key <span class="keyword">int</span>, freq <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := &amp;node&#123;</span><br><span class="line">        key		:	key,</span><br><span class="line">    &#125;</span><br><span class="line">    this.freqToKeys[freq].doubleList.addLast(x)</span><br><span class="line">    this.freqToKeys[freq].hashMap[key] = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在插入新的节点时，需要修改<code>FK</code>表的哈希表和双链表。</p>
<h2 id="对底层数据结构进行操作"><a href="#对底层数据结构进行操作" class="headerlink" title="对底层数据结构进行操作"></a>对底层数据结构进行操作</h2><p>&emsp;&emsp;该层的主要作用是对我们实现的<code>LinkedHashSet</code>结构封装一些通用操作，用以满足<code>FK</code>表的更新和删除操作，主要包含以下几个方法：</p>
<ol>
<li>删除<code>DoubleList</code>中某一节点的方法<code>remove(x *node)</code>。</li>
<li>删除<code>DoubleList</code>中表首元素的方法<code>removeFirst()</code>。</li>
<li>在<code>DoubleList</code>中表尾部增加新元素的<code>addLast()</code>。</li>
</ol>
<h3 id="实现remove方法"><a href="#实现remove方法" class="headerlink" title="实现remove方法"></a>实现<code>remove</code>方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">remove</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev.next = x.next</span><br><span class="line">    x.next.prev = x.prev</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="实现removeFirst方法"><a href="#实现removeFirst方法" class="headerlink" title="实现removeFirst方法"></a>实现<code>removeFirst</code>方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">removeFirst</span><span class="params">()</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dl.head.next == dl.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    first := dl.head.next</span><br><span class="line">    dl.remove(first)</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现addLast方法"><a href="#实现addLast方法" class="headerlink" title="实现addLast方法"></a>实现<code>addLast</code>方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">addLast</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev = dl.tail.prev</span><br><span class="line">    x.next = dl.tail</span><br><span class="line">    dl.tail.prev.next = x</span><br><span class="line">    dl.tail.prev = x</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h1 id="总体算法"><a href="#总体算法" class="headerlink" title="总体算法"></a>总体算法</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ###############基础数据结构###################</span></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key		<span class="keyword">int</span></span><br><span class="line">    prev	*node</span><br><span class="line">    next	*node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双端链表</span></span><br><span class="line"><span class="keyword">type</span> DoubleList <span class="keyword">struct</span> &#123;</span><br><span class="line">    head	*node</span><br><span class="line">    tail	*node</span><br><span class="line">    size	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化双端链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorDL</span><span class="params">()</span> *<span class="title">DoubleList</span></span> &#123;</span><br><span class="line">    dh := &amp;node&#123;</span><br><span class="line">        key		:	<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dt := &amp;node &#123;</span><br><span class="line">        key		:	<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dh.next,dt.prev = dt,dh</span><br><span class="line">    <span class="keyword">return</span> &amp;DoubleList&#123;</span><br><span class="line">        head	:	dh,</span><br><span class="line">        tail	:	dt,</span><br><span class="line">        size	:	<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造LinkedHashSet作为freqToKeys表</span></span><br><span class="line"><span class="keyword">type</span> LinkedHashSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashMap		<span class="keyword">map</span>[<span class="keyword">int</span>]*node</span><br><span class="line">    doubleList	*DoubleList    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化LinkedHashSet</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorLH</span><span class="params">()</span> *<span class="title">LinkedHashSet</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node)</span><br><span class="line">    dl := constructorDL()</span><br><span class="line">    <span class="keyword">return</span> &amp;LinkedHashSet&#123;</span><br><span class="line">        hashMap		:	m,</span><br><span class="line">        doubleList	:	dl,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ##############底层方法（用于直接操作数据结构）####################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除双端链表中的某一节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">remove</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev.next = x.next</span><br><span class="line">    x.next.prev = x.prev</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除双端链表表头元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">removeFirst</span><span class="params">()</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dl.head.next == dl.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    first := dl.head.next</span><br><span class="line">    dl.remove(first)</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在双端链表尾部添加新元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">addLast</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev = dl.tail.prev</span><br><span class="line">    x.next = dl.tail</span><br><span class="line">    dl.tail.prev.next = x</span><br><span class="line">    dl.tail.prev = x</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ###############LFU类的实现##################</span></span><br><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    keyToVal	<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>				<span class="comment">// key 到 val 的映射，我们后文称为 KV 表</span></span><br><span class="line">    keyToFreq	<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>				<span class="comment">// key 到 freq 的映射，我们后文称为 KF 表</span></span><br><span class="line">    freqToKeys	<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet	<span class="comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span></span><br><span class="line">    minFreq		<span class="keyword">int</span>						<span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="built_in">cap</span>			<span class="keyword">int</span>						<span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化LFU类，加载KV表、KF表以及FK表，设置最小频率树minFreq</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LFUCache</span></span> &#123;</span><br><span class="line">    kv := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    kf := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    fk := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet)</span><br><span class="line">    <span class="keyword">return</span> LFUCache&#123;</span><br><span class="line">        keyToVal	:	kv,</span><br><span class="line">        keyToFreq	:	kf,</span><br><span class="line">        freqToKeys	:	fk,</span><br><span class="line">        minFreq		:	<span class="number">0</span>,</span><br><span class="line">        <span class="built_in">cap</span>			:	capacity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.increaseFreq(key)</span><br><span class="line">    <span class="keyword">return</span> this.keyToVal[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Put方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; ok &#123;  <span class="comment">// 若key已存在，修改对应的val即可</span></span><br><span class="line">        this.keyToVal[key] = value</span><br><span class="line">        this.increaseFreq(key)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// key不存在，需要插入</span></span><br><span class="line">    <span class="comment">// 容量已满的话需要淘汰一个freq最小的key</span></span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> &lt;= <span class="built_in">len</span>(this.keyToVal) &#123;</span><br><span class="line">        this.removeMinFreqKey()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入key和val，对应的freq为1</span></span><br><span class="line">    this.keyToVal[key] = value	<span class="comment">// 插入KV表</span></span><br><span class="line">    this.keyToFreq[key] = <span class="number">1</span>		<span class="comment">// 插入KF表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[<span class="number">1</span>]; !ok &#123;  <span class="comment">// 如果没有freq为1的LinkedHashSet，则生成一个</span></span><br><span class="line">        this.freqToKeys[<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,<span class="number">1</span>)  <span class="comment">// 插入新key后的freq肯定是1</span></span><br><span class="line">    this.minFreq = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ################中间抽象层####################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除使用频率最低节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">removeMinFreqKey</span><span class="params">()</span></span> &#123;</span><br><span class="line">    keyList := this.freqToKeys[this.minFreq].doubleList	<span class="comment">// 获得最小freq的LinkedHashSet</span></span><br><span class="line">    deleteKey := keyList.removeFirst()	<span class="comment">// 删除LinkedHashSet的双链表头的元素</span></span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[this.minFreq].hashMap,deleteKey.key)		<span class="comment">// 删除LinkedHashSet的哈希表对应元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[this.minFreq].hashMap) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,this.minFreq)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delete</span>(this.keyToVal,deleteKey.key)		<span class="comment">// 更新KV表</span></span><br><span class="line">    <span class="built_in">delete</span>(this.keyToFreq,deleteKey.key)	<span class="comment">// 更新KF表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加某一节点的使用频数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">increaseFreq</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    freq := this.keyToFreq[key]</span><br><span class="line">    this.keyToFreq[key] = freq+<span class="number">1</span>	<span class="comment">// 更新KF表</span></span><br><span class="line">    <span class="comment">// 将key从freq对应的列表和哈希表中删除</span></span><br><span class="line">    this.freqToKeys[freq].doubleList.remove(this.freqToKeys[freq].hashMap[key])</span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[freq].hashMap,key)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[freq].hashMap) == <span class="number">0</span> &#123; <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,freq)</span><br><span class="line">        <span class="keyword">if</span> freq == this.minFreq &#123;  <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">            this.minFreq++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将key加入到freq+1对应的列表和哈希表中</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[freq+<span class="number">1</span>]; !ok &#123;</span><br><span class="line">        this.freqToKeys[freq+<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,freq+<span class="number">1</span>)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 对最近使用的节点的处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">addRecently</span><span class="params">(key <span class="keyword">int</span>, freq <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := &amp;node&#123;</span><br><span class="line">        key		:	key,</span><br><span class="line">    &#125;</span><br><span class="line">    this.freqToKeys[freq].doubleList.addLast(x)</span><br><span class="line">    this.freqToKeys[freq].hashMap[key] = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>LFU</tag>
      </tags>
  </entry>
  <entry>
    <title>链表习题解析</title>
    <url>/2021/09/24/%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="链表高频题目"><a href="#链表高频题目" class="headerlink" title="链表高频题目"></a>链表高频题目</h1><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a class="link" href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加<i class="fas fa-external-link-alt"></i></a></h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="addtwonumber1.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;本题很自然的就想到先将两个链表保存的数都转化成变量的形式存储下来，直接相加后再逐位用链表保存后输出。但是，在提交代码后，发现其中一个测试用例没有通过。原来是其中一个链表转换成数字变量后，它直接溢出了，导致出错。所以要完全AC这道题，这种方法肯定是不行的。</p>
<p>&emsp;&emsp;由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为<code>n1,n2</code>，进位值为<code>carry</code>，他们的和为<code>n1+n2+carry</code>，其中答案链表处相应位置的数字为<code>(n1+n2+carry)%10</code>，而新的进位值为<code>(n1+n2+carry)/10</code>。</p>
<p>&emsp;&emsp;如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0 。此外，如果链表遍历结束后，有 <code>carry&gt;0</code>，还需要在答案链表的后面附加一个节点，节点的值为 <code>carry</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    carry := <span class="number">0</span></span><br><span class="line">    v := <span class="number">0</span></span><br><span class="line">    h1 := l1	<span class="comment">// 保存头节点</span></span><br><span class="line">    f1 := l1	<span class="comment">// 记录前一节点，方便拼接</span></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;	<span class="comment">// 当l1和l2都没有遍历到表尾</span></span><br><span class="line">        v = (l1.Val+l2.Val+carry)%<span class="number">10</span>	<span class="comment">// 值</span></span><br><span class="line">        carry = (l1.Val+l2.Val+carry)/<span class="number">10</span>   <span class="comment">//	进位</span></span><br><span class="line">        l1.Val = v		<span class="comment">//	保存到l1中（直接替换掉这个位置节点的值）</span></span><br><span class="line">        f1 = l1			<span class="comment">//	f1跟进</span></span><br><span class="line">        l1 = l1.Next	<span class="comment">//	l1指向其Next</span></span><br><span class="line">        l2 = l2.Next	<span class="comment">//	l2指向其Next</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry != <span class="number">0</span> &#123;	<span class="comment">// l1和l2等长且最后还有一位进位</span></span><br><span class="line">        f1.Next = &amp;ListNode&#123;	<span class="comment">// 创造一个节点，其值为进位值</span></span><br><span class="line">            Val     :       carry,</span><br><span class="line">            Next    :       <span class="literal">nil</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;	<span class="comment">//	l1更长，处理完l1剩余的节点</span></span><br><span class="line">        <span class="keyword">for</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            v = (l1.Val+carry)%<span class="number">10</span></span><br><span class="line">            carry = (l1.Val+carry)/<span class="number">10</span>        </span><br><span class="line">            l1.Val = v</span><br><span class="line">            f1 = l1</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> carry != <span class="number">0</span> &#123;	<span class="comment">//	考虑最后是否有进位</span></span><br><span class="line">            f1.Next = &amp;ListNode&#123;</span><br><span class="line">                Val     :       carry,</span><br><span class="line">                Next    :       <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;	<span class="comment">//	l2更长，处理完l2剩余的节点</span></span><br><span class="line">        f1.Next = l2</span><br><span class="line">        <span class="keyword">for</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            v = (l2.Val+carry)%<span class="number">10</span></span><br><span class="line">            carry = (l2.Val+carry)/<span class="number">10</span>     </span><br><span class="line">            l2.Val = v</span><br><span class="line">            f1 = l2</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> carry != <span class="number">0</span> &#123;	<span class="comment">//	考虑最后是否有进位</span></span><br><span class="line">            f1.Next = &amp;ListNode&#123;</span><br><span class="line">                Val     :       carry,</span><br><span class="line">                Next    :       <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h1><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a class="link" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表<i class="fas fa-external-link-alt"></i></a></h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="merge_ex1.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<p>这题思路很简单，用下图就可以概括：</p>
<p><img lazyload src="/images/loading.svg" data-src="1.gif" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    dummy := &amp;ListNode&#123;Val:<span class="number">0</span>,Next:<span class="literal">nil</span>,&#125;</span><br><span class="line">    tail := dummy</span><br><span class="line">    <span class="keyword">var</span> node *ListNode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l1.Val &lt;= l2.Val &#123;</span><br><span class="line">            node = &amp;ListNode&#123;</span><br><span class="line">                Val     :   l1.Val,</span><br><span class="line">                Next    :   <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = &amp;ListNode&#123;</span><br><span class="line">                Val     :   l2.Val,</span><br><span class="line">                Next    :   <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        tail.Next = node</span><br><span class="line">        tail = node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        tail.Next = l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        tail.Next = l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a class="link" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表<i class="fas fa-external-link-alt"></i></a></h2><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：lists &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：lists &#x3D; [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>



<p>提示：</p>
<ul>
<li><code>k == lists.length</code></li>
<li><code>0 &lt;= k &lt;= 10^4</code></li>
<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>
<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>
<li><code>lists[i]</code> 按 升序 排列</li>
<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;将每个链表的节点分别填充入最小堆中，就可以实现所有节点数值的升序排列。最小堆的实现参考我的另一篇文章<a href="https://jiahaohong1997.github.io/2021/09/27/%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/">二叉堆的Go语言实现</a>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h[i]&lt;h[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(*h)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    l := <span class="built_in">len</span>(lists)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    h := &amp;IntHeap&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;l; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> lists[i] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        node := lists[i]</span><br><span class="line">        <span class="keyword">for</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            *h = <span class="built_in">append</span>(*h, node.Val)</span><br><span class="line">            node = node.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> h.Len() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    heap.Init(h)</span><br><span class="line"></span><br><span class="line">    head := &amp;ListNode&#123;</span><br><span class="line">        Val     :       (*h)[<span class="number">0</span>],</span><br><span class="line">        Next    :       <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    t := head</span><br><span class="line">    heap.Pop(h)</span><br><span class="line">    <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        x := heap.Pop(h).(<span class="keyword">int</span>)</span><br><span class="line">        node := &amp;ListNode&#123;</span><br><span class="line">            Val     :       x,</span><br><span class="line">            Next    :       <span class="literal">nil</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        t.Next = node</span><br><span class="line">        t = node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a class="link" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点<i class="fas fa-external-link-alt"></i></a></h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="remove_ex1.jpg" alt="avatat"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1], n &#x3D; 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], n &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;这个逻辑就很简单了，要删除倒数第 <code>n</code> 个节点，就得获得倒数第 <code>n + 1</code> 个节点的引用，首先，我们先让一个指针 <code>p1</code> 指向链表的头节点 <code>head</code>，然后走 <code>k</code> 步：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph1.jpg" alt="avatar"></p>
<p>现在的 <code>p1</code>，只要再走 <code>n - k</code> 步，就能走到链表末尾的空指针了对吧？</p>
<p>趁这个时候，再用一个指针 <code>p2</code> 指向链表头节点 <code>head</code>：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph2.jpg" alt="avatar"></p>
<p>接下来就很显然了，让 <code>p1</code> 和 <code>p2</code> 同时向前走，<code>p1</code> 走到链表末尾的空指针时走了 <code>n - k</code> 步，<code>p2</code> 也走了 <code>n - k</code> 步，也就是链表的倒数第 <code>k</code> 个节点：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph3.jpg" alt="avatar"></p>
<p>这样，只遍历了一次链表，就获得了倒数第 <code>k</code> 个节点 <code>p2</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    fast, slow := head, head</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;	<span class="comment">//fast指向nil，说明n=链表的节点数，即删除第一个节点</span></span><br><span class="line">        <span class="keyword">return</span> head.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fast.Next != <span class="literal">nil</span> &#123;	<span class="comment">// 定位到要删除节点的前一个节点</span></span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    slow.Next = slow.Next.Next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a class="link" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表<i class="fas fa-external-link-alt"></i></a></h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<p><img lazyload src="/images/loading.svg" data-src="160_statement.png" alt="avatar"></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="160_example_1.png" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Intersected at &#39;8&#39;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="160_example_2.png" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Intersected at &#39;2&#39;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="160_example_3.png" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>listA </code>中节点数目为 <code>m</code></li>
<li><code>listB</code> 中节点数目为<code>n</code></li>
<li><code>0 &lt;= m, n &lt;= 3 * 104</code></li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li><code>0 &lt;= skipA &lt;= m</code></li>
<li><code>0 &lt;= skipB &lt;= n</code></li>
<li>如果 <code>listA </code>和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>如果<code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;这个题直接的想法可能是用 <code>HashSet</code> 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间。</p>
<p>&emsp;&emsp;如果不用额外的空间，只使用两个指针，你如何做呢？难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：</p>
<p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/5.jpg" alt="avatar"></p>
<p>&emsp;&emsp;如果用两个指针 <code>p1</code> 和 <code>p2</code> 分别在两条链表上前进，并不能<strong>同时</strong>走到公共节点，也就无法得到相交节点 <code>c1</code>。</p>
<p>&emsp;&emsp;<strong>所以，解决这个问题的关键是，通过某些方式，让</strong> <strong><code>p1</code></strong> <strong>和</strong> <strong><code>p2</code></strong> <strong>能够同时到达相交节点</strong> **<code>c1</code>**。</p>
<p>&emsp;&emsp;所以，我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。如果这样进行拼接，就可以让 <code>p1</code> 和 <code>p2</code> 同时进入公共部分，也就是同时到达相交节点 <code>c1</code>：</p>
<p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/7.jpg" alt="avatar"></p>
<p>&emsp;&emsp;那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 <code>nil</code> 呢？这个逻辑可以覆盖这种情况的，相当于 <code>c1</code> 节点是 <code>nil</code> 空指针嘛，可以正确返回 <code>nil</code>。</p>
<p>按照这个思路，可以写出如下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    a, b := headA, headB</span><br><span class="line">    <span class="keyword">for</span> a != b &#123;</span><br><span class="line">        <span class="keyword">if</span> a != <span class="literal">nil</span> &#123;</span><br><span class="line">            a = a.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a = headB</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> b != <span class="literal">nil</span> &#123;</span><br><span class="line">            b = b.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b = headA</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，这道题就解决了，空间复杂度为 <code>O(1)</code>，时间复杂度为 <code>O(N)</code>。</p>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="反转整个链表"><a href="#反转整个链表" class="headerlink" title="反转整个链表"></a>反转整个链表</h2><ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;	<span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    last := reverse(head.Next)</span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    first := head.Next.Next</span><br><span class="line">    second := head.Next</span><br><span class="line">    third := head</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> first != <span class="literal">nil</span> &#123;</span><br><span class="line">        second.Next = third</span><br><span class="line">        third = second</span><br><span class="line">        second = first</span><br><span class="line">        first = first.Next</span><br><span class="line">    &#125;</span><br><span class="line">    second.Next = third</span><br><span class="line">    <span class="keyword">return</span> second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="反转链表前n个节点"><a href="#反转链表前n个节点" class="headerlink" title="反转链表前n个节点"></a>反转链表前n个节点</h2><p>&emsp;&emsp;比如说对于下图链表，执行 <code>reverseN(head, 3)</code>：</p>
<p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/6.jpg" alt="avatar"></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> successor *ListNode	<span class="comment">// 后驱节点</span></span><br><span class="line">successor = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseN</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        successor = head.Next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    last := reverseN(head.Next,n<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    head.Next = successor</span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseN</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    first := head.Next.Next</span><br><span class="line">    second := head.Next</span><br><span class="line">    third := head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;		<span class="comment">// n=1,不需要翻转</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> &#123;		<span class="comment">// n=2,直接翻转前两个节点即可</span></span><br><span class="line">        second.Next = third</span><br><span class="line">        third.Next = first</span><br><span class="line">        <span class="keyword">return</span> second</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> n<span class="number">-2</span> &gt; <span class="number">0</span> &#123;	<span class="comment">// n&gt;2时的情况，结合上图来推一遍会比较清晰</span></span><br><span class="line">        second.Next = third</span><br><span class="line">        third = second</span><br><span class="line">        second = first</span><br><span class="line">        first = first.Next</span><br><span class="line">        n--</span><br><span class="line">    &#125;</span><br><span class="line">    second.Next = third</span><br><span class="line">    third.Next = first</span><br><span class="line">    <span class="keyword">return</span> second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="反转链表的一部分"><a href="#反转链表的一部分" class="headerlink" title="反转链表的一部分"></a>反转链表的一部分</h2><p>&emsp;&emsp;给一个索引区间 <code>[m,n]</code>（索引从 1 开始），仅仅反转区间中的链表元素。</p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, m,n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">1</span> &#123;	<span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">return</span> reverseN(head,n)	<span class="comment">// 相当于反转前n个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">    head.Next = reverseBetween(head.Next, m<span class="number">-1</span>, n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>迭代</li>
</ul>
<p><a class="link" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="rev2ex2.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4</span><br><span class="line">输出：[1,4,3,2,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [5], left &#x3D; 1, right &#x3D; 1</span><br><span class="line">输出：[5]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目为 <code>n</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>-500 &lt;= Node.val &lt;= 500</code></li>
<li><code>1 &lt;= left &lt;= right &lt;= n</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;我们以下图中黄色区域的链表反转为例。</p>
<p><img lazyload src="/images/loading.svg" data-src="1615105129-iUPoGi-image.png" alt="avatar"></p>
<p>&emsp;&emsp;反转 <code>left</code> 到 <code>right</code> 部分以后，再拼接起来。我们还需要记录 <code>left</code>的前一个节点，和 <code>right</code> 的后一个节点。如图所示：</p>
<p><img lazyload src="/images/loading.svg" data-src="1615105150-pfWiGq-image.png" alt="avatar"></p>
<ul>
<li>第 1 步：先将待反转的区域反转；</li>
<li>第 2 步：把 pre 的 next 指针指向反转以后的链表头节点，把反转以后的链表的尾节点的 next 指针指向 succ</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    dummyNode := &amp;ListNode&#123;Val:<span class="number">-1</span>&#125;</span><br><span class="line">    dummyNode.Next = head</span><br><span class="line">    pre := dummyNode</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;left<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        pre = pre.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点</span></span><br><span class="line">    rightNode := pre</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; right-left+<span class="number">1</span>; i++ &#123;</span><br><span class="line">        rightNode = rightNode.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 3 步：切断出一个子链表（截取链表）</span></span><br><span class="line">    leftNode := pre.Next;</span><br><span class="line">    curr := rightNode.Next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：切断链接</span></span><br><span class="line">    pre.Next = <span class="literal">nil</span></span><br><span class="line">    rightNode.Next = <span class="literal">nil</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 第4步：反转区间</span></span><br><span class="line">    reverse(leftNode)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 5 步：接回到原来的链表中</span></span><br><span class="line">    pre.Next = rightNode</span><br><span class="line">    leftNode.Next = curr</span><br><span class="line">    <span class="keyword">return</span> dummyNode.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="如何判断回文链表"><a href="#如何判断回文链表" class="headerlink" title="如何判断回文链表"></a>如何判断回文链表</h1><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a class="link" href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表<i class="fas fa-external-link-alt"></i></a></h2><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="pal1linked-list.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="pal2linked-list.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围<code>[1, 105]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>
<p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;最一般的做法是先用一个数组将整个链表存储下来，再从数组的两端向中间逼近来判断是否是回文串。进阶要求是用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题。</p>
<p>&emsp;&emsp;先通过快慢指针翻转后半部分链表（注意分情况讨论奇数和偶数）。然后翻转后半部分链表（如果是奇数链表，slow指针还要再走一步），最后通过比较前后两部分来判断是否是回文链表。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fast, slow := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;	<span class="comment">// 找到链表的中间位置</span></span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;  <span class="comment">// 偶数串，slow指向后半部分的第一个节点处</span></span><br><span class="line">        backHead := reverse(slow)</span><br><span class="line">        <span class="keyword">for</span> backHead != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> backHead.Val != head.Val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            backHead = backHead.Next</span><br><span class="line">            head = head.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 奇数串，slow指向前后两段的正中间</span></span><br><span class="line">        slow = slow.Next</span><br><span class="line">        backHead := reverse(slow)</span><br><span class="line">        <span class="keyword">for</span> backHead != <span class="literal">nil</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> backHead.Val != head.Val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            backHead = backHead.Next</span><br><span class="line">            head = head.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    pre, cur := head, head.Next</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        nxt := cur.Next</span><br><span class="line">        cur.Next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = nxt</span><br><span class="line">    &#125;</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的序列化和反序列化</title>
    <url>/2021/10/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="序列化的目的"><a href="#序列化的目的" class="headerlink" title="序列化的目的"></a>序列化的目的</h1><p>&emsp;&emsp;JSON 的运用非常广泛，比如我们经常将变成语言中的结构体序列化成 JSON 字符串，存入缓存或者通过网络发送给远端服务，消费者接受 JSON 字符串然后进行反序列化，就可以得到原始数据了。这就是「序列化」和「反序列化」的目的，以某种固定格式组织字符串，使得数据可以独立于编程语言。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><a class="link" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化<i class="fas fa-external-link-alt"></i></a></p>
<p>&emsp;&emsp;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>&emsp;&emsp;请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p><strong>提示:</strong> 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="serdeser.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,null,null,4,5]</span><br><span class="line">输出：[1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 <code>[0, 104]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>&emsp;&emsp;我们可以用 <code>serialize</code> 方法将二叉树序列化成字符串，用 <code>deserialize</code> 方法将序列化的字符串反序列化成二叉树，至于以什么格式序列化和反序列化，这个完全由你决定。比如说输入如下这样一棵二叉树：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph2.jpg" alt="avatar"></p>
<p>&emsp;&emsp;<code>serialize</code> 方法也许会把它序列化成字符串 <code>2,1,#,6,3,#,#</code>，其中 <code>#</code> 表示 <code>null</code> 指针，那么把这个字符串再输入 <code>deserialize</code> 方法，依然可以还原出这棵二叉树。也就是说，这两个方法会成对儿使用，你只要保证他俩能够自洽就行了。</p>
<p>&emsp;&emsp;想象一下，二叉树结该是一个二维平面内的结构，而序列化出来的字符串是一个线性的一维结构。<strong>所谓的序列化不过就是把结构化的数据「打平」，其实就是在考察二叉树的遍历方式</strong>。</p>
<p>&emsp;&emsp;二叉树的遍历方式有哪些？递归遍历方式有前序遍历，中序遍历，后序遍历；迭代方式一般是层级遍历。本文就把这些方式都尝试一遍，来实现 <code>serialize</code> 方法和 <code>deserialize</code> 方法。</p>
<h2 id="结构体构造"><a href="#结构体构造" class="headerlink" title="结构体构造"></a>结构体构造</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Codec <span class="keyword">struct</span> &#123;</span><br><span class="line">    s       <span class="keyword">string</span></span><br><span class="line">    null    <span class="keyword">string</span></span><br><span class="line">    sep     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">Codec</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Codec&#123;</span><br><span class="line">        null    :   <span class="string">&quot;#&quot;</span>,  <span class="comment">// 空节点</span></span><br><span class="line">        sep     :   <span class="string">&quot;,&quot;</span>,  <span class="comment">// 分隔符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>&emsp;&emsp;如下二叉树（<code>#</code> 代表空指针 null），可以直观看出前序遍历做的事情：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph1.jpg" alt="avatar"></p>
<p>&emsp;&emsp;那么 <code>res = [1,2,-1,4,-1,-1,3,-1,-1]</code>，这就是将二叉树「打平」到了一个列表中，其中 -1 代表 null。</p>
<p>那么，将二叉树打平到一个字符串中也是完全一样的，至此，我们已经可以写出序列化函数 <code>serialize</code> 的代码了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Serializes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">serialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        this.s = this.s + this.null + this.sep</span><br><span class="line">        <span class="keyword">return</span> this.s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node := strconv.Itoa(root.Val)</span><br><span class="line">    this.s = this.s + node + this.sep</span><br><span class="line">    this.serialize(root.Left)</span><br><span class="line">    this.serialize(root.Right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> this.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，思考一下如何写 <code>deserialize</code> 函数，将字符串反过来构造二叉树。首先我们可以把字符串转化成列表：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">this.s = <span class="string">&quot;1,2,#,4,#,#,3,#,#,&quot;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一般语境下，单单前序遍历结果是不能还原二叉树结构的，因为缺少空指针的信息，至少要得到前、中、后序遍历中的两种才能还原二叉树。但是这里的 <code>node</code>列表包含空指针的信息，所以只使用 <code>node</code> 列表就可以还原二叉树。那么，反序列化过程也是一样，<strong>先确定根节点 <code>root</code>，然后遵循前序遍历的规则，递归生成左右子树即可</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Deserializes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">deserialize</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>) </span><br><span class="line">    j := <span class="number">0</span></span><br><span class="line">    f := <span class="number">0</span></span><br><span class="line">    x := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> data[i] == <span class="string">&#x27;,&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;#&#x27;</span> &#123;	<span class="comment">// 当前节点是空指针</span></span><br><span class="line">            m = <span class="built_in">append</span>(m,math.MinInt32)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;-&#x27;</span> &#123;	<span class="comment">// 当前节点是负值</span></span><br><span class="line">            <span class="keyword">for</span> j = i+<span class="number">1</span>; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span>+x</span><br><span class="line">            &#125;           </span><br><span class="line">            m = <span class="built_in">append</span>(m,<span class="number">-1</span>*f)</span><br><span class="line">            i = j</span><br><span class="line">            f = <span class="number">0</span> </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j = i; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span>+x</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            m = <span class="built_in">append</span>(m,f)</span><br><span class="line">            i = j</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(&amp;m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(m *[]<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(*m) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 列表最左侧就是根节点</span></span><br><span class="line">    first := (*m)[<span class="number">0</span>]</span><br><span class="line">    *m = (*m)[<span class="number">1</span>:]	<span class="comment">// 引用全局变量进行操作，就不会随递归栈进行变化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> first == math.MinInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    root := &amp;TreeNode&#123;first,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">    root.Left = helper(m)</span><br><span class="line">    root.Right = helper(m)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><p>&emsp;&emsp;明白了前序遍历的解法，后序遍历就比较容易理解了，我们首先实现 <code>serialize</code> 序列化方法，只需要稍微修改辅助方法即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">serialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        this.s = this.s + this.null + this.sep</span><br><span class="line">        <span class="keyword">return</span> this.s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.serialize(root.Left)</span><br><span class="line">    this.serialize(root.Right)</span><br><span class="line"></span><br><span class="line">    x := strconv.Itoa(root.Val)</span><br><span class="line">    this.s = this.s + x + this.sep</span><br><span class="line">    <span class="keyword">return</span> this.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;后序遍历导致结果的顺序发生变化：</p>
<p><img lazyload src="/images/loading.svg" data-src="postorder.jpg" alt="avatar"></p>
<p>&emsp;&emsp;关键的难点在于，如何实现后序遍历的 <code>deserialize</code> 方法呢？是不是也简单地将关键代码放到后序遍历的位置就行了呢？**<code>deserialize</code> 方法首先寻找 <code>root</code> 节点的值，然后递归计算左右子节点<strong>。那么我们这里也应该顺着这个基本思路走，后续遍历中，<code>root</code> 节点的值能不能找到？<code>root</code> 的值是列表的最后一个元素。我们应该从后往前取出列表元素，先用最后一个元素构造 <code>root</code>，然后递归调用生成 <code>root</code> 的左右子树。</strong>注意，根据上图，从后往前在 <code>nodes</code> 列表中取元素，一定要先构造 <code>root.right</code> 子树，后构造 <code>root.left</code> 子树**。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">deserialize</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(data);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> data[i] == <span class="string">&#x27;,&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;#&#x27;</span> &#123;</span><br><span class="line">            m = <span class="built_in">append</span>(m,math.MinInt32)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;-&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j=i+<span class="number">1</span>; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span> + x</span><br><span class="line">            &#125;</span><br><span class="line">            m = <span class="built_in">append</span>(m,<span class="number">-1</span>*f)</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">            i = j</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j=i; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span> + x</span><br><span class="line">            &#125;</span><br><span class="line">            m = <span class="built_in">append</span>(m,f)</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">            i = j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(&amp;m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(m *[]<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(*m) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n := <span class="built_in">len</span>(*m)</span><br><span class="line">    last := (*m)[n<span class="number">-1</span>]</span><br><span class="line">    *m = (*m)[:n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> last == math.MinInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    root := &amp;TreeNode&#123;</span><br><span class="line">        Val     :       last,</span><br><span class="line">        Left    :       <span class="literal">nil</span>,</span><br><span class="line">        Right   :       <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    root.Right = helper(m)	<span class="comment">//一定要先构造 root.right 子树</span></span><br><span class="line">    root.Left = helper(m)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="中序遍历-不能实现"><a href="#中序遍历-不能实现" class="headerlink" title="中序遍历(不能实现)"></a>中序遍历(不能实现)</h2><p>&emsp;&emsp;先说结论，中序遍历的方式行不通，因为无法实现反序列化方法 <code>deserialize</code>。</p>
<p>&emsp;&emsp;序列化方法 <code>serialize</code> 依然容易，只要把字符串的拼接操作放到中序遍历的位置就行了。但是，我们刚才说了，要想实现反序列方法，首先要构造 <code>root</code> 节点。前序遍历得到的 <code>nodes</code> 列表中，第一个元素是 <code>root</code> 节点的值；后序遍历得到的 <code>nodes</code> 列表中，最后一个元素是 <code>root</code> 节点的值。</p>
<p>&emsp;&emsp;而中序遍历的<code>root</code> 的值被夹在两棵子树的中间，也就是在 <code>nodes</code> 列表的中间，我们不知道确切的索引位置，所以无法找到 <code>root</code> 节点，也就无法进行反序列化。</p>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>序列化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">serialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        this.s = this.s + this.null + this.sep</span><br><span class="line">        <span class="keyword">return</span> this.s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    nodeNum := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; nodeNum&gt;<span class="number">0</span>; i++ &#123;</span><br><span class="line">        p := []*TreeNode&#123;&#125;</span><br><span class="line">        nodeNum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(q); j++ &#123;</span><br><span class="line">            node := q[j]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">                this.s = this.s + this.null + this.sep</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            this.s = this.s + strconv.Itoa(node.Val) + this.sep</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                nodeNum++</span><br><span class="line">                p = <span class="built_in">append</span>(p,node.Left)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p,<span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                nodeNum++</span><br><span class="line">                p = <span class="built_in">append</span>(p,node.Right)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p,<span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>层级遍历序列化得出的结果如下图：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph3.jpg" alt="avatar"></p>
<p>&emsp;&emsp;可以看到，每一个非空节点都会对应两个子节点，<strong>那么反序列化的思路也是用队列进行层级遍历，同时用索引 <code>i</code> 记录对应子节点的位置</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">deserialize</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(data);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> data[i] == <span class="string">&#x27;,&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;#&#x27;</span> &#123;</span><br><span class="line">            m = <span class="built_in">append</span>(m,math.MinInt32)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> data[i] == <span class="string">&#x27;-&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j=i+<span class="number">1</span>; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span> + x</span><br><span class="line">            &#125;</span><br><span class="line">            m = <span class="built_in">append</span>(m,<span class="number">-1</span>*f)</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">            i = j</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j=i; data[j] != <span class="string">&#x27;,&#x27;</span>; j++ &#123;</span><br><span class="line">                x = <span class="keyword">int</span>(data[j]) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                f = f*<span class="number">10</span> + x</span><br><span class="line">            &#125;</span><br><span class="line">            m = <span class="built_in">append</span>(m,f)</span><br><span class="line">            f = <span class="number">0</span></span><br><span class="line">            i = j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(m []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(m) == <span class="number">0</span> || m[<span class="number">0</span>] == math.MinInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root := &amp;TreeNode&#123;m[<span class="number">0</span>],<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(m); &#123;</span><br><span class="line">        parent := q[<span class="number">0</span>]</span><br><span class="line">        q = q[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> m[i] != math.MinInt32 &#123;	<span class="comment">// 左子树</span></span><br><span class="line">            parent.Left = &amp;TreeNode&#123;m[i],<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">            q = <span class="built_in">append</span>(q,parent.Left)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.Left = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> m[i] != math.MinInt32 &#123;	<span class="comment">// 右子树</span></span><br><span class="line">            parent.Right = &amp;TreeNode&#123;m[i],<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">            q = <span class="built_in">append</span>(q,parent.Right)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.Right = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>最大栈</title>
    <url>/2021/10/03/%E6%9C%80%E5%A4%A7%E6%A0%88/</url>
    <content><![CDATA[<h1 id="最大栈介绍"><a href="#最大栈介绍" class="headerlink" title="最大栈介绍"></a>最大栈介绍</h1><p>&emsp;&emsp;直接参考Leetcode上895题：<a class="link" href="https://leetcode-cn.com/problems/maximum-frequency-stack/">895. 最大频率栈<i class="fas fa-external-link-alt"></i></a></p>
<p>实现 <code>FreqStack</code>，模拟类似栈的数据结构的操作的一个类。</p>
<p><code>FreqStack</code> 有两个函数：</p>
<ul>
<li><code>push(int x)</code>，将整数 <code>x</code> 推入栈中。</li>
<li><code>pop()</code>，它移除并返回栈中出现最频繁的元素。<ul>
<li>如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],</span><br><span class="line">[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]</span><br><span class="line">输出：[null,null,null,null,null,null,null,5,7,5,4]</span><br><span class="line">解释：</span><br><span class="line">执行六次 .push 操作后，栈自底向上为 [5,7,5,7,4,5]。然后：</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 5，因为 5 是出现频率最高的。</span><br><span class="line">栈变成 [5,7,5,7,4]。</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 7，因为 5 和 7 都是频率最高的，但 7 最接近栈顶。</span><br><span class="line">栈变成 [5,7,5,4]。</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 5 。</span><br><span class="line">栈变成 [5,7,4]。</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 4 。</span><br><span class="line">栈变成 [5,7]。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>对 <code>FreqStack.push(int x)</code> 的调用中 <code>0 &lt;= x &lt;= 10^9</code>。</li>
<li>如果栈的元素数目为零，则保证不会调用 <code>FreqStack.pop()</code>。</li>
<li>单个测试样例中，对 <code>FreqStack.push</code> 的总调用次数不会超过 <code>10000</code>。</li>
<li>单个测试样例中，对 <code>FreqStack.pop</code> 的总调用次数不会超过 <code>10000</code>。</li>
<li>所有测试样例中，对 <code>FreqStack.push</code> 和 <code>FreqStack.pop</code> 的总调用次数不会超过 <code>150000</code>。</li>
</ul>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>&emsp;&emsp;<strong>这种设计数据结构的问题，主要是要搞清楚问题的难点在哪里，然后结合各种基本数据结构的特性，高效实现题目要求的 API</strong>。</p>
<p>那么，我们仔细思考一下 <code>push</code> 和 <code>pop</code> 方法，难点如下：</p>
<p>1、每次 <code>pop</code> 时，必须要知道频率最高的元素是什么。</p>
<p>2、如果频率最高的元素有多个，还得知道哪个是最近 <code>push</code> 进来的元素是哪个。</p>
<p>为了实现上述难点，我们要做到以下几点：</p>
<p>1、肯定要有一个变量 <code>maxFreq</code> 记录当前栈中最高的频率是多少。</p>
<p>2、我们得知道一个频率 <code>freq</code> 对应的元素有哪些，且这些元素要有时间顺序。</p>
<p>3、随着 <code>pop</code> 的调用，每个 <code>val</code> 对应的频率会变化，所以还得维持一个映射记录每个 <code>val</code> 对应的 <code>freq</code>。</p>
<h1 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h1><p>&emsp;&emsp;综上，我们可以先实现 <code>FreqStack</code> 所需的数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FreqStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    maxFreq     <span class="keyword">int</span>     <span class="comment">// 出现最大频数的记录</span></span><br><span class="line">    valToFreq   <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">    freqToVal   <span class="keyword">map</span>[<span class="keyword">int</span>]*stack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">FreqStack</span></span> &#123;	<span class="comment">// 初始化最大栈</span></span><br><span class="line">    mf := <span class="number">0</span></span><br><span class="line">    vf := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    fv := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*stack,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> FreqStack&#123;</span><br><span class="line">        maxFreq     :       mf,</span><br><span class="line">        valToFreq   :       vf,</span><br><span class="line">        freqToVal   :       fv,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们来亲自构建<code>stack</code>这一数据结构及其方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;			<span class="comment">// 栈可以用一个简单的切片来表示</span></span><br><span class="line">    list        []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorStack</span><span class="params">()</span> *<span class="title">stack</span></span> &#123;	<span class="comment">// 初始化栈</span></span><br><span class="line">    l := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;stack&#123;</span><br><span class="line">        list    :       l,   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">push</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;		<span class="comment">// 入栈方法</span></span><br><span class="line">    s.list = <span class="built_in">append</span>(s.list,val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;		<span class="comment">// 出栈方法，返回出栈的元素</span></span><br><span class="line">    n := <span class="built_in">len</span>(s.list)</span><br><span class="line">    old := s.list</span><br><span class="line">    last := old[n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        s.list = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s.list = old[:n<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">len</span><span class="params">()</span> <span class="title">int</span></span> &#123;		<span class="comment">// 计算栈的容量的方法</span></span><br><span class="line">    n := <span class="built_in">len</span>(s.list)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其实这有点类似前文<a href="https://jiahaohong1997.github.io/tags/LFU/">LFU算法</a>，注意 <code>freqToVal</code> 中 <code>val</code> 列表用一个栈实现，如果一个 <code>freq</code> 对应的元素有多个，根据栈的特点，可以首先取出最近添加的元素。</p>
<p>要记住在 <code>push</code> 和 <code>pop</code> 方法中同时修改 <code>maxFreq</code>、<code>VF</code> 表、<code>FV</code> 表，否则容易出现 bug。</p>
<h2 id="Push方法"><a href="#Push方法" class="headerlink" title="Push方法"></a><code>Push</code>方法</h2><p>现在，我们可以来实现 <code>push</code> 方法了。</p>
<p>我们要分别实现对<code>FreqStack</code>结构体中三个元素的更新。</p>
<ul>
<li><code>valToFreq(VF表)</code>：如果<code>val</code>对应的映射存在，则映射到的值加1；如果不存在，则初始为1；</li>
<li><code>freqToVal(FV表)</code>：如果新加入的<code>val</code>对应的新的<code>freq</code>在<code>FV</code>表中没有初始化的栈，则创建一个新栈，将该<code>val</code>入栈；否则直接入栈；</li>
<li><code>maxFreq</code>：比较新的<code>freq</code>与原始的<code>maxFreq</code>，取大者作为<code>maxFreq</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FreqStack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> freq <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改vf表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.valToFreq[val]; !ok &#123;</span><br><span class="line">        this.valToFreq[val] = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.valToFreq[val]++</span><br><span class="line">    &#125;</span><br><span class="line">    freq = this.valToFreq[val]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改fv表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToVal[freq]; !ok &#123;</span><br><span class="line">        this.freqToVal[freq] = constructorStack()</span><br><span class="line">        this.freqToVal[freq].push(val)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.freqToVal[freq].push(val)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改最大频数</span></span><br><span class="line">    <span class="keyword">if</span> freq &gt; this.maxFreq &#123;</span><br><span class="line">        this.maxFreq = freq</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Pop-方法"><a href="#Pop-方法" class="headerlink" title="Pop()方法"></a><code>Pop()</code>方法</h2><p>我们要分别实现对<code>FreqStack</code>结构体中三个元素的更新。</p>
<ul>
<li><code>freqToVal(FV表)</code>：找到<code>maxFreq</code>在<code>FV</code>表中的映射，如果映射到的<code>stack</code>容量为1(说明只有一个数的频率是<code>maxFreq</code>)，则将<code>maxFreq</code>减一并将栈顶元素出栈；否则直接将栈顶元素出栈；</li>
<li><code>valToFreq(VF表)</code>：找到出栈元素对应的<code>VF</code>表的映射（代表其出现频率），将其直接减一；</li>
<li><code>maxFreq</code>：已经在修改<code>FV</code>表时进行了选择性的修改，不做特殊操作。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FreqStack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.maxFreq == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> popNum <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改fv表</span></span><br><span class="line">    freq := this.maxFreq</span><br><span class="line">    <span class="keyword">if</span> this.freqToVal[freq].<span class="built_in">len</span>() == <span class="number">1</span> &#123;</span><br><span class="line">        popNum = this.freqToVal[freq].pop()</span><br><span class="line">        this.maxFreq--      <span class="comment">// 修改最大频数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        popNum = this.freqToVal[freq].pop() </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改vf表</span></span><br><span class="line">    this.valToFreq[popNum]--</span><br><span class="line">    <span class="keyword">return</span> popNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>完整的最大栈实现代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    list        []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">push</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s.list = <span class="built_in">append</span>(s.list,val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s.list)</span><br><span class="line">    old := s.list</span><br><span class="line">    last := old[n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        s.list = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s.list = old[:n<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stack)</span> <span class="title">len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s.list)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorStack</span><span class="params">()</span> *<span class="title">stack</span></span> &#123;</span><br><span class="line">    l := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;stack&#123;</span><br><span class="line">        list    :       l,   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FreqStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    maxFreq     <span class="keyword">int</span>     <span class="comment">// 出现最大频数的记录</span></span><br><span class="line">    valToFreq   <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">    freqToVal   <span class="keyword">map</span>[<span class="keyword">int</span>]*stack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">FreqStack</span></span> &#123;</span><br><span class="line">    mf := <span class="number">0</span></span><br><span class="line">    vf := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    fv := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*stack,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> FreqStack&#123;</span><br><span class="line">        maxFreq     :       mf,</span><br><span class="line">        valToFreq   :       vf,</span><br><span class="line">        freqToVal   :       fv,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FreqStack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> freq <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改vf表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.valToFreq[val]; !ok &#123;</span><br><span class="line">        this.valToFreq[val] = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.valToFreq[val]++</span><br><span class="line">    &#125;</span><br><span class="line">    freq = this.valToFreq[val]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改fv表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToVal[freq]; !ok &#123;</span><br><span class="line">        this.freqToVal[freq] = constructorStack()</span><br><span class="line">        this.freqToVal[freq].push(val)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.freqToVal[freq].push(val)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改最大频数</span></span><br><span class="line">    <span class="keyword">if</span> freq &gt; this.maxFreq &#123;</span><br><span class="line">        this.maxFreq = freq</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *FreqStack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.maxFreq == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> popNum <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改fv表</span></span><br><span class="line">    freq := this.maxFreq</span><br><span class="line">    <span class="keyword">if</span> this.freqToVal[freq].<span class="built_in">len</span>() == <span class="number">1</span> &#123;</span><br><span class="line">        popNum = this.freqToVal[freq].pop()</span><br><span class="line">        this.maxFreq--      <span class="comment">// 修改最大频数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        popNum = this.freqToVal[freq].pop() </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改vf表</span></span><br><span class="line">    this.valToFreq[popNum]--</span><br><span class="line">    <span class="keyword">return</span> popNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FreqStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(val);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Pop();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>最大栈</tag>
      </tags>
  </entry>
  <entry>
    <title>堆的Go语言实现</title>
    <url>/2021/09/27/%E5%A0%86%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="堆的简介"><a href="#堆的简介" class="headerlink" title="堆的简介"></a>堆的简介</h1><p>&emsp;&emsp;首先，堆和二叉树有啥关系呢，为什么人们总数把堆画成一棵二叉树？因为，堆在逻辑上其实是一种特殊的二叉树<strong>（完全二叉树）</strong>，只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针：</p>
<p>&emsp;&emsp;画个图你立即就能理解了，比如 <code>arr</code> 是一个字符数组，注意数组的第一个索引 0 空着不用：</p>
<p><img lazyload src="/images/loading.svg" data-src="2.png" alt="avatar"></p>
<p>&emsp;&emsp;因为这棵二叉树是<font color="red">「完全二叉树」</font>，所以把 <code>arr[1]</code> 作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。</p>
<p>&emsp;&emsp;为了方便讲解，下面都会画的图都是二叉树结构，相信你能把树和数组对应起来。二叉堆还分为最大堆和最小堆。<strong>最大堆的性质是：每个节点都大于等于它的两个子节点。</strong>类似的，最小堆的性质是：每个节点都小于等于它的子节点。</p>
<h1 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h1><p>&emsp;&emsp;在Go语言的标准库<code>container/heap</code>中，实现了二叉堆，我们先来看看这个包下面有什么内容。</p>
<ol>
<li>接口定义</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，这个堆结构继承自 sort.Interface, 回顾下 <a href="https://jiahaohong1997.github.io/2021/06/10/%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89sort%E5%87%BD%E6%95%B0/">sort.Interface</a>，它需要实现三个方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">	Len() <span class="keyword">int</span></span><br><span class="line">	Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">	Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上堆接口定义的两个方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(h Interface, x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span> <span class="title">interface</span></span>&#123;&#125; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;也就是说，要实现一个堆需要完整实现上述5个方法。</p>
<ol start="2">
<li>上浮<code>up</code>和下沉<code>down</code>方法</li>
</ol>
<p>&emsp;&emsp;我们要讲的是最小堆，每个节点都比它的两个子节点小，但是在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。</p>
<p>&emsp;&emsp;对于最小堆，会破坏堆性质的有有两种情况：</p>
<ul>
<li><code>down</code>：如果某个节点 A 比它的子节点（中的一个）大，那么 A 就不配做父节点，应该下去，下面那个更小的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">down</span><span class="params">(h Interface, i0, n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	i := i0</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		j1 := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> j1 &gt;= n || j1 &lt; <span class="number">0</span> &#123; <span class="comment">// j1 &lt; 0 after int overflow</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		j := j1 <span class="comment">// left child</span></span><br><span class="line">		<span class="keyword">if</span> j2 := j1 + <span class="number">1</span>; j2 &lt; n &amp;&amp; h.Less(j2, j1) &#123;</span><br><span class="line">			j = j2 <span class="comment">// = 2*i + 2  // right child</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !h.Less(j, i) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		h.Swap(i, j)</span><br><span class="line">		i = j</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i &gt; i0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>up</code>：如果某个节点 A 比它的父节点小，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">up</span><span class="params">(h Interface, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		i := (j - <span class="number">1</span>) / <span class="number">2</span> <span class="comment">// parent</span></span><br><span class="line">		<span class="keyword">if</span> i == j || !h.Less(j, i) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		h.Swap(i, j)</span><br><span class="line">		j = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，错位的节点 A 可能要上浮（或下沉）很多次，才能到达正确的位置，恢复堆的性质。所以代码中肯定有一个 <code>for</code> 循环。</p>
<ul>
<li><code>fix</code>：当堆中某一节点的值发生改变后，要对其进行<strong>上浮</strong>或<strong>下沉</strong>操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fix</span><span class="params">(h Interface, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !down(h, i, h.Len()) &#123;</span><br><span class="line">		up(h, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>初始化结构体（建堆）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(h Interface)</span></span> &#123;</span><br><span class="line">	<span class="comment">// heapify</span></span><br><span class="line">	n := h.Len()</span><br><span class="line">	<span class="keyword">for</span> i := n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		down(h, i, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可见，在Go语言中是以<code>0</code>为首开始存储的，所以对于这歌满二叉树，索引为<code>x</code>的节点左子树索引为<code>2*x+1</code>，右子树为<code>2*x+2</code>。</p>
<ol start="4">
<li>堆的增，出堆和删操作</li>
</ol>
<ul>
<li>增<code>Push</code></li>
</ul>
<p>&emsp;&emsp;当在当前堆中增加元素时，先在队列的最末尾处（完全二叉树的最后一个节点）将其插入，然后再利用<strong>上浮</strong>操作调整其位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Push pushes the element x onto the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(h Interface, x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    h.Push(x)	<span class="comment">// h.Push(x)是外层实体的方法，与本方法不相同</span></span><br><span class="line">	up(h, h.Len()<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>出堆<code>Pop</code></li>
</ul>
<p>&emsp;&emsp;堆的Pop操作是先将堆顶元素与最后一个元素交换位置，然后再将交换后的堆顶元素<strong>下沉</strong>到属于它的位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pop removes and returns the minimum element (according to Less) from the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="comment">// Pop is equivalent to Remove(h, 0).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	n := h.Len() - <span class="number">1</span></span><br><span class="line">	h.Swap(<span class="number">0</span>, n)</span><br><span class="line">	down(h, <span class="number">0</span>, n)</span><br><span class="line">    <span class="keyword">return</span> h.Pop()	<span class="comment">// 这里的h.Pop()是用户自己定义的方法，以上部分操作都只负责将堆顶元素放到末尾并使堆保持其规则，最后这一行是用户自己对实体的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>删除任意节点<code>Remove</code></li>
</ul>
<p>&emsp;&emsp;删除任意节点的索引为<code>i</code>，将其与最后一个节点调换位置，然后将调换到索引<code>i</code>处的节点<strong>下沉</strong>到属于它的位置。特别的：出堆操作就是删除最后一个节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Remove removes and returns the element at index i from the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(h Interface, i <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	n := h.Len() - <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> n != i &#123;</span><br><span class="line">		h.Swap(i, n)</span><br><span class="line">		<span class="keyword">if</span> !down(h, i, n) &#123;</span><br><span class="line">			up(h, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h.Pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="实现int类型的堆"><a href="#实现int类型的堆" class="headerlink" title="实现int类型的堆"></a>实现int类型的堆</h1><p>&emsp;&emsp;在官方文档给的示例中<a class="link" href="https://github1s.com/golang/go/blob/master/src/container/heap/example_intheap_test.go">example_intheap_test.go<i class="fas fa-external-link-alt"></i></a>，介绍了怎么通过调用heap包来实现int类型的二叉堆。我们来看看其具体的实现流程。</p>
<ol>
<li>定义一个新的类型，实现五个固定的方法</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;	<span class="comment">// 小端堆用&lt;，大端堆则反过来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;		<span class="comment">// 增添一个新元素</span></span><br><span class="line">	<span class="comment">// Push and Pop use pointer receivers because they modify the slice&#x27;s length,</span></span><br><span class="line">	<span class="comment">// not just its contents.</span></span><br><span class="line">	*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;	<span class="comment">// 推出最后一个元素</span></span><br><span class="line">	old := *h</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	x := old[n<span class="number">-1</span>]</span><br><span class="line">	*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>完整代码</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 2012 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This example demonstrates an integer heap built using the heap interface.</span></span><br><span class="line"><span class="keyword">package</span> heap_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/heap&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Push and Pop use pointer receivers because they modify the slice&#x27;s length,</span></span><br><span class="line">	<span class="comment">// not just its contents.</span></span><br><span class="line">	*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	old := *h</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	x := old[n<span class="number">-1</span>]</span><br><span class="line">	*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example inserts several ints into an IntHeap, checks the minimum,</span></span><br><span class="line"><span class="comment">// and removes them in order of priority.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example_intHeap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">	heap.Init(h)	<span class="comment">// 初始化这个堆，此时堆已经建好了</span></span><br><span class="line">	heap.Push(h, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;minimum: %d\n&quot;</span>, (*h)[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, heap.Pop(h))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Output:</span></span><br><span class="line">	<span class="comment">// minimum: 1</span></span><br><span class="line">	<span class="comment">// 1 2 3 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>&emsp;&emsp;在<code>/src/container/heap/example_pq_test.go</code>文件中给出了使用堆实现一个优先队列的示例。不同于int类型的堆，可以直接根据元素的值的大小决定其优先级，优先队列中的每个元素需要通过一个<code>priority</code>变量设置各自的优先级。同时，还需要设置一个变量<code>index</code>来保持与队列中的索引号一致。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An Item is something we manage in a priority queue.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">    value	<span class="keyword">string</span> <span class="comment">// The value of the item; arbitrary.</span></span><br><span class="line">    priority	<span class="keyword">int</span> <span class="comment">// The priority of the item in the queue.</span></span><br><span class="line">    <span class="comment">// The index is needed by update and is maintained by the heap.Interface methods.</span></span><br><span class="line">    index	<span class="keyword">int</span> <span class="comment">// The index of the item in the heap.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;然后就可以初始化一个堆了，我们要为这个优先队列设立<code>Len()</code>、<code>Swap()</code>、<code>Less()</code>三个方法使其先变成一个<code>sort.Interface</code>类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A PriorityQueue implements heap.Interface and holds Items.</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(pq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">    pq[i].index = i</span><br><span class="line">    pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// We want Pop to give us the highest, not lowest, priority so we use greater than here.</span></span><br><span class="line">    <span class="keyword">return</span> pq[i].priority &gt; pq[j].priority</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;然后就是经典的<code>Push()</code>和<code>Pop()</code>方法的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(*pq)</span><br><span class="line">    item := x.(*Item)</span><br><span class="line">    item.index = n</span><br><span class="line">    *pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *pq</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    item := old[n<span class="number">-1</span>]</span><br><span class="line">    old[n<span class="number">-1</span>] = <span class="literal">nil</span>	<span class="comment">// avoid memory leak</span></span><br><span class="line">    item.index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">    *pq = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;当某一个节点的值或优先级发生改变时，再实现一个<code>update</code>方法来调整优先队列的顺序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">update</span><span class="params">(item *Item, value, priority)</span></span> &#123;</span><br><span class="line">    item.value = value</span><br><span class="line">    item.priority = priority</span><br><span class="line">    heap.fix(pq, item.index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;完整的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heap_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/heap&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An Item is something we manage in a priority queue.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">    value	<span class="keyword">string</span>	<span class="comment">// The value of the item; arbitrary.</span></span><br><span class="line">    priority	<span class="keyword">int</span>	<span class="comment">// The priority of the item in the queue.</span></span><br><span class="line">    <span class="comment">// The index is needed by update and is maintained by the heap.Interface methods.</span></span><br><span class="line">    index	<span class="keyword">int</span>	<span class="comment">// The index of the item in the heap.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A PriorityQueue implements heap.Interface and holds Items.</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(pq)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">    pq[i].index = i</span><br><span class="line">    pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// We want Pop to give us the highest, not lowest, priority so we use greater than here.</span></span><br><span class="line">    <span class="keyword">return</span> pq[i].priority &gt; pq[j].priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(*pq)</span><br><span class="line">    item := x.(*Item)</span><br><span class="line">    item.index = n</span><br><span class="line">    *pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *pq</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    item := old[n<span class="number">-1</span>]</span><br><span class="line">    old[n<span class="number">-1</span>] = <span class="literal">nil</span>	<span class="comment">// avoid memory leak</span></span><br><span class="line">    item.index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">    *pq = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">update</span><span class="params">(item *Item, value, priority)</span></span> &#123;</span><br><span class="line">    item.value = value</span><br><span class="line">    item.priority = priority</span><br><span class="line">    heap.fix(pq, item.index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// This example creates a PriorityQueue with some items, adds and manipulates an item,</span></span><br><span class="line"><span class="comment">// and then removes the items in priority order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example_priorityQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Some items and their priorities.</span></span><br><span class="line">	items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">		<span class="string">&quot;banana&quot;</span>: <span class="number">3</span>, <span class="string">&quot;apple&quot;</span>: <span class="number">2</span>, <span class="string">&quot;pear&quot;</span>: <span class="number">4</span>,</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create a priority queue, put the items in it, and</span></span><br><span class="line">    <span class="comment">// establish the priority queue (heap) invariants.</span></span><br><span class="line">    pq := <span class="built_in">make</span>(PriorityQueue,<span class="built_in">len</span>(items))</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> value, priority := <span class="keyword">range</span> items &#123;</span><br><span class="line">        pq[i] = &amp;Items &#123;</span><br><span class="line">            value	:	value,</span><br><span class="line">            priority	:	priority,</span><br><span class="line">            index	:	i,</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    heap.Init(&amp;pq)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Insert a new item and then modify its priority.</span></span><br><span class="line">    item := &amp;Item&#123;</span><br><span class="line">        value:    <span class="string">&quot;orange&quot;</span>,</span><br><span class="line">        priority: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    heap.Push(&amp;pq, item)</span><br><span class="line">    pq.update(item, item.value, <span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Take the items out; they arrive in decreasing priority order.</span></span><br><span class="line">    <span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        item := heap.Pop(&amp;pq).(*Item)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%.2d:%s &quot;</span>, item.priority, item.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// 05:orange 04:pear 03:banana 02:apple</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="LeetCode经典题目"><a href="#LeetCode经典题目" class="headerlink" title="LeetCode经典题目"></a>LeetCode经典题目</h1><h2 id="实现一个优先队列"><a href="#实现一个优先队列" class="headerlink" title="实现一个优先队列"></a>实现一个优先队列</h2><p>&emsp;&emsp;优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。 优先队列往往用堆来实现。我们在上一节实现了一个int类型的堆，它的排序规则是直接根据存入的数据的值来决定的。对于优先队列而言，我们存入的数据可能是一个切片的索引数组，其排序规则是该切片的值的大小，只不过体现在堆中，存入的是其索引。这样我们就可以通过其索引控制出入优先队列是时机，并保证能够适时地得到堆顶的值。如下图所示：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph1.jpg" alt="avatar"></p>
<p>&emsp;&emsp;接下来我们来看一道很经典的题。</p>
<p><a class="link" href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值<i class="fas fa-external-link-alt"></i></a></p>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,-1], k &#x3D; 1</span><br><span class="line">输出：[1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [9,11], k &#x3D; 2</span><br><span class="line">输出：[11]</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,-2], k &#x3D; 2</span><br><span class="line">输出：[4]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= nums.length &lt;= 105</code></p>
</li>
<li><p><code>-104 &lt;= nums[i] &lt;= 104</code></p>
</li>
<li><p><code>1 &lt;= k &lt;= nums.length</code></p>
</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;由于每次都要找到最大值，很自然的想到一种数据结构：<strong>优先队列（堆）</strong>，其中的大根堆可以帮助我们实时维护一系列元素中的最大值。</p>
<p>&emsp;&emsp;对于本题而言，初始时，我们使用数组 <code>nums</code> 的前 <code>k</code> 个元素的索引初始化大根堆，堆中索引的排序规则是数组 <code>nums</code> 的大小所决定。每当我们向右移动窗口时，我们就可以把一个新的元素的索引放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。我们在什么情况下出堆呢？每次有新元素入堆时，我们都要先判断一下位于堆顶的索引是否<code>&lt;=新入堆元素索引-k</code>。如果条件成立，则执行出堆操作，直到堆顶元素的索引在滑动窗口的范围内。</p>
<p>&emsp;&emsp;本题可以学习到的很重要的一个技巧就是出堆的操作可以不用着急，可以根据题目的实际需求，判断堆顶元素的索引是否符合当前选择范围再统一执行出堆操作，直到堆顶元素代表的索引在要求的范围内。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a[h[i]] &gt; a[h[j]]	<span class="comment">// 排序规则不是索引大小，而是数组元素的值的大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    v := old[<span class="built_in">len</span>(old)<span class="number">-1</span>]</span><br><span class="line">    h = old[:<span class="built_in">len</span>(old)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    a = nums</span><br><span class="line">    <span class="keyword">var</span> h IntHeap</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;k; i++ &#123;</span><br><span class="line">        h = <span class="built_in">append</span>(h,i)</span><br><span class="line">    &#125;</span><br><span class="line">    heap.Init(&amp;h)	<span class="comment">// 初始化堆</span></span><br><span class="line">    </span><br><span class="line">    ret := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">1</span>)</span><br><span class="line">    ret[<span class="number">0</span>] = a[h[<span class="number">0</span>]]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=k; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        heap.Push(&amp;h, i.(<span class="keyword">int</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> h[<span class="number">0</span>] &lt;= i-k &#123;	<span class="comment">// 判断堆顶索引对应的元素是否在滑动窗口中，不在则持续出堆</span></span><br><span class="line">            heap.Pop(&amp;h)</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, a[h[<span class="number">0</span>]])	<span class="comment">// 堆顶元素在滑动窗口中，加入输出数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Go语言标准库</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算技巧</title>
    <url>/2021/10/29/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="几个有趣的位操作"><a href="#几个有趣的位操作" class="headerlink" title="几个有趣的位操作"></a>几个有趣的位操作</h1><h2 id="利用或操作｜和空格将英文字符转换成小写"><a href="#利用或操作｜和空格将英文字符转换成小写" class="headerlink" title="利用或操作｜和空格将英文字符转换成小写"></a>利用或操作<code>｜</code>和空格将英文字符转换成小写</h2> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="string">&#x27;a&#x27;</span></span><br><span class="line">A := <span class="string">&#x27;A&#x27;</span></span><br><span class="line"> </span><br><span class="line">t1 := <span class="keyword">string</span>(a | <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">t2 := <span class="keyword">string</span>(A | <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"> </span><br><span class="line">fmt.Println(t1)  <span class="comment">// a</span></span><br><span class="line">fmt.Println(t2)  <span class="comment">// a</span></span><br></pre></td></tr></table></figure>



<h2 id="利用与操作-amp-和下划线将英文字符转换成大写"><a href="#利用与操作-amp-和下划线将英文字符转换成大写" class="headerlink" title="利用与操作&amp;和下划线将英文字符转换成大写"></a>利用与操作<code>&amp;</code>和下划线将英文字符转换成大写</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := <span class="string">&#x27;b&#x27;</span></span><br><span class="line">B := <span class="string">&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line">t3 := <span class="keyword">string</span>(b &amp; <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">t4 := <span class="keyword">string</span>(B &amp; <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(t3)		<span class="comment">// B</span></span><br><span class="line">fmt.Println(t4)		<span class="comment">// B</span></span><br></pre></td></tr></table></figure>



<h2 id="利用异或操作-和空格进行英文大小写互换"><a href="#利用异或操作-和空格进行英文大小写互换" class="headerlink" title="利用异或操作^和空格进行英文大小写互换"></a>利用异或操作<code>^</code>和空格进行英文大小写互换</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := <span class="string">&#x27;c&#x27;</span></span><br><span class="line">C := <span class="string">&#x27;C&#x27;</span></span><br><span class="line"></span><br><span class="line">t5 := <span class="keyword">string</span>(c ^ <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">t6 := <span class="keyword">string</span>(C ^ <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(t5)		<span class="comment">// C</span></span><br><span class="line">fmt.Println(t6)		<span class="comment">// c</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis主从复制</title>
    <url>/2021/11/09/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;主从复制，是指将一台Redis服务器上的数据，复制到其他的Redis服务器上。前者称为主节点（Master），后者称为从节点（Slave）。数据的复制是单向的，只能从主节点到从节点。Master以写为主，Slave以读为主。</p>
<p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/1.png" alt="avatar"></p>
<p>主从复制，读写分离，80%的情况都是读操作，可以减缓服务器的压力。</p>
<p>&emsp;&emsp;默认情况下，每台Redis服务器都是主节点，且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。主从复制的作用主要包括：</p>
<ul>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式；</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余；</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量；</li>
<li>高可用(集群)基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>
</ul>
<p>&emsp;&emsp;一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：</p>
<ul>
<li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</li>
<li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256GB，也不能将所有的内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20GB</li>
</ul>
<p>&emsp;&emsp;对于电商网站上的商品，一般都是一次上传，无数次浏览的，也就是“多读少写”。</p>
<h2 id="环境配置-单机上模拟，多机同理"><a href="#环境配置-单机上模拟，多机同理" class="headerlink" title="环境配置(单机上模拟，多机同理)"></a>环境配置(单机上模拟，多机同理)</h2><p>只配置从库，不用配置主库。</p>
<p>查看当前库的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0   <span class="comment"># 没有从机</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:05fce2cd1d05bab4c0c503cb7ef7c5c4c1b445e0</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;将redis的配置文件复制若干次（要配置的从节点个数）：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph2.jpg" alt="avatar"></p>
<p>然后修改每个配置文件中的项目如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">port 6380  <span class="comment"># 端口号要改成从服务的节点</span></span><br><span class="line">pidfile /var/run/redis_6380.pid  <span class="comment"># pid file也要改成对应的名字</span></span><br><span class="line">logfile <span class="string">&quot;6380.log&quot;</span>	<span class="comment"># 日志文件名也要对应</span></span><br><span class="line">dbfilename dump6380.rdb  <span class="comment"># rdb文件命名也要修改</span></span><br></pre></td></tr></table></figure>



<p>然后分别启动主从服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server redis-config/redis79.conf</span><br><span class="line">redis-server redis-config/redis80.conf</span><br><span class="line">redis-server redis-config/redis81.conf</span><br></pre></td></tr></table></figure>

<p>查看进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br><span class="line">  501 76856     1   0 12:08上午 ??         0:00.15 redis-server 127.0.0.1:6379</span><br><span class="line">  501 76963     1   0 12:09上午 ??         0:00.09 redis-server 127.0.0.1:6380</span><br><span class="line">  501 77118     1   0 12:09上午 ??         0:00.02 redis-server 127.0.0.1:6381</span><br><span class="line">  501 77166 73157   0 12:09上午 ttys004    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox redis</span><br></pre></td></tr></table></figure>



<h3 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h3><p>&emsp;&emsp;默认情况下，redis服务都是主机，一般情况下只需要配置从机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## port 6379</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:35cf0a87f4009c0db73dc38088333e56c6ae4ebd</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 6380</span></span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:89cbbf9896b1e99c65b6ce88e7d67af16bbb49f6</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 6381</span></span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:e0f2e6d24e37f5ce033a886d647c641b10289329</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;若将6379端口上的服务设为主机，6380、6381端口上的服务为从机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># slaveof [host] [port]</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6380&gt; slaveof 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave	<span class="comment"># 角色转变为从机</span></span><br><span class="line">master_host:127.0.0.1	<span class="comment"># 主机地址</span></span><br><span class="line">master_port:6379	<span class="comment"># 主机端口</span></span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:2</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:84</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:494f98ba6749c752bb7ff2fb6e47f7c89c5712b8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:84</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:84</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt; slaveof 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:3</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:364</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:494f98ba6749c752bb7ff2fb6e47f7c89c5712b8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:364</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:351</span><br><span class="line">repl_backlog_histlen:14</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;再查看一下主机（6379）上的主从信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=392,lag=1	<span class="comment"># 从机信息</span></span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=392,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:494f98ba6749c752bb7ff2fb6e47f7c89c5712b8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:392</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:392</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;真实的主从配置应该在配置文件中配置，这样才是永久的，在redis客户端中通过命令来配置只是暂时的。</p>
<p>在配置文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">################################# REPLICATION #################################</span></span><br><span class="line"><span class="comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;  # 在此处配置主机的地址和端口</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在一主二从的配置方式中，主机可以写，从机不能写只能读。主机中的所有信息和数据，都会自动被从机保存。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 主机</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment">### 从机1</span></span><br><span class="line">127.0.0.1:6380&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 从机2</span></span><br><span class="line">127.0.0.1:6381&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k1&quot;</span></span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;若尝试在从机中写入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">(error) READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;默认情况下，主机断开连接，从机依旧是连接到主机的，但是没有写操作了。当主机重新连回来时，从机依旧可以重新开始接收主机写入的数据。</p>
<p>&emsp;&emsp;如果是使用命令行配置的主从，若主机断开连接，重新连回来仍然是其他从机的主机；若某一个从机断开连接，再连回来就不再是从机了，在其断开连接后主机写入的数据就无法同步了。但只要重新将其设置为原来主机的丛机，马上就会写入主机的全部数据。</p>
<blockquote>
<p>复制原理</p>
</blockquote>
<p>Slave启动成功连接到master后会发送一个sync同步命令。Master接收到命令，启动后台的存盘进程，同时收集所有接受到的用于修改数据集命令，在后台进程执行完毕之后，Master将传送整个数据文件到Slave，并完成一次完全同步。Slave服务在接收集到数据文件数据后，将其存盘并加载到内存中。Master继续将新的所有收集到的修改命令一次传给Slave，完成同步。但是只要重新连接Master，一次完全同步（全量复制）将被自动执行。</p>
<ul>
<li>全量复制：Slave在接收到数据文件数据后，将其存盘并加载到内存中</li>
<li>增量复制：继续将新的所有收集到的修改命令一次传给Slave</li>
</ul>
<h3 id="层层链路"><a href="#层层链路" class="headerlink" title="层层链路"></a>层层链路</h3><p>&emsp;&emsp;另一种主从节点的配置方式如下图所示，1号服务既作为0号服务的从节点，也作为2号服务的主节点，打印看它的主从信息。</p>
<p><img lazyload src="/images/loading.svg" data-src="3.png" alt="avater"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:3</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:99242</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:494f98ba6749c752bb7ff2fb6e47f7c89c5712b8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:99242</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:99242</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;它的身份（role）还是作为从节点，所以是无法写入信息的。此时再向0号节点（Master）写入，1号、2号均能读取0号节点的值。这种形式也能完成主从复制。</p>
<p>&emsp;&emsp;如果此时Master断开，这时候能不能剩下的从节点选出一个作为Master吗？此时需要手动将其中一个从节点设置为主节点，使用<code>slaveof no one</code>让某个Slave变成Master，再其他节点手动连接到这个节点上（变来就以该节点作为Master的从节点不需要设置）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; slaveof no one</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=100321,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:7f67d870c3fd771f6427ea40516d4e8bdd26ab20</span><br><span class="line">master_replid2:494f98ba6749c752bb7ff2fb6e47f7c89c5712b8</span><br><span class="line">master_repl_offset:100321</span><br><span class="line">second_repl_offset:100308</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:100321</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;若原来的Master连回来之后，是不能够再自动将其作为主节点的。它已经被谋朝篡位了！！！！</p>
<h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>&emsp;&emsp;这是一种自动选取Master的模式。主从切换技术的方法是：当主机服务宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务不可用。这是一种不推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵模式）架构来解决这个问题。</p>
<p>&emsp;&emsp;谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库切换为主库。哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，他会独立运行。<strong>其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控多个Redis实例。</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="4.png" alt="avatar"></p>
<p>&emsp;&emsp;哨兵有两个作用：</p>
<ol>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器；</li>
<li>当哨兵监测到Master宕机，会自动将Slave切换成Master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让他们切换主机。</li>
</ol>
<p>&emsp;&emsp;然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。哥哥哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/5.png" alt="avatar"></p>
<p>&emsp;&emsp;假设主服务器宕机，哨兵1监测到这个结果，系统不会马上进行failover过程，仅仅是哨兵1主观认为主服务器不可用，这个现象称为<strong>主观下线</strong>，当其他的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover（故障转移）操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的主服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>&emsp;&emsp;采用一主二从的方式。</p>
<ol>
<li>配置哨兵配置文件<code>sentinel.conf</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 1</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>

<p>后面这个数字1，代表主机挂了，Slave投票让谁接替称为主机，票数最多的，就会成为主机。</p>
<ol start="2">
<li>启动哨兵</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hongjiahao@Mac  /usr/<span class="built_in">local</span>/bin  redis-sentinel redis-config/sentinel/sentinel.conf</span><br><span class="line">6546:X 12 Nov 2021 00:57:31.378 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.378 <span class="comment"># Redis version=6.2.3, bits=64, commit=00000000, modified=0, pid=6546, just started</span></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.378 <span class="comment"># Configuration loaded</span></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.379 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 256).</span><br><span class="line">6546:X 12 Nov 2021 00:57:31.379 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._</span><br><span class="line">           _.-``__ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line">      _.-``    `.  `_.  <span class="string">&#x27;&#x27;</span>-._           Redis 6.2.3 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line"> (    <span class="string">&#x27;      ,       .-`  | `,    )     Running in sentinel mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="string">&#x27;|     Port: 26379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 6546</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |           https://redis.io</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line">      `-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span></span><br><span class="line">          `-._        _.-<span class="string">&#x27;</span></span><br><span class="line"><span class="string">              `-.__.-&#x27;</span></span><br><span class="line"></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.382 <span class="comment"># Sentinel ID is 4a00c3f869d1b542c0ae2f9c6c26ff69c0ebb5bc</span></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.382 <span class="comment"># +monitor master myredis 127.0.0.1 6379 quorum 1</span></span><br><span class="line">6546:X 12 Nov 2021 00:57:31.384 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379</span><br><span class="line">6546:X 12 Nov 2021 00:57:31.385 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>主机6379宕机，此时就会从从机中选择一个服务作为新的Master</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/6.jpg" alt="avater"></p>
<p>&emsp;&emsp;此时主机变成6380，若原主机6379重新连上，<strong>只能成为新Master的从机</strong>。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1、哨兵集群，基于主从复制，所有的主从配置优点全有；</p>
<p>2、主从节点可以切换，鼓掌可以转移，系统的可用性会更好；</p>
<p>3、哨兵模式就是主从模式的升级，手动到自动，更加健壮。</p>
<p>缺点：</p>
<p>1、Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦；</p>
<p>2、实现哨兵模式的配置其实很麻烦，里面有很多选择。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的ip port</span></span><br><span class="line"><span class="comment"># master-name 可以自己命名主节点名字。只能由字母A-Z、数字0-9、三个字符“.-_”组成</span></span><br><span class="line"><span class="comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联，呢么这是客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; </span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6380 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel实例的运行端口 默认26379。    如果有哨兵集群，还需要配置每个哨兵的端口</span></span><br><span class="line">port 26379</span><br><span class="line">user default on nopass ~* &amp;* +@all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码，这样所有连接Redis实例的客户端都需要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel连接主从的密码，注意必须主从设置一样的验证码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass myredis ********</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多少毫秒之后，主节点没有应答哨兵sentinel。此时哨兵主观认为主节点下线，默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds muredis 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定了在发生failover主从切换时每次最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长。</span></span><br><span class="line"><span class="comment"># 但如果这个数字越大，就意味着越多的slave因为replication而不可用</span></span><br><span class="line"><span class="comment"># 可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态</span></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs myredis 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel notification-script myredis /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关客户端master地址已经发生改变的信息</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本：</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script myredis /var/redis/reconfig.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir <span class="string">&quot;/usr/local/bin&quot;</span></span><br><span class="line"></span><br><span class="line">sentinel myid 4a00c3f869d1b542c0ae2f9c6c26ff69c0ebb5bc</span><br><span class="line">sentinel config-epoch myredis 1</span><br><span class="line">sentinel leader-epoch myredis 1</span><br><span class="line">sentinel current-epoch 1</span><br><span class="line">sentinel known-replica myredis 127.0.0.1 6379</span><br><span class="line">sentinel known-replica myredis 127.0.0.1 6381</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中的字符串操作</title>
    <url>/2021/11/10/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>注：本节内容参考自<a class="link" href="http://books.studygolang.com/The-Golang-Standard-Library-by-Example/">《Go语言标准库》<i class="fas fa-external-link-alt"></i></a>，结合自己实际的使用体验进行总结。</p>
<h1 id="字符串的常见操作"><a href="#字符串的常见操作" class="headerlink" title="字符串的常见操作"></a>字符串的常见操作</h1><ul>
<li>字符串长度</li>
<li>求子串</li>
<li>是否存在某个字符或子串</li>
<li>子串出现的次数（字符串匹配）</li>
<li>字符串切割为[]string</li>
<li>字符串是否存在某个前缀或后缀</li>
<li>字符或子串在字符串中首次出现的位置或最后一次出现的位置</li>
<li>通过某个字符串将[]string连接起来</li>
<li>字符串重复几次</li>
<li>字符串中子串替换</li>
<li>大小写转换</li>
<li>Trim操作</li>
<li>…</li>
</ul>
<p>&emsp;&emsp;string类型可以看做一种特殊的slice类型，因此获取长度可以使用内置的函数 <code>len()</code>，同时支持切片操作，因此子串很容易获得。这里说的字符，指得是 rune 类型，即一个 UTF-8 字符（Unicode 代码点）</p>
<h1 id="1-字符串比较"><a href="#1-字符串比较" class="headerlink" title="1.字符串比较"></a>1.字符串比较</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compare函数，用于比较两个字符串的大小，如果两个字符串相等，返回0；如果a小于b，返回-1；如果a大于b，返回1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compare</span><span class="params">(a,b <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EqualFold函数，计算s与t忽略字母大小写是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EqualFold</span><span class="params">(s,t <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<p> <strong>示例：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="string">&quot;gopher&quot;</span></span><br><span class="line">b := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">fmt.Println(strings.Compare(a, b))</span><br><span class="line">fmt.Println(strings.Compare(a, a))</span><br><span class="line">fmt.Println(strings.Compare(b, a))</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.EqualFold(<span class="string">&quot;GO&quot;</span>, <span class="string">&quot;go&quot;</span>))</span><br><span class="line">fmt.Println(strings.EqualFold(<span class="string">&quot;壹&quot;</span>, <span class="string">&quot;一&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h1 id="2-是否存在某个字符或子串"><a href="#2-是否存在某个字符或子串" class="headerlink" title="2.是否存在某个字符或子串"></a>2.是否存在某个字符或子串</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子串 substr 在 s 中，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// chars 中任何一个 Unicode 代码点在 s 中，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsAny</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="comment">// Unicode 代码点 r 在 s 中，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsRune</span><span class="params">(s <span class="keyword">string</span>, r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<p>这里对 ContainsAny 函数进行一下说明，看如下例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;team&quot;</span>, <span class="string">&quot;i&quot;</span>))</span><br><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;failure&quot;</span>, <span class="string">&quot;u &amp; i&quot;</span>))</span><br><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;in failure&quot;</span>, <span class="string">&quot;s g&quot;</span>))</span><br><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">fmt.Println(strings.ContainsAny(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;也就是说，第二个参数 chars 中任意一个字符（Unicode Code Point）如果在第一个参数 s 中存在，则返回 true。</p>
<p>&emsp;&emsp;查看这三个函数的源码，发现它们只是调用了相应的 Index 函数（子串出现的位置），然后和 0 作比较返回 true 或 fale。如，Contains：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Index(s, substr) &gt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-子串出现的次数"><a href="#3-子串出现的次数" class="headerlink" title="3.子串出现的次数"></a>3.子串出现的次数</h1><p>&emsp;&emsp;在数据结构与算法中，可能会讲解以下字符串匹配算法：</p>
<ul>
<li>朴素匹配算法</li>
<li>KMP 算法</li>
<li>Rabin-Karp 算法</li>
<li>Boyer-Moore 算法</li>
</ul>
<p>&emsp;&emsp;在 Go 中，查找子串出现次数即字符串模式匹配，实现的是 Rabin-Karp 算法。Count 函数的签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在 Count 的实现中，处理了几种特殊情况，属于字符匹配预处理的一部分。这里要特别说明一下的是当 sep 为空时，Count 的返回值是：utf8.RuneCountInString(s) + 1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(strings.Count(<span class="string">&quot;cheese&quot;</span>, <span class="string">&quot;e&quot;</span>))</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(<span class="string">&quot;谷歌中国&quot;</span>))</span><br><span class="line">fmt.Println(strings.Count(<span class="string">&quot;谷歌中国&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">12</span>  </span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>



<p>另外，Count 是计算子串在字符串中出现的无重叠的次数，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(strings.Count(<span class="string">&quot;fivevev&quot;</span>, <span class="string">&quot;vev&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>



<h1 id="4-字符串分割为-string"><a href="#4-字符串分割为-string" class="headerlink" title="4.字符串分割为[]string"></a>4.字符串分割为[]string</h1><h2 id="Fields-和-FieldsFunc"><a href="#Fields-和-FieldsFunc" class="headerlink" title="Fields 和 FieldsFunc"></a>Fields 和 FieldsFunc</h2><p>这两个函数的签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FieldsFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) []<span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Fields 用一个或多个连续的空格分隔字符串 s，返回子字符串的数组（slice）。如果字符串 s 只包含空格，则返回空列表 ([]string 的长度为 0）。其中，空格的定义是 unicode.IsSpace，常见间隔符包括：’\t’, ‘\n’, ‘\v’, ‘\f’, ‘\r’, ‘ ‘, U+0085 (NEL), U+00A0 (NBSP)。</p>
<p>由于是用空格分隔，因此结果中不会含有空格或空子字符串，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;Fields are: %q&quot;</span>, strings.Fields(<span class="string">&quot;  foo bar  baz   &quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Fields are: [<span class="string">&quot;foo&quot;</span> <span class="string">&quot;bar&quot;</span> <span class="string">&quot;baz&quot;</span>]</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;FieldsFunc 用这样的 Unicode 代码点 c 进行分隔：满足 f(c) 返回 true。该函数返回[]string。如果字符串 s 中所有的代码点 (unicode code points) 都满足 f(c) 或者 s 是空，则 FieldsFunc 返回空 slice。</p>
<p>也就是说，我们可以通过实现一个回调函数来指定分隔字符串 s 的字符。比如上面的例子，我们通过 FieldsFunc 来实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(strings.FieldsFunc(<span class="string">&quot;  foo bar  baz   &quot;</span>, unicode.IsSpace))</span><br></pre></td></tr></table></figure>

<p>实际上，Fields 函数就是调用 FieldsFunc 实现的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> FieldsFunc(s, unicode.IsSpace)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>题目示例：</strong></p>
<p><a class="link" href="https://leetcode-cn.com/problems/count-vowel-substrings-of-a-string/">2062. 统计字符串中的元音子字符串<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>子字符串</strong> 是字符串中的一个连续（非空）的字符序列。</p>
<p><strong>元音子字符串</strong> 是 <strong>仅</strong> 由元音（<code>&#39;a&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;i&#39;</code>、<code>&#39;o&#39;</code> 和 <code>&#39;u&#39;</code>）组成的一个子字符串，且必须包含 <strong>全部五种</strong> 元音。给你一个字符串 <code>word</code> ，统计并返回 <code>word</code> 中 <strong>元音子字符串的数目</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：word &#x3D; &quot;aeiouu&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：下面列出 word 中的元音子字符串（斜体加粗部分）：</span><br><span class="line">- &quot;aeiouu&quot;</span><br><span class="line">- &quot;aeiouu&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：word &#x3D; &quot;unicornarihan&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：word 中不含 5 种元音，所以也不会存在元音子字符串。</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countVowelSubstrings</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="params">(ans <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> strings.FieldsFunc(word, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> !strings.ContainsRune(<span class="string">&quot;aeiou&quot;</span>, r) &#125;) &#123; <span class="comment">// 分割出仅包含元音的字符串</span></span><br><span class="line"></span><br><span class="line">		cnt := [<span class="string">&#x27;v&#x27;</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">		l := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> _, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">			cnt[ch]++</span><br><span class="line">			<span class="keyword">for</span> cnt[s[l]] &gt; <span class="number">1</span> &#123; <span class="comment">// 双指针，仅当该元音个数不止一个时才移动左指针</span></span><br><span class="line">				cnt[s[l]]--</span><br><span class="line">				l++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> cnt[<span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[<span class="string">&#x27;e&#x27;</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[<span class="string">&#x27;i&#x27;</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[<span class="string">&#x27;o&#x27;</span>] &gt; <span class="number">0</span> &amp;&amp; cnt[<span class="string">&#x27;u&#x27;</span>] &gt; <span class="number">0</span> &#123; <span class="comment">// 必须包含全部五种元音</span></span><br><span class="line">				ans += l + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Split、SplitAfter、SplitN和SplitAfterN"><a href="#Split、SplitAfter、SplitN和SplitAfterN" class="headerlink" title="Split、SplitAfter、SplitN和SplitAfterN"></a>Split、SplitAfter、SplitN和SplitAfterN</h2><p>&emsp;&emsp;之所以将这四个函数放在一起讲，是因为它们都是通过一个同一个内部函数来实现的。它们的函数签名及其实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123; <span class="keyword">return</span> genSplit(s, sep, <span class="number">0</span>, <span class="number">-1</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitAfter</span><span class="params">(s, sep <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123; <span class="keyword">return</span> genSplit(s, sep, <span class="built_in">len</span>(sep), <span class="number">-1</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitN</span><span class="params">(s, sep <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123; <span class="keyword">return</span> genSplit(s, sep, <span class="number">0</span>, n) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitAfterN</span><span class="params">(s, sep <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123; <span class="keyword">return</span> genSplit(s, sep, <span class="built_in">len</span>(sep), n) &#125;</span><br></pre></td></tr></table></figure>

<p>它们都调用了 genSplit 函数。</p>
<p>这四个函数都是通过 sep 进行分割，返回[]string。如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 <code>Split(&quot;abc&quot;,&quot;&quot;)</code>，得到的是[a b c]。</p>
<p>Split(s, sep) 和 SplitN(s, sep, -1) 等价；SplitAfter(s, sep) 和 SplitAfterN(s, sep, -1) 等价。</p>
<p>那么，Split 和 SplitAfter 有啥区别呢？通过这两句代码的结果就知道它们的区别了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;foo,bar,baz&quot;</span>, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.SplitAfter(<span class="string">&quot;foo,bar,baz&quot;</span>, <span class="string">&quot;,&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;foo&quot;</span> <span class="string">&quot;bar&quot;</span> <span class="string">&quot;baz&quot;</span>]</span><br><span class="line">[<span class="string">&quot;foo,&quot;</span> <span class="string">&quot;bar,&quot;</span> <span class="string">&quot;baz&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>也就是说，Split 会将 s 中的 sep 去掉，而 SplitAfter 会保留 sep。</p>
<p>&emsp;&emsp;带 N 的方法可以通过最后一个参数 n 控制返回的结果中的 slice 中的元素个数，当 n &lt; 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n &gt; 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.SplitN(<span class="string">&quot;foo,bar,baz&quot;</span>, <span class="string">&quot;,&quot;</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;foo&quot;</span> <span class="string">&quot;bar,baz&quot;</span>]</span><br></pre></td></tr></table></figure>



<p>另外看一下官方文档提供的例子，注意一下输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;a man a plan a canal panama&quot;</span>, <span class="string">&quot;a &quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot; xyz &quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Bernardo O&#x27;Higgins&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;a&quot;</span> <span class="string">&quot;b&quot;</span> <span class="string">&quot;c&quot;</span>]</span><br><span class="line">[<span class="string">&quot;&quot;</span> <span class="string">&quot;man &quot;</span> <span class="string">&quot;plan &quot;</span> <span class="string">&quot;canal panama&quot;</span>]</span><br><span class="line">[<span class="string">&quot; &quot;</span> <span class="string">&quot;x&quot;</span> <span class="string">&quot;y&quot;</span> <span class="string">&quot;z&quot;</span> <span class="string">&quot; &quot;</span>]</span><br><span class="line">[<span class="string">&quot;&quot;</span>]</span><br></pre></td></tr></table></figure>



<h1 id="5-字符串中是否有某个前缀或后缀"><a href="#5-字符串中是否有某个前缀或后缀" class="headerlink" title="5.字符串中是否有某个前缀或后缀"></a>5.字符串中是否有某个前缀或后缀</h1><p>这两个函数比较简单，源码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s 中是否以 prefix 开始</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) &gt;= <span class="built_in">len</span>(prefix) &amp;&amp; s[<span class="number">0</span>:<span class="built_in">len</span>(prefix)] == prefix</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s 中是否以 suffix 结尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasSuffix</span><span class="params">(s, suffix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) &gt;= <span class="built_in">len</span>(suffix) &amp;&amp; s[<span class="built_in">len</span>(s)-<span class="built_in">len</span>(suffix):] == suffix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 prefix 或 suffix 为 “” , 返回值总是 true。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(strings.HasPrefix(<span class="string">&quot;Gopher&quot;</span>, <span class="string">&quot;Go&quot;</span>))</span><br><span class="line">fmt.Println(strings.HasPrefix(<span class="string">&quot;Gopher&quot;</span>, <span class="string">&quot;C&quot;</span>))</span><br><span class="line">fmt.Println(strings.HasPrefix(<span class="string">&quot;Gopher&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">fmt.Println(strings.HasSuffix(<span class="string">&quot;Amigo&quot;</span>, <span class="string">&quot;go&quot;</span>))</span><br><span class="line">fmt.Println(strings.HasSuffix(<span class="string">&quot;Amigo&quot;</span>, <span class="string">&quot;Ami&quot;</span>))</span><br><span class="line">fmt.Println(strings.HasSuffix(<span class="string">&quot;Amigo&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h1 id="6-字符或子串在字符串中出现的位置"><a href="#6-字符或子串在字符串中出现的位置" class="headerlink" title="6.字符或子串在字符串中出现的位置"></a>6.字符或子串在字符串中出现的位置</h1><p>有一序列函数与该功能有关：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 s 中查找 sep 的第一次出现，返回第一次出现的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 在 s 中查找字节 c 的第一次出现，返回第一次出现的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexByte</span><span class="params">(s <span class="keyword">string</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// chars 中任何一个 Unicode 代码点在 s 中首次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexAny</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// 查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br><span class="line"><span class="comment">// Unicode 代码点 r 在 s 中第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexRune</span><span class="params">(s <span class="keyword">string</span>, r <span class="keyword">rune</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有三个对应的查找最后一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndex</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexByte</span><span class="params">(s <span class="keyword">string</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexAny</span><span class="params">(s, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<p>在 2.1.1 小节提到过，Contain 相关的函数内部调用的是响应的 Index 函数。</p>
<p>这一序列函数，只举 IndexFunc 的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">han := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unicode.Is(unicode.Han, c) <span class="comment">// 汉字</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(strings.IndexFunc(<span class="string">&quot;Hello, world&quot;</span>, han))</span><br><span class="line">fmt.Println(strings.IndexFunc(<span class="string">&quot;Hello, 世界&quot;</span>, han))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-1</span><br><span class="line">7</span><br></pre></td></tr></table></figure>



<h1 id="7-字符串拼接（JOIN）操作"><a href="#7-字符串拼接（JOIN）操作" class="headerlink" title="7.字符串拼接（JOIN）操作"></a>7.字符串拼接（JOIN）操作</h1><p>&emsp;&emsp;将字符串数组（或slice）连接起来可以通过Join来实现，函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<p>看一下标准库的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  n := <span class="built_in">len</span>(sep) * (<span class="built_in">len</span>(a) - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">      n += <span class="built_in">len</span>(a[i])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">  bp := <span class="built_in">copy</span>(b, a[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">for</span> _, s := <span class="keyword">range</span> a[<span class="number">1</span>:] &#123;</span><br><span class="line">      bp += <span class="built_in">copy</span>(b[bp:], sep)</span><br><span class="line">      bp += <span class="built_in">copy</span>(b[bp:], s)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单使用示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(Join([]<span class="keyword">string</span>&#123;<span class="string">&quot;name=xxx&quot;</span>, <span class="string">&quot;age=xx&quot;</span>&#125;, <span class="string">&quot;&amp;&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name=xxx&amp;age=xx</span><br></pre></td></tr></table></figure>



<h1 id="8-字符串重复几次"><a href="#8-字符串重复几次" class="headerlink" title="8.字符串重复几次"></a>8.字符串重复几次</h1><p>函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(s <span class="keyword">string</span>, count <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<p>将 s 重复 count 次，如果 count 为负数或返回值长度 len(s)*count 超出 string 上限会导致 panic，这个函数使用很简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;ba&quot;</span> + strings.Repeat(<span class="string">&quot;na&quot;</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">banana</span><br></pre></td></tr></table></figure>



<h1 id="9-字符替换"><a href="#9-字符替换" class="headerlink" title="9.字符替换"></a>9.字符替换</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(mapping <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">rune</span>, <span class="title">s</span> <span class="title">string</span>) <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<p>Map 函数，将 s 的每一个字符按照 mapping 的规则做映射替换，如果 mapping 返回值 &lt;0 ，则舍弃该字符。该方法只能对每一个字符做处理，但处理方式很灵活，可以方便的过滤，筛选汉字等。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mapping := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> r &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; r &lt;= <span class="string">&#x27;Z&#x27;</span>: <span class="comment">// 大写字母转小写</span></span><br><span class="line">        <span class="keyword">return</span> r + <span class="number">32</span></span><br><span class="line">    <span class="keyword">case</span> r &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; r &lt;= <span class="string">&#x27;z&#x27;</span>: <span class="comment">// 小写字母不处理</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    <span class="keyword">case</span> unicode.Is(unicode.Han, r): <span class="comment">// 汉字换行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 过滤所有非字母、汉字的字符</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(strings.Map(mapping, <span class="string">&quot;Hello你#￥%……\n（&#x27;World\n,好Hello^(&amp;(*界gopher...&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">gopher</span><br></pre></td></tr></table></figure>



<h1 id="10-字符串子串替换"><a href="#10-字符串子串替换" class="headerlink" title="10.字符串子串替换"></a>10.字符串子串替换</h1><p>进行字符串替换时，考虑到性能问题，能不用正则尽量别用，应该用这里的函数。</p>
<p>字符串替换的函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 new 替换 s 中的 old，一共替换 n 个。</span></span><br><span class="line"><span class="comment">// 如果 n &lt; 0，则不限制替换次数，即全部替换</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> <span class="keyword">string</span>, n <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 该函数内部直接调用了函数 Replace(s, old, new , -1)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReplaceAll</span><span class="params">(s, old, <span class="built_in">new</span> <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(strings.Replace(<span class="string">&quot;oink oink oink&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;ky&quot;</span>, <span class="number">2</span>))</span><br><span class="line">fmt.Println(strings.Replace(<span class="string">&quot;oink oink oink&quot;</span>, <span class="string">&quot;oink&quot;</span>, <span class="string">&quot;moo&quot;</span>, <span class="number">-1</span>))</span><br><span class="line">fmt.Println(strings.ReplaceAll(<span class="string">&quot;oink oink oink&quot;</span>, <span class="string">&quot;oink&quot;</span>, <span class="string">&quot;moo&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">oinky oinky oink</span><br><span class="line">moo moo moo</span><br><span class="line">moo moo moo</span><br></pre></td></tr></table></figure>



<h1 id="11-大小写转换"><a href="#11-大小写转换" class="headerlink" title="11.大小写转换"></a>11.大小写转换</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLowerSpecial</span><span class="params">(c unicode.SpecialCase, s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpperSpecial</span><span class="params">(c unicode.SpecialCase, s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<p>大小写转换包含了 4 个相关函数，ToLower,ToUpper 用于大小写转换。ToLowerSpecial,ToUpperSpecial 可以转换特殊字符的大小写。 举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(strings.ToLower(<span class="string">&quot;HELLO WORLD&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToLower(<span class="string">&quot;Ā Á Ǎ À&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, <span class="string">&quot;壹&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, <span class="string">&quot;HELLO WORLD&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToLower(<span class="string">&quot;Önnek İş&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, <span class="string">&quot;Önnek İş&quot;</span>))</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.ToUpper(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToUpper(<span class="string">&quot;ā á ǎ à&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, <span class="string">&quot;一&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, <span class="string">&quot;hello world&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToUpper(<span class="string">&quot;örnek iş&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, <span class="string">&quot;örnek iş&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">ā á ǎ à</span><br><span class="line">壹</span><br><span class="line">hello world</span><br><span class="line">önnek iş</span><br><span class="line">önnek iş</span><br><span class="line">HELLO WORLD</span><br><span class="line">Ā Á Ǎ À       // 汉字拼音有效</span><br><span class="line">一           //  汉字无效</span><br><span class="line">HELLO WORLD</span><br><span class="line">ÖRNEK IŞ</span><br><span class="line">ÖRNEK İŞ    // 有细微差别</span><br></pre></td></tr></table></figure>



<h1 id="12-标题处理"><a href="#12-标题处理" class="headerlink" title="12.标题处理"></a>12.标题处理</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Title</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToTitle</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToTitleSpecial</span><span class="params">(c unicode.SpecialCase, s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<p>标题处理包含 3 个相关函数，其中 Title 会将 s 每个单词的首字母大写，不处理该单词的后续字符。ToTitle 将 s 的每个字母大写。ToTitleSpecial 将 s 的每个字母大写，并且会将一些特殊字母转换为其对应的特殊大写字母。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(strings.Title(<span class="string">&quot;hElLo wOrLd&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitle(<span class="string">&quot;hElLo wOrLd&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, <span class="string">&quot;hElLo wOrLd&quot;</span>))</span><br><span class="line">fmt.Println(strings.Title(<span class="string">&quot;āáǎà ōóǒò êēéěè&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitle(<span class="string">&quot;āáǎà ōóǒò êēéěè&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, <span class="string">&quot;āáǎà ōóǒò êēéěè&quot;</span>))</span><br><span class="line">fmt.Println(strings.Title(<span class="string">&quot;dünyanın ilk borsa yapısı Aizonai kabul edilir&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitle(<span class="string">&quot;dünyanın ilk borsa yapısı Aizonai kabul edilir&quot;</span>))</span><br><span class="line">fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, <span class="string">&quot;dünyanın ilk borsa yapısı Aizonai kabul edilir&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HElLo WOrLd</span><br><span class="line">HELLO WORLD</span><br><span class="line">HELLO WORLD</span><br><span class="line">Āáǎà Ōóǒò Êēéěè</span><br><span class="line">ĀÁǍÀ ŌÓǑÒ ÊĒÉĚÈ</span><br><span class="line">ĀÁǍÀ ŌÓǑÒ ÊĒÉĚÈ</span><br><span class="line">Dünyanın Ilk Borsa Yapısı Aizonai Kabul Edilir</span><br><span class="line">DÜNYANIN ILK BORSA YAPISI AIZONAI KABUL EDILIR</span><br><span class="line">DÜNYANIN İLK BORSA YAPISI AİZONAİ KABUL EDİLİR</span><br></pre></td></tr></table></figure>



<h1 id="13-修剪（Trim）"><a href="#13-修剪（Trim）" class="headerlink" title="13.修剪（Trim）"></a>13.修剪（Trim）</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 s 左侧和右侧中匹配 cutset 中的任一字符的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 左侧的匹配 cutset 中的任一字符的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeft</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 右侧的匹配 cutset 中的任一字符的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRight</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 如果 s 的前缀为 prefix 则返回去掉前缀后的 string , 否则 s 没有变化。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 如果 s 的后缀为 suffix 则返回去掉后缀后的 string , 否则 s 没有变化。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSuffix</span><span class="params">(s, suffix <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 左侧和右侧的间隔符去掉。常见间隔符包括：&#x27;\t&#x27;, &#x27;\n&#x27;, &#x27;\v&#x27;, &#x27;\f&#x27;, &#x27;\r&#x27;, &#x27; &#x27;, U+0085 (NEL)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 左侧和右侧的匹配 f 的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 左侧的匹配 f 的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeftFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">string</span></span></span><br><span class="line"><span class="comment">// 将 s 右侧的匹配 f 的字符去掉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRightFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<p>包含了 9 个相关函数用于修剪字符串。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="string">&quot;!!!@@@你好,!@#$ Gophers###$$$&quot;</span></span><br><span class="line">fmt.Println(strings.Trim(x, <span class="string">&quot;@#$!%^&amp;*()_+=-&quot;</span>))</span><br><span class="line">fmt.Println(strings.TrimLeft(x, <span class="string">&quot;@#$!%^&amp;*()_+=-&quot;</span>))</span><br><span class="line">fmt.Println(strings.TrimRight(x, <span class="string">&quot;@#$!%^&amp;*()_+=-&quot;</span>))</span><br><span class="line">fmt.Println(strings.TrimSpace(<span class="string">&quot; \t\n Hello, Gophers \n\t\r\n&quot;</span>))</span><br><span class="line">fmt.Println(strings.TrimPrefix(x, <span class="string">&quot;!&quot;</span>))</span><br><span class="line">fmt.Println(strings.TrimSuffix(x, <span class="string">&quot;$&quot;</span>))</span><br><span class="line"></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !unicode.Is(unicode.Han, r) <span class="comment">// 非汉字返回 true</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(strings.TrimFunc(x, f))</span><br><span class="line">fmt.Println(strings.TrimLeftFunc(x, f))</span><br><span class="line">fmt.Println(strings.TrimRightFunc(x, f))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">你好,!@<span class="comment">#$ Gophers</span></span><br><span class="line">你好,!@<span class="comment">#$ Gophers###$$$</span></span><br><span class="line">!!!@@@你好,!@<span class="comment">#$ Gophers</span></span><br><span class="line">Hello, Gophers</span><br><span class="line">!!@@@你好,!@<span class="comment">#$ Gophers###$$$</span></span><br><span class="line">!!!@@@你好,!@<span class="comment">#$ Gophers###$$</span></span><br><span class="line">你好</span><br><span class="line">你好,!@<span class="comment">#$ Gophers###$$$</span></span><br><span class="line">!!!@@@你好</span><br></pre></td></tr></table></figure>



<h1 id="14-Reader类型"><a href="#14-Reader类型" class="headerlink" title="14.Reader类型"></a>14.Reader类型</h1><p>&emsp;&emsp;看到名字就能猜到，这是实现了 <code>io</code> 包中的接口。它实现了 io.Reader（Read 方法），io.ReaderAt（ReadAt 方法），io.Seeker（Seek 方法），io.WriterTo（WriteTo 方法），io.ByteReader（ReadByte 方法），io.ByteScanner（ReadByte 和 UnreadByte 方法），io.RuneReader（ReadRune 方法） 和 io.RuneScanner（ReadRune 和 UnreadRune 方法）。</p>
<p>Reader 结构如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">  s        <span class="keyword">string</span>    <span class="comment">// Reader 读取的数据来源</span></span><br><span class="line">  i        <span class="keyword">int</span> <span class="comment">// current reading index（当前读的索引位置）</span></span><br><span class="line">  prevRune <span class="keyword">int</span> <span class="comment">// index of previous rune; or &lt; 0（前一个读取的 rune 索引位置）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见 Reader 结构没有导出任何字段，而是提供一个实例化方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">Reader</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;该方法接收一个字符串，返回的 Reader 实例就是从该参数字符串读数据。在后面学习了 bytes 包之后，可以知道 bytes.NewBufferString 有类似的功能，不过，如果只是为了读取，NewReader 会更高效。</p>
<p>&emsp;&emsp;其他方法不介绍了，都是之前接口的实现，有兴趣的可以看看源码实现，大部分都是根据 i、prevRune 两个属性来控制。</p>
<h1 id="15-Builder类型"><a href="#15-Builder类型" class="headerlink" title="15.Builder类型"></a>15.Builder类型</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Builder <span class="keyword">struct</span> &#123;</span><br><span class="line">    addr *Builder <span class="comment">// of receiver, to detect copies by value</span></span><br><span class="line">    buf  []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;该类型实现了 io 包下的 Writer, ByteWriter, StringWriter 等接口，可以向该对象内写入数据，Builder 没有实现 Reader 等接口，所以该类型不可读，但提供了 String 方法可以获取对象内的数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该方法向 b 写入一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteByte</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// WriteRune 方法向 b 写入一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="comment">// WriteRune 方法向 b 写入字节数组 p</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="comment">// WriteRune 方法向 b 写入字符串 s</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="comment">// Len 方法返回 b 的数据长度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// Cap 方法返回 b 的 cap。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">// Grow 方法将 b 的 cap 至少增加 n (可能会更多)。如果 n 为负数，会导致 panic。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Grow</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="comment">// Reset 方法将 b 清空 b 的所有内容。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">Reset</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// String 方法将 b 的数据以 string 类型返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<p>Builder 有 4 个与写入相关的方法，这 4 个方法的 error 都总是为 nil.</p>
<p>Builder 的 cap 会自动增长，一般不需要手动调用 Grow 方法。</p>
<p>String 方法可以方便的获取 Builder 的内容。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := strings.Builder&#123;&#125;</span><br><span class="line">_ = b.WriteByte(<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">n, _ := b.WriteRune(<span class="string">&#x27;夕&#x27;</span>)</span><br><span class="line">fmt.Println(n)</span><br><span class="line">n, _ = b.Write([]<span class="keyword">byte</span>(<span class="string">&quot;Hello, World&quot;</span>))</span><br><span class="line">fmt.Println(n)</span><br><span class="line">n, _ = b.WriteString(<span class="string">&quot;你好，世界&quot;</span>)</span><br><span class="line">fmt.Println(n)</span><br><span class="line">fmt.Println(b.Len())</span><br><span class="line">fmt.Println(b.Cap())</span><br><span class="line">b.Grow(<span class="number">100</span>)</span><br><span class="line">fmt.Println(b.Len())</span><br><span class="line">fmt.Println(b.Cap())</span><br><span class="line">fmt.Println(b.String())</span><br><span class="line">b.Reset()</span><br><span class="line">fmt.Println(b.String())</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">12</span><br><span class="line">15</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">31</span><br><span class="line">164</span><br><span class="line">7夕Hello, World你好，世界</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go语言标准库</category>
      </categories>
      <tags>
        <tag>strings</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL常见问题补充</title>
    <url>/2021/11/20/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1 id="数据表的类型"><a href="#数据表的类型" class="headerlink" title="数据表的类型"></a>数据表的类型</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">MYISM</th>
<th align="center">INNODB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">事务支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">数据行锁定</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">外键约束</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">表空间的大小</td>
<td align="center">较小</td>
<td align="center">较大，约为MYSIM2倍</td>
</tr>
</tbody></table>
<ul>
<li>MYSIM：节约空间，速度较快</li>
<li>INNODB：安全性高，支持事务处理，多表多用户操作</li>
</ul>
<h1 id="DROP、TRUNCATE和DELETE的区别"><a href="#DROP、TRUNCATE和DELETE的区别" class="headerlink" title="DROP、TRUNCATE和DELETE的区别"></a>DROP、TRUNCATE和DELETE的区别</h1><ul>
<li><p>TRUNCATE和DELETE的相同点：都能删除数据面都不会删除表结构</p>
</li>
<li><p>区别：</p>
<ul>
<li>DROP table 【表名】<ul>
<li><strong>删除内容和定义</strong>，并释放空间。执行drop语句，<strong>将使此表的结构</strong>一起删除。</li>
</ul>
</li>
<li>TRUNCATE <ul>
<li><strong>删除内容、释放空间但不删除定义</strong>(也就是保留表的数据结构)。与drop不同的是,只是<strong>清空表数据</strong>而已。</li>
<li>重新设置，自增列计数器会归零</li>
<li>不会影响事务</li>
</ul>
</li>
<li>DELETE from 【表名】(where 【列名】= 值)<ul>
<li><strong>只删除内容、释放空间但不删除定义</strong>；但是delete即<strong>可以对行数据进行删除</strong>，也可以对整表数据进行删除。</li>
<li>自增列计数器保持原来的值</li>
</ul>
</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>delete语句执行删除的过程是<strong>每次从表中删除一行</strong>，并且同时将该行的删除操作作为事务<strong>记录在日志</strong>中保存，以便进行进行回滚操作。</li>
<li><strong>执行速度</strong>一般来说：drop&gt;truncate&gt;delete</li>
<li>delete语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，<strong>事务提交之后才生效</strong>；如果有相应的 trigger，执行的时候将被触发。truncate、drop 是数据库定义语言(ddl)<strong>，操作立即生效</strong>，原数据不放到 rollback segment 中，不能回滚，操作不触发trigger。</li>
<li> truncate语句执行以后，<strong>id标识列还是按顺序排列</strong>，保持连续；而delete语句执行后，<strong>ID标识列不连续</strong></li>
</ul>
</li>
</ul>
<h1 id="为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？"><a href="#为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？" class="headerlink" title="为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？"></a>为什么要分解Mysql中复杂的关联查询，在应用层实现多次请求？</h1><p>分解关联查询的方式重构查询的优势有：</p>
<blockquote>
<ul>
<li><p><strong>让缓存的效率更高</strong>。我们知道执行一条sql的时候，会先去查询缓存中查找。那么许多应用程序可以方便地缓存单表查询对应的结果对象。如果关联查询，那么关联中的某个表发生了变化，那么就无法使用查询缓存，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。<br>将查询拆分后，执行单个查询可以减少锁的竞争。</p>
</li>
<li><p>在应用层做关联，可以更容易对数据库进行拆分，在现如今分库分表普遍使用的情景下，更容易做到高性能和可扩展。</p>
</li>
<li><p>查询本身效率也可能会有所提升。比如：让某些查询用IN()代替关联查询，可以让Mysql按照ID顺序进行查询，着可能比随机的关联要更高效。</p>
</li>
<li><p>可以减少冗余记录的查询。在应用层做关联，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能徐娅重复地访问一部分数据。从这方面看，这样的重构还可能会减少网络和内存的消耗。</p>
</li>
<li><p>分解关联查询，相当于在应用中实现了哈希关联，而不是使用Mysql的类似嵌套循环关联。某些场景哈希关联的效率更高效</p>
</li>
</ul>
</blockquote>
<p><img lazyload src="/images/loading.svg" data-src="overviewMySql.png" alt="avatar"></p>
<h1 id="MySQL索引原理"><a href="#MySQL索引原理" class="headerlink" title="MySQL索引原理"></a>MySQL索引原理</h1><h2 id="索引的目的"><a href="#索引的目的" class="headerlink" title="索引的目的"></a>索引的目的</h2><p>&emsp;&emsp;索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。</p>
<h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><p>&emsp;&emsp;除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。</p>
<p>&emsp;&emsp;数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？我们会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p>
<p>&emsp;&emsp;考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>&emsp;&emsp;前面讲了生活中索引的例子，索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph2.jpg" alt="avatar"></p>
<p>&emsp;&emsp;如上图，是一颗b+树，关于b+树的定义可以参见<a class="link" href="http://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B+树<i class="fas fa-external-link-alt"></i></a>，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<ul>
<li>b+树的查找过程</li>
</ul>
<p>&emsp;&emsp;如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>
<ul>
<li>b+树的性质</li>
</ul>
<ol>
<li><p>通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即<strong>索引字段要尽量的小</strong>，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</p>
</li>
<li><p>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的<strong>最左匹配特性</strong>。</p>
</li>
</ol>
<h2 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h2><h3 id="建索引的几大原则"><a href="#建索引的几大原则" class="headerlink" title="建索引的几大原则"></a>建索引的几大原则</h3><ol>
<li><strong>最左前缀匹配原则</strong>，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li><strong>=和in可以乱序</strong>，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</li>
<li><strong>尽量选择区分度高的列作为索引</strong>，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</li>
<li><strong>索引列不能参与计算</strong>，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</li>
<li><strong>尽量的扩展索引，不要新建索引</strong>。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
</ol>
<h3 id="慢查询优化的基本步骤"><a href="#慢查询优化的基本步骤" class="headerlink" title="慢查询优化的基本步骤"></a>慢查询优化的基本步骤</h3><ol start="0">
<li>先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li>
<li>where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看看那个字段的区分度最高</li>
<li>expalin查看执行计划，是否与预期一致（从锁定记录较少的表开始查）</li>
<li>order by limit 形式的sql语句让排序的表优先查</li>
<li>了解业务方使用场景</li>
<li>加索引时参照建立索引的几大原则</li>
<li>观察结果，不符合预期的继续从0分析</li>
</ol>
<h3 id="几个慢查询案例"><a href="#几个慢查询案例" class="headerlink" title="几个慢查询案例"></a>几个慢查询案例</h3><ul>
<li>案例一</li>
</ul>
<p>很多情况下，我们写SQL只是为了实现功能，这只是第一步，不同的语句书写方式对于效率往往有本质的差别，这要求我们对mysql的执行计划和索引原则有非常清楚的认识，请看下面的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   <span class="keyword">distinct</span> cert.emp_id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   (</span><br><span class="line">      <span class="keyword">select</span></span><br><span class="line">         emp.id <span class="keyword">as</span> emp_id,</span><br><span class="line">         emp_cert.id <span class="keyword">as</span> cert_id </span><br><span class="line">      <span class="keyword">from</span></span><br><span class="line">         employee emp </span><br><span class="line">      <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">         emp_certificate emp_cert </span><br><span class="line">            <span class="keyword">on</span> emp.id <span class="operator">=</span> emp_cert.emp_id </span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">         emp.is_deleted<span class="operator">=</span><span class="number">0</span></span><br><span class="line">   ) cert </span><br><span class="line">      <span class="keyword">on</span> (</span><br><span class="line">         cl.ref_table<span class="operator">=</span><span class="string">&#x27;Employee&#x27;</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid<span class="operator">=</span> cert.emp_id</span><br><span class="line">      ) </span><br><span class="line">      <span class="keyword">or</span> (</span><br><span class="line">         cl.ref_table<span class="operator">=</span><span class="string">&#x27;EmpCertificate&#x27;</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid<span class="operator">=</span> cert.cert_id</span><br><span class="line">      ) </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date <span class="operator">&gt;=</span><span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date<span class="operator">&lt;=</span><span class="string">&#x27;2013-11-08 16:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure>



<ol start="0">
<li>先运行一下，53条记录 1.87秒，又没有用聚合语句，比较慢</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">53</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">1.87</span> sec)</span><br></pre></td></tr></table></figure>

<ol>
<li>explain</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type  <span class="operator">|</span> possible_keys                   <span class="operator">|</span> key                   <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>               <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> Extra                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> cl         <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> cm_log_cls_id,idx_last_upd_date <span class="operator">|</span> idx_last_upd_date     <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>   <span class="number">379</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> temporary   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>                            <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span> <span class="number">63727</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> emp        <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>                            <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span> <span class="number">13317</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> emp_cert   <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> emp_certificate_empid           <span class="operator">|</span> emp_certificate_empid <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.emp.id <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> index                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;简述一下执行计划，首先mysql根据idx_last_upd_date索引扫描cm_log表获得379条记录；然后查表扫描了63727条记录，分为两部分，derived表示构造表，也就是不存在的表，可以简单理解成是一个语句形成的结果集，后面的数字表示语句的ID。derived2表示的是ID = 2的查询构造了虚拟表，并且返回了63727条记录。我们再来看看ID = 2的语句究竟做了写什么返回了这么大量的数据，首先全表扫描employee表13317条记录，然后根据索引emp_certificate_empid关联emp_certificate表，rows = 1表示，每个关联都只锁定了一条记录，效率比较高。获得后，再和cm_log的379条记录根据规则关联。从执行过程上可以看出返回了太多的数据，返回的数据绝大部分cm_log都用不到，因为cm_log只锁定了379条记录。</p>
<p>&emsp;&emsp;如何优化呢？可以看到我们在运行完后还是要和cm_log做join,那么我们能不能之前和cm_log做join呢？仔细分析语句不难发现，其基本思想是如果cm_log的ref_table是EmpCertificate就关联emp_certificate表，如果ref_table是Employee就关联employee表，我们完全可以拆成两部分，并用union连接起来，注意这里用union，而不用union all是因为原语句有“distinct”来得到唯一的记录，而union恰好具备了这种功能。如果原语句中没有distinct不需要去重，我们就可以直接使用union all了，因为使用union需要去重的动作，会影响SQL性能。</p>
<p>优化过的语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   emp.id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   employee emp </span><br><span class="line">      <span class="keyword">on</span> cl.ref_table <span class="operator">=</span> <span class="string">&#x27;Employee&#x27;</span> </span><br><span class="line">      <span class="keyword">and</span> cl.ref_oid <span class="operator">=</span> emp.id  </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date <span class="operator">&gt;=</span><span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date<span class="operator">&lt;=</span><span class="string">&#x27;2013-11-08 16:00:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> emp.is_deleted <span class="operator">=</span> <span class="number">0</span>  </span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">   emp.id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   emp_certificate ec </span><br><span class="line">      <span class="keyword">on</span> cl.ref_table <span class="operator">=</span> <span class="string">&#x27;EmpCertificate&#x27;</span> </span><br><span class="line">      <span class="keyword">and</span> cl.ref_oid <span class="operator">=</span> ec.id  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   employee emp </span><br><span class="line">      <span class="keyword">on</span> emp.id <span class="operator">=</span> ec.emp_id  </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date <span class="operator">&gt;=</span><span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date<span class="operator">&lt;=</span><span class="string">&#x27;2013-11-08 16:00:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> emp.is_deleted <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>不需要了解业务场景，只需要改造的语句和改造之前的语句保持结果一致</p>
</li>
<li><p>现有索引可以满足，不需要建索引</p>
</li>
<li><p>用改造后的语句实验一下，只需要10ms 降低了近200倍！</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type   <span class="operator">|</span> possible_keys                   <span class="operator">|</span> key               <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> cl         <span class="operator">|</span> <span class="keyword">range</span>  <span class="operator">|</span> cm_log_cls_id,idx_last_upd_date <span class="operator">|</span> idx_last_upd_date <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span>  <span class="number">379</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> emp        <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>                         <span class="operator">|</span> <span class="keyword">PRIMARY</span>           <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.cl.ref_oid <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> cl         <span class="operator">|</span> <span class="keyword">range</span>  <span class="operator">|</span> cm_log_cls_id,idx_last_upd_date <span class="operator">|</span> idx_last_upd_date <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span>  <span class="number">379</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> ec         <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>,emp_certificate_empid   <span class="operator">|</span> <span class="keyword">PRIMARY</span>           <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.cl.ref_oid <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> emp        <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>                         <span class="operator">|</span> <span class="keyword">PRIMARY</span>           <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> meituanorg.ec.emp_id  <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                            <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span></span><br><span class="line"><span class="number">53</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>



<ul>
<li>案例二</li>
</ul>
<p>举这个例子的目的在于颠覆我们对列的区分度的认知，一般上我们认为区分度越高的列，越容易锁定更少的记录，但在一些特殊的情况下，这种理论是有局限性的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   stage_poi sp </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   sp.accurate_result<span class="operator">=</span><span class="number">1</span> </span><br><span class="line">   <span class="keyword">and</span> (</span><br><span class="line">      sp.sync_status<span class="operator">=</span><span class="number">0</span> </span><br><span class="line">      <span class="keyword">or</span> sp.sync_status<span class="operator">=</span><span class="number">2</span> </span><br><span class="line">      <span class="keyword">or</span> sp.sync_status<span class="operator">=</span><span class="number">4</span></span><br><span class="line">   );</span><br></pre></td></tr></table></figure>

<ol start="0">
<li>先看看运行多长时间,951条数据6.22秒，真的很慢。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">951</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">6.22</span> sec)</span><br></pre></td></tr></table></figure>

<ol>
<li>先explain，rows达到了361万，type = ALL表明是全表扫描。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>    <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> sp    <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">3613155</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>所有字段都应用查询返回记录数，因为是单表查询 0已经做过了951条。</p>
</li>
<li><p>让explain的rows 尽量逼近951。</p>
</li>
</ol>
<p>看一下accurate_result = 1的记录数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),accurate_result <span class="keyword">from</span> stage_poi  <span class="keyword">group</span> <span class="keyword">by</span> accurate_result;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span> accurate_result <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">1023</span> <span class="operator">|</span>              <span class="number">-1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2114655</span> <span class="operator">|</span>               <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">972815</span> <span class="operator">|</span>               <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们看到accurate_result这个字段的区分度非常低，整个表只有-1,0,1三个值，加上索引也无法锁定特别少量的数据。</p>
<p>再看一下sync_status字段的情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),sync_status <span class="keyword">from</span> stage_poi  <span class="keyword">group</span> <span class="keyword">by</span> sync_status;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span> sync_status <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">3080</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3085413</span> <span class="operator">|</span>           <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>同样的区分度也很低，根据理论，也不适合建立索引。</p>
<p>&emsp;&emsp;问题分析到这，好像得出了这个表无法优化的结论，两个列的区分度都很低，即便加上索引也只能适应这种情况，很难做普遍性的优化，比如当sync_status 0、3分布的很平均，那么锁ß定记录也是百万级别的。</p>
<ol start="4">
<li><p>找业务方去沟通，看看使用场景。业务方是这么来使用这个SQL语句的，每隔五分钟会扫描符合条件的数据，处理完成后把sync_status这个字段变成1,五分钟符合条件的记录数并不会太多，1000个左右。了解了业务方的使用场景后，优化这个SQL就变得简单了，因为业务方保证了数据的不平衡，如果加上索引可以过滤掉绝大部分不需要的数据。</p>
</li>
<li><p>根据建立索引规则，使用如下语句建立索引</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stage_poi <span class="keyword">add</span> index idx_acc_status(accurate_result,sync_status);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>观察预期结果,发现只需要200ms，快了30多倍。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">952</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.20</span> sec)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们再来回顾一下分析问题的过程，单表查询相对来说比较好优化，大部分时候只需要把where条件里面的字段依照规则加上索引就好，如果只是这种“无脑”优化的话，显然一些区分度非常低的列，不应该加索引的列也会被加上索引，这样会对插入、更新性能造成严重的影响，同时也有可能影响其它的查询语句。所以我们第4步调差SQL的使用场景非常关键，我们只有知道这个业务场景，才能更好地辅助我们更好的分析和优化查询语句。</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务概览与设计</title>
    <url>/2021/11/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="微服务概念"><a href="#微服务概念" class="headerlink" title="微服务概念"></a>微服务概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现<strong>服务组件化</strong>，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活：</p>
<ul>
<li>原子服务：关注单一业务场景</li>
<li>独立进程：能够独立部署和交付</li>
<li>隔离部署：减小某一物理机crash对全局的影响</li>
<li>去中心化服务治理：服务之间的通讯rpc直连，减少集中的负载均衡</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>基础设施的建设、复杂度高</li>
<li>微服务应用是分布式系统，由此会带来固有的复杂性。开发者不得不使用RPC或者消息传递，来实现进程间的通信；此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题</li>
<li>分区的数据库架构，同时更新多个业务主体的事务很普遍。这种事务对于单体应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务锁使用的不同数据库，从而对开发者提出了更高的要求和挑战</li>
<li>测试一个基于微服务架构的应用是很复杂的任务</li>
<li>服务模块间的依赖，应用的升级有可能会涉及多个服务模块的修改</li>
<li>对运维的基础设施的挑战比较大</li>
</ul>
<h2 id="组件服务化"><a href="#组件服务化" class="headerlink" title="组件服务化"></a>组件服务化</h2><p>&emsp;&emsp;传统实现组件的方式是通过库(library)，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。我们用 Go 实施一个微服务：</p>
<ul>
<li>kit：一个微服务的基础库（框架）</li>
<li>service：业务代码＋ hit 依赖＋ 第三方依赖组成的业务微服务</li>
<li>RPC + message queue: 轻量级通讯</li>
</ul>
<p>&emsp;&emsp;<strong>本质上等同于，多个微服务组合(compose)完成了一个完整的用户场景(usecase)。</strong></p>
<h2 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h2><p>&emsp;&emsp;每个服务面临的业务场景不同，可以针对性的选择合适的技术解决方案。但也需要避免过度多样化，结合团队实际情况来选择取舍，要是每个服务都用不同的语言的技术栈来实现，想想维护成本真够高的。</p>
<ul>
<li>数据去中心化：每个服务独享自身的数据存储设施(缓存，数据库等)</li>
<li>治理去中心化：避免集中式做流量分发和负载均衡</li>
<li>技术去中心化：不绑定某一特定语言</li>
</ul>
<p>&emsp;&emsp;<strong>每个服务独享自身的数据存储设施(缓存，数据库等)，不像传统应用共享一个缓存和数据库，这样有利于服务的独立性，隔旁相关干扰。</strong></p>
<h2 id="基础设施自动化"><a href="#基础设施自动化" class="headerlink" title="基础设施自动化"></a>基础设施自动化</h2><p>&emsp;&emsp;无自动化不微服务，自动化包括测试和部署。单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、监控和部署的复杂度都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。</p>
<ul>
<li>CICD: Gitlab + Gitlab Hooks + kubernetes</li>
<li>Testing：测试环境、单元测试、API 自动化测试</li>
<li>在线运行时: kubernetes, 以及一系列Prometheus, ELK, Conrtol Panle</li>
</ul>
<h2 id="可用性-amp-兼容性设计"><a href="#可用性-amp-兼容性设计" class="headerlink" title="可用性 &amp; 兼容性设计"></a>可用性 &amp; 兼容性设计</h2><p>&emsp;&emsp;微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的新问题，如网络延迟、消息格式、负载均衡和容错，忽略其中任何一点都属于对“分布式计算的误解”。</p>
<ul>
<li>隔离</li>
<li>超时控制</li>
<li>负载保护</li>
<li>限流</li>
<li>降级</li>
<li>重试</li>
<li>负载均衡</li>
</ul>
<p>&emsp;&emsp;一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻蓮记保持服务契约（接口）的兼容性。发送时要保守，接收时要开放。按照伯斯塔次法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。</p>
<h1 id="微服务设计"><a href="#微服务设计" class="headerlink" title="微服务设计"></a>微服务设计</h1><h2 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h2><ol>
<li>按照垂直功能进行拆分，对外暴露了一批微服务，但是因为缺乏统一的出口面临不少问题：</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/1.png" alt="avatar"></p>
<ul>
<li>客户端到微服务直接通信，强耦合：不利于服务的更新迭代，要始终保留过往版本的接口</li>
<li>需要多次请求，客户端聚合数据，工作量巨大，延迟高</li>
<li>协议不利于统一，各个部门间有差异，需要端来兼容</li>
<li>面向“端”（不同终端）的API适配，耦合到了内部服务</li>
<li>多终端兼容逻辑复杂，每个服务都需要处理</li>
<li>统一逻辑无法收敛，比如安全认证、限流</li>
</ul>
<ol start="2">
<li>新增一个app-interface 用于统一的协议出口，在服务哪进行大量的 dataset join（各种微服务数据的聚合），按照业务的场景来设计粗粒度的 API，给后续业务演进带来很多优势：</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="2.png" alt="avatar"></p>
<ul>
<li>轻量交互：协议精简、聚合</li>
<li>差异服务：数据裁剪以及聚合、针对终端定制化API</li>
<li>动态升级：原有系统兼容升级，更新服务而非协议</li>
<li>沟通效率提升，协作模式演进为移动业务+网关小组</li>
</ul>
<p>BFF 可以认为是一种适配服务，将后端的微服务进行适配（主要包括聚合裁剪和格式适配等逻辑），向无线端设备暴露友好和统一的API，方便无线设备接入访问后端服务。</p>
<p>最致命的一个问题是整个 app-interface 属于单点故障，严重代码缺陷或流量洪峰可能引发集群宕机。</p>
<p><img lazyload src="/images/loading.svg" data-src="3.png" alt="avatar"></p>
<ul>
<li>但各模块也会导致后续业务集成复杂度高，根据康威法则，单块的无线BFF和多团队之间就出现不匹配问题，团队之间沟通协调成本高，交付效率低下</li>
<li>很多跨横切面逻辑，比如安全认证，日志监控，限流熔断。随着时间推移，代码变得越来越复杂，技术栈越来越多</li>
</ul>
<ol start="3">
<li>跨横切面(Cross-Cutting Concerns)的功能, 需要协调更新框架升级发版(路由、认证、限流、安<br>全），因此全部上沉，引入了 API Gateway，把业务集成度高的 BFF 层和通用功能服务层 API<br>Gateway 进行了分层处理。</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="4.png" alt="avatar"></p>
<p>在新的架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器。在网关的配合下，单块 BFF<br>实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提开。另外，把跨横切面逻<br>辑从 BFF 剥离到网关上去以后，BFF 的开发人员可以更加专法业务逻辑交付，实现了架构上的关注分离<br>(Separation of Concerns).</p>
<p>业务流量实所为：<br>移动端 -&gt; API Gateway -&gt; BFF -&gt; Mircoservice, 在 FE Web业务中，BFF 可以是nodejs 来做服务端渲染<br>(SSR, Server-Side Rendering), 注意这里忽略了上游的 CDN、4/7层负载均衡(ELB)。</p>
<h2 id="Mircoservice划分"><a href="#Mircoservice划分" class="headerlink" title="Mircoservice划分"></a>Mircoservice划分</h2><p>&emsp;&emsp;微服务架构时遇到的第一个问题就是如何划分服务的边界。在实际项目中通常会采用两种不同的方式划分服务便捷，即通过业务职能（Business Capbility）或是DDD的限界上下文（Bounded Context）。</p>
<ul>
<li>Business Capbility</li>
</ul>
<p>&emsp;&emsp;由公司内部不同的部门提供的职能。例如客户服务部门提供客户服务职能，财务部门提供财务相关的职能。</p>
<ul>
<li>Bounded Context</li>
</ul>
<p>&emsp;&emsp;限界上下文DDD中用来划分不同业务边界的元素，这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案域，为了解决某种类型的业务问题，贴近领域知识，也就是业务。</p>
<p>这本质上也促进了组织结构的演进：Service per team</p>
<p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/5.png" alt="avatar"></p>
<ul>
<li><p>CQRS</p>
<p>将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新。(其实就是读写分离)</p>
</li>
</ul>
<p>在稿件服务演进过程中，围绕着创作稿件、审核稿件、最终发布稿件有大量的逻辑揉在一块，其中稿件本身的状态也有非常多种，但是最终前台用户只关注稿件能否查看，依赖稿件数据库 binlog 以及订阅binlog 的中间 canal， 将稿件结果发布到消息队列katka 中，最终消费数据独立组建一个稿件查阅结果数据库，并对外提供一个独立查询服务，来板分复杂架构和业务。<br><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/6.jpg" alt="avatar"></p>
<p>将稿件审核并写入数据库(archive-result-database)的服务(稿件job)和外部用户查看稿件审核结果的服务(稿件结果)分离开来。</p>
<h2 id="Mircoservice安全"><a href="#Mircoservice安全" class="headerlink" title="Mircoservice安全"></a>Mircoservice安全</h2><p>&emsp;&emsp;对于外网的请求来说，我们通常在 API Gateway进行统一的认证拦截，一旦认证成功，我们会使用 Header 方式通过 RPC 元数据传递的方式带到 BFF 层，BFF 获取后把身份信息注入到应用的 Context 中，BFF 到其他下层的微服务，建议是直接在 RPC Request 中带入用户身份信息(UserID)请求服务。</p>
<ul>
<li><p>API Gateway -&gt; BFF -&gt; Service</p>
</li>
<li><p>Biz Auth -&gt; UID -&gt; Request Args</p>
</li>
</ul>
<p>对于服务内部，一般要区分身份认证和授权。</p>
<ul>
<li>Full Trust</li>
<li>Half Trust</li>
<li>Zero Trust </li>
</ul>
<h1 id="gRPC和服务发现"><a href="#gRPC和服务发现" class="headerlink" title="gRPC和服务发现"></a>gRPC和服务发现</h1><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/7.jpg" alt="avatar"></p>
<ul>
<li><p>多语言：语言中立，支持多种语言。</p>
</li>
<li><p>轻量级、高性能序列化支持 PB（Protocol Buffer）和 JSON，PB 是一种语言无关的高性能系列化框架</p>
</li>
<li><p>可插拔。</p>
</li>
<li><p>IDL：基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端口以及客户端 Stub。</p>
</li>
<li><p>移动端：基于标准的 HTTP/2 设计，支持双向流、消息头压缩、单TCP的多路复用、服务端推送等特性。这些特性是的 gRPC 在移动端设备上更加省电和节省网络流量。</p>
</li>
<li><p>服务而非对象、消息而非引用：促进微服务的系统间粗粒度消息交互设计理念。</p>
</li>
<li><p>负载无关的：不同的服务需要使用不同的消息类型和编码, 例如 protocol buffers, JSON, XML 和 Thrift。</p>
</li>
<li><p>流: Streaming APl。</p>
</li>
<li><p>阻塞式和非阻塞式：支持异步和同步处理在客户端和服务端间交互的消息序列。</p>
</li>
<li><p>元数据交换：常见的横切关注点，如认证或跟踪，依赖数据交换。</p>
</li>
<li><p>标准化状态码：客户端通常以有限的方式响应 API 调用返回的错误。</p>
</li>
</ul>
<h2 id="gRPC-HealthCheck"><a href="#gRPC-HealthCheck" class="headerlink" title="gRPC - HealthCheck"></a>gRPC - HealthCheck</h2><p>gRPC 有一个标准的健康检测协议，在 gRPC 的所有语言实现中基本都提供了生成代码和用于设置运行状态的功能。</p>
<p>主动健康检查 health check，，可以在服务提供者服务不稳定时，被消费者所感知，份时从负载均衡中摘除，减少错误请求。当服务提供者重新稳定后，health check 成功，重新加入到消费者的负载均衡，恢复请求。health check  同样也被用于外挂方式的容器健康检测，或者流量检测(K8sliveness &amp; readiness)。</p>
<p><img lazyload src="/images/loading.svg" data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/8.jpg" alt="avatar"></p>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><h3 id="客户端发现"><a href="#客户端发现" class="headerlink" title="客户端发现"></a>客户端发现</h3><p>&emsp;&emsp;一个服务实例被启动时，它的网络地址会被写到注册表上；当服务实例终止时，再从注册表中删除；这个服务实例的注册表通过心跳机制动态刷新；客户端使用一个负载均衡算法，去选择一个可用的服务实例，来响应这个请求。</p>
<h3 id="服务端发现"><a href="#服务端发现" class="headerlink" title="服务端发现"></a>服务端发现</h3><p>&emsp;&emsp;客户端通过负载均衡器向一个服务发送请求，这个负载均衡器会查询服务注册表，并将请求路由到可用的服务实例上。服务实例在服务注册表上被注册和注销(Consul Template+Nginx, kubernetesteted)。</p>
<p><img lazyload src="/images/loading.svg" data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/9.jpg" alt="avatar"></p>
<p>微服务的核心是去中心化，使用客户端发现模式。</p>
<p><img lazyload src="/images/loading.svg" data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/10.jpg" alt="avatar"></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Gin如何优雅的停止监听</title>
    <url>/2021/12/08/%E4%BD%BF%E7%94%A8Gin%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%81%9C%E6%AD%A2%E7%9B%91%E5%90%AC/</url>
    <content><![CDATA[<h1 id="暴力停止"><a href="#暴力停止" class="headerlink" title="暴力停止"></a>暴力停止</h1><p>&emsp;&emsp;我们在 go run main.go 后，若需要停止监听，需要使用 <code>ctrl+c</code> 终止监听。该方案会立即终止服务器监听，同时结束正在处理的请求，也就是说若存在未处理完毕的请求，是不能继续处理的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run() <span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="优雅停止"><a href="#优雅停止" class="headerlink" title="优雅停止"></a>优雅停止</h1><p>&emsp;&emsp;代替示例代码中 <code>router.Run()</code> 方法，我们可以使用 <code>http.Server</code> 内置的 <a class="link" href="https://golang.org/pkg/net/http/#Server.Shutdown">Shutdown()<i class="fas fa-external-link-alt"></i></a> 方法优雅地停止。所谓优雅，指的是可以将正在处理的请求处理完毕后再关闭服务器。示例代码如下 main.go ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 常规的初始化路由</span></span><br><span class="line">    router := gin.Default()</span><br><span class="line">    router.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">        c.String(http.StatusOK, <span class="string">&quot;Welcome Gin Server&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 定义服务器</span></span><br><span class="line">    srv := &amp;http.Server&#123;</span><br><span class="line">        Addr:    <span class="string">&quot;:8080&quot;</span>,</span><br><span class="line">        Handler: router,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用 goroutine 启动监听</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// srv.ListenAndServe() 监听</span></span><br><span class="line">        <span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;</span><br><span class="line">            log.Fatalf(<span class="string">&quot;listen: %s\n&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待中断信号以优雅地关闭服务器（设置 5 秒的超时时间）</span></span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal)</span><br><span class="line">    signal.Notify(quit, os.Interrupt)</span><br><span class="line">    <span class="comment">// quit 信道是同步信道，若没有信号进来，处于阻塞状态</span></span><br><span class="line">    <span class="comment">// 反之，则执行后续代码</span></span><br><span class="line">    &lt;-quit</span><br><span class="line">    log.Println(<span class="string">&quot;Shutdown Server ...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    <span class="comment">// 调用 srv.Shutdown() 完成优雅停止</span></span><br><span class="line">    <span class="comment">// 调用时传递了一个上下文对象，对象中定义了超时时间</span></span><br><span class="line">    <span class="keyword">if</span> err := srv.Shutdown(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;Server Shutdown:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;Server exiting&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试以上代码，结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running <span class="keyword">in</span> <span class="string">&quot;debug&quot;</span> mode. Switch to <span class="string">&quot;release&quot;</span> mode <span class="keyword">in</span> production.</span><br><span class="line"> - using env:   <span class="built_in">export</span> GIN_MODE=release</span><br><span class="line"> - using code:  gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /                         --&gt; main.main.func1 (3 handlers)</span><br><span class="line">2019/11/05 22:49:04 Shutdown Server ...</span><br><span class="line">[GIN] 2019/11/05 - 22:49:07 | 200 |    5.0000438s |             ::1 | GET      /</span><br><span class="line">2019/11/05 22:49:08 Server exiting</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Go框架</category>
      </categories>
      <tags>
        <tag>web框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的错误处理</title>
    <url>/2021/12/05/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="Error-vs-Exception"><a href="#Error-vs-Exception" class="headerlink" title="Error vs Exception"></a>Error vs Exception</h1><p>先看下面一段代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a named type for our new error type</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement the error interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New creates interface values of type error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> errorString(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrNamedType = New(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> ErrStructType = errors.New(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ErrNamedType == New(<span class="string">&quot;EOF&quot;</span>) &#123;  <span class="comment">// true</span></span><br><span class="line">		fmt. Println(<span class="string">&quot;Named Type Error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ErrStructType == errors.New(<span class="string">&quot;EOF&quot;</span>) &#123; <span class="comment">// false</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;Struct Type Error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>ErrNamedType</code> 是我们自己定义的<code>Error</code> 方法，它是一个<code>string</code> 类型的变量(错误描述)，只要错误描述相同，那么两个<code>Error</code>是一样的。<code>ErrStructType</code>是通过<code>go</code>标准库定义的<code>Error</code> 类型，它是指向<code>string</code> 类型的错误描述的指针，即使错误描述一样，也会因为指向其地址的指针不同而不同。</p>
<h2 id="各语言的演进历史"><a href="#各语言的演进历史" class="headerlink" title="各语言的演进历史"></a>各语言的演进历史</h2><ul>
<li>C</li>
</ul>
<p>&emsp;&emsp;单返回值，一般通过传递指针作为入参，返回值为 int 表示成功还是失败。</p>
<ul>
<li>C++</li>
</ul>
<p>&emsp;&emsp;引入了exception，但是无法知道被调用方会城出什么异常。</p>
<ul>
<li>Java</li>
</ul>
<p>&emsp;&emsp;引入了checked exception，方法的所有者必须申明，调用者必须处理。在启动时拋出大量的异常是司空见惯的事情，并在它们的调用堆栈中尽职地记录下来。Java 异常不再是异常，而是变得司空见惯了。它们从良性到灾难性都有使用，异常的严重性由两数的调用者来区分。</p>
<ul>
<li>Go</li>
</ul>
<p>&emsp;&emsp;Go 的处理异常逻辑是不引入 exception，支持多参数返回，所以很容易的在函数签名中带上实现了 error interface 的对象，交由调用者来判定。如果一个西数返回了(value,error)，你不<strong>能对这个 value 做任何假设，必须先判定 error</strong>。唯一可以忽路error 的是，如果你连 value 也不关心。Go 中有 panic 的机制，如果你认为和其他语言的 exception 一样，那你就错了。当我们拋出异常的时候，相当于你把 exception 扔给了调用者来处理。比如，你在C++ 中，把string 转为 int， 如果转换失败，拋出异常。或者在 java 中转换 string 为 date 失败时，拋出异常。Go panic 意味着 fatal error（就是挂了）。不能假设调用者来解决 panic，意味着代码不能继续运行。</p>
<p>&emsp;&emsp;使用多个返回值和一个简单的约定，Go解决了让程序员知道什么时候出了问题，并为真正的异常情况保留了 panic。可以更好的分别什么时候是良性异常，什么时候是真正的错误。通过 panic + recover 还可以为代码兜底，放弃掉这个<code>request</code> 进而保证别的<code>request</code> 的正常处理。</p>
<p>&emsp;&emsp;对于真正意外的情况，那些表示不可恢复的程序错误，例如索引l越界、不可恢复的环境问题、栈溢出，我们才使用 panic。对于其他的错误情况，我们应该是期望使用 error 来进行判定。下面是Go使用这种机制的理由：</p>
<ol>
<li>简单</li>
<li>考虑失败，而不是成功(plan for failure, not success)</li>
<li>没有隐藏的控制流</li>
<li>完全交给你来控制 Error</li>
<li>Error are values</li>
</ol>
<h1 id="Sentinel-Error"><a href="#Sentinel-Error" class="headerlink" title="Sentinel Error"></a>Sentinel Error</h1><p>&emsp;&emsp;预定义的特定错误，我们叫做 <code>sentinel error</code>，这个名字来源于计算机编程中使用一个特定的值来表示不可能进行进一步处理的做法。所以对于Go，我们使用特定的值来表示错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err == ErrSomething &#123;...&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Error)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="keyword">string</span>(e) &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;使用 <code>sentinel</code>值是最不灵活的错误处理策略，因为调用方法必须使用 == 将结果与预先声明的值进行比较。当你想要提供更多的上下文，这就出现了一个问题，因为返回一个不通的错误将破坏相等性检查。</p>
<p>&emsp;&emsp;甚至是一些有意义的 <code>fmt.Errof</code>携带一些上下文，也会破坏调用者的 ==，将调用者被迫查看error.Error()方法的输出，一查看它是否与特定的字符串匹配。</p>
<ul>
<li>不依赖 error.Error() 的输出</li>
</ul>
<p>&emsp;&emsp;不应该依赖检测 error.Error() 的输出，Error 方法存在于 error 接口主要用于方便程序员使用而不是程序（编写测试可能会依赖这个返回）。这个输出的字符串用于记录日志、输出到 stdout。</p>
<ul>
<li>Sentinel errors 成为你 API 公共部分</li>
</ul>
<p>&emsp;&emsp;如果你的公共函数或方法返回一个特定的错误，那么该值必须是公共的，当然要有文档记录，这会增加API的表面积。</p>
<p>&emsp;&emsp;如果 API 定义了一个返回特定错误的 interface，则该接口的所有实现豆浆杯限制为仅返回该错误，即使它们可以提供更具描述性的错误。</p>
<p>&emsp;&emsp;比如 io.Reader。像 io.Copy 这类函数需要 reader 的实现者返回 io.EOF 来告诉调用者没有更多的数据了，但这又不是错误。</p>
<ul>
<li>Sentinel errors 在两个包之间创建了依赖</li>
</ul>
<p>&emsp;&emsp;sentinel errors最糟糕的问题是它在两个包之间床架了源代码依赖关系。例如，检查错误是否等于 io.EOF，你的代码必须导入 io 包。这个特定的例子听起来并不是十分糟糕，因为它非常常见，但是想想一下，当项目中的许多包到处错误值时，存在耦合，项目中的其他包必须注入这些错误值才能检查特定的错误条件。</p>
<ul>
<li>结论：尽可能避免 Sentinel errors</li>
</ul>
<p>&emsp;&emsp;避免在编写代码时使用 Sentinel errors。在标准库中有一些使用它们的情况，但这不是好的模仿对象。 </p>
<h1 id="Error-Types"><a href="#Error-Types" class="headerlink" title="Error Types"></a>Error Types</h1><p>Error type 是实现了 error 接口的自定义类型。例如 MyError 类型记录了文件和行号以展示发生了什么。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Msg		<span class="keyword">string</span></span><br><span class="line">    File	<span class="keyword">string</span></span><br><span class="line">    Line	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s:%d: %s&quot;</span>, e.File, e.Line, e.Msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;<span class="string">&quot;Something happened&quot;</span>, <span class="string">&quot;server.go&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := test()</span><br><span class="line">    <span class="keyword">switch</span> err := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">        <span class="comment">// call succeeded, nothing to do</span></span><br><span class="line">        <span class="keyword">case</span> *MyError:</span><br><span class="line">        fmt.Println(<span class="string">&quot;error occurred on line&quot;</span>, err.Line)</span><br><span class="line">    	<span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// unknown error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;与错误值相比，错误类型的一大改进是它们能够包装底层错误以提供更多上下文。一个不错的例子就是 os.PathError 它提供了底层执行了什么操作、那个路径出了什么问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op	<span class="keyword">string</span></span><br><span class="line">    Path	<span class="keyword">string</span></span><br><span class="line">    Err	error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;调用者要使用类型断言和类型 switch，就要让自定义的 error 变为 public。这种模型会导致和调用者产生强耦合，从而导致 API 变得脆弱。</p>
<p>&emsp;&emsp;结论是尽量避免使用 error types，虽然错误类型比 sentinel errors 更好，因为它们可以捕获关于错误的更多上下文，但是 error types 共享 error values 许多相同的问题。因此，建议避免错误类型，或者至少避免它们成为公共 API 的一部分。</p>
<h1 id="Opaque-errors"><a href="#Opaque-errors" class="headerlink" title="Opaque errors"></a>Opaque errors</h1><p>&emsp;&emsp;这是一种最灵活的错误处理策略，因为它要求代码和调用者之间的耦合最少。我们将这种风格成为不透明的错误处理，因为虽然知道发生了错误，但没有能力看到错误的内部。作为调用者，关于操作的结果，你所知道的就是它起作用了，或者没有起作用（成功还是失败）。</p>
<p>&emsp;&emsp;这就是不透明错误处理的全部功能-只需返回错误而不假设其内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/quux/bar&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	x, err := bar. Foo</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> f</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// use x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Assert errors for behaviour, not type</li>
</ul>
<p>&emsp;&emsp;在少数情況下，这种二分错误处理方法是不够的。例如，与进程外的世界进行交互（如网络活动），需要调用方调查错误的性质，以确定重试该操作是否合理。在这种情況下，我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值。考虑这个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> temporary <span class="keyword">interface</span> &#123;</span><br><span class="line">    Temporary()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsTemporary returns true if err is temporary</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsTemporary</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    te, ok := err.(temporary)</span><br><span class="line">    <span class="keyword">return</span> ok &amp;&amp; te.Temporary()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的关键是，这个逻辑可以在不导入定义错误的包或者实际上不了解 err 的底层类型的情况下实现——只对它的行为感兴趣。</p>
<h1 id="Handling-Error"><a href="#Handling-Error" class="headerlink" title="Handling Error"></a>Handling Error</h1><p>&emsp;&emsp;无错误的正常流程代码，将成为一条直线，而不是缩紧的代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do stuff</span></span><br><span class="line"></span><br><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// handle error</span></span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;我们看一下net/http 标准包里对 WriteResponse 的写法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key, Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code	<span class="keyword">int</span></span><br><span class="line">	Reason	<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, st Status, headers []Header, body o.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	-, err := fmt.Fprintf(w,<span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, st.Code, st.Reason)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">        _, err := fmt.Fprintf(w, <span class="string">&quot;%s: %s\r\n&quot;</span>, h.Key, h.Value)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> _, err := fmt.Fprint(w <span class="string">&quot;\r\n&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _, err = io.Copy(w, body)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式写了大量的 <code>if err != nil</code>，如果采用下面这种方式，可以避免出现大量的重复代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> errWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	io.Writer</span><br><span class="line">	err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errWriter)</span> <span class="title">Write</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, e.err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">    n, e.err = e.Writer.Write(buf)</span><br><span class="line">    <span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(wio.Writer, st Status, headers []Header, body io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ew := &amp;errWriter&#123;Writer: w&#125;</span><br><span class="line">    fmt.Fprintf(ew, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, st.Code, st.Reason)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">        fmt.Fprintf(ew, <span class="string">&quot;%s: %s\r\n&quot;</span>, h.Key, h.Value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Fprint(ew, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">    io.Copy(ew, body)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ew.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们实际上在封装的 errWriter 中处理掉了</p>
<h1 id="Wrap-erros"><a href="#Wrap-erros" class="headerlink" title="Wrap erros"></a>Wrap erros</h1><p>&emsp;&emsp;没有生成错误的 file:line 信息。没有导致错误的调用堆栈的堆栈跟踪。这段代码的作者将被迫进行长时间的代码分割，以发现是哪个代码路径触发了文件未找到错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span> <span class="params">(r *Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := authenticate(r.User)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;authenticate failed: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是正如我们前面看到的，这种模式与 sentinel errors 或 type assertions 的使用不兼容，因为将错误值转换为字符串，将其与另一个字符串合并，然后将其转换回 fmt.Errorf 破坏了原始的错误，导致等值判定失败。</p>
<p>&emsp;&emsp;You should only handle errors once. Handling an error means inspecting the error value and making a single decision.</p>
<p>我们经常发现类似的代码，在错误处理中，带了两个任务：记录日志井且再次返回错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w i0.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    -, err : = w.Write(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;unable to write:&quot;</span>, err)	<span class="comment">// annotated error goes to log file</span></span><br><span class="line">        <span class="keyword">return</span> err								<span class="comment">// unannotated error returned to caller</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;在下面这个例子中，如果在 w.Write 过程中发生了一个错误，那么一行代码将被写入日志文件中，记录错误发生的文件和行，并且错误也会返回给调用者，调用者可能会记录并返回它，一直返回到程序的顶部。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	buf, err := json.Marshal(conf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log. Printf(<span class="string">&quot;could not marshal config: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;could not write config: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;Go 中的错误处理契约规定，在出现错误的情况下，不能对其他返回值的内容做出任何假设。由于 JSON 序列化失败，buf 的内容是未知的，可能它不包含任何内容，但更糟糕的是，他可能包含一个半写的 JSON 片段。</p>
<p>&emsp;&emsp;由于程序员在检查并记录错误后忘记 return，损坏的缓冲区将被传递给 WriteAll，这可能会成功，因此配置文件将被错误地写入。但是，该函数返回的结果是正确的。</p>
<p>&emsp;&emsp;日志记录与错误无关且对调试没有帮助的信息应被视为噪音，应予以质疑。记录的原因是因为某些东西失败了，而日志包含了答案。</p>
<ul>
<li>错误要被日志记录。</li>
<li>应用程序处理错误，保证100%完整性。</li>
<li>之后不再报告当前错误。</li>
</ul>
<h2 id="使用-github-com-pkg-errors-库"><a href="#使用-github-com-pkg-errors-库" class="headerlink" title="使用 github.com/pkg/errors 库"></a>使用 github.com/pkg/errors 库</h2><p><img lazyload src="/images/loading.svg" data-src="graphAlph1.jpg" alt="avatar"></p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph2.jpg" alt="avatar"></p>
<p>&emsp;&emsp;通过使用 pkg/errors 包，可以想错误值添加上下文，这种方式既可以由人也可以由机器检查。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := w.Write(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// annotated error goes to log file</span></span><br><span class="line">        log.Println(<span class="string">&quot;unable to write:&quot;</span>, err)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// unannotated error returned to caller</span></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种方式既打印了日志，还抛出了错误，违背了只处理一次的行为，使用下面的代码可以完美解决。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Write</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	_, err := w.Write(buf)</span><br><span class="line">    <span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;write failed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>在你的业务代码中，使用 errors.New 或者 errors.Errorf 返回错误，它们同errors.Wrap 一样，都会返回错误的堆栈信息。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseArgs</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.Errorf(<span class="string">&quot;not enough arguments, expected at least 3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>如果调用其他包内的函数，通常简单的直接返回</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>如果和其他库进行协作，考虑使用 errors.Wrap 或者 errors.Wrapf 保存堆栈信息。同样适用于和标准库协作的时候。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.Wrapf(err, <span class="string">&quot;failed to open %q&quot;</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>直接返回错误，而不是每个错误产生的地方到处打印日志</li>
<li>在程序的顶部或者是工作的 goroutine 顶部（请求入口），使用 %+v 把堆栈详情记录</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := app.Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;FATAL: %+v\n&quot;</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>使用 errors.Cause 获取root error， 在进行和 sentinel error 判定。还可以对其进行断言。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> err := errors.Cause(err).(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *MyError:</span><br><span class="line">        <span class="comment">// handle specifically</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// unknown error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>Packages that are reusable across many projects only return root error values.</li>
</ul>
<p>选择 wrap error 是只有 applications 可以选择应用的策略。具有最高可重用性的包只能返回根错误值。此机制与 Go 标准库中使用的相同。</p>
<ul>
<li>If the error is not going to be handled, wrap and return up the call stack.</li>
</ul>
<p>这是关于函数/方法调用返回的每个错误的基本问题。如果函数/方法不打算处理错误，那么用足够的上下文 wrap errors 并将其返回到调用堆栈中。例如，额外的上下文可以是使用的输入参数或失败的查询语句。确定您记录的上下文是足够多还是大多的一个好方法是检查日志并验证它们在开发期间是否为您工作。</p>
<ul>
<li>Once an error is handled, it is not allowed to be passed up the call stack any longer.</li>
</ul>
<p>一旦确定函数/方法将处理错误，错误就不再是错误。如果函数/方法仍然需要发出返回，则它不能返<br>错误值。它应该只返回零（比如降级处理中，你返回了降级数据，然后需要 return nil）。</p>
]]></content>
      <categories>
        <category>Error机制</category>
      </categories>
      <tags>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title>gin开发中踩过的坑</title>
    <url>/2021/12/13/gin%E5%BC%80%E5%8F%91%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h1 id="gin框架操作Cookie"><a href="#gin框架操作Cookie" class="headerlink" title="gin框架操作Cookie"></a>gin框架操作Cookie</h1><p>坑：c.SetCookie 中的的 domain 定义成什么就要用什么访问 cookie 才会生效，例如，定义的 127.0.0.1，浏览器访问时也必须输入 127.0.0.1 才行，localhost 都不行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line">    router.GET(<span class="string">&quot;/cookie&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        cookie, err := c.Cookie(<span class="string">&quot;gin_cookie&quot;</span>) <span class="comment">// 获取Cookie</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            cookie = <span class="string">&quot;NotSet&quot;</span></span><br><span class="line">            <span class="comment">// 给客户端设置Cookie,maxAge：3600秒后过期，</span></span><br><span class="line">            <span class="comment">// path：cookie/为Cookie所在目录，</span></span><br><span class="line">            <span class="comment">// domain stinrg：域名</span></span><br><span class="line">            <span class="comment">// secure：是否只能通过https访问</span></span><br><span class="line">            <span class="comment">// httpOnly bool：是否允许别人通过js获取自己的cookie</span></span><br><span class="line">            c.SetCookie(<span class="string">&quot;gin_cookie&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="number">3600</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Cookie value: %s \n&quot;</span>, cookie)</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存穿透与雪崩</title>
    <url>/2021/11/12/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[<h1 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;用户想要查询一个数据，发现Redis数据库中没有，也就是缓存没有命中，于是向持久层数据库（例如Mysql）查询，发现也没有，于是本次查询失败。当用户很多时，缓存都没有命中（秒杀），于是都去请求持久层数据库，这会给持久层数据库造成很大压力，这时候就相当于出现了缓存穿透。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>&emsp;&emsp;布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。</p>
<p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/1.png" alt="avater"></p>
<ul>
<li>特点</li>
</ul>
<p>&emsp;&emsp;特点是高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<ul>
<li>结构</li>
</ul>
<p>&emsp;&emsp;布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph2.jpg" alt="avatar"></p>
<p>&emsp;&emsp;如果我们要映射一个值到布隆过滤器中，我们需要使用<strong>多个不同的哈希函数</strong>生成<strong>多个哈希值，</strong>并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph3.jpg" alt="avatar"></p>
<p>&emsp;&emsp;我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph4.jpg" alt="avatar"></p>
<p>&emsp;&emsp;值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，<strong>说明没有任何一个值映射到这个 bit 位上</strong>，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” <strong>存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</strong></p>
<p>&emsp;&emsp;这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p>
<ul>
<li>如何选择哈希函数和布隆过滤器的长度</li>
</ul>
<p>&emsp;&emsp;很显然，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。</p>
<p>&emsp;&emsp;另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。</p>
<h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><p>&emsp;&emsp;当存储层布命中后，即使返回空对象也将其存储起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。</p>
<p> <img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/5.png" alt="avatar"></p>
<p>但是这种方法有两个问题：</p>
<ol>
<li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多空值的键；</li>
<li>即使对空值设置了过期时间，还是会存在缓存层和存储层数据有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li>
</ol>
<h1 id="缓存击穿（查询量太大，缓存过期）"><a href="#缓存击穿（查询量太大，缓存过期）" class="headerlink" title="缓存击穿（查询量太大，缓存过期）"></a>缓存击穿（查询量太大，缓存过期）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;这里需要注意和缓存穿透的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开一个洞。</p>
<p>&emsp;&emsp;当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同市访问数据库来查询最新数据，并且回写缓存，会导致数据库瞬间压力过大。</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="设置热点数据永不过期"><a href="#设置热点数据永不过期" class="headerlink" title="设置热点数据永不过期"></a>设置热点数据永不过期</h3><p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题。</p>
<h3 id="加互斥锁"><a href="#加互斥锁" class="headerlink" title="加互斥锁"></a>加互斥锁</h3><p>分布式锁：使用分布式锁，保证每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>
<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>&emsp;&emsp;缓存雪崩，指在某一时间段，缓存集中过期失效，Redis宕机。产生雪崩的原因：比如双十一零点会迎来一波抢购，这波商品比较集中的放入了缓存，假设缓存一小时。那么到凌晨一点，这批商品的缓存都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会到达存储层，造成存储层挂掉。</p>
<p><img lazyload src="/images/loading.svg" data-src="Go%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/6.png" alt="avatar"></p>
<p>&emsp;&emsp;其实集中过期到不是非常致命，比较致命的是缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对服务器造成的压力是不可预知的美很有可能瞬间就把数据库压垮。</p>
<p>双十一：停掉一些服务（保证主要的服务可用），例如退款功能。</p>
<h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h3><p>&emsp;&emsp;既然Redis可能挂掉，那就多增设几台redis，这样一台挂掉之后其他的还能继续工作，其实就是搭建集群。（异地多活）。</p>
<h3 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h3><p>&emsp;&emsp;在缓存失效后，通过加锁或者队列来控制读数据写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<h3 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h3><p>&emsp;&emsp;在正式部署前，把可能的数据预先访问一遍，这样大部分的数据就回家再到缓存中。在即将发生大并发访问前手动出发家在缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务可用性设计</title>
    <url>/2021/12/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h1><p>&emsp;&emsp;本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。</p>
<ul>
<li>服务隔离</li>
</ul>
<ol>
<li><p>动静隔离</p>
<p> 小到 CPU 的 cacheline <a class="link" href="https://www.cnblogs.com/cyfonly/p/5800758.html">false sharing<i class="fas fa-external-link-alt"></i></a>、数据库 mysql 表设计中避免 bufferpool 频繁过期，隔离动静表，大到架构设计中的图片、静态资源等缓存加速。本质上都体现的一样的思路，即加速/缓存访问变换频次小的。<br> 案例一： CDN 场景中，将静态资源和动态 API 分离，也是体现了隔离的思路:<br><img lazyload src="/images/loading.svg" data-src="CDN.png" alt="avatar"></p>
<p> *. 降低了应用服务器的负载，静态文件访问负载全部通过CDN；<br> *. 对象存储费用最低；<br> *. 海量存储空间，无需考虑存储架构的升级；<br> *. 静态CDN带宽加速，延迟低。</p>
<p>案例二：用户创作稿件库<br> archive: 稿件表，存储稿件的名称、作者、分类、tag、状态等信息，表示稿件的基本信息。在一个投稿流程中，一旦稿件创建改动的频率比较低。<br> archive_stat: 稿件统计表，表示稿件的播放、点赞、收藏、投币数量，比较高频的更新。随着稿件获取流量，稿件被用户所消费，各类计数信息更新比较频繁。<br><img lazyload src="/images/loading.svg" data-src="archive.png" alt="avatar"><br> MySQL BufferPool 是用于缓存 DataPage 的，DataPage 可以理解为缓存了表的行，那么如果频繁更新 DataPage 不断会置换，会导致命中率下降的问题，所以我们在表设计中，仍然可以沿用类似的思路，其主表基本更新，在上游 Cache 未命中，透穿到 MySQL，仍然有 BufferPool 的缓存。</p>
</li>
<li><p>读写分离：主从、Replicaset、CQRS</p>
</li>
</ol>
<ul>
<li>轻重隔离</li>
</ul>
<ol>
<li><p>核心隔离</p>
<p> 业务按照 Level 进行资源池划分（L0/L1/L2）<br><img lazyload src="/images/loading.svg" data-src="level.png" alt="avatar"><br> 核心/非核心的故障域的差异性隔离（机器资源、依赖资源）<br> 多集群，通过冗余资源来提升吞吐和容灾能力。</p>
</li>
<li><p>快慢隔离<br>&emsp;&emsp;我们可以把服务的吞吐想象为一个池，当突然洪流进来时，池子需要一定时间才能排放完，这时候其他支流在池子里待的时间取决于前面的排放能力，耗时就会增高，对小请求产生影响。</p>
</li>
</ol>
<p>日志传输体系的架构设计中，整个流都会投放到一个 kafka topic 中（早期设计目的: 更好的顺序 IO），流内会区分不同的 logid，logid 会有不同的 sink 端，它们之前会出现差速，比如 HDFS 抖动吞吐下降，ES 正常水位，全局数据就会整体反压。<br><img lazyload src="/images/loading.svg" data-src="kafka.png" alt="avatar"><br>按照各种纬度隔离：sink、部门、业务、logid、重要性（S/A/B/C）。<br>业务日志也属于某个 logid，日志等级就可以作为隔离通道。</p>
<ol start="3">
<li>热点隔离(也是解决缓存击穿的策略)</li>
</ol>
<p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行缓存。比如：<br>小表广播（单起一个goroutine，采用copy-on-write的方式更新localcache）: 从 remotecache 提升为 localcache，app 定时更新，甚至可以让运营平台支持广播刷新 localcache。<a class="link" href="https://pkg.go.dev/sync/atomic">atomic.Value<i class="fas fa-external-link-alt"></i></a><br><img lazyload src="/images/loading.svg" data-src="atomic.png" alt="avatar"><br>主动预热（旁路监控方式，类似地震前30秒的预警，提前一段时间将缓存中的热点数据变成localcache 存储）: 比如直播房间页高在线情况下 bypass 监控主动防御。<br><img lazyload src="/images/loading.svg" data-src="monitor.png" alt="avatar"></p>
<ul>
<li>物理隔离</li>
</ul>
<ol>
<li><p>线程隔离<br>&emsp;&emsp;主要通过线程池进行隔离，也是实现服务隔离的基础。把业务进行分类并交给不同的线程池进行处理，当某个线程池处理一种业务请求发生问题时，不会讲故障扩散和影响到其他线程池，保证服务可用。<br>对于 Go 来说，所有 IO 都是 Nonblocking，且托管给了 Runtime，只会阻塞 Goroutine，不阻塞 M，我们只需要考虑 Goroutine 总量的控制，不需要线程模型语言的线程隔离。<br><img lazyload src="/images/loading.svg" data-src="java.png" alt="avatar"></p>
</li>
<li><p>进程隔离<br>&emsp;&emsp;容器化（docker），容器编排引擎（k8s）。我们15年在 KVM 上部署服务；16年使用 Docker Swarm；17年迁移到 Kubernetes，到年底在线应用就全托管了，之后很快在线应用弹性公有云上线；20年离线 Yarn 和 在线 K8s 做了在离线混部（错峰使用），之后计划弹性公有云配合自建 IDC 做到离线的混合云架构。</p>
</li>
<li><p>集群隔离<br>&emsp;&emsp;过多集群方案，即逻辑上是一个应用，物理上部署多套应用，通过 cluster 区分。</p>
</li>
</ol>
<h2 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h2><ol>
<li>转码集群被超大视频攻击，导致转码大量延迟。</li>
</ol>
<p>&emsp;&emsp;针对大视频、较大视频、重要视频分别设置转码集群，当再遭遇转码攻击，只会影响部分的服务器，还能维持整体的可用。</p>
<ol start="2">
<li>缩略图服务，被大图实时缩略吃完所有 CPU，导致正常的小图缩略被丢弃，大量503。</li>
</ol>
<p>&emsp;&emsp;对于请求的图像，不会专门针对所有设备都预设好图片的尺寸，会根据用户的设备大小进行实时的缩略。如果请求了大量的 gif，那么对 gif的每一帧都要进行实时缩略，耗时比图像要久很多。把 gif 和正常图像分为两个集群来处理，将全剧故障化解为局部故障。</p>
<ol start="3">
<li><p> 数据库实例 cgroup 未隔离，导致大 SQL 引起的集体故障。</p>
</li>
<li><p> INFO 日志量过大，导致异常 ERROR 日志采集延迟。</p>
</li>
</ol>
<h1 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h1><p>&emsp;&emsp;超时控制，我们的组件能够快速失效（fail fast），因为我们不希望等到断开的实例直到超时。没有什么比挂起的请求和无响应的界面更令人失望。这不仅浪费资源，而且还会让用户体验变得更差。我们的服务是互相调用的，所以在这些延迟叠加前，应该特别注意防止那些超时的操作。<br><img lazyload src="/images/loading.svg" data-src="timeout.png" alt="avatar"></p>
<ul>
<li>网路传递具有不确定性。</li>
<li>客户端和服务端不一致的超时策略导致资源浪费。</li>
<li>默认值”策略。(不建议使用“永不超时”默认值)</li>
<li>高延迟服务导致 client 浪费资源等待，使用超时传递: 进程间传递 + 跨进程传递。</li>
</ul>
<p>&emsp;&emsp;超时控制是微服务可用性的第一道关，良好的超时策略，可以尽可能让服务不堆积请求，尽快清空高延迟的请求，释放 Goroutine。</p>
<h2 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h2><p>&emsp;&emsp;实际业务开发中，我们依赖的微服务的超时策略并不清楚，或者随着业务迭代耗时超生了变化，意外的导致依赖者出现了超时。<br>处理策略：</p>
<ul>
<li> 服务提供者定义好 latency SLO，更新到 gRPC Proto 定义中，服务后续迭代，都应保证 SLO。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> google.example.library.v1;</span><br><span class="line"></span><br><span class="line">service LibraryService &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Lagency SLO: 95th in 100ms, 99th in 150ms.</span></span><br><span class="line"></span><br><span class="line"> rpc CreateBook(CreateBookRequest) returns (Book);</span><br><span class="line"></span><br><span class="line"> rpc GetBook(GetBookRequest) returns Book);</span><br><span class="line"></span><br><span class="line"> rpc ListBooks(ListBooksRequest) returns (ListBooksResponse);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>避免出现意外的默认超时策略，或者意外的配置超时策略。</p>
<ul>
<li>kit 基础库兜底默认超时，比如 100ms，进行配置防御保护，避免出现类似 60s 之类的超大超时策略。</li>
<li>配置中心公共模版，对于未配置的服务使用公共配置。</li>
</ul>
<h3 id="超时传递"><a href="#超时传递" class="headerlink" title="超时传递"></a>超时传递</h3><p> &emsp;&emsp;超时传递: 当上游服务已经超时返回 504，但下游服务仍然在执行，会导致浪费资源做无用功。超时传递指的是把当前服务的剩余 Quota 传递到下游服务中，继承超时策略，控制请求级别的全局超时控制。<br> <img lazyload src="/images/loading.svg" data-src="timetransfer.png" alt="avatar"><br> 取配置的超时控制策略与剩余时间的最小值。</p>
<ul>
<li><p>进程内超时控制<br>&emsp;&emsp;一个请求在每个阶段(网络请求)开始前，就要检查是否还有足够的剩余来处理请求，以及继承他的超时策略，使用 Go 标准库的 <a class="link" href="https://pkg.go.dev/context">context.WithTimeout<i class="fas fa-external-link-alt"></i></a>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *asiiConn)</span> <span class="title">Get</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="params">(result \*Item, err error)</span></span> &#123;</span><br><span class="line">	c.conn.SetWriteDeadline(shrinkDeadline(ctx, c.writeTimeout))</span><br><span class="line">	<span class="keyword">if</span> _, err = fmt.Fprintf(c.rw, <span class="string">&quot;gets %s\r\n&quot;</span>, key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>多进程的超时控制<br><img lazyload src="/images/loading.svg" data-src="processcontrol.png" alt="avatar"></p>
</li>
</ul>
<ol>
<li>A gRPC 请求 B，1s超时。</li>
<li>B 使用了300ms 处理请求，再转发请求 C。</li>
<li>C 配置了600ms 超时，但是实际只用了500ms。</li>
<li>到其他的下游，发现余量不足，取消传递。</li>
</ol>
<p>在需要强制执行时，下游的服务可以覆盖上游的超时传递和配额。<br>在 gRPC 框架中，会依赖 gRPC Metadata Exchange，基于 HTTP2 的 Headers 传递 grpc-timeout 字段，自动传递到下游，构建带 timeout 的 context。</p>
<p><img lazyload src="/images/loading.svg" data-src="Bimodel.png" alt="avatar"></p>
<ul>
<li>双峰分布: 95%的请求耗时在100ms内，5%的请求可能永远不会完成（长超时）。</li>
<li>对于监控不要只看 mean，可以看看耗时分布统计，比如 95th，99th。</li>
<li>设置合理的超时，拒绝超长请求，或者当Server 不可用要主动失败。</li>
</ul>
<p><strong>超时决定着服务线程耗尽。</strong></p>
<h2 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h2><ul>
<li>SLB 入口 Nginx 没配置超时导致连锁故障。</li>
<li>服务依赖的 DB 连接池漏配超时，导致请求阻塞，最终服务集体 OOM。</li>
<li>下游服务发版耗时增加，而上游服务配置超时过短，导致上游请求失败。</li>
</ul>
<h1 id="过载保护和限流"><a href="#过载保护和限流" class="headerlink" title="过载保护和限流"></a>过载保护和限流</h1><h2 id="过载保护"><a href="#过载保护" class="headerlink" title="过载保护"></a>过载保护</h2><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>   一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：</p>
<ul>
<li>假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。</li>
<li>桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝。</li>
<li>当一个 n 个字节大小的数据包到达，将从桶中删除n 个令牌，接着数据包被发送到网络上。</li>
<li>如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="token-bucket.png" alt="avatar"><br>token-bucket rate limit algorithm: <a class="link" href="https://pkg.go.dev/golang.org/x/time/rate">/x/time/rate<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>作为计量工具（The Leaky Bucket Algorithm as a Meter）时，可以用于流量整形（Traffic Shaping）和流量控制（TrafficPolicing），漏桶算法的描述如下：</p>
<ul>
<li> 一个固定容量的漏桶，按照常量固定速率流出水滴。</li>
<li>如果桶是空的，则不需流出水滴。</li>
<li>可以以任意速率流入水滴到漏桶。</li>
<li>如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。<br><img lazyload src="/images/loading.svg" data-src="leaky-bucket.png" alt="avatar"><br>leaky-bucket rate limit algorithm: <a class="link" href="https://pkg.go.dev/go.uber.org/ratelimit">/go.uber.org/ratelimit<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h3 id="令牌桶和漏桶算法的弊端"><a href="#令牌桶和漏桶算法的弊端" class="headerlink" title="令牌桶和漏桶算法的弊端"></a>令牌桶和漏桶算法的弊端</h3><p>&emsp;&emsp;漏斗桶/令牌桶确实能够保护系统不被拖垮, 但不管漏斗桶还是令牌桶, 其防护思路都是设定一个指标, 当超过该指标后就阻止或减少流量的继续进入，当系统负载降低到某一水平后则恢复流量的进入。但其通常都是被动的，其实际效果取决于限流阈值设置是否合理，但往往设置合理不是一件容易的事情。</p>
<ul>
<li>集群增加机器或者减少机器限流阈值是否要重新设置?</li>
<li>设置限流阈值的依据是什么?</li>
<li>人力运维成本是否过高?</li>
<li>当调用方反馈429时, 这个时候重新设置限流, 其实流量高峰已经过了重新评估限流是否有意义?</li>
</ul>
<p>&emsp;&emsp;这些其实都是采用漏斗桶/令牌桶的缺点, 总体来说就是太被动, 不能快速适应流量变化。因此我们需要一种自适应的限流算法，即: 过载保护，根据系统当前的负载自动丢弃流量。</p>
<h3 id="根据系统负载做过载保护"><a href="#根据系统负载做过载保护" class="headerlink" title="根据系统负载做过载保护"></a>根据系统负载做过载保护</h3><p>&emsp;&emsp;计算系统临近过载时的峰值吞吐作为限流的阈值来进行流量控制，达到系统保护。</p>
<ul>
<li>服务器临近过载时，主动抛弃一定量的负载，目标是自保。</li>
<li>在系统稳定的前提下，保持系统的吞吐量。</li>
</ul>
<p>常见做法：利特尔法则<br><img lazyload src="/images/loading.svg" data-src="lierte.png" alt="avatar"></p>
<ul>
<li>CPU、内存作为信号量进行节流。</li>
<li>队列管理: 队列长度、LIFO。</li>
<li>可控延迟算法: <a class="link" href="https://blog.csdn.net/dog250/article/details/72849893">Co<i class="fas fa-external-link-alt"></i></a><a class="link" href="https://blog.csdn.net/dog250/article/details/72849893">D<i class="fas fa-external-link-alt"></i></a><a class="link" href="https://blog.csdn.net/dog250/article/details/72849893">el<i class="fas fa-external-link-alt"></i></a>。</li>
</ul>
<p>如何计算接近峰值时的系统吞吐？</p>
<ul>
<li><p>CPU: 使用一个独立的线程采样，每隔 250ms 触发一次。在计算均值时，使用了简单滑动平均去除峰值的影响。<br><img lazyload src="/images/loading.svg" data-src="cpu.png" alt="avatar"></p>
</li>
<li><p>Inflight: 当前服务中正在进行的请求的数量。</p>
</li>
<li><p>Pass&amp;RT: 最近5s，pass 为每100ms采样窗口内成功请求的数量，rt 为单个采样窗口中平均响应时间。<br><img lazyload src="/images/loading.svg" data-src="slide.png" alt="avatar"></p>
</li>
<li><p>使用 CPU 的滑动均值（CPU &gt; 800）作为启发阈值，一旦触发进入到过载保护阶段，算法为：(pass* rt) &lt; inflight</p>
</li>
<li><p>限流效果生效后，CPU 会在临界值（800）附近抖动，如果不使用冷却时间，那么一个短时间的 CPU 下降就可能导致大量请求被放行，严重时会打满 CPU。</p>
</li>
<li><p>在冷却时间后，重新判断阈值（CPU &gt; 800 ），是否持续进入过载保护。</p>
</li>
</ul>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>&amp;emsp&emsp;在一段时间内，定义某个客户或应用可以接收或处理多少个请求的技术。例如，通过限流，你可以过滤掉产生流量峰值的客户和微服务，或者可以确保你的应用程序在自动扩展（Auto Scaling）失效前都不会出现过载的情况。</p>
<ul>
<li>令牌桶、漏桶 针对单个节点，无法分布式限流。</li>
<li>QPS 限流<ul>
<li>不同的请求可能需要数量迥异的资源来处理。</li>
<li>某种静态 QPS 限流不是特别准。</li>
</ul>
</li>
<li>给每个用户设置限制<ul>
<li>全局过载发生时候，针对某些“异常”进行控制。</li>
<li>一定程度的“超卖”配额。</li>
</ul>
</li>
<li>按照优先级丢弃。</li>
<li>拒绝请求也需要成本。<br><img lazyload src="/images/loading.svg" data-src="rateLimitEnabled.png" alt="avatar"></li>
</ul>
<h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p>&emsp;&emsp; 分布式限流，是为了控制某个应用全局的流量，而非真对单个节点纬度。</p>
<ul>
<li>单个大流量的接口，使用 redis 容易产生热点。</li>
<li>pre-request 模式对性能有一定影响，高频的网络往返。  </li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="distributed.png" alt="avatar"></p>
<p>思考：<br>&emsp;&emsp;从获取单个 quota 升级成批量 quota。quota: 表示速率，获取后使用令牌桶算法来限制。</p>
<ul>
<li>每次心跳后，异步批量获取 quota，可以大大减少请求 redis 的频次，获取完以后本地消费，基于令牌桶拦截</li>
<li>每次申请的配额需要手动设定静态值略欠灵活，比如每次要20，还是50</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="redis.png" alt="avatar"></p>
<p>如何基于单个节点按需申请，并且避免出现不公平的现象？<br>初次使用默认值，一旦有过去历史窗口的数据，可以基于历史窗口数据进行 quota 请求。</p>
<p>思考：<br>我们经常面临给一组用户划分稀有资源的问题，他们都享有等价的权利来获取资源，但是其中一些用户实际上只需要比其他用户少的资源。那么我们如何来分配资源呢？一种在实际中广泛使用的分享技术称作“最大最小公平分享”（Max-Min Fairness）。<br><img lazyload src="/images/loading.svg" data-src="max-min.png" alt="avatar"></p>
<p>直观上，公平分享分配给每个用户想要的可以满足的最小需求，然后将没有使用的资源均匀的分配给需要‘大资源’的用户。</p>
<p>最大最小公平分配算法的形式化定义如下：<br>•资源按照需求递增的顺序进行分配。<br>•不存在用户得到的资源超过自己的需求。<br>•未得到满足的用户等价的分享资源。</p>
<p><img lazyload src="/images/loading.svg" data-src="compare.png" alt="avatar"></p>
<h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>&emsp;&emsp;每个接口配置阈值，运营工作繁重，最简单的我们配置服务级别 quota，更细粒度的，我们可以根据不同重要性设定 quota，我们引入了重要性（criticality）:</p>
<p>•最重要 CRITICAL_PLUS，为最终的要求预留的类型，拒绝这些请求会造成非常严重的用户可见的问题。<br>•重要 CRITICAL，生产任务发出的默认请求类型。拒绝这些请求也会造成用户可见的问题。但是可能没那么严重。<br>•可丢弃的 SHEDDABLE_PLUS 这些流量可以容忍某种程度的不可用性。这是批量任务发出的请求的默认值。这些请求通常可以过几分钟、几小时后重试。<br>•可丢弃的 SHEDDABLE 这些流量可能会经常遇到部分不可用情况，偶尔会完全不可用。</p>
<p>&emsp;&emsp;gRPC 系统之间，需要自动传递重要性信息。如果后端接受到请求 A，在处理过程中发出了请求 B 和 C 给其他后端，请求 B 和 C 会使用与 A 相同的重要性属性。</p>
<p>•全局配额不足时，优先拒绝低优先级的。<br>•全局配额，可以按照重要性分别设置。<br>•过载保护时，低优先级的请求先被拒绝。</p>
<h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>&emsp;&emsp;断路器（Circuit Breakers）: 为了限制操作的持续时间，我们可以使用超时，超时可以防止挂起操作并保证系统可以响应。因为我们处于高度动态的环境中，几乎不可能确定在每种情况下都能正常工作的准确的时间限制。断路器以现实世界的电子元件命名，因为它们的行为是都是相同的。断路器在分布式系统中非常有用，因为重复的故障可能会导致雪球效应，并使整个系统崩溃。</p>
<ul>
<li>服务依赖的资源出现大量错误。</li>
<li>某个用户超过资源配额时，后端任务会快速拒绝请求，返回“配额不足”的错误，但是拒绝回复仍然会消耗一定资源。有可能后端忙着不停发送拒绝请求，导致过载。<br><img lazyload src="/images/loading.svg" data-src="rongduan.png" alt="avatar"></li>
</ul>
<p>Google SRE<br>max(0, (requests - K*accepts) / (requests + 1))<br><img lazyload src="/images/loading.svg" data-src="google.png" alt="avatar"><br><img lazyload src="/images/loading.svg" data-src="google1.png" alt="avatar"></p>
<h3 id="Gutter"><a href="#Gutter" class="headerlink" title="Gutter"></a>Gutter</h3><p>&emsp;&emsp;基于熔断的 gutter kafka ，用于接管自动修复系统运行过程中的负载，这样只需要付出10%的资源就能解决部分系统可用性问题。我们经常使用 failover 的思路，但是完整的 failover 需要翻倍的机器资源，平常不接受流量时，资源浪费。高负载情况下接管流量又不一定完整能接住。所以这里核心利用熔断的思路，是把抛弃的流量转移到 gutter 集群，如果 gutter 也接受不住的流量，重新回抛到主集群，最大力度来接受。<br><img lazyload src="/images/loading.svg" data-src="gutter.png" alt="avatar"></p>
<h3 id="客户端流控"><a href="#客户端流控" class="headerlink" title="客户端流控"></a>客户端流控</h3><p>positive feedback: 用户总是积极重试，访问一个不可达的服务。<br>•客户端需要限制请求频次，retry backoff 做一定的请求退让。<br><img lazyload src="/images/loading.svg" data-src="backoff.png" alt="avatar"><br>•可以通过接口级别的 error_details，挂载到每个 API 返回的响应里。<br><img lazyload src="/images/loading.svg" data-src="error.png" alt="avatar"></p>
<h3 id="Case-1"><a href="#Case-1" class="headerlink" title="Case"></a>Case</h3><ol>
<li>二层缓存穿透、大量回源导致的核心服务（例如Mysql）故障。</li>
</ol>
<p>通过限流策略，控制到达Mysql的请求速率，让Mysql的缓存逐步建立，避免被海量的请求直接打死。</p>
<ol start="2">
<li>异常客户端引起的服务故障（query of death）</li>
</ol>
<ul>
<li>请求放大。</li>
<li>资源数放大</li>
</ul>
<p>针对相应的用户做专门的限制，比如最多只放行 k 个请求。</p>
<ol start="3">
<li>用户重试导致的大面积故障。</li>
</ol>
<p>在客户端限制用户的请求频次。</p>
<h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><p>&emsp;&emsp;通过降级回复来减少工作量，或者丢弃不重要的请求。而且需要了解哪些流量可以降级，并且有能力区分不同的请求。我们通常提供降低回复的质量来答复减少所需的计算量或者时间。我们自动降级通常需要考虑几个点：<br>•确定具体采用哪个指标作为流量评估和优雅降级的决定性指标（如，CPU、延迟、队列长度、线程数量、错误等）。<br>•当服务进入降级模式时，需要执行什么动作？<br>•流量抛弃或者优雅降级应该在服务的哪一层实现？是否需要在整个服务的每一层都实现，还是可以选择某个高层面的关键节点来实现？</p>
<p>同时我们要考虑一下几点：<br>•优雅降级不应该被经常触发 - 通常触发条件现实了容量规划的失误，或者是意外的负载。<br>•演练，代码平时不会触发和使用，需要定期针对一小部分的流量进行演练，保证模式的正常。<br>•应该足够简单。</p>
<h2 id="降级本质为-提供有损服务。"><a href="#降级本质为-提供有损服务。" class="headerlink" title="降级本质为: 提供有损服务。"></a>降级本质为: 提供有损服务。</h2><ol>
<li><p>UI 模块化，非核心模块降级。</p>
<ul>
<li>BFF 层聚合 API，模块降级。<br><img lazyload src="/images/loading.svg" data-src="bilibili.png" alt="avatar"></li>
</ul>
</li>
<li><p>页面上一次缓存副本。</p>
</li>
<li><p>默认值、热门推荐等。</p>
</li>
<li><p>流量拦截 + 定期数据缓存(过期副本策略)。</p>
</li>
</ol>
<p>处理策略<br>•页面降级、延迟服务、写/读降级、缓存降级<br>•抛异常、返回约定协议、Mock 数据、Fallback 处理<br><img lazyload src="/images/loading.svg" data-src="fallback.png" alt="avatar"></p>
<h2 id="Case-2"><a href="#Case-2" class="headerlink" title="Case"></a>Case</h2><ol>
<li>客户端解析协议失败，app 奔溃。</li>
</ol>
<p>要返回的默认降级数据（空数组、nil）一定要和客户端的开发人员进行沟通，否则会导致客户端解析失败而闪退。</p>
<ol start="2">
<li>客户端部分协议不兼容，导致页面失败。</li>
<li> local cache 数据源缓存，发版失效 + 依赖接口故障，引起的白屏。</li>
</ol>
<p>解决方案：在远程remote cache 中再保存一份。</p>
<h1 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h1><p>&emsp;&emsp;当请求返回错误（例: 配额不足、超时、内部错误等），对于 backend 部分节点过载的情况下，倾向于立刻重试，但是需要留意重试带来的流量放大:</p>
<p>•限制重试次数和基于重试分布的策略（重试比率: 10%）。<br>•随机化、指数型递增的重试周期: exponential ackoff + jitter。<br>•client 测记录重试次数直方图，传递到 server，进行分布判定，交由 server 判定拒绝。<br>•只应该在失败的这层进行重试，当重试仍然失败，全局约定错误码“过载，无须重试”，避免级联重试。</p>
<h2 id="Case-3"><a href="#Case-3" class="headerlink" title="Case"></a>Case</h2><ol>
<li>Nginx upstream retry 过大，导致服务雪崩。</li>
</ol>
<ol start="2">
<li><p>业务不幂等，导致的重试，数据重复。<br>•全局唯一 ID: 根据业务生成一个全局唯一 ID，在调用接口时会传入该 ID，接口提供方会从相应的存储系统比如 redis 中去检索这个全局 ID 是否存在，如果存在则说明该操作已经执行过了，将拒绝本次服务请求；否则将相应该服务请求并将全局 ID 存入存储系统中,之后包含相同业务 ID 参数的请求将被拒绝。<br>•去重表: 这种方法适用于在业务中有唯一标识的插入场景。比如在支付场景中，一个订单只会支付一次，可以建立一张去重表,将订单 ID 作为唯一索引。把支付并且写入支付单据到去重表放入一个事务中了，这样当出现重复支付时，数据库就会抛出唯一约束异常,操作就会回滚。这样保证了订单只会被支付一次。<br>•多版本并发控制: 适合对更新请求作幂等性控制,比如要更新商品的名字，这是就可以在更新的接口中增加一个版本号来做幂等性控制。</p>
</li>
<li><p>多层级重试传递，放大流量引起雪崩。</p>
</li>
</ol>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="数据中心内部的负载均衡"><a href="#数据中心内部的负载均衡" class="headerlink" title="数据中心内部的负载均衡"></a>数据中心内部的负载均衡</h2><p>&emsp;&emsp;在理想情况下，某个服务的负载会完全均匀地分发给所有的后端任务。在任何时刻，最忙和最不忙的节点永远消耗同样数量的CPU。<br>目标：<br>•均衡的流量分发。<br>•可靠的识别异常节点。<br>•scale-out，增加同质节点扩容。<br>•减少错误，提高可用性。<br><img lazyload src="/images/loading.svg" data-src="SLB.png" alt="avatar"></p>
<p>   在 backend 之间的 load 差异比较大：</p>
<ul>
<li>每个请求的处理成本不同。</li>
<li>物理机环境的差异:<ul>
<li>服务器很难强同质性。</li>
<li>存在共享资源争用（内存缓存、带宽、IO等）。</li>
</ul>
</li>
<li>性能因素:<ul>
<li>FullGC。</li>
<li>JVM JIT。<br><img lazyload src="/images/loading.svg" data-src="load.png" alt="avatar"></li>
</ul>
</li>
</ul>
<p>参考JSQ（最闲轮训）负载均衡算法带来的问题，缺乏的是服务端全局视图，因此我们目标需要综合考虑：负载+可用性。<br><img lazyload src="/images/loading.svg" data-src="LB.png" alt="avatar"></p>
<p><img lazyload src="/images/loading.svg" data-src="S.png" alt="avatar"></p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ul>
<li>变更管理:<ul>
<li>70％的问题是由变更引起的，恢复可用代码并不总是坏事。</li>
</ul>
</li>
<li>避免过载:<ul>
<li>过载保护、流量调度等。</li>
</ul>
</li>
<li>依赖管理:<ul>
<li>任何依赖都可能故障，做 chaos monkey testing，注入故障测试。</li>
</ul>
</li>
<li>优雅降级:<ul>
<li>有损服务，避免核心链路依赖故障。</li>
</ul>
</li>
<li>重试退避:<ul>
<li>退让算法，冻结时间，API retry detail 控制策略。</li>
</ul>
</li>
<li>超时控制:<ul>
<li>进程内 + 服务间 超时控制。</li>
</ul>
</li>
<li>极限压测 + 故障演练。</li>
<li>扩容 + 重启 + 消除有害流量。</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记（二）</title>
    <url>/2022/01/05/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="两大纬度，三大主线"><a href="#两大纬度，三大主线" class="headerlink" title="两大纬度，三大主线"></a>两大纬度，三大主线</h1><p><img lazyload src="/images/loading.svg" data-src="redis1.jpg" alt="avatar"></p>
<ul>
<li><p>两大维度</p>
</li>
<li><p><input disabled type="checkbox">  应用纬度</p>
</li>
<li><p><input disabled type="checkbox">  系统纬度</p>
</li>
<li><p>三大主线</p>
</li>
<li><p><input disabled type="checkbox">  ==高性能主线==，包括线程模型、数据结构、持久化、网络框架</p>
</li>
<li><p><input disabled type="checkbox">  ==高可靠主线==，包括主从复制、哨兵机制</p>
</li>
<li><p><input disabled type="checkbox">  ==高可扩展主线==，包括数据分片、负载均衡</p>
</li>
</ul>
<h2 id="Redis的组件和功能"><a href="#Redis的组件和功能" class="headerlink" title="Redis的组件和功能"></a>Redis的组件和功能</h2><p><img lazyload src="/images/loading.svg" data-src="redis2.jpg" alt="avatar"></p>
<ol>
<li>Redis 主要通过网络框架进行访问，而不再是动态库了，这也使得 Redis 可以作为一个基础性的网络服务进行访问，扩大了 Redis 的应用范围。</li>
<li>Redis 数据模型中的 value 类型很丰富，因此也带来了更多的操作接口，例如面向列表的 LPUSH/LPOP，面向集合的 SADD/SREM 等。</li>
<li>Redis 的持久化模块能支持两种方式：日志（AOF）和快照（RDB），这两种持久化方式具有不同的优劣势，影响到 Redis 的访问性能和可靠性。</li>
<li>Redis 支持高可靠集群和高可扩展集群</li>
</ol>
<h1 id="快速的Redis有哪些慢操作"><a href="#快速的Redis有哪些慢操作" class="headerlink" title="快速的Redis有哪些慢操作"></a>快速的Redis有哪些慢操作</h1><h2 id="Redis快在哪儿"><a href="#Redis快在哪儿" class="headerlink" title="Redis快在哪儿"></a>Redis快在哪儿</h2><ul>
<li>Redis是内存数据库， 所有操作都在内存上完成，内存的访问速度本身就很快。</li>
<li>归功于它的数据结构。键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 Redis 快速处理数据的基础。</li>
</ul>
<h2 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>&emsp;&emsp;底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。它们和数据类型的对应关系如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis3.jpg" alt="avatar"><br>&emsp;&emsp;可以看到，String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型，它们的特点是<strong>一个键对应了一个集合的数据</strong>。</p>
<h3 id="键和值用什么数据结构组织"><a href="#键和值用什么数据结构组织" class="headerlink" title="键和值用什么数据结构组织"></a>键和值用什么数据结构组织</h3><p>&emsp;&emsp;为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一 个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。<br>&emsp;&emsp;在下图中，可以看到，哈希桶中的 entry 元素中保存了 key 和 value 指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过 value 指针被查找到。</p>
<p><img lazyload src="/images/loading.svg" data-src="redis4.jpg" alt="avatar"></p>
<p>&emsp;&emsp;因为这个哈希表保存了所有的键值对，所以，我也把它称为==全局哈希表==。哈希表的最大好处很明显，就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。<br>&emsp;&emsp;查找过程主要依赖于哈希计算，和数据量的多少并没有直接关系。也就是说， 不管哈希表里有 10 万个键还是 100 万个键，我们只需要一次计算就能找到相应的键。但是，当你往 Redis 中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在的风险点，那就是哈希表的冲突问题和 rehash 可能带来的操作阻塞。</p>
<h3 id="为什么哈希表操作变慢了"><a href="#为什么哈希表操作变慢了" class="headerlink" title="为什么哈希表操作变慢了"></a>为什么哈希表操作变慢了</h3><p>&emsp;&emsp;当你往哈希表中写入更多数据时，哈希冲突是不可避免的问题。这里的哈希冲突，也就是指，两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。毕竟，哈希桶的个数通常要少于 key 的数量，这也就是说，难免会有一些 key的哈希值对 应到了同一个哈希桶中。Redis 解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。如下图所示：entry1、entry2 和 entry3 都需要保存在哈希桶 3 中，导致了哈希冲突。此时，entry1 元素会通过一个<em>next指针指向 entry2，同样，entry2 也会通过</em>next指针指向 entry3。这样一来，即使哈希桶 3 中的元素有 100 个，我们也可以通过 entry 元素中的指针，把它们连起来。这就形成了一个链表，也叫作哈希冲突链。<br><img lazyload src="/images/loading.svg" data-src="redis5.jpg" alt="avatar"></p>
<p>&emsp;&emsp;但是，这里依然存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。对于追求“快”的 Redis 来说，这是不太能接受的。所以，Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。那具体怎么做呢？<br>&emsp;&emsp;为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p>
<ol>
<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>
<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li>
<li>释放哈希表 1 的空间。</li>
</ol>
<p>&emsp;&emsp;这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了渐进式 rehash。简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis6.jpg" alt="avatar"><br>&emsp;&emsp;这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操 作，保证了数据的快速访问。</p>
<h3 id="集合类数据的操作效率"><a href="#集合类数据的操作效率" class="headerlink" title="集合类数据的操作效率"></a>集合类数据的操作效率</h3><p>&emsp;&emsp;和 String 类型不同，一个集合类型的值，==第一步是通过全局哈希表找到对应的哈希桶位置==，==第二步是在集合中再增删改查==。那么，集合的操作效率和哪些因素相关呢？首先，与集合的底层数据结构有关。例如，使用哈希表实现的集合，要比使用链表实现的 集合访问效率更高。其次，操作效率和这些操作本身的执行特点有关，比如读写一个元素 的操作要比读写所有元素的效率高。</p>
<h4 id="集合类数据的底层数据结构"><a href="#集合类数据的底层数据结构" class="headerlink" title="集合类数据的底层数据结构"></a>集合类数据的底层数据结构</h4><p>&emsp;&emsp;集合类型的底层数据结构主要有 5 种：整数数组、双向链表、哈希表、压缩列表和跳表。<br>&emsp;&emsp;压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。<br><img lazyload src="/images/loading.svg" data-src="redis7.jpg" alt="avatar"><br>&emsp;&emsp;在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。</p>
<p>我们再来看下跳表。</p>
<p>&emsp;&emsp;有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。具体来说，跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis8.jpg" alt="avatar"></p>
<p>&emsp;&emsp;如果我们要在链表中查找 33 这个元素，只能从头开始遍历链表，查找 6 次，直到找到 33 为止。此时，复杂度是 O(N)，查找效率很低。<br>&emsp;&emsp;为了提高查找速度，我们来增加一级索引：从第一个元素开始，每两个元素选一个出来作为索引。这些索引再通过指针指向原始的链表。例如，从前两个元素中抽取元素 1 作为一级索引，从第三、四个元素中抽取元素 11 作为一级索引。此时，我们只需要 4 次查找就 能定位到元素 33 了。<br>&emsp;&emsp;如果我们还想再快，可以再增加二级索引：从一级索引中，再抽取部分元素作为二级索引。例如，从一级索引中抽取 1、27、100 作为二级索引，二级索引指向一级索引。这样，我们只需要 3 次查找，就能定位到元素 33 了。<br>&emsp;&emsp;可以看到，这个查找过程就是在多级索引上跳来跳去，最后定位到元素。这也正好符合“跳”表的叫法。当数据量很大时，跳表的查找复杂度就是 O(logN)。<br><img lazyload src="/images/loading.svg" data-src="redis9.jpg" alt="avatar"></p>
<h2 id="不同操作的复杂度"><a href="#不同操作的复杂度" class="headerlink" title="不同操作的复杂度"></a>不同操作的复杂度</h2><ol>
<li>==单元素操作==，是指每一种集合类型对单个数据实现的增删改查操作。例如，Hash 类型的 HGET、HSET 和 HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)；Set 类型用哈希表作为底层数据结构时，它的 SADD、 SREM、SRANDMEMBER 复杂度也是 O(1)。集合类型支持同时对多个元素进行增删改查，例如 Hash 类型的 HMGET 和 HMSET，Set 类型的 SADD 也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了。</li>
<li>==范围操作==，<strong>是指集合类型中的遍历操作，可以返回集合中的所有数据</strong>，比如 Hash 类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List 类型的 LRANGE 和 ZSet 类型的 ZRANGE。<strong>这类操作的复杂度一般是 O(N)，比较耗时， 我们应该尽量避免</strong>。不过，Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了<strong>渐进式遍历</strong>，每次只返回有限数量的数据。这样一来，相比于 HGETALL、SMEMBERS 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞。</li>
<li>==统计操作==，是指<strong>集合类型对集合中所有元素个数的记录</strong>，例如 LLEN 和 SCARD。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。</li>
<li>==例外情况==，是指某些数据结构的特殊记录，例如<strong>压缩列表和双向链表都会记录表头和表尾的偏移量</strong>。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。</li>
</ol>
<h2 id="Redis选择不同数据结构的考量"><a href="#Redis选择不同数据结构的考量" class="headerlink" title="Redis选择不同数据结构的考量"></a>Redis选择不同数据结构的考量</h2><p>&emsp;&emsp;Redis 之所以能快速操作键值对，一方面是因为 O(1) 复杂度的哈希表被广泛使用，包括 String、Hash 和 Set，它们的操作复杂度基本由哈希表决定，另一方面，Sorted Set 也采用了 O(logN) 复杂度的跳表。不过，集合类型的范围操作，因为要遍历底层数据结构，复 杂度通常是 O(N)。这里，我的建议是：用其他命令来替代，例如可以用 SCAN 来代替， 避免在 Redis 内部产生费时的全集合遍历操作。<br>&emsp;&emsp;当然，我们不能忘了复杂度较高的 List 类型，它的两种底层实现结构：双向链表和压缩列表的操作复杂度都是 O(N)。但是它的 POP/PUSH 效率很高，那么就将它主要用于 FIFO 队列场景，而不是作为一个可以随机读写的集合。<strong>另外，List底层使用压缩列表本质上是将所有元素紧挨着存储，所以分配的是一块连续的内存空间，虽然数据结构本身没有时间复杂度的优势，但是这样节省空间而且也能避免一 些内存碎片，它比链表占用的内存要更少。 Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。</strong></p>
<h1 id="高性能-IO-模型"><a href="#高性能-IO-模型" class="headerlink" title="高性能 IO 模型"></a>高性能 IO 模型</h1><p>&emsp;&emsp;首先要厘清一个事实，说 Redis 是单线程模型，主要是指 <strong>Redis 的网络 IO 和键值对的读写是由一个线程来完成的</strong>，这也是 Redis 对外提供键值存储服务的主要流程。 但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p>
<h2 id="为什么使用单线程"><a href="#为什么使用单线程" class="headerlink" title="为什么使用单线程"></a>为什么使用单线程</h2><ol>
<li>==为什么不使用多线程==：并发访问控制一直是多线程开发中的一个难点问题，如果没有精细的设计，比如说，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。而且，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。为了避免这些问题，Redis 直接采用了单线程模式。</li>
<li>==单线程 Redis 为什么快==：一方面，Redis 的大部分操作在内存上完成，再加上它使用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。另一方面，就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</li>
</ol>
<h2 id="基本-IO-模型与阻塞点"><a href="#基本-IO-模型与阻塞点" class="headerlink" title="基本 IO 模型与阻塞点"></a>基本 IO 模型与阻塞点</h2><p>&emsp;&emsp;Redis 处理一个客户端发来的 Get 请求，要经过以下步骤：要监听客户端请求 （bind/listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。<br>&emsp;&emsp;下图显示了这一过程，其中，bind/listen、accept、recv、parse 和 send 属于网络 IO 处理，而 get 属于键值数据操作。既然 Redis 是单线程，那么，最基本的一种实现是在一个线程中依次执行上面说的这些操作。<br><img lazyload src="/images/loading.svg" data-src="redis10.jpg" alt="avatar"><br>&emsp;&emsp;但是，在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听到一个客户端有连接请求，但一直==未能成功建立起连接==时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果==数据一直没有到达==，Redis 也会一直阻塞在 recv()。这就导致 Redis 整个线程阻塞，无法处理其他客户端请求，效率很低。不过，幸运的是， socket 网络模型本身支持非阻塞模式。</p>
<h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>&emsp;&emsp;在 socket 模型中，不同操作调用后会返回不同的套接字类型。socket() 方法会返回主动套接字，然后调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字。<br><img lazyload src="/images/loading.svg" data-src="redis11.jpg" alt="avatar"><br>&emsp;&emsp;针对监听套接字，我们可以设置非阻塞模式：当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但是，要注意的是，调用 accept() 时，已经存在监听套接字了。<br>&emsp;&emsp;虽然 Redis 线程可以不用继续等待，但是总得有机制继续在监听套接字上等待后续连接请求，并在有请求时通知 Redis。类似的，我们也可以针对已连接套接字设置非阻塞模式：Redis 调用 recv() 后，如果已连 接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作。我们也需要有机 制继续监听该已连接套接字，并在有数据达到时通知 Redis。这样才能保证 Redis 线程，既不会像基本 IO 模型中一直在阻塞点等待，也不会导致 Redis 无法处理实际到达的连接请求或数据。</p>
<p>到此，Linux 中的 IO 多路复用机制就要登场了。</p>
<h3 id="基于多路复用的高性能-I-O-模型"><a href="#基于多路复用的高性能-I-O-模型" class="headerlink" title="基于多路复用的高性能 I/O 模型"></a>基于多路复用的高性能 I/O 模型</h3><p>&emsp;&emsp;Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，<strong>同时存在多个监听套接字和已连接套接字</strong>。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。<br>&emsp;&emsp;下图就是基于多路复用的 Redis IO 模型。图中的多个 FD 就是刚才所说的多个套接字。 Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理 上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。<br><img lazyload src="/images/loading.svg" data-src="redis12.jpg" alt="avatar"><br>&emsp;&emsp;为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来， Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时， Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。<br>&emsp;&emsp;以连接请求和读数据请求为例，具体解释一下:<br>&emsp;&emsp;这两个请求分别对应 Accept 事件和 Read 事件，Redis 分别对这两个事件注册 accept 和 get 回调函数。当 Linux 内核监听到有连接请求或读数据请求时，就会触发 Accept 事件 和 Read 事件，此时，内核就会回调 Redis 相应的 accept 和 get 函数进行处理。</p>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>&emsp;&emsp;随着硬件性能提升，Redis 的性能瓶颈可能出现网络 IO 的读写，也就是：单个线程处理网络读写的速度跟不上底层网络硬件的速度。读写网络的 <code>read/write</code> 系统调用占用了Redis 执行期间大部分CPU 时间，瓶颈主要在于网络的 IO 消耗。所以，Redis6.0版本 采用多个 IO 线程来处理网络请求，提高网络请求处理的并行度。<strong>需要注意的是，Redis 多 IO 线程模型只用来处理网络读写请求，对于 Redis 的读写命令，依然是单线程处理</strong>。这是因为，网络处理经常是瓶颈，通过多线程并行处理可提高性能。<br>架构图如下：<br><img lazyload src="/images/loading.svg" data-src="redis13.jpg" alt="avatar"><br>主线程与 IO 多线程是如何实现协作呢？<br><img lazyload src="/images/loading.svg" data-src="redis14.jpg" alt="avatar"><br>主要流程：</p>
<ol>
<li>主线程负责接收建立连接请求，获取 <code>socket</code> 放入全局等待读处理队列；</li>
<li>主线程通过轮询将可读 <code>socket</code> 分配给 IO 线程；</li>
<li>主线程阻塞等待 IO 线程读取 <code>socket</code> 完成；</li>
<li>主线程执行 IO 线程读取和解析出来的 Redis 请求命令；</li>
<li>主线程阻塞等待 IO 线程将指令执行结果回写回 <code>socket</code>完毕；</li>
<li>主线程清空全局队列，等待客户端后续的请求。</li>
</ol>
<p>思路：<strong>将主线程 IO 读写任务拆分出来给一组独立的线程处理，使得多个 socket 读写可以并行化，但是 Redis 命令还是主线程串行执行。</strong></p>
<p>模型缺陷:<br>&emsp;&emsp;Redis 的多线程网络模型实际上并不是一个标准的 <code>Multi-Reactors/Master-Workers</code> 模型。Redis 的多线程方案中，I/O 线程任务仅仅是通过 socket 读取客户端请求命令并解析，却没有真正去执行命令。所有客户端命令最后还需要回到主线程去执行，因此对多核的利用率并不算高，而且每次主线程都必须在分配完任务之后忙轮询等待所有 I/O 线程完成任务之后才能继续执行其他逻辑。</p>
<h1 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a>AOF 日志</h1><h2 id="AOF-日志是如何实现的"><a href="#AOF-日志是如何实现的" class="headerlink" title="AOF 日志是如何实现的"></a>AOF 日志是如何实现的</h2><p>&emsp;&emsp;对于SQL这类的数据库，基本都是写前日志（Write Ahead Log, WAL），也就是在实际写数据前，先将数据记录在日志中，以便故障时恢复。AOF 正好相反，它是写后日志，也就是说先执行 Redis 命令写入数据，再记录日志。如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis15.jpg" alt="avatar"></p>
<p>&emsp;&emsp;传统的数据库日志，记录的是修改后的数据，而 AOF 记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存下来的。我们以 Redis 收到“set testkey testvalue”命令后记录的日志为例，看看 AOF 日志的内容。其中，“*3”表示当前命令有三个部分，每部分都是由“$+数字”开头，后面紧跟着 具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节。例 如，“$3 set”表示这部分有 3 个字节，也就是“set”命令。<br><img lazyload src="/images/loading.svg" data-src="redis16.jpg" alt="avatar"></p>
<p>&emsp;&emsp;AOF 采用写后日志的方式有两个好处：第一，不需要消耗额外的资源检查命令是否正确，只需要在成功写入之后更新日志即可；第二，因为是在写入后更新日志，不必担心被阻塞当前的写操作。<br>&emsp;&emsp;但是这种方式也有天然的缺点，第一，如果在一条命令成功执行后服务器突然宕机，此时还没来得及在 AOF 日志中保存下这条命令，那么再重启服务后这条命令的写入/更新操作就不会被执行；第二，虽然不会阻塞当前的写操作，但是写日志也是在主进程中执行的，如果磁盘的IO压力很大导致写日志很慢，那么之后的 Redis 命令就会被阻塞。<br>&emsp;&emsp;这两个风险都是和 AOF 写回磁盘的时机相关的。这也就意味着，如果我们能够控制一个写命令执行完后 AOF 日志写回磁盘的时机，这两个风险就解除了。</p>
<h2 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h2><ul>
<li>Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</li>
<li>Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li>
<li>No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li>
</ul>
<p>三种写回策略的比较：<br><img lazyload src="/images/loading.svg" data-src="redis17.jpg" alt="avatar"><br>&emsp;&emsp;这时我们就要根据我们的系统的需求来进行 trade-off 了，如果想要保证高可靠，那么就采取 Always 的策略；如果追求的是高性能，那么久采用 no 策略，将控制写回的时机完全交给操作系统；如果想要兼顾两者，那就选择 everysec 策略。</p>
<h2 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h2><p>&emsp;&emsp;随着时间的推移，Redis 的 AOF 日志文件会越来越大，此时可能有三种因素共同制约日志文件的大小：</p>
<ol>
<li>操作系统对每个文件的大小上限有限制；</li>
<li>日志文件过大，每次要打开文件往里面写入，对性能的损耗就越大；</li>
<li>当使用 AOF 日志恢复数据时，由于 AOF 日志过大，整个恢复过程就会很慢。</li>
</ol>
<p>&emsp;&emsp;这个时候，AOF 重写机制就登场了。AOF 会根据日志的现状重新创建一个日志文件，对一个键值对的修改可能是经过很多条 Redis 命令后形成的最终的结果，此时只需要一条命令就能替换掉之前所有的命令。这样一来，一个键值对在重写日志中只用一条命令就行了，在日志恢复时，只用执行这条命令，就可以直接完成这个键值对的写入了。</p>
<p>下面这张图就是一个例子：<br><img lazyload src="/images/loading.svg" data-src="redis18.jpg" alt="avatar"></p>
<p>&emsp;&emsp;重写机制虽然能够大大缩减日志文件的大小，但是可以想见，这必定是一个非常消耗资源的操作，那么 AOF 重写会阻塞主线程吗？为避免 AOF 重写阻塞主线程，重写过程会在后台起一个线程来完成。可以总结为一句话：“<strong>一个拷贝，两处日志</strong>”。</p>
<ul>
<li><strong>一个拷贝</strong>：主线程 fork 一个线程来重写 AOF 日志时，会将主线程内存拷贝一份给子线程，这里面包含了数据库的最新数据，子线程就可以在不影响主线程的前提下逐一把拷贝的数据写成操作存入重写日志。</li>
<li><strong>两处日志</strong>：如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这 个 AOF 日志的操作仍然是齐全的，可以用于恢复；而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这 样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日 志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我 们就可以用新的 AOF 文件替代旧文件了。<br><img lazyload src="/images/loading.svg" data-src="redis19.jpg" alt="avatar"><br>&emsp;&emsp; 总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个 日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。</li>
</ul>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>AOF 日志重写的时候，是由 bgrewriteaof 子进程来完成的，不用主线程参与，我们今天说的非阻塞也是指子进程的执行不阻塞主线程。但是，你觉得，这个重写过程有没有其他潜在的阻塞风险呢？如果有的话，会在哪里阻塞？<br>答：fork子进程，fork这个瞬间一定是会阻塞主线程的（注意，fork时并不会一次性拷贝所有内存数据给子进程），fork采用操作系统提供的写实复制(Copy On Write)机制，就是为了避免一次性拷贝大量内存数据给子进程造成的长时间阻塞问题，但<strong>fork子进程需要拷贝进程必要的数据结构，其中有一项就是拷贝内存页表</strong>（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，实例越大，内存页表越大，fork阻塞时间越久。拷贝内存页表完成后，子进程与父进程指向相同的内存地址空间，也就是说此时虽然产生了子进程，但是并没有申请与父进程相同的内存大小。那什么时候父子进程才会真正内存分离呢？“写实复制”顾名思义，就是在写发生时，才真正拷贝内存真正的数据，这个过程中，父进程也可能会产生阻塞的风险，就是下面介绍的场景。</li>
</ol>
<p>fork出的子进程指向与父进程相同的内存地址空间，此时子进程就可以执行AOF重写，把内存中的所有数据写入到AOF文件中。但是此时父进程依旧是会有流量写入的，如果父进程操作的是一个已经存在的key，那么这个时候父进程就会真正拷贝这个key对应的内存数据，申请新的内存空间，这样逐渐地，父子进程内存数据开始分离，父子进程逐渐拥有各自独立的内存空间。因为内存分配是以页为单位进行分配的，默认4k，如果父进程此时操作的是一个bigkey，重新申请大块内存耗时会变长，可能会产阻塞风险。另外，如果操作系统开启了内存大页机制(Huge Page，页面大小2M)，那么父进程申请内存时阻塞的概率将会大大提高，所以在Redis机器上需要关闭Huge Page机制。Redis每次fork生成RDB或AOF重写完成后，都可以在Redis log中看到父进程重新申请了多大的内存空间。</p>
<ol start="2">
<li>AOF 重写也有一个重写日志，为什么它不共享使用 AOF 本身的日志呢？<br>答：一个原因是父子进程写同一个文件必然会产生竞争问题，控制竞争就意味着会影响父进程的性能。二是如果AOF重写过程中失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用。所以Redis AOF重写一个新文件，重写失败的话，直接删除这个文件就好了，不会对原先的AOF文件产生影响。等重写完成之后，直接替换旧文件即可。</li>
</ol>
<h1 id="RDB-内存快照"><a href="#RDB-内存快照" class="headerlink" title="RDB 内存快照"></a>RDB 内存快照</h1><p>&emsp;&emsp;上一节说到 AOF 日志将 Redis 的写命令逐一记录下来，在服务重启时再逐一执行恢复数据。如果 AOF 日志文件过大，这一过程通常是很缓慢的。这一节将讨论另一种持久化方式：内存快照。所谓内存快照，就是指内存中的数据在某一个时刻的状态记录。这就类似于照片，当你给朋友拍照时，一张照片就能把朋友一瞬间的形象完全记下来。对 Redis 来说，它实现类似照片记录效果的方式，就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 RDB 文件，其中，RDB 就是 Redis DataBase 的缩写。和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，我 们可以直接把 RDB 文件读入内存，很快地完成恢复。听起来好像很不错，但内存快照也并不是最优选项。为什么这么说呢？有另个问题要考虑：</p>
<ol>
<li>我们应该对那些数据做快照？这关系到快照的执行效率问题；</li>
<li>做快照时，数据还能被增删改吗？这关系到 Redis 是否被阻塞，能否同时正常处理请求。</li>
</ol>
<p>拿拍照片来举例子。我们在拍照时，通常要关注两个问题：</p>
<ol>
<li>如何取景？也就是说，我们打算把哪些人、哪些物拍到照片中；</li>
<li>在按快门前，要记着提醒朋友不要乱动，否则拍出来的照片就模糊了。</li>
</ol>
<h2 id="给哪些数据做快照"><a href="#给哪些数据做快照" class="headerlink" title="给哪些数据做快照?"></a>给哪些数据做快照?</h2><p>&emsp;&emsp;Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是<strong>全量快照</strong>，也就是说，把内存中的所有数据都记录到磁盘中，这就类似于给 100 个人拍合影，把每一个人都拍进照片里。这样做的好处是，一次性记录了所有数据，一个都不少。同样，给内存的全量数据做快照， 把它们全部写入磁盘也会花费很多时间。而且，全量数据越多，RDB 文件就越大，往磁盘上写数据的时间开销就越大。对于 Redis 而言，它的单线程模型就决定了，我们要尽量避免所有会阻塞主线程的操作， 所以，针对任何操作，我们都会提一个灵魂之问：“它会阻塞主线程吗?”。RDB 文件的生成是否会阻塞主线程，这就关系到是否会降低 Redis 的性能。</p>
<p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。</p>
<ul>
<li>save：在主线程中执行，会导致阻塞；</li>
<li>bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。</li>
</ul>
<p>&emsp;&emsp;我们就可以通过 bgsave 命令来执行全量快照，这既提供了数据的可靠性保证，也避免了对 Redis 的性能影响。</p>
<p>&emsp;&emsp;接下来，我们要关注的问题就是，在对内存数据做快照时，这些数据还能“动”吗? 也就是说，这些数据还能被修改吗？ 这个问题非常重要，这是因为，如果数据能被修改，那就意味着 Redis 还能正常处理写操作。否则，所有写操作都得等到快照完了才能执行，性能一下子就降低了。</p>
<h2 id="快照时数据能修改吗"><a href="#快照时数据能修改吗" class="headerlink" title="快照时数据能修改吗?"></a>快照时数据能修改吗?</h2><p>&emsp;&emsp;当我们采用 bgsave 方式来生成快照时，其实是 fork 了一个子进程。根据 Linux 中 fork 系统调用的规则，子进程在创建后并不会将父进程所有的内存数据都单独拷贝一份，而是拷贝一份页表，背后指向和父进程一样的物理地址。当有新的 Redis 写入命令时，原来的键值对发生了修改，那么就会启用 copy-on-write 思想，子进程会在内存中复制一份该键值对，并通过页表指向该新创建的地址，这就做到了在进行快照时，数据发生了修改，子进程仍然可以把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。<br><img lazyload src="/images/loading.svg" data-src="redis20.jpg" alt="avatar"><br>&emsp;&emsp;这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影 响。到这里，我们就解决了对“哪些数据做快照”以及“做快照时数据能否修改”这两大问 题：Redis 会使用 bgsave 对当前内存中的所有数据做快照，这个操作是子进程在后台完 成的，这就允许主线程同时可以修改数据。</p>
<p>&emsp;&emsp;现在，我们再来看另一个问题：多久做一次快照？我们在拍照的时候，还有项技术叫“连 拍”，可以记录人或物连续多个瞬间的状态。那么，快照也适合“连拍”吗？</p>
<h2 id="可以每秒做一次快照吗？"><a href="#可以每秒做一次快照吗？" class="headerlink" title="可以每秒做一次快照吗？"></a>可以每秒做一次快照吗？</h2><p>&emsp;&emsp;对于快照来说，所谓“连拍”就是指连续地做快照。这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。但是，这其中的快照间隔时间就很关键了。<br>&emsp;&emsp;如下图所示，我们先在 T0 时刻做了一次快照，然后又在 T0+t 时刻做了一次快照，在这期间，数据块 5 和 9 被修改了。如果在 t 这段时间内，机器宕机了，那么，只能按照 T0 时刻的快照进行恢复。此时，数据块 5 和 9 的修改值因为没有快照记录，就无法恢复了。<br><img lazyload src="/images/loading.svg" data-src="redis21.jpg" alt="avatar"><br>&emsp;&emsp;所以，要想尽可能恢复数据，t 值就要尽可能小，t 越小，就越像“连拍”。那么，t 值可以小到什么程度呢，比如说是不是可以每秒做一次快照？毕竟，每次快照都是由 bgsave 子进程在后台执行，也不会阻塞主线程。这种想法其实是错误的。虽然 <strong>bgsave 执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销</strong>。</p>
<ol>
<li>一方面，对于<strong>磁盘</strong>而言，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</li>
<li>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后 不会再阻塞主线程，但是，<strong>fork 这个创建过程本身会阻塞主线程</strong>，而且主线程的内存越 大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。</li>
</ol>
<p>&emsp;&emsp;此时，我们可以做<strong>增量快照</strong>，所谓增量快照，就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。</p>
<p>&emsp;&emsp;在第一次做完全量快照后，T1 和 T2 时刻如果再做快照，我们只需要将被修改的数据写入快照文件就行。但是，这么做的前提是，我们需要<strong>记住哪些数据被修改了</strong>。你可不要小瞧 这个“记住”功能，它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis22.jpg" alt="avatar"><br>&emsp;&emsp;如果我们对每一个键值对的修改，都做个记录，那么，如果有 1 万个被修改的键值对，我们就需要有 1 万条额外的记录。而且，有的时候，键值对非常小，比如只有 32 字节，而记录它被修改的元数据信息，可能就需要 8 字节，这样的画，为了“记住”修改，引入的额外空间开销比较大。这对于内存资源宝贵的 Redis 来说，有些得不偿失。</p>
<p>&emsp;&emsp;到这里，你可以发现，虽然跟 AOF 相比，快照的恢复速度快，但是，快照的频率不好把握，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销，那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？我们再仔细想一想，使用 AOF 日志不是能很好的记录修改吗。</p>
<h2 id="混合使用-AOF-日志和内存快照"><a href="#混合使用-AOF-日志和内存快照" class="headerlink" title="混合使用 AOF 日志和内存快照"></a>混合使用 AOF 日志和内存快照</h2><p>&emsp;&emsp;简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。<br><img lazyload src="/images/loading.svg" data-src="redis23.jpg" alt="avatar"><br>&emsp;&emsp;这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势。</p>
<h1 id="主从库同步"><a href="#主从库同步" class="headerlink" title="主从库同步"></a>主从库同步</h1><p>&emsp;&emsp;当启动多个 Redis 实例的时候，它们之间就可以通过 replicaof （Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。例如，现在有实例 1（ip：172.16.19.3）和实例 2（ip：172.16.19.5），我们在实例 2 上执行以下这个命令后，实例 2 就变成了实例 1 的从库，并从实例 1 上复制数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">replicaof 172.16.19.3 6379</span><br></pre></td></tr></table></figure>

<h2 id="主从库第一次同步"><a href="#主从库第一次同步" class="headerlink" title="主从库第一次同步"></a>主从库第一次同步</h2><p>三个阶段：<br><img lazyload src="/images/loading.svg" data-src="redis24.jpg" alt="avatar"></p>
<ul>
<li><p>阶段一：<br>&emsp;&emsp;主从库建立连接，协商同步，主要是为全量复制做准备。具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。<br>runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设 为“？”。<br>offset，此时设为 -1，表示第一次复制。</p>
</li>
<li><p>第二阶段<br>&emsp;&emsp;主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。<strong>FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库主库执行 bgsave 命令，把当前所有的数据都复制给从库</strong>。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。</p>
</li>
<li><p>第三阶段<br>&emsp;&emsp;在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p>
</li>
</ul>
<h2 id="主从级联分担全量复制时主库的压力"><a href="#主从级联分担全量复制时主库的压力" class="headerlink" title="主从级联分担全量复制时主库的压力"></a>主从级联分担全量复制时主库的压力</h2><p>&emsp;&emsp;对于主库来说，完成第一次主从同步，即一次全量复制，有两个耗时的操作：生成 RDB 文件和传输 RDB 文件。如果从库过多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步。fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。此外，传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。可以使用“主-从-从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。<br><img lazyload src="/images/loading.svg" data-src="redis25.jpg" alt="avatar"></p>
<h2 id="主从库间的网络断了怎么办？"><a href="#主从库间的网络断了怎么办？" class="headerlink" title="主从库间的网络断了怎么办？"></a>主从库间的网络断了怎么办？</h2><p>&emsp;&emsp;在 Redis 2.8 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步。听名字大概就可以猜到它和全量复制的不同：全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库。那么，增量复制时，主从库之间具体是怎么保持同步的呢？这里的奥妙就在于 repl_backlog_buffer 这个缓冲区。我们先来看下它是如何用于增量命令的同步的。<br>&emsp;&emsp;当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。repl_backlog_buffer 是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己 已经读到的位置。刚开始的时候，主库和从库的写读位置在一起，这算是它们的起始位置。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，我们通常用偏移量来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是 master_repl_offset。主库接收的新写操作越多，这个值就会越大。同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量 slave_repl_offset 也在不断增加。正常情况下，这两个偏移量基本相等。<br><img lazyload src="/images/loading.svg" data-src="redis26.jpg" alt="avatar"><br><img lazyload src="/images/loading.svg" data-src="redis27.jpg" alt="avatar"><br>&emsp;&emsp;，因为 repl_backlog_buffer 是一个环形缓冲区，所以在 缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。针对这种情况，一方面，可以根据 Redis 所在服务器的内存资源再适当增加 repl_backlog_size 值，比如说设置成缓冲空间大小的 4 倍，另一方面，可以考虑使用切片集群来分担单个主库的请求压力。</p>
<h2 id="为什么使用-RDB-文件进行主从复制，而不是用-AOF？"><a href="#为什么使用-RDB-文件进行主从复制，而不是用-AOF？" class="headerlink" title="为什么使用 RDB 文件进行主从复制，而不是用 AOF？"></a>为什么使用 RDB 文件进行主从复制，而不是用 AOF？</h2><ol>
<li>相同数据下，AOF 文件比 RDB 更大，因此需要的网络带宽更多；</li>
<li>在恢复数据时，使用RDB更快。RDB 是数据库的快照文件，记录的是某一时刻数据库中所有键值对的状态，而 AOF 文件记录的是所有的写 Redis 命令，在做全量复制的时候会需要大量的时间；</li>
<li>如果使用AOF文件来同步相对来说丢的数据更少，但是不表示不丢数据。即也需要第三 个阶段来保证数据的一致性。因此相对来说使用RDB开销更小些。</li>
</ol>
<h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><p>&emsp;&emsp;在主从模式下。如果从库挂了，那么客户端的请求会被其他正常工作的从库接收。但如果是主库挂了，那么客户端的写请求将不再能够被处理，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis28.jpg" alt="avatar"><br>&emsp;&emsp;无论是写服务中断，还是从库无法同步数据，都是不可接受的。所以，如果主库挂了，我们就需要运行一个新的主库，比如手将一个从库切换为主库。这就涉及三个问题：</p>
<ol>
<li>主库真的挂了吗？</li>
<li>该选择哪个从库作为主库？</li>
<li>怎么把新主库的相关信息通知给从库和客户端呢？</li>
</ol>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>&emsp;&emsp;哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。</p>
<ul>
<li><p>监控<br>&emsp;&emsp;监控是指哨兵进程在运行时，周期性地给所有主从库发送 PING 命令，检测它们是否仍然在线。如果从库没有在规定时间内相应哨兵的 PING 命令，哨兵就会将它标记为“下线状态“；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下限，然后开始自动切换主库的流程。</p>
</li>
<li><p>选主<br>&emsp;&emsp;主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。这一步完成后，现在的集群里就有了新主库。</p>
</li>
<li><p>通知<br>&emsp;&emsp;在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。</p>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="redis29.jpg" alt="avatar"></p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><ul>
<li>主观下线<br>&emsp;&emsp;哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么哨兵会将它标记为“主观下线”。</li>
</ul>
<p>&emsp;&emsp;首先，我们要知道啥叫误判。很简单，就是主库实际并没有下线，但是哨兵误以为它下线了。误判一般会发生在集群网络压力较大、网络拥塞，或者是主库本身压力较大的情况下。哨兵机制<strong>通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群</strong>来减少误判。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。在判断主库是否下线时，不能由一个哨兵说了算，只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“客观下线”，这个叫法也是表明主库下线成为一个客观事实了。这个判断原则就是：少数服从多数。同时，这会进一步触发哨兵开始主从切换流程。<br><img lazyload src="/images/loading.svg" data-src="redis30.jpg" alt="avatar"></p>
<ul>
<li>客观下线<br>&emsp;&emsp;简单来说，“客观下线”的标准就是，当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”。这样一来，就可以减少误判 的概率，也能避免误判带来的无谓的主从库切换。（当然，有多少个实例做出“主观下线”的判断才可以，可以由 Redis 管理员自行设定）。</li>
</ul>
<h2 id="选主"><a href="#选主" class="headerlink" title="选主"></a>选主</h2><p>&emsp;&emsp;我们在多个从库中，先按照<strong>一定的筛选条件</strong>，把不符合条件的从库去掉。然后，我们再按照<strong>一定的规则</strong>，给剩下的从库逐个打分，将得分最高的从库选为新主库，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis31.jpg" alt="avatar"></p>
<ul>
<li><p>一定的筛选条件<br>&emsp;&emsp;在选主时，<strong>除了要检查从库的当前在线状态，还要判断它之前的网络连接状态</strong>。如果从库总是和主库断连，而且断连次数超出了一定的阈值，我们就有理由相信，这个从库的网络状况并不是太好，就可以把这个从库筛掉了。</p>
</li>
<li><p>一定的规则<br>&emsp;&emsp;我们可以分别按照三个规则依次进行三轮打分，这三个规则分别是从库优先级、从库复制进度以及从库 ID 号。只要在某一轮中，有从库得分最高，那么它就是主库了，选主过程到此结束。如果没有出现得分最高的从库，那么就继续进行下一轮。</p>
</li>
</ul>
<ol>
<li><p>第一轮：优先级最高的从库得分高。<br>&emsp;&esmsp;用户可以通过 slave-priority 配置项，给不同的从库设置不同优先级。比如，你有两个从库，它们的内存大小不一样，你可以手动给内存大的实例设置一个高优先级。在选主时，哨兵会给优先级高的从库打高分，如果有一个从库优先级最高，那么它就是新主库了。如果从库的优先级都一样，那么哨兵开始第二轮打分。</p>
</li>
<li><p>第二轮：和旧主库同步程度最接近的从库得分高。<br>&emsp;&emsp;这个规则的依据是，如果选择和旧主库同步最接近的那个从库作为主库，那么，这个新主库上就有最新的数据。主从库同步时有个命令传播的过程。在这个过程中，主库会用 master_repl_offset 记录当前的最新写操作在 repl_backlog_buffer 中的位置，而从库会用 slave_repl_offset 这个值记录当前的复制进度。此时，我们想要找的从库，它的 slave_repl_offset 需要最接近 master_repl_offset。如果在所有从库中，有从库的 slave_repl_offset 最接近 master_repl_offset，那么它的得分就最高，可以作为新主库。就像下图所示，旧主库的 master_repl_offset 是 1000，从库 1、2 和 3 的 slave_repl_offset 分别是 950、990 和 900，那么，从库 2 就应该被选为新主库。<br><img lazyload src="/images/loading.svg" data-src="redis32.jpg" alt="avatar"><br>当然，如果有两个从库的 slave_repl_offset 值大小是一样的（例如，从库 1 和从库 2 的 slave_repl_offset 值都是 990），我们就需要给它们进行第三轮打分了。</p>
</li>
<li><p>第三轮：ID 号小的从库得分高。</p>
</li>
</ol>
<h2 id="哨兵集群的原理"><a href="#哨兵集群的原理" class="headerlink" title="哨兵集群的原理"></a>哨兵集群的原理</h2><p>&emsp;&emsp;我们通常通过使用哨兵集群来对主从库的状态进行监控并在主库挂掉时选出新的主库。那么哨兵出现故障呢？实际上，一旦多个实例组成哨兵集群，即使一个实例挂掉，剩下的哨兵依然会继续履行原始的职能，通过哨兵集群的配置项（如下所示），我们可以发现，哨兵在建立的一开始对彼此是没有感知的，它们各自知道的只有 Redis 主库的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在配置哨兵的信息时，我们只需要用到下面的这个配置项，设置主库的 IP 和端口，并没有配置其他哨兵的连接信息。</p>
<h3 id="基于-Pub-Sub-机制的哨兵集群的相互感知"><a href="#基于-Pub-Sub-机制的哨兵集群的相互感知" class="headerlink" title="基于 Pub/Sub 机制的哨兵集群的相互感知"></a>基于 Pub/Sub 机制的哨兵集群的相互感知</h3><p>&emsp;&emsp;哨兵之间能够相互发现，要归功于 Redis 的pub/sub 机制，即发布/订阅机制。哨兵只要和主库建立了连接，就可以在主库上发布消息了，比如说发布它自己的连接信 息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。<br>&emsp;&emsp;除了哨兵实例，我们自己编写的应用程序也可以通过 Redis 进行消息的发布和订阅。所以，为了区分不同应用的消息，Redis 会以频道的形式，对这些消息进行分门别类的管理。所谓的频道，实际上就是消息的类别。当消息类别相同时，它们就属于同一个频道。 反之，就属于不同的频道。只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换。<br>&emsp;&emsp;在主从集群中，主库上有一个名为“__sentinel__:hello”的频道，不同哨兵就是通过它来相互发现，实现互相通信的。<br>&emsp;&emsp;举个例子，具体说明一下。在下图中，哨兵 1 把自己的 IP（172.16.19.3）和端口 （26579）发布到“__sentinel__:hello”频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。然后，哨兵 2、3 可以和哨兵 1 建立网络连接。通过这个方式，哨兵 2 和 3 也可以建立网络连接，这样一来，哨兵集群就形成了。它们相互间可以通过网络连接进行通信，比如说对主库有没有下线这件事儿进行判断和协商。<br><img lazyload src="/images/loading.svg" data-src="redis33.jpg" alt="avatar"><br>&emsp;&emsp;哨兵除了彼此之间建立起连接形成集群外，还需要和从库建立连接。这是因为，在哨兵的监控任务中，它需要对主从库都进行心跳判断，而且在主从库切换完成后，它还需要通知从库，让它们和新主库进行同步。</p>
<h3 id="哨兵如何何知道从库的-IP-地址和端口"><a href="#哨兵如何何知道从库的-IP-地址和端口" class="headerlink" title="哨兵如何何知道从库的 IP 地址和端口"></a>哨兵如何何知道从库的 IP 地址和端口</h3><p>&emsp;&emsp;哨兵向主库发送 INFO 命令来完成的。就像下图所示，哨兵 2 给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。哨兵 1 和 3 可以通过相同的方法和从库建立连接。<br><img lazyload src="/images/loading.svg" data-src="redis34.jpg" alt="avatar"><br>&emsp;&emsp;通过 pub/sub 机制，哨兵之间可以组成集群，同时，哨兵又通过 INFO 命令，获得了从库连接信息，也能和从库建立连接，并进行监控了。</p>
<h3 id="基于-pub-sub-机制的客户端事件通知"><a href="#基于-pub-sub-机制的客户端事件通知" class="headerlink" title="基于 pub/sub 机制的客户端事件通知"></a>基于 pub/sub 机制的客户端事件通知</h3><p>&emsp;&emsp;哨兵不能只和主、从库连接。因为，主从库切换后，客户端也需要知道新主库的连接信息，才能向新主库发送请求操作。所以，哨兵还需要完成把新主库的信息告诉客户端这个任务。而且，在实际使用哨兵时，我们有时会遇到这样的问题：如何在客户端通过监控了解哨兵进行主从切换的过程呢？比如说，主从切换进行到哪一步了？这其实就是要求，客户端能够获取到哨兵集群在监控、选主、切换这个过程中发生的各种事件。<br>&emsp;&emsp;从本质上说，哨兵就是一个运行在特定模式下的 Redis 实例，只不过它并不服务请求操作，只是完成监控、选主和通知的任务。所以，每个哨兵实例也提供 pub/sub 机制，客户端可以从哨兵订阅消息。哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。<br><img lazyload src="/images/loading.svg" data-src="redis35.jpg" alt="avatar"><br>&emsp;&emsp;知道了这些频道之后，你就可以让客户端从哨兵这里订阅消息了。具体的操作步骤是，客户端读取哨兵的配置文件后，可以获得哨兵的地址和端口，和哨兵建立网络连接。然后，我们可以在客户端执行订阅命令，来获取不同的事件消息。</p>
<p>举个例子，你可以执行如下命令，来订阅“所有实例进入客观下线状态的事件”：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SUBSCRIBE +odown</span><br></pre></td></tr></table></figure>

<p>当然，你也可以执行如下命令，订阅所有的事件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PSUBSCRIBE *</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当哨兵把新主库选择出来后，客户端就会看到下面的 switch-master 事件。这个事件表示主库已经切换了，新主库的 IP 地址和端口信息已经有了。这个时候，客户端就可以用这里面的新主库地址和端口进行通信了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">switch-master &lt;master name&gt; &lt;oldip&gt; &lt;oldport&gt; &lt;newip&gt; &lt;newport&gt;</span><br></pre></td></tr></table></figure>

<h3 id="由哪个哨兵执行主从切换"><a href="#由哪个哨兵执行主从切换" class="headerlink" title="由哪个哨兵执行主从切换?"></a>由哪个哨兵执行主从切换?</h3><p>&emsp;&emsp;实际上，<strong>选主和执行主从切换这两个流程是分裂的，并不是由发现主库下线的哨兵直接执行，而也是通过“投票”的方式选出执行的哨兵</strong>。哨兵集群要判定主库“客观下线”，需要有一定数量的实例都认为该主库已经“主观下线”了。任何一个实例只要自身判断主库“主观下线”后，就会给其他实例发送 is-master-downby-addr 命令。接着，其他实例会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相 当于赞成票，N 相当于反对票。<br><img lazyload src="/images/loading.svg" data-src="redis36.jpg" alt="avatar"></p>
<p>&emsp;&emsp;一个哨兵获得了仲裁所需的赞成票数后，就可以标记主库为“客观下线”。这个所需的赞成票数是通过哨兵配置文件中的 quorum 配置项设定的。例如，现在有 5 个哨兵，quorum 配置的是 3，那么，一个哨兵需要 3 张赞成票，就可以标记主库为“客观下线”了。这 3 张赞成票包括哨兵自己的一张赞成票和另外两个哨兵的赞成票。<br>&emsp;&emsp;此时，这个哨兵就可以再给其他哨兵发送命令，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。这个投票过程称为“Leader 选举”。因为最终执行主从切换的哨兵 称为 Leader，投票过程就是确定 Leader。在投票过程中，任何一个想成为 Leader 的哨兵，要满足两个条件：第一，拿到半数以上的赞成票；第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。以 3 个哨兵为例，假设此时的 quorum 设置为 2，那么，任何一个想成为 Leader 的哨兵只要拿到 2 张赞成票，就可以了。</p>
<p>下面展示一下 3 个哨兵、quorum 为 2 的选举过程。<br><img lazyload src="/images/loading.svg" data-src="redis37.jpg" alt="avatar"><br>&emsp;&emsp;如果 S3 没有拿到 2 票 Y，那么这轮投票就不会产生 Leader。哨兵集群会等待一段时间（也就是哨兵故障转移超时时间的 2 倍），再重新选举。这是因为，哨兵集群能够进行成功投票，很大程度上依赖于选举命令的正常网络传播。如果网络压力较大或有短时堵塞， 就可能导致没有一个哨兵能拿到半数以上的赞成票。所以，等到网络拥塞好转之后，再进行投票选举，成功的概率就会增加。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>&emsp;&emsp;假设有一个 Redis 集群，是“一主四从”，同时配置了包含 5 个哨兵实例的集群，quorum 值设为 2。在运行过程中，如果有 3 个哨兵实例都发生故障了，此时，Redis 主库如果有故障，还能正确地判断主库“客观下线”吗？如果可以的话，还能进行主从库自动切换吗？<br>答：1、可以正确的判断主库“客观下线”，以为其中一个哨兵已经获得了“客观下线”所需要 的投票数；2、不能进行自动的主从切换，因为在主从切换的时候，必须选择出一个主哨兵，但是选择 主哨兵有2个条件：2.1、获得半数以上的票数；2.2、票数大于等于 quorum 值。在已经有3个哨兵挂掉的情况下不可能获得超过半数的票。</p>
<h1 id="Redis-切片集群"><a href="#Redis-切片集群" class="headerlink" title="Redis 切片集群"></a>Redis 切片集群</h1><p>&emsp;&emsp;我们先设想一个场景，如果要存储一个很大规模的数据，例如要用 Redis 保存 5000 万个键值对，每个键值对大约是 512B，粗略地计算了一下，这些键值对所占的内存空间大约是 25GB（5000 万 *512B）。选择一台 32 GB 内存的主机来部署 Redis，32GB 的内存能保存所有数据，而且还留有 7GB，可以保证系统的正常运行。同时采用 RDB 对数据做持久化，以确保 Redis 实例故障后，还能从 RDB 恢复数据。但是，在实际的使用场景中，这种方式可能会导致 Redis 的响应相当慢，这跟 Redis 的持久化机制有关系。在使用 RDB 进行持久化时，Redis 会 fork 子进程来完成，fork 操作的用时和 Redis 的数据量是正相关的，而 fork 在执行时会阻塞主线程。数据量越大，fork 操作造成的主线程阻塞的时间越长。所以，在使用 RDB 对 25GB 的数据进行持久化时，数据量较大，后台运行的子进程在 fork 创建时阻塞了主线程，于是就导致 Redis 响应变慢了。<br>&emsp;&emsp;这样看来，光是通过扩容内存来解决数据量大的问题会引入新的问题。这时我们可以考虑 Redis 的切片集群，它可以保存大量数据，而且对 Redis 主线程的阻塞影响较小。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>&emsp;&emsp;切片集群，也叫分片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。回到我们刚刚的场景中，如果把 25GB 的数据平均分成 5 份（当然，也可以不做均分），使用 5 个实例来保存，每个实例只需要保存 5GB 数据。如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis38.jpg" alt="avatar"><br>&emsp;&emsp;那么，在切片集群中，实例在为 5GB 数据生成 RDB 时，数据量就小了很多，fork 子进程一般不会给主线程带来较长时间的阻塞。采用多个实例保存数据切片后，我们既能保存25GB 数据，又避免了 fork 子进程阻塞主线程而导致的响应突然变慢。</p>
<h2 id="如何保存更多数据"><a href="#如何保存更多数据" class="headerlink" title="如何保存更多数据"></a>如何保存更多数据</h2><p>&emsp;&emsp;为了保存大量数据，我们可以使用大内存云主机和切片集群两种方法。实际上，这两种方法分别对应着 Redis 应对数据量增多的两种方案：纵向扩展（scale up）和横向扩展（scale out）。</p>
<ul>
<li>纵向扩展：升级单个 Redis 实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU。就像下图中，原来的实例内存是 8GB，硬盘是 50GB，纵向扩展后， 内存增加到 24GB，磁盘增加到 150GB。</li>
<li>横向扩展：横向增加当前 Redis 实例的个数，就像下图中，原来使用 1 个 8GB 内存、 50GB 磁盘的实例，现在使用三个相同配置的实例。<br><img lazyload src="/images/loading.svg" data-src="redis39.jpg" alt="avatar"></li>
</ul>
<h2 id="数据切片和实例的对应分布关系"><a href="#数据切片和实例的对应分布关系" class="headerlink" title="数据切片和实例的对应分布关系"></a>数据切片和实例的对应分布关系</h2><p>&emsp;&emsp;在切片集群中，数据需要分布在不同实例上，那么，数据和实例之间如何对应呢？这就和接下来我要讲的 Redis Cluster 方案有关了。不过，我们要先弄明白切片集群和 Redis Cluster 的联系与区别。实际上，切片集群是一种保存大量数据的通用机制，这个机制可以有不同的实现方案。在 Redis 3.0 之前，官方并没有针对切片集群提供具体的方案。从 3.0 开始，官方提供了一个名为 Redis Cluster 的方案，用于实现切片集群。Redis Cluster 方案中就规定了数据和实例的对应规则。<br>&emsp;&emsp;Redis Cluster 方案采用哈希槽来处理数据与实例的映射关系。一个 Redis 切片集群共有 16384 个哈希槽，，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。<br>&emsp;&emsp;具体的映射分为两步：</p>
<ol>
<li>根据键值对的 key 计算出一个哈希值，匹配到某一个哈希槽上</li>
<li>将具体的哈希槽与 Redis 切片实例关联上</li>
</ol>
<p>&emsp;&emsp;我们在部署 Redis Cluster 方案时，可以使用 cluster create 命令创建集群，此时，Redis 会自动把这些槽平均分布在集群实例上。例如，如果集群中有 N 个实例，那么，每个实例上的槽个数为 16384/N 个。我们也可以使用 cluster meet 命令手动建立实例间的连接，形成集群，再使用 cluster addslots 命令，指定每个实例上的哈希槽个数。假设集群中不同 Redis 实例的内存大小配置不一，如果把哈希槽均分在各个实例上，在保存相同数量的键值对时，和内存大的实例相比，内存小的实例就会有更大的容量压力。遇到这种情况时，你可以根据不同实例的资源配置情况，使用 cluster addslots 命令手动分配哈希槽。<br>&emsp;&emsp;数据、哈希槽、实例这三者的映射分布情况如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis40.jpg" alt="avatar"><br>&emsp;&emsp;示意图中的切片集群一共有 3 个实例，同时假设有 5 个哈希槽，我们首先可以通过下面的命令手动分配哈希槽：实例 1 保存哈希槽 0 和 1，实例 2 保存哈希槽 2 和 3，实例 3 保存哈希槽 4。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -h 172.16.19.3 –p 6379 cluster addslots 0,1 </span><br><span class="line">redis-cli -h 172.16.19.4 –p 6379 cluster addslots 2,3 </span><br><span class="line">redis-cli -h 172.16.19.5 –p 6379 cluster addslots 4</span><br></pre></td></tr></table></figure>

<h2 id="客户端如何定位数据"><a href="#客户端如何定位数据" class="headerlink" title="客户端如何定位数据"></a>客户端如何定位数据</h2><p>&emsp;&emsp;一般来说，客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端。但是，在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，是不知道其他实例拥有的哈希槽信息的。那么，客户端为什么可以在访问任何一个实例时，都能获得所有的哈希槽信息呢？这是因为，Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。<br>&emsp;&emsp;但是，在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：</p>
<ol>
<li>在集群中，实例有新增或删除，Redis 需要重新分配哈希槽；</li>
<li>为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。</li>
</ol>
<p>&emsp;&emsp;此时，实例之间还可以通过相互传递消息，获得最新的哈希槽分配信息，但是，客户端是无法主动感知这些变化的。这就会导致，它缓存的分配信息和最新的分配信息就不一致了。Redis Cluster 方案提供了一种重定向机制，所谓的“重定向”，就是指，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令。那客户端又是怎么知道重定向时的新实例的访问地址呢？当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回下面的 MOVED 命令响应结果，这个结果中就包含了新实例的访问地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET hello:key (error) MOVED 13320 172.16.19.5:6379</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中，MOVED 命令表示，客户端请求的键值对所在的哈希槽 13320，实际是在 172.16.19.5 这个实例上。通过返回的 MOVED 命令，就相当于把哈希槽所在的新实例的信息告诉给客户端了。这样一来，客户端就可以直接和 172.16.19.5 连接，并发送操作请求了。</p>
<p>&emsp;&emsp;如下图所示，由于负载均衡， Slot 2 中的数据已经从实例 2 迁移到了实例 3，但是，客户端缓存仍然记录着“Slot 2 在实例 2”的信息，所以会给实例 2 发送命令。实例 2 给客户端返回一条 MOVED 命令，把 Slot 2 的最新位置（也就是在实例 3 上），返回给客户端，客户端就会再次向实例 3 发送请求，同时还会更新本地缓存，把 Slot 2 与实例的对应关系更新过来。<br><img lazyload src="/images/loading.svg" data-src="redis41.jpg" alt="avatar"></p>
<p>&emsp;&emsp;在实际的使用过程中还会出现一种情况，客户端向实例 2 发送请求，但此时，Slot 2 中的数据只有一部分迁移到了实例 3，还有部分数据没有迁移。在这种迁移部分完成的情况下，客户端就会收到一条 ASK 报错信息，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET hello:key </span><br><span class="line">(error) ASK 13320 172.16.19.5:6379</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个结果中的 ASK 命令就表示，客户端请求的键值对所在的哈希槽 13320，在 172.16.19.5 这个实例上，但是这个哈希槽正在迁移。此时，客户端需要先给 172.16.19.5 这个实例发送一个 ASKING 命令。这个命令的意思是，让这个实例允许执行客户端接下来发送的命令。然后，客户端再向这个实例发送 GET 命令，以读取数据。<br><img lazyload src="/images/loading.svg" data-src="redis42.jpg" alt="avatar"></p>
<p>&emsp;&emsp;和 MOVED 命令不同，ASK 命令并不会更新客户端缓存的哈希槽分配信息。所以，在上图中，如果客户端再次请求 Slot 2 中的数据，它还是会给实例 2 发送请求。这也就是说，ASK 命令的作用只是让客户端能给新实例发送一次请求，而不像 MOVED 命令那样，会更改本地缓存，让后续所有命令都发往新实例。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记（一）</title>
    <url>/2021/09/16/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>&emsp;&emsp;学习视频地址：<a class="link" href="https://www.bilibili.com/video/BV1S54y1R7SB?p=4&spm_id_from=pageDriver">【狂神说Java】Redis最新超详细版教程通俗易懂<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="为什么要用NoSQL"><a href="#为什么要用NoSQL" class="headerlink" title="为什么要用NoSQL"></a>为什么要用NoSQL</h1><p>&emsp;&emsp;用户的个人信息、社交网络、地理位置、用户自己产生的数据、用户日志等等爆发式增长。使用NoSQL数据库可以很好的解决上述情况。</p>
<h1 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h1><p>&emsp;&emsp;NoSQL=Not Only SQL。泛指非关系型数据库。随着web2.0互联网的诞生，传统的关系型数据库很难应付此时的需求。尤其是超大规模，高并发的社区。NoSQL在当今大数据时代下十分通用，Redis是发展最快的。</p>
<p>&emsp;&emsp;很多的数据类型用户的个人信息、社交网络、地理位置等数据的存储不需要一个固定的格式。不需要多余的操作就可以横向扩展（使用键值对来存储）。</p>
<p>&emsp;&emsp;特点：</p>
<ol>
<li>方便扩展（数据之间没有关系，很好扩展）</li>
<li>大数据条件下性能高（Redis一秒写8万次，读取11万次，NoSQL的缓存）</li>
<li>数据类型多样，不需要事先设计数据库，随取随用</li>
<li>传统的RDBMS和NoSQL</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传统的RDBMS</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都在单独的表中</span><br><span class="line">- 数据操作语言，数据定义语言</span><br><span class="line">- 严格的一致性</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NoSQL</span><br><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储、列存储、文档存储、图形数据库（社交关系）</span><br><span class="line">- 最终一致性</span><br><span class="line">- CAP定理和BASE（异地多活）</span><br><span class="line">- 高性能、高可用、高可扩展</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;NoSQL的四大分类：</p>
<ol>
<li>kv键值对：<strong>Redis</strong>、memcache</li>
<li>文档型数据库（bson和json格式）：</li>
</ol>
<ul>
<li><strong>MangoDB</strong><ul>
<li>MangoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档</li>
<li>MangoDB是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库中功能最丰富的，最像关系型数据库的</li>
</ul>
</li>
<li>CouchDB</li>
</ul>
<ol start="3">
<li>列存储数据库</li>
</ol>
<ul>
<li><strong>HBase</strong></li>
<li>分布式文件系统</li>
</ul>
<ol start="4">
<li>图关系数据库（存放关系，比如：朋友圈，广告推荐）</li>
</ol>
<ul>
<li><strong>Neo4j</strong></li>
<li>InfoGrid</li>
</ul>
<h1 id="Mac下Redis的运行环境"><a href="#Mac下Redis的运行环境" class="headerlink" title="Mac下Redis的运行环境"></a>Mac下Redis的运行环境</h1><p>&emsp;&emsp;在Mac中，Redis的安装目录在<code>/usr/local/bin</code>下,Redis默认不是后台启动的，修改配置文件<code>redis.conf</code>中的<code>daemonize</code>项为yes，如下图：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph1.jpg" alt="avatar"></p>
<h2 id="启动Redis"><a href="#启动Redis" class="headerlink" title="启动Redis"></a>启动Redis</h2><p>&emsp;&emsp;在<code>/usr/local/bin</code>目录下启动Redis，并使用之前修改后的配置文件：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph2.jpg" alt="avatar"></p>
<p>&emsp;&emsp;使用<code>redis-cli</code>进行连接并验证Redis服务是否正常启动：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph3.jpg" alt="avatar"></p>
<p>&emsp;&emsp;输入<code>Ping</code>后返回<code>Pong</code>说明连接成功。</p>
<p>&emsp;&emsp;查看redis进程是否开启：</p>
<p><img lazyload src="/images/loading.svg" data-src="graphAlph4.jpg" alt="avatar"></p>
<h2 id="关闭Redis服务"><a href="#关闭Redis服务" class="headerlink" title="关闭Redis服务"></a>关闭Redis服务</h2><p>&emsp;&emsp;使用<code>shutdown</code>命令关闭服务：</p>
<p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/5.jpg" alt="avatar"></p>
<h1 id="Redis-benchmark"><a href="#Redis-benchmark" class="headerlink" title="Redis-benchmark"></a>Redis-benchmark</h1><p>&emsp;&emsp;官方自带的性能测试工具，redis 性能测试工具可选参数如下所示：</p>
<p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/6.jpg" alt="avatar"></p>
<p>&emsp;&emsp;简单测试下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试：100个并发连接，每个并发100000个请求</span></span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br></pre></td></tr></table></figure>

<p>测试结果如下图所示：</p>
<p><img lazyload src="/images/loading.svg" data-src="%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/7.jpg" alt="avatar"></p>
<h1 id="Redis的基础知识"><a href="#Redis的基础知识" class="headerlink" title="Redis的基础知识"></a>Redis的基础知识</h1><p>&emsp;&emsp;Redis有16个数据库，默认使用第一个数据库，可以使用select切换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 3  <span class="comment"># 切换成3号数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; dbsize  <span class="comment"># 查看数据库的大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;切换回0号数据库后查看其大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; select 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;hongjiahao&quot;</span></span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;查看数据库所有的key：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;mylist&quot;</span></span><br><span class="line">2) <span class="string">&quot;myhash&quot;</span></span><br><span class="line">3) <span class="string">&quot;key:__rand_int__&quot;</span></span><br><span class="line">4) <span class="string">&quot;name&quot;</span></span><br><span class="line">5) <span class="string">&quot;counter:__rand_int__&quot;</span></span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;清空当前数据库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;清空全部数据库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name hongjiahao  <span class="comment"># 在0号数据库插入键值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;hongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; select 3	<span class="comment"># 切换到3号数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; flushall		<span class="comment"># 清空所有数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; select 0		<span class="comment"># 切回到0号数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *		<span class="comment"># 查看0号数据库的所有键值</span></span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Redis是单线程的！</p>
</blockquote>
<p>Redis很快，官方表示Redis是基于内存操作的，CPU不是其性能瓶颈，Redis的性能瓶颈时根据机器的内存和网络带宽决定的，所以可以使用单线程的方案来实现。</p>
<p>Redis是C语言写的，官方提供的数据是100000+ QPS，完全不比同样是使用key-value的Memecache差。</p>
<p><strong>Redis为什么是单线程但还很快？</strong></p>
<p>误区一：高性能的服务器一定是多线程的</p>
<p>误区二：多线程一定比单线程快</p>
<p>核心：Redis将全部的数据放在内存中，所以使用单线程来操作效率就是最高的，如果使用多线程，反而会因为上下文切换而降低其效率。</p>
<h1 id="Redis五大数据类型"><a href="#Redis五大数据类型" class="headerlink" title="Redis五大数据类型"></a>Redis五大数据类型</h1><blockquote>
<p>Redis是一个开源（BSD许可）的内存数据结构存储，被用作数据库、缓存和消息代理。Redis提供的数据结构包括：字符串、哈希值、列表、集合、带范围查询的排序集合、位图、超日志、地理空间索引和流。Redis有内置的复制、Lua脚本、LRU驱逐、事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster的自动分区提供高可用性。</p>
</blockquote>
<p>&emsp;&emsp;查看某个key是否存在&amp;移除某个键值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name hongjiahao</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 24</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists name  <span class="comment"># 查看name作为key是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; exists name1 <span class="comment"># 查看name1作为key是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; move name 1  <span class="comment"># 移除name</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;设置过期时间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name hongjiahao</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;hongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; expire name 10 <span class="comment"># 设置name在10秒之后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name <span class="comment"># 查看还有几秒name过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) -2	<span class="comment"># 返回-2，name已过期</span></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;查看当前key的类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name hongjiahao</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> name  <span class="comment"># 查看当前key的类型</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> age</span><br><span class="line">string</span><br></pre></td></tr></table></figure>



<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><h3 id="append、strlen"><a href="#append、strlen" class="headerlink" title="append、strlen"></a>append、strlen</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;hongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; append name 1997  <span class="comment"># 在键值对中追加字符串,如果key不存在，相当于set了一个新key</span></span><br><span class="line">(<span class="built_in">integer</span>) 14</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;hongjiahao1997&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; strlen name		<span class="comment"># 获取字符串长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 14</span><br></pre></td></tr></table></figure>

<h3 id="incr、decr、incrby、decrby"><a href="#incr、decr、incrby、decrby" class="headerlink" title="incr、decr、incrby、decrby"></a>incr、decr、incrby、decrby</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> views 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr views  <span class="comment"># views中的值加一</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr views	<span class="comment"># views中的值减一</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incrby views 10 <span class="comment"># views中的值加10</span></span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decrby views 5	<span class="comment"># views中的值减5</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="getrange、strange、setex、sent、meet、mget、对象、getset"><a href="#getrange、strange、setex、sent、meet、mget、对象、getset" class="headerlink" title="getrange、strange、setex、sent、meet、mget、对象、getset"></a>getrange、strange、setex、sent、meet、mget、对象、getset</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 hello,hongjiahao</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; getrange k1 0 3	<span class="comment"># 截取k1的0到3号索引</span></span><br><span class="line"><span class="string">&quot;hell&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange k1 0 -1 <span class="comment"># 截取k1整串</span></span><br><span class="line"><span class="string">&quot;hello,hongjiahao&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setrange:替换指定位置开始的字符</span></span><br><span class="line">127.0.0.1:6379&gt; setrange k1 1 a <span class="comment"># 将索引为1的字符替换为a</span></span><br><span class="line">(<span class="built_in">integer</span>) 16</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;hallo,hongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setrange k1 1 aaa <span class="comment"># 将索引为1的字符替换为aaa</span></span><br><span class="line">(<span class="built_in">integer</span>) 16</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;haaao,hongjiahao&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># setex(set with expire)  设置过期时间</span></span><br><span class="line"><span class="comment"># setnx(set if not exists)   不存在再设置(在分布式锁中常用)</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; setex k2 30 <span class="string">&quot;hello&quot;</span>  <span class="comment"># 设置一个键值对，并使其生命周期为30秒</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ttl k2</span><br><span class="line">(<span class="built_in">integer</span>) 23</span><br><span class="line">127.0.0.1:6379&gt; ttl k2</span><br><span class="line">(<span class="built_in">integer</span>) 18</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; setnx k3 <span class="string">&quot;Redis&quot;</span>	<span class="comment"># 若k3不存在，则初始化一个键值对</span></span><br><span class="line">(<span class="built_in">integer</span>) 1		<span class="comment"># 成功</span></span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line"><span class="string">&quot;Redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setnx k3 <span class="string">&quot;MangoDB&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0		<span class="comment"># 失败</span></span><br><span class="line">127.0.0.1:6379&gt; get k3		<span class="comment"># 若直接使用set k3 MangoDB，会覆盖掉之前设置的Redis</span></span><br><span class="line"><span class="string">&quot;Redis&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># mset	批量设置键值对</span></span><br><span class="line"><span class="comment"># mget	批量打印键值对</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># msetnx	批量设置（所有都不存在才初始化），是一个原子性的操作，要么一起成功，要么一起失败</span></span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 vv1 k2 vv2 k3 vv3 k4 vv4</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3 k4</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">4) (nil)</span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># 对象</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> user:1 &#123;name:lisi,age:13&#125; <span class="comment"># 设置一个user对象，值为json字符来保存一个对象</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get user:1</span><br><span class="line"><span class="string">&quot;&#123;name:lisi,age:13&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种巧妙的方式：user:&#123;id&#125;:&#123;field&#125;，如此设置在Redis中是完全ok的</span></span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 12</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">2) <span class="string">&quot;12&quot;</span></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># getset	# 先获取，再设置。如果不存在值，则返回nil，如果存在值，先返回原来值，再设置新的值</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; getset db Redis</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;Redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getset db mangodb</span><br><span class="line"><span class="string">&quot;Redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;mangodb&quot;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;String类型的使用场景：value除了是字符串还能是数字</p>
<ul>
<li>计数器</li>
<li>统计多单位的数量（eg.: set User:9999:follow 20000）</li>
<li>对象缓存存储</li>
</ul>
<h2 id="List类型-列表"><a href="#List类型-列表" class="headerlink" title="List类型(列表)"></a>List类型(列表)</h2><p>&emsp;&emsp;基本的数据类型，列表。在Redis中，可以使用List实现栈、队列、阻塞队列。所有的List命令都是L开头的。</p>
<h3 id="LPUSH、RPUSH、LRANGE"><a href="#LPUSH、RPUSH、LRANGE" class="headerlink" title="LPUSH、RPUSH、LRANGE"></a>LPUSH、RPUSH、LRANGE</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># LPUSH   向列表的左端插入</span></span><br><span class="line"><span class="comment"># RPUSH   向列表的右端插入</span></span><br><span class="line"><span class="comment"># LRANGE  获取列表中指定区间的值</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSH list one	<span class="comment"># 将一个或多个值插入到列表的头部（左插）</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1  <span class="comment"># 获取list中的所有值</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 1	 <span class="comment"># 获取list中的指定值</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPUSH list four	<span class="comment"># 将一个或多个值插入到列表的头部（右插）</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;four&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="LPOP、LINDEX"><a href="#LPOP、LINDEX" class="headerlink" title="LPOP、LINDEX"></a>LPOP、LINDEX</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># LPOP  最左端的值出队</span></span><br><span class="line"><span class="comment"># LINDEX 获取列表的某一个值</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPOP list <span class="comment"># 移除列表的左端第一个元素</span></span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;four&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP list <span class="comment"># 移除列表的右端第一个元素</span></span><br><span class="line"><span class="string">&quot;four&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX list 0  <span class="comment"># 获取第一个值</span></span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="Llen、Lrem、Ltrim"><a href="#Llen、Lrem、Ltrim" class="headerlink" title="Llen、Lrem、Ltrim"></a>Llen、Lrem、Ltrim</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># Llen 返回列表的长度</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Llen list</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># Lrem  移除指定值</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">4) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Lrem list 1 one		<span class="comment"># 移除1个one</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; Lrem list 2 three	<span class="comment"># 移除2个three</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># Ltrim  截取指定区间内的值更新list</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello1&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello2&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist <span class="string">&quot;hello3&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello2&quot;</span></span><br><span class="line">4) <span class="string">&quot;hello3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ltrim mylist 1 2	<span class="comment"># 截取索引[1,2]的值并修改List</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello2&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="组合命令，例如RPOPLPUSH"><a href="#组合命令，例如RPOPLPUSH" class="headerlink" title="组合命令，例如RPOPLPUSH"></a>组合命令，例如RPOPLPUSH</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># RPOPLPUSH  移除列表最后一个元素并将其添加到新的列表</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH mylist myotherlist <span class="comment"># 移除mylist列表最后一个元素并将其添加到myotherlist列表</span></span><br><span class="line"><span class="string">&quot;hello2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE myotherlist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>



<h3 id="更新Lset、插入Linsert"><a href="#更新Lset、插入Linsert" class="headerlink" title="更新Lset、插入Linsert"></a>更新Lset、插入Linsert</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># lset 向一个已经存在的列表中添加值（指定已存在的索引），相当于更新操作</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exists list</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item</span><br><span class="line">(error) ERR no such key  <span class="comment"># 如果不存在列表，则会报错</span></span><br><span class="line">127.0.0.1:6379&gt; lpush list value  <span class="comment"># list: [value]</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) <span class="string">&quot;value&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item <span class="comment"># 相当于间接做了更新操作</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 0</span><br><span class="line">1) <span class="string">&quot;item&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 1 other <span class="comment"># 不存在该索引的位置，添加错误</span></span><br><span class="line">(error) ERR index out of range</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># linsert (linsert key BEFORE|AFTER pivot element) 向一个列表中某个元素的前/后插入新值</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist world</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; linsert mylist before <span class="string">&quot;world&quot;</span> <span class="string">&quot;,&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;,&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; linsert mylist after world !</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;,&quot;</span></span><br><span class="line">3) <span class="string">&quot;world&quot;</span></span><br><span class="line">4) <span class="string">&quot;!&quot;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>实际上是一个双端链表，可以在节点的前后插入新节点</li>
<li>如果key不存在，需要先创建之后再更改或添加</li>
<li>如果移除了一个链表中的所有值，那么就变成了空链表，也就代表它不存在了</li>
<li>在链表的两端插入或改动值，效率最高。中间的元素效率会相对低一些</li>
<li>作为消息队列：LPUSH  RPOP；作为栈：LPUSH  LPOP</li>
</ul>
<h2 id="Set类型-集合"><a href="#Set类型-集合" class="headerlink" title="Set类型(集合)"></a>Set类型(集合)</h2><p>&emsp;&emsp;Set中的值是不能重复的！Set的命令开头基本都是S。</p>
<h3 id="Sadd、Smembers、Sismember"><a href="#Sadd、Smembers、Sismember" class="headerlink" title="Sadd、Smembers、Sismember"></a>Sadd、Smembers、Sismember</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># sadd 向集合中添加元素</span></span><br><span class="line"><span class="comment"># smembers 查看置顶集合中的所有元素</span></span><br><span class="line"><span class="comment"># sismember 判断某个元素是否在指定的集合中</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hellohongjiahao&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hognjiahao&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;hognjiahao&quot;</span></span><br><span class="line">3) <span class="string">&quot;hellohongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sismember myset hello <span class="comment"># 存在则返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember myset hhh	<span class="comment"># 不存咋则返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;hello&quot;</span> <span class="comment"># 元素“hello”已存在，添加失败，返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>



<h3 id="Scard、Srem"><a href="#Scard、Srem" class="headerlink" title="Scard、Srem"></a>Scard、Srem</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># scard 获取指定集合中的元素个数</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; scard myset	<span class="comment"># 查看元素个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; srem myset hello  <span class="comment"># 移除hello</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember myset hello</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>



<h3 id="Srandmember、Spop"><a href="#Srandmember、Spop" class="headerlink" title="Srandmember、Spop"></a>Srandmember、Spop</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># srandmember 随机获取元素</span></span><br><span class="line"><span class="comment"># spop 随机移除元素</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;hellohongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;hellohongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;hognjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">&quot;hellohongjiahao&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;wuxingyi&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;hognjiahao&quot;</span></span><br><span class="line">4) <span class="string">&quot;hellohongjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line"><span class="string">&quot;hognjiahao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;wuxingyi&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;hellohongjiahao&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="Smove"><a href="#Smove" class="headerlink" title="Smove"></a>Smove</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># smove  将一个元素移到另一个集合中</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd myset1 hello world !</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 xixi haha fuck</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; smove myset1 myset2 hello <span class="comment"># 将myset1中的hello移到myset2中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset1</span><br><span class="line">1) <span class="string">&quot;world&quot;</span></span><br><span class="line">2) <span class="string">&quot;!&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) <span class="string">&quot;haha&quot;</span></span><br><span class="line">2) <span class="string">&quot;xixi&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">4) <span class="string">&quot;fuck&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li>差集Sdiff</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># sdiff A B 所有属于A集合但不属于B集合的元素</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sadd myset1 a b c d</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 a w d s c</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure>



<ul>
<li>交集Sinter</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># sinter A B  A和B集合的交集</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sinter myset1 myset2</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;d&quot;</span></span><br><span class="line">3) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>并集Sunion</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="comment"># sunion A B  A和集合B的并集</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sunion myset1 myset2</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;w&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;s&quot;</span></span><br><span class="line">5) <span class="string">&quot;c&quot;</span></span><br><span class="line">6) <span class="string">&quot;d&quot;</span></span><br></pre></td></tr></table></figure>



<p>应用：</p>
<p>可以将A用户所有的关注up的uid放在一个set中，A的粉丝的uid放在另一个set中。</p>
<p>例如：共同关注，共同爱好，推荐好友</p>
<h2 id="Hash类型-哈希"><a href="#Hash类型-哈希" class="headerlink" title="Hash类型(哈希)"></a>Hash类型(哈希)</h2><p>&emsp;&emsp;Map集合，key-map集合，类似<code>key-&#123;&#123;key1,value1&#125;,&#123;key1,value2&#125;,...&#125;</code>，但本质和string类型没有太大区别，还是一个简单的key-value。</p>
<h3 id="Hset、Hget、Hmset、Hmget、Hgetall、Hdel"><a href="#Hset、Hget、Hmset、Hmget、Hgetall、Hdel" class="headerlink" title="Hset、Hget、Hmset、Hmget、Hgetall、Hdel"></a>Hset、Hget、Hmset、Hmget、Hgetall、Hdel</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># hset	设置一个具体的key-value</span></span><br><span class="line"><span class="comment"># hget	获取一个具体的key的value</span></span><br><span class="line"><span class="comment"># hmset	同时设置多个字段值</span></span><br><span class="line"><span class="comment"># hmget	同时获取多个key下的value</span></span><br><span class="line"><span class="comment"># hgetall 同时获得所有字段值</span></span><br><span class="line"><span class="comment"># hdel	删除某个指定的字段</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> myhash field1 hongjiahao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash field1</span><br><span class="line"><span class="string">&quot;hongjiahao&quot;</span></span><br><span class="line">hmset myhash field1 hello field2 world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget myhash field1 field2	<span class="comment"># &quot;hongjiahao&quot;被覆盖</span></span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;field2&quot;</span></span><br><span class="line">4) <span class="string">&quot;world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash field1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;field2&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="Hlen、Hexists、Hkeys、Hvals"><a href="#Hlen、Hexists、Hkeys、Hvals" class="headerlink" title="Hlen、Hexists、Hkeys、Hvals"></a>Hlen、Hexists、Hkeys、Hvals</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># hlen	获取hash表的字段数量</span></span><br><span class="line"><span class="comment"># hexists	判断哈希表中的指定字段是否存在</span></span><br><span class="line"><span class="comment"># hkeys	获取哈希表的所有key</span></span><br><span class="line"><span class="comment"># hvals 获取哈希表的所有value</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hmset myhash field1 hello field2 world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hlen myhash</span><br><span class="line">(<span class="built_in">integer</span>) 2	</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field1	<span class="comment"># 存在field1字段，返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field3	<span class="comment"># 不存在field2字段，返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash	<span class="comment"># 获取哈希表的所有key</span></span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;field2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hvals myhash	<span class="comment"># 获取哈希表的所有value</span></span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="Hincrby、Hsetnx"><a href="#Hincrby、Hsetnx" class="headerlink" title="Hincrby、Hsetnx"></a>Hincrby、Hsetnx</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># hincrby 哈希表中指定字段的value加减</span></span><br><span class="line"><span class="comment"># hsetnx 如果不存在则设置</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hset myhash field3 5</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash field3 1</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash field3 -1</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field4 hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field4 world</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;field1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;field2&quot;</span></span><br><span class="line">4) <span class="string">&quot;world&quot;</span></span><br><span class="line">5) <span class="string">&quot;field3&quot;</span></span><br><span class="line">6) <span class="string">&quot;5&quot;</span></span><br><span class="line">7) <span class="string">&quot;field4&quot;</span></span><br><span class="line">8) <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;hash用于变更的数据 user{ name, age, hobby, …}，尤其是用户信息的保存，或经常变化的信息。hash更适合对象的存储，string更加适合字符串的存储。</p>
<h3 id="Zset类型（有序集合）"><a href="#Zset类型（有序集合）" class="headerlink" title="Zset类型（有序集合）"></a>Zset类型（有序集合）</h3><p>&emsp;&emsp;在set的基础上，增加了一个值<code>score</code>用于记录key的优先级。</p>
<h3 id="Zadd、Zrange、Zrangebyscore、Zrevrange"><a href="#Zadd、Zrange、Zrangebyscore、Zrevrange" class="headerlink" title="Zadd、Zrange、Zrangebyscore、Zrevrange"></a>Zadd、Zrange、Zrangebyscore、Zrevrange</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># zadd 添加字段</span></span><br><span class="line"><span class="comment"># zrange 按索引查找</span></span><br><span class="line"><span class="comment"># zrangebyscore 按照set字段的优先级排序(默认由低到高排序)</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 two</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 3 three 4 four</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange myset 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">4) <span class="string">&quot;four&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 2500 xiaohong</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 5000 zhangsan</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 500 kuangshen</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf  <span class="comment"># 按照薪水的优先级排序（范围负无穷到正无穷）</span></span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">3) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrevrange salary 0 -1	<span class="comment"># 从大到小排序</span></span><br><span class="line">1) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">2) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">3) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf withscores <span class="comment"># 加上优先级</span></span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line">5) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">6) <span class="string">&quot;5000&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf 2500 withscores <span class="comment"># 上界是2500的情况</span></span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">3) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">4) <span class="string">&quot;2500&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf (2500 withscores <span class="comment"># 上界2500是开区间，不能包含在内</span></span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;500&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary (500 2500 withscores <span class="comment"># 下界500是开区间，不能包含在内</span></span><br><span class="line">1) <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">2) <span class="string">&quot;2500&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="Zrem、Zcard、Zcount"><a href="#Zrem、Zcard、Zcount" class="headerlink" title="Zrem、Zcard、Zcount"></a>Zrem、Zcard、Zcount</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">########################################################################################</span></span><br><span class="line"><span class="comment"># zrem  移除set中的指定元素</span></span><br><span class="line"><span class="comment"># zcard 获取有序集合中的元素个数</span></span><br><span class="line"><span class="comment"># zcount 获取指定区间的成员数量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrem salary xiaohong</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;kuangshen&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zcard salary</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 hello 2 world 3 hongjiahao</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>



<p>其余的一些API可以通过官方文档查看</p>
<p>案例思路：set 排序（用于存储班级成绩表，工资表排序）</p>
<p>​                    普通消息（1），重要消息（2），带权重进行判断</p>
<p>​                    排行榜应用实现</p>
<h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h3><p>朋友的定位，附近的人，打车距离计算</p>
<p>Redis的Geo在Redis的3.2版本就已经推出了。该功能可以推算地理位置的信息，两地之间的距离，方圆几里的人。</p>
<p>查询城市经纬度的网站：<a class="link" href="http://www.jsons.cn/lngcode/">http://www.jsons.cn/lngcode/<i class="fas fa-external-link-alt"></i></a></p>
<p>只有6个命令。</p>
<h4 id="geoadd：添加地理位置"><a href="#geoadd：添加地理位置" class="headerlink" title="geoadd：添加地理位置"></a>geoadd：添加地理位置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># geoadd 添加城市数据（经纬度）</span></span><br><span class="line"><span class="comment"># 规则：两级无法直接添加，一般会下载城市数据然后一次性导入</span></span><br><span class="line"><span class="comment"># 参数：注意经纬度的有效范围</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 114.05 22.52 shenzhen 120.16 30.24 hangzhou 108.96 34.26 xian</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>



<h4 id="geopos：查找指定的成员位置"><a href="#geopos：查找指定的成员位置" class="headerlink" title="geopos：查找指定的成员位置"></a>geopos：查找指定的成员位置</h4><p>获得当前定位：一定是个坐标值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># geopos： 获取指定的经纬度</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geopos china:city beijing chongqing</span><br><span class="line">1) 1) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">   2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="geodist：两人之间的直线距离"><a href="#geodist：两人之间的直线距离" class="headerlink" title="geodist：两人之间的直线距离"></a>geodist：两人之间的直线距离</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai</span><br><span class="line"><span class="string">&quot;1067378.7564&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai km <span class="comment"># 单位：km</span></span><br><span class="line"><span class="string">&quot;1067.3788&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="georadius：以给定的经纬度为中心，找出某一半径内的元素"><a href="#georadius：以给定的经纬度为中心，找出某一半径内的元素" class="headerlink" title="georadius：以给定的经纬度为中心，找出某一半径内的元素"></a>georadius：以给定的经纬度为中心，找出某一半径内的元素</h4><p>我附近的人？（获得所有附近的人的地址：定位），然后通过半径来查询</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km <span class="comment"># 以（110，30）为中心，找出半径1000km内的城市</span></span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withdist <span class="comment"># 显示距离</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) <span class="string">&quot;341.9374&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) <span class="string">&quot;483.8340&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord <span class="comment"># 显示坐标</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord count 1 <span class="comment"># 只查询一个</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord count 2 <span class="comment"># 查询两个</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="georadiusbymember：根据具体的元素查询"><a href="#georadiusbymember：根据具体的元素查询" class="headerlink" title="georadiusbymember：根据具体的元素查询"></a>georadiusbymember：根据具体的元素查询</h4><p>具体功能和上面一致，不过使用具体的成员代替坐标位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># georadiusbymember：查找位于指定元素指定距离的元素</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km</span><br><span class="line">1) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="geohash：返回一个或多个位置元素的Geohash表示"><a href="#geohash：返回一个或多个位置元素的Geohash表示" class="headerlink" title="geohash：返回一个或多个位置元素的Geohash表示"></a>geohash：返回一个或多个位置元素的Geohash表示</h4><p>该命令将返回11个字符的Geohash字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># geohash：将二维的经纬度转换成一维的字符串，两个字符串越接近表示两个地点位置越近</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geohash china:city beijing chongqing</span><br><span class="line">1) <span class="string">&quot;wx4fbxxfke0&quot;</span></span><br><span class="line">2) <span class="string">&quot;wm5xzrybty0&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="底层的实现原理Zset"><a href="#底层的实现原理Zset" class="headerlink" title="底层的实现原理Zset"></a>底层的实现原理Zset</h4><p>可以使用Zset命令来操作Geo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1 <span class="comment"># 查看地图中全部的元素</span></span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span> </span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">5) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">6) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem china:city beijing <span class="comment"># 移除beijing</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">5) <span class="string">&quot;shanghai&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><p>什么是基数？</p>
<p>A{1,3,5,7,8,7}</p>
<p>B{1,3,5,7,8}</p>
<p>基数（不重复的元素的数量）：A的基数：4；B的基数：5</p>
<p>Redis Hyperloglog 用于基数统计</p>
<p>优点：占用的内存是固定的，2^64不同的元素，只需要12KB内存。如果要从内存的角度来比较，Hyperloglog就是首选。</p>
<p>有0.81%的错误率。</p>
<p>使用场景：</p>
<p>网页的UV（unique visitor）：一个人访问一个网站多次，但还是只算做一个访问者。传统的方式中，用set保存用户的id，然后可以统计set中的元素数量作为判断标准。这个方式如果保存大量的用户id，就会占用较大的存储。我们的目的是计数，而不是保存用户id。</p>
<h4 id="PFadd、PFcount、PFmerge"><a href="#PFadd、PFcount、PFmerge" class="headerlink" title="PFadd、PFcount、PFmerge"></a>PFadd、PFcount、PFmerge</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PFadd  创建一组元素</span></span><br><span class="line"><span class="comment"># PFcount 统计一组元素中的基数</span></span><br><span class="line"><span class="comment"># PFmerge 合并几组元素到指定组中</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; PFadd mykey a b c d e f g h i j</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFcount mykey</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; PFadd mykey2 i j z x c v b n m</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFcount mykey2</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE mykeys mykey mykey2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFcount mykeys</span><br><span class="line">(<span class="built_in">integer</span>) 15</span><br></pre></td></tr></table></figure>



<h3 id="Bitmaps：位存储"><a href="#Bitmaps：位存储" class="headerlink" title="Bitmaps：位存储"></a>Bitmaps：位存储</h3><h4 id="setbit"><a href="#setbit" class="headerlink" title="setbit"></a>setbit</h4><p>使用bitmaps记录周一到周日的打卡情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 7 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<h4 id="getbit"><a href="#getbit" class="headerlink" title="getbit"></a>getbit</h4><p>查看某一天是否打卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 4</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h4 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a>bitcount</h4><p>统计打卡的天数</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>



<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>原子性：要么同时成功，要么同时失败！</p>
<p>关系型数据库保证了原子性，Redis的单条命令是保证原子性的，但是事务不保证原子性。</p>
<p>Redis事务的本质：一组命令的集合。一个事务中的所有命令都会被序列化，在事务的执行过程中，会按照顺序执行。一次性、顺序性、排他性。Redis事务没有隔离级别的概念，所有的命令在事务中，没有直接执行，只有发起执行命令的时候才会执行。</p>
<p>Redis的事务：</p>
<ul>
<li>开启事务（Multi）</li>
<li>命令入队（…）</li>
<li>执行事务（exec）</li>
</ul>
<p>锁：Redis可以实现乐观锁</p>
<p>正常执行事务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; multi	</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br><span class="line">4) OK</span><br></pre></td></tr></table></figure>



<p>放弃事务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k4	<span class="comment"># 事务队列中的命令不会被执行</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>



<p>编译性错误：命令有错，事务中的所有命令都不会被执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; getset k3 <span class="comment"># 错误的命令</span></span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;getset&#x27;</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k5 v5</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>	<span class="comment"># 执行事务时报错，所有的命令都不会被执行</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; get k5</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>



<p>运行时异常，如果事务队列中存在语法性错误，那么执行命令的时候，其他命令还可以正常执行，错误的命令会抛出异常。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 <span class="string">&quot;v1&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line"><span class="comment"># 虽然第一条命令报错了，但是事务依旧执行成功了</span></span><br><span class="line">1) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p><strong>悲观锁：</strong></p>
<ul>
<li>悲观锁：很悲观，什么时候都会出问题，无论做什么都加锁</li>
</ul>
<p><strong>乐观锁：</strong></p>
<ul>
<li>乐观锁：很乐观，认为什么时候都不会出现问题，所以不会上锁。更新数据的时候判断一下，在此期间是否有人修改过这个数据</li>
<li>获取version</li>
<li>更新的时候比较version</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money  <span class="comment"># 监视money对象</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI	<span class="comment"># 事务正常结束，数据期间没有发生变动，这个时候就正常执行</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure>

<p>正常执行成功</p>
<p>测试多线程修改完值，使用watch可以当作redis的乐观锁操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 线程2</span></span><br><span class="line">127.0.0.1:6379&gt; get money</span><br><span class="line"><span class="string">&quot;80&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 1000</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 线程1</span></span><br><span class="line">127.0.0.1:6379&gt; watch money	<span class="comment"># 监视money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; DECRBY money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY out 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC	<span class="comment"># 执行之前，另外一个线程修改了money的值，会导致事务执行失败</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; UNWATCH	 <span class="comment"># 解锁</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money	<span class="comment"># 重新加锁</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI	<span class="comment"># 开启新事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; DECRBY money 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY money 1</span><br><span class="line">QUEUED	</span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC	<span class="comment"># 比对监视的值是否发生了变化，如果没有发生变化，可以执行成功</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 999</span><br><span class="line">2) (<span class="built_in">integer</span>) 1000</span><br></pre></td></tr></table></figure>

<p>如果修改失败，获取最新的值就好。</p>
<h2 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h2><p>1、配置文件 unit单位，对大小写不敏感</p>
<p>2、包含</p>
<p>3、网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1  <span class="comment"># 绑定的ip</span></span><br><span class="line">protected-mode yes	<span class="comment"># 保护模式</span></span><br><span class="line">port 6379	<span class="comment"># 端口设置</span></span><br></pre></td></tr></table></figure>



<p>4、通用设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">daemonize yes	<span class="comment"># 以守护进程的方式运行，默认是no，需要自己开启为yes</span></span><br><span class="line">pidfile /var/run/redis_6379.pid  <span class="comment"># 如果以后台的方式运行，需要指定一个进程文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="comment"># Specify the server verbosity level.</span></span><br><span class="line"><span class="comment"># This can be one of:</span></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably)</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel notice	<span class="comment"># 启动记录日志的级别</span></span><br><span class="line">logfile <span class="string">&quot;&quot;</span>	<span class="comment"># 生成的日志文件位置及文件名</span></span><br><span class="line">databases 16	<span class="comment"># 数据库的数量：16个</span></span><br><span class="line">always-show-logo no  <span class="comment"># 是否总是显示logo</span></span><br></pre></td></tr></table></figure>



<p>5、快照</p>
<p>redis是内存数据库，如果没有持久化，那么数据断电即失</p>
<p>持久化：在规定的时间内执行了多少次操作后，会持久化到 .rdb  .aof</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果3600内，如果至少有一个key进行了修改，就进行持久化操作</span></span><br><span class="line">save 3600 1</span><br><span class="line"><span class="comment"># 如果300内，如果至少有100个key进行了修改，就进行持久化操作</span></span><br><span class="line">save 300 100</span><br><span class="line"><span class="comment"># 如果60内，如果至少有10000个key进行了修改，就进行持久化操作</span></span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes  <span class="comment"># 持久化如果出错，是否还要持续工作</span></span><br><span class="line">rdbcompression yes	<span class="comment"># 是否压缩.rdb文件，需要消耗一些cpu资源</span></span><br><span class="line">rdbchecksum yes	<span class="comment"># 保存.rdb文件时进行错误校验</span></span><br><span class="line"></span><br><span class="line">dir /usr/<span class="built_in">local</span>/var/db/redis/   <span class="comment"># .rdb文件保存的目录</span></span><br></pre></td></tr></table></figure>



<p>6、REPLICATION（主从复制）</p>
<p>7、安全</p>
<p>可以设置redis的密码，默认是没有密码的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass <span class="string">&quot;hjh1314lvwxy&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;hjh1314lvwxy&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务后</span></span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth hjh1314lvwxy</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;hjh1314lvwxy&quot;</span></span><br></pre></td></tr></table></figure>



<p>8、CLIENTS限制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">maxclients 10000 	<span class="comment"># 设置能连接上redis的最大客户端的数量</span></span><br><span class="line">maxmemory &lt;bytes&gt;	<span class="comment"># redis配置最大的内存容量</span></span><br><span class="line">maxmemory-policy noeviction	<span class="comment"># 内存大道上限之后的处理策略</span></span><br></pre></td></tr></table></figure>



<p>9、APPEND ONLY MODE  aof配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly no	<span class="comment"># 默认不开启aof模式，默认使用rdb方式持久化</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span>	<span class="comment"># 持久化文件的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always	# 每次修改都会sync，消耗性能</span></span><br><span class="line">appendfsync everysec	<span class="comment"># 每秒执行一次sync，可能会丢失这一秒的数据</span></span><br><span class="line"><span class="comment"># appendfsync no		# 不执行sync，这时候操作系统自己同步数据，速度最快</span></span><br></pre></td></tr></table></figure>



<h2 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h2><h3 id="RDB（Redis-Database）"><a href="#RDB（Redis-Database）" class="headerlink" title="RDB（Redis Database）"></a>RDB（Redis Database）</h3><p>&emsp;&emsp;Redis是内存数据库，如果不将内存中的数据库状态保存在磁盘，一旦服务器退出进程，服务器中的数据库状态也会消失。所以Redis提供了持久化功能。</p>
<p>&emsp;&emsp;在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是Snapshot快照，它会腐蚀是将快照文件直接读到内存当中。</p>
<p>&emsp;&emsp;Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入一个临时文件中，待持久化过程都结束了，再用这个临时文件替换掉上次持久化好的文件。整个过程中，主进程不进行任何OI操作。这就确保了极高的性能。如果需进行大规模的数据恢复，且对于数据恢复的完整性不是特别敏感，那RDB方式要比AOF更加高效。RDB的缺点是最后一次持久化的数据可能丢失。</p>
<p>&emsp;&emsp;rdb保存的文件是dump.rdb，可以在配置文件的快照项下修改。修改持久化的频率为：每60秒进行了5次操作就保存一次。</p>
<p><img lazyload src="/images/loading.svg" data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/8.jpg" alt="avatar"></p>
<p>&emsp;&emsp;下图设置了dump.rdb的保存地址。</p>
<p><img lazyload src="/images/loading.svg" data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/9.jpg" alt="avatar"></p>
<h4 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h4><p>1、save的规则满足的情况下，会自动触发rdb规则</p>
<p>2、执行flushall命令，会触发rdb规则</p>
<p>3、退出redis，会产生rdb文件</p>
<h4 id="恢复rdb文件"><a href="#恢复rdb文件" class="headerlink" title="恢复rdb文件"></a>恢复rdb文件</h4><p>1、只需将rdb文件放到redis的启动项中</p>
<p>2、查看需要存放的位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir  <span class="comment"># 查看rdb文件的启动地址</span></span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/usr/local/var/db/redis&quot;</span> <span class="comment"># 如果在这个目录下存在rdb文件，启动时就会自动恢复其中的数据</span></span><br></pre></td></tr></table></figure>



<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1、适合大规模的数据恢复</p>
<p>2、对数据的完整性要求不高</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1、需要一定的时间间隔进行自动化保存，如果redis意外宕机了，最后一次修改的数据就没了</p>
<p>2、fork进程的时候，会占用一定的内存空间</p>
<h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><p>&emsp;&emsp;将我们的所有命令记录下来（history），恢复的时候再重新执行记录的命令。</p>
<p>&emsp;&emsp;以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据结构，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<p>&emsp;&emsp;AOF保存的是appendonly.aof文件。AOF模式默认是不开启的，需要手动设置开启。只需要将appendonly改为yes就可以开启aof。</p>
<p> <img lazyload src="/images/loading.svg" data-src="%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88%E4%B8%8E%E8%AE%BE%E8%AE%A1/10.jpg" alt="avatar"></p>
<p>&emsp;&emsp;appendonly.aof的保存路径如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir  <span class="comment"># 查看rdb文件的启动地址</span></span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/usr/local/var/db/redis&quot;</span> <span class="comment"># 如果在这个目录下存在rdb文件，启动时就会自动恢复其中的数据</span></span><br></pre></td></tr></table></figure>



<p>写入的频率</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<p>如果aof文件的大小大雨64mB，会fork一个新的进程来讲文件进行重写。aof默认文件无限追加，文件会越来越大。</p>
<p>&emsp;&emsp;如果appendonly.aof文件有错误，此时redis是启动不起来的，需要先修复这个aof文件。redis为我们提供了一个工具：<code>redis-check-aof</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure>

<p>如果文件正常，重启即可直接恢复了。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>1、每一次修改都同步，文件的完整性会更加好</p>
<p>2、每秒同步一次，可能只会丢失一秒的数据</p>
<p>3、从不同步，效率最高</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>1、相对于数据文件来说，aof远远大于rdb，恢复的速度也比rdb慢</p>
<p>2、aof运行效率也要比rdb慢，所以redis默认采用rdb持久化</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>RDb持久化方式能够在指定的时间间隔内对数据进行快照存储</li>
<li>AOF持久化方式记录每次对服务器的写操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis协议追加每次写的操作到文件末尾，Redis还能对后台进行重写，是的AOF文件的体积不至于过大</li>
<li>只做缓存，如果你希望你的数据只在服务器端存在，可以不使用任何持久化</li>
<li>同时开启两种持久化方式<ul>
<li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要更完整</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。但RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的bug。</li>
</ul>
</li>
<li>性能建议<ul>
<li>因为RDB文件只用做后备用途，见一直在slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1 这条规则</li>
<li>如果Enable AOF，好处是在最恶劣的情况下也只会丢失不超多2秒的数据，启动脚本较简单，只需要load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的，只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写默认64mB太小了，可以设到5GB以上，默认超过原大小100%大小重写可以改到适当的数值。</li>
<li>如果不Enable AOF，仅靠 Mater-Slave Replication 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。</li>
</ul>
</li>
</ul>
<h2 id="Redis订阅发布"><a href="#Redis订阅发布" class="headerlink" title="Redis订阅发布"></a>Redis订阅发布</h2><p>订阅端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe JiahaoHong1997  <span class="comment"># 订阅一个频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;JiahaoHong1997&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 等待读取推送的消息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span>	<span class="comment"># 消息</span></span><br><span class="line">2) <span class="string">&quot;JiahaoHong1997&quot;</span>	<span class="comment"># 来自的频道</span></span><br><span class="line">3) <span class="string">&quot;hello,jiahao&quot;</span>	<span class="comment"># 消息的具体内容</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;JiahaoHong1997&quot;</span></span><br><span class="line">3) <span class="string">&quot;ganbadie&quot;</span></span><br></pre></td></tr></table></figure>

<p>发送端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish JiahaoHong1997 <span class="string">&quot;hello,jiahao&quot;</span> <span class="comment"># 发布者发布消息到频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; publish JiahaoHong1997 <span class="string">&quot;ganbadie&quot;</span>	<span class="comment"># 发布者发布消息到频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>



<blockquote>
<p>原理</p>
</blockquote>
<p>&emsp;&emsp;Redis是用C实现的，通过分析Redis源码里的pubsub.c文件，了解发布和订阅机制的底层实现，借此加深对Redis的理解。</p>
<p>&emsp;&emsp;Redis通过publish、subscribe和psubscribe等命令实现发布和订阅功能。通过subscribe命令订阅某频道后，redis-server里维护了一个字典，字典的关键词是一个个channel，而字典的值则是一个链表，链表中保存了所有订阅这个channel的客户端。subscribe命令的关键，就是将客户端添加到给定的channel的订阅列表中。</p>
<p>&emsp;&emsp;通过publish命令向订阅者发送消息，redis-server会使用给定的频道作为键，在它所维护的channel字典中朝着记录了订阅这个频道的所有客户端的链表，链里这个链表，将消息发布给订阅者。</p>
<p>&emsp;&emsp;在Redis中，可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有的订阅它的客户端会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p>
<p>使用场景：</p>
<p>1、实时消息系统</p>
<p>2、实时聊天（频道当作聊天室，将信息回给所有人即可）</p>
<p>3、订阅、关注系统</p>
<p>稍微复杂的场景通常使用消息队列。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL学习笔记</title>
    <url>/2022/01/05/SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MySQL中的SQL是如何执行的"><a href="#MySQL中的SQL是如何执行的" class="headerlink" title="MySQL中的SQL是如何执行的"></a>MySQL中的SQL是如何执行的</h1><p>&emsp;&emsp;MySQL是典型的 Client/Server 架构，服务器端程序使用的是 mysqld。整体的 MySQL 流程如下图所示：<br><img lazyload src="/images/loading.svg" data-src="mysql1.jpg" alt="avatar"><br>&emsp;&emsp;可以看到的MySQL三层：</p>
<ol>
<li>==连接层==：客户端和服务端建立连接（例如tcp），客户端发送 SQL 至服务端；</li>
<li>==SQL 层==：对 SQL 语句进行查询处理；</li>
<li>==存储引擎层==：与数据库文件打交道，负责数据的存储和读取。</li>
</ol>
<h2 id="SQL-层"><a href="#SQL-层" class="headerlink" title="SQL 层"></a>SQL 层</h2><p>其中 SQL 层与数据库文件的存储方式无关，我们来看下 SQL 层的结构：<br><img lazyload src="/images/loading.svg" data-src="mysql2.jpg" alt="avatar"><br>&emsp;&emsp;其流程总结如下：</p>
<ol>
<li>==查询缓存==：服务端接收到客户端的 SQL 语句后，先在缓存中查询该语句，有结果命中缓存就直接返回给客户端；如果没有就进入到解析器阶段；</li>
<li>==解析器==：在解析器中对 SQL 语句进行语法分析、语义分析；</li>
<li>==优化器==：在优化器中会确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引来检索等；</li>
<li>==执行器==：在执行之前需要判断该用户是否具备权限，如果具备权限就执行 SQL 查询并返回结果。如果设置了查询缓存，这时会将查询结果进行缓存。</li>
</ol>
<p>SQL 语句→缓 存查询→解析器→优化器→执行器</p>
<h2 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h2><p>&emsp;&emsp;MySQL 的存储引擎采用了插件的形 式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎。</p>
<ol>
<li>==InnoDB 存储引擎==：MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。</li>
<li>==MyISAM 存储引擎==：MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。</li>
<li>Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。</li>
<li>NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</li>
<li>Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。</li>
</ol>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记（三）</title>
    <url>/2022/01/18/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="String-类型的底层数据结构"><a href="#String-类型的底层数据结构" class="headerlink" title="String 类型的底层数据结构"></a>String 类型的底层数据结构</h1><h2 id="为什么-String-类型内存开销大"><a href="#为什么-String-类型内存开销大" class="headerlink" title="为什么 String 类型内存开销大"></a>为什么 String 类型内存开销大</h2><p>&emsp;&emsp;除了记录实际数据，string 类型还需要额外的内存空间记录数据长度、空间使用等信息，这些信息也叫作元数据。当实际保存的数据较小时，元数据的空间开销就显得比较大了。<br>&emsp;&emsp;string 类型是如何保存数据的呢？</p>
<ol>
<li>当保存 64 位有符号整数时，string 类型会把它保存为一个 8 字节的 Long 类型整数，这种保存方式通常也叫作 int 编码方式。</li>
<li>当保存的数据中包含字符时，String 类型就会用简单动态字符串（Simple Dynamic String，SDS）结构体来保存，如下图所示：</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="redis43.jpg" alt="avatar"><br><strong>这里其实类似 Go 的 slice 类型的底层数据结构</strong><br>buf：字节数组，保存实际数据。为了表示字节数组的结束，Redis 会自动在数组最后加一个“\0”，这就会额外占用 1 个字节的开销。<br>len：占 4 个字节，表示 buf 的已用长度。<br>alloc：也占个 4 字节，表示 buf 的实际分配长度，一般大于 len。</p>
<p>&emsp;&emsp;可以看到，在 SDS 中，buf 保存实际数据，而 len 和 alloc 本身其实是 SDS 结构体的额外开销。另外，对于 String 类型来说，除了 SDS 的额外开销，还有一个来自于 RedisObject 结构体的开销。因为 Redis 的数据类型有很多，而且，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等），所以，Redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据。<br>&emsp;&emsp;一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在，例如指向 String 类型的 SDS 结构所在的内存地址，可以看一下下面的示意图。<br><img lazyload src="/images/loading.svg" data-src="redis44.jpg" alt="avatar"><br>&emsp;&emsp;为了节省内存空间，Redis 还对 Long 类型整数和 SDS 的内存布局做了专门的设计。</p>
<ul>
<li>一方面，当保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。</li>
<li>另一方面，当保存的是字符串数据，并且字符串小于等于 44 字节时，RedisObject 中的元 数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。这种布局方式也被 称为 embstr 编码方式。</li>
<li>当字符串大于 44 字节时，SDS 的数据量就开始变多了，Redis 就不再把 SDS 和RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。这种布局方式被称为 raw 编码模式。</li>
</ul>
<p>如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis45.jpg" alt="avatar"></p>
<p>举例说明一下：我们用 10 位数来表示图片 ID 和图片存储对象 ID，例如，图片 ID 为 1101000051，它在存储系统中对应的 ID 号是 3301000051。可以看到，图片 ID 和图片存储对象 ID 正好一一对应，是典型的“键 - 单值”模式。因为 10 位数的图片 ID 和图片存储对象 ID 是 Long 类型整数，所以可以直接用 int 编码的 RedisObject 保存。每个 int 编码的 RedisObject 元数据部分占 8 字节，指针部分被直接赋值为 8 字节的整数了。此时，每个 ID 会使用 16 字节，加起来一共是 32 字节。同时，Redis 会使用一个全局哈希表保存所有键值对，哈希表的每一项是一个 dictEntry 的结构体，用来指向一个键值对。dictEntry 结构中有三个 8 字节的指针， 分别指向 key、value 以及下一个 dictEntry，三个指针共 24 字节，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis46.jpg" alt="avatar"><br>&emsp;&emsp;此时，这三个指针占据了 24 字节，但是实际上会占用 32 字节，这就要提到 Redis 使用的内存分配库 jemalloc 了。jemalloc 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。如果你申请 24 字节空间，jemalloc 则会分配 32 字节。所以存储这样一个 “键 - 值”对要使用 64 个字节。<br>&emsp;&emsp;明明有效信息只有 16 字节，使用 String 类型保存时，却需要 64 字节的内存空间，有 48 字节都没有用于保存实际的数据。</p>
<h2 id="用什么数据结构可以节省内存？"><a href="#用什么数据结构可以节省内存？" class="headerlink" title="用什么数据结构可以节省内存？"></a>用什么数据结构可以节省内存？</h2><p>&emsp;&emsp;Redis 有一种底层数据结构，叫压缩列表（ziplist），这是一种非常节省内存的结构。我们先回顾下压缩列表的构成。表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量，以及列表中的 entry 个数。压缩列表尾还有一个 zlend，表示列表结束。<br><img lazyload src="/images/loading.svg" data-src="redis47.jpg" alt="avatar"><br>&emsp;&emsp;压缩列表之所以能够节省内存，是因为它是用一系列连续的 entry 保存数据。每个 entry 的元数据包括下面几部分。</p>
<ul>
<li>prev_len：表示前一个 entry 的长度。prev_len 有两种取值情况：1 字节或 5 字节。取值 1 字节时，表示上一个 entry 的长度小于 254 字节。虽然 1 字节的值能表示的数值范围是 0 到 255，但是压缩列表中 zlend 的取值默认是 255，因此，就默认用 255 表示整个压缩列表的结束，其他表示长度的地方就不能再用 255 这个值了。所以，当上一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节，否则，就取值为 5 字节；</li>
<li>len：表示自身长度，4 字节；</li>
<li>encoding：表示编码方式，1 字节；</li>
<li>content：保存实际数据。</li>
</ul>
<p>&emsp;&emsp;这些 entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。我们以保存图片存储对象 ID 为例，来分析一下压缩列表是如何节省内存空间的。每个 entry 保存一个图片存储对象 ID（8 字节），此时，每个 entry 的 prev_len 只需要 1 个字节就行，因为每个 entry 的前一个 entry 长度都只有 8 字节，小于 254 字节。这样一来，一个图片的存储对象 ID 所占用的内存大小是 14 字节（1+4+1+8=14），实际分配 16 字节。</p>
<p>&emsp;&emsp;我们以一个全局的视角去看使用 string 类型的存储形式，每张图片 ID 都会占用一个哈希桶位，这就增加了哈希冲突的概率。并且，元数据和指针会占用大量的空间。<br><img lazyload src="/images/loading.svg" data-src="redis48.png" alt="avatar"></p>
<p>&emsp;&emsp;若使用 Hash 类型来存储，可以采取二级编码方法。这里说的二级编码， 就是把一个单值的数据拆分成两部分，前一部分作为 Hash 集合的 key，后一部分作为 Hash 集合的 value，这样一来，我们就可以把单值数据保存到 Hash 集合中了。<br>&emsp;&emsp;以图片 ID 1101000060 和图片存储对象 ID 3302000080 为例，我们可以把图片 ID 的前 7 位（1101000）作为 Hash 类型的键，把图片 ID 的最后 3 位（060）和图片存储对象 ID 分别作为 Hash 类型值中的 key 和 value。<br>&emsp;&emsp;按照这种设计方法，在存储了大量的图片和对象的数据后，在 Redis 中插入了一组图片 ID 及其存储对象 ID 的记录，并且用 info 命令查看了内存开销，发现，增加一条记录后，内存占用只增加了 16 字节，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info memory </span><br><span class="line"><span class="comment"># Memory </span></span><br><span class="line">used_memory:1039120</span><br><span class="line">127.0.0.1:6379&gt; hset 1101000 060 3302000080 </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; info memory </span><br><span class="line"><span class="comment"># Memory </span></span><br><span class="line">used_memory:1039136</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这是因为图片 ID 的前 7 位（1101000）作为 key 在之前已经存储过了，采用 以 压缩列表为底层数据结构的 hash 类型，就可以根据 key 的后三位 （060）存储在压缩列表中，增加的内存仅仅是压缩列表中一个 entry 的大小。而以 string 类型来存储“键 - 值”对，都要新分配一个哈希桶，开辟一个哈希桶下的新 entry 节点来存储。<br><img lazyload src="/images/loading.svg" data-src="redis49.png" alt="avatar"></p>
<p>&emsp;&emsp;最后，你可能也会有疑惑：“二级编码一定要把图片 ID 的前 7 位作为 Hash 类型的键，把最后 3 位作为 Hash 类型值中的 key 吗？”其实，二级编码方法中采用的 ID 长度是有讲究的。Redis Hash 类型的两种底层实现结构，分别是压缩列表和哈希表。Hash 类型设置了用压缩列表保存数据时的两个阈值，一旦超过了阈值，Hash 类型就会用哈希表来保存数据了。这两个阈值分别对应以下两个配置项：</p>
<ol>
<li>hash-max-ziplist-entries：表示用压缩列表保存时哈希集合中的最大元素个数。</li>
<li>hash-max-ziplist-value：表示用压缩列表保存时哈希集合中单个元素的最大长度。</li>
</ol>
<p>&emsp;&emsp;如果我们往 Hash 集合中写入的元素个数超过了 hash-max-ziplist-entries，或者写入的单个元素大小超过了 hash-max-ziplist-value，Redis 就会自动把 Hash 类型的实现结构由压缩列表转为哈希表。一旦从压缩列表转为了哈希表，Hash 类型就会一直用哈希表进行保存，而不会再转回压缩列表了。在节省内存空间方面，哈希表就没有压缩列表那么高效了。<strong>为了能充分使用压缩列表的精简内存布局，我们一般要控制保存在 Hash 集合中的元素个数</strong>。所以，在刚才的二级编码中，我们只用图片 ID 最后 3 位作为 Hash 集合的 key，也就 保证了 Hash 集合的元素个数不超过 1000，同时，我们把 hash-max-ziplist-entries 设置 为 1000，这样一来，Hash 集合就可以一直使用压缩列表来节省内存空间了。</p>
<h1 id="数据存储的业务场景"><a href="#数据存储的业务场景" class="headerlink" title="数据存储的业务场景"></a>数据存储的业务场景</h1><h2 id="聚合统计（Set）"><a href="#聚合统计（Set）" class="headerlink" title="聚合统计（Set）"></a>聚合统计（Set）</h2><p>&emsp;&emsp;所谓的聚合统计，就是指统计多个集合元素的聚合结果，包括：统计多个集合的共有元素（交集统计）；把两个集合相比，统计其中一个集合独有的元素（差集统计）；统计多个集合的所有元素（并集统计）。</p>
<h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><p>&emsp;&emsp;统计手机 App 每天的新增用户数和第二天的留存用户数。要完成这个统计任务，我们可以用一个集合记录所有登录过 App 的用户 ID，同时，用另一个集合记录每一天登录过 App 的用户 ID。然后，再对这两个集合做聚合统计。我们来看下具体的操作。</p>
<ol>
<li><p>记录所有登录过 App 的用户 ID，我们可以直接使用 Set 类型，把 key 设置为 user:id，表示记录的是用户 ID，value 就是一个 Set 集合，里面是所有登录过 App 的用户 ID，我们可以把这个 Set 叫作累计用户 Set，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis50.jpg" alt="avatar"></p>
</li>
<li><p>还需要把每一天登录的用户 ID，记录到一个新集合中，我们把这个集合叫作每 日用户 Set，它有两个特点：</p>
</li>
</ol>
<ul>
<li>key 是 user:id 以及当天日期，例如 user:id:20200803；</li>
<li>value 是 Set 集合，记录当天登录的用户 ID。<br><img lazyload src="/images/loading.svg" data-src="redis51.jpg" alt="avatar"></li>
</ul>
<h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><p>&emsp;&emsp;假设我们的手机 App 在 2020 年 8 月 3 日上线，那么，8 月 3 日前是没有用户的。此时，累计用户 Set 是空集，当天登录的用户 ID 会被记录到 key 为 user:id:20200803 的 Set 中。所以，user:id:20200803 这个 Set 中的用户就是当天的新增用户。然后，我们计算累计用户 Set 和 user:id:20200803 Set 的并集结果，结果保存在 user:id 这个累计用户 Set 中，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SUNIONSTORE  user:id  user:id  user:id:20200803</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此时，user:id 这个累计用户 Set 中就有了 8 月 3 日的用户 ID。等到 8 月 4 日再统计时，我们把 8 月 4 日登录的用户 ID 记录到 user:id:20200804 的 Set 中。接下来，我们执行 SDIFFSTORE 命令计算累计用户 Set 和 user:id:20200804 Set 的差集，结果保存在 key 为 user:new 的 Set 中，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SDIFFSTORE  user:new  user:id:20200804  user:id</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看到，这个差集中的用户 ID 在 user:id:20200804 的 Set 中存在，但是不在累计用户 Set 中。所以，user:new 这个 Set 中记录的就是 8 月 4 日的新增用户。</p>
<p>&emsp;&emsp;当要计算 8 月 4 日的留存用户时，我们只需要再计算 user:id:20200803 和 user:id:20200804 两个 Set 的交集，就可以得到同时在这两个集合中的用户 ID 了，这些就是在 8 月 3 日登录，并且在 8 月 4 日留存的用户。执行的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SINTERSTORE  user:id:rem  user:id:20200803  user:id:20200804</span><br></pre></td></tr></table></figure>

<h3 id="潜在风险及解决策略"><a href="#潜在风险及解决策略" class="headerlink" title="潜在风险及解决策略"></a>潜在风险及解决策略</h3><ul>
<li><p>潜在风险：Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。</p>
</li>
<li><p>解决策略：可以从主从集群中选择一个从库，让它专门负责聚合计算，或者是把数据读取到客户端，在客户端来完成聚合统计，这样就可以规避阻塞主库实例和其他从库实例的风险了。</p>
</li>
</ul>
<h2 id="排序统计（List、Sorted-Set）"><a href="#排序统计（List、Sorted-Set）" class="headerlink" title="排序统计（List、Sorted Set）"></a>排序统计（List、Sorted Set）</h2><p>&emsp;&emsp;最新评论列表包含了所有评论中的最新留言，<strong>这就要求集合类型能对元素保序</strong>，也就是说，集合中的元素可以按序排列，这种对元素保序的集合类型叫作有序集合。在 Redis 常用的 4 个集合类型中（List、Hash、Set、Sorted Set），List 和 Sorted Set 就属于有序集合。<br>&emsp;&emsp;List 是按照元素进入 List 的顺序进行排序的，而 Sorted Set 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p>
<h3 id="业务场景-1"><a href="#业务场景-1" class="headerlink" title="业务场景"></a>业务场景</h3><ol>
<li>List</li>
</ol>
<p>&emsp;&emsp;每个商品对应一个 List，这个 List 包含了对这个商品的所有评论，而且会按照评论时间保存这些评论，每来一个新评论，就用 LPUSH 命令把它插入 List 的队头。在只有一页评论的时候，我们可以很清晰地看到最新的评论，但是，在实际应用中，网站一般会分页显示最新的评论列表，一旦涉及到分页操作，List 就可能会出现问题了。</p>
<p>&emsp;&emsp;假设当前的评论 List 是{A, B, C, D, E, F}（其中，A 是最新的评论，以此类推，F 是最早的评论），在展示第一页的 3 个评论时，我们可以用下面的命令，得到最新的三条评论 A、B、C：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LRANGE product1 0 2</span><br><span class="line">1) <span class="string">&quot;A&quot;</span></span><br><span class="line">2) <span class="string">&quot;B&quot;</span></span><br><span class="line">3) <span class="string">&quot;C&quot;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后，再用下面的命令获取第二页的 3 个评论，也就是 D、E、F。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LRANGE product1 3 5</span><br><span class="line">1) <span class="string">&quot;D&quot;</span></span><br><span class="line">2) <span class="string">&quot;E&quot;</span></span><br><span class="line">3) <span class="string">&quot;F&quot;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是，如果在展示第二页前，又产生了一个新评论 G，评论 G 就会被 LPUSH 命令插入到评论 List 的队头，评论 List 就变成了{G, A, B, C, D, E, F}。此时，再用刚才的命令获取第二页评论时，就会发现，评论 C 又被展示出来了，也就是 C、D、E。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LRANGE product1 3 5</span><br><span class="line">1) <span class="string">&quot;C&quot;</span></span><br><span class="line">2) <span class="string">&quot;D&quot;</span></span><br><span class="line">3) <span class="string">&quot;E&quot;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;之所以会这样，关键原因就在于，List 是通过元素在 List 中的位置来排序的，当有一个新元素插入时，原先的元素在 List 中的位置都后移了一位，比如说原来在第 1 位的元素现在排在了第 2 位。所以，对比新元素插入前后，List 相同位置上的元素就会发生变化，用 LRANGE 读取时，就会读到旧元素。</p>
<ol start="2">
<li>Sorted Set<br>&emsp;&emsp;和 List 相比，Sorted Set 就不存在这个问题，因为它是根据元素的实际权重来排序和获取数据的。我们可以按评论时间的先后给每条评论设置一个权重值，然后再把评论保存到 Sorted Set 中。Sorted Set 的 ZRANGEBYSCORE 命令就可以按权重排序后返回元素。这样的话，即使集合中的元素频繁更新，Sorted Set 也能通过 ZRANGEBYSCORE 命令准确地获取到按序排列的数据。假设越新的评论权重越大，目前最新评论的权重是 N，我们执行下面的命令时，就可以获得最新的 10 条评论：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ZRANGEBYSCORE comments N-9 N</span><br></pre></td></tr></table></figure></li>
</ol>
<p>&emsp;&emsp;所以，在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议优先考虑使用 Sorted Set。</p>
<h2 id="二值状态统计（Bitmap）"><a href="#二值状态统计（Bitmap）" class="headerlink" title="二值状态统计（Bitmap）"></a>二值状态统计（Bitmap）</h2><p>&emsp;&emsp;二值状态就是指集合元素的取 值就只有 0 和 1 两种。在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。</p>
<h3 id="业务场景-2"><a href="#业务场景-2" class="headerlink" title="业务场景"></a>业务场景</h3><p>&emsp;&emsp;在签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。这个时候，我们就可以选择 Bitmap。这是 Redis 提供的扩展数据类型。</p>
<h3 id="bitmap-的实现原理"><a href="#bitmap-的实现原理" class="headerlink" title="bitmap 的实现原理"></a>bitmap 的实现原理</h3><p>&emsp;&emsp;Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态。你可以把 Bitmap 看作是一个 bit 数组。<br>&emsp;&emsp;Bitmap 提供了 GETBIT/SETBIT 操作，使用一个偏移值 offset 对 bit 数组的某一个 bit 位进行读和写。不过，需要注意的是，Bitmap 的偏移量是从 0 开始算的，也就是说 offset 的最小值是 0。当使用 SETBIT 对一个 bit 位进行写操作时，这个 bit 位会被设置为 1。Bitmap 还提供了 BITCOUNT 操作，用来统计这个 bit 数组中所有“1”的个数。</p>
<h3 id="具体例子1"><a href="#具体例子1" class="headerlink" title="具体例子1"></a>具体例子1</h3><p>&emsp;&emsp;假设我们要统计 ID 3000 的用户在 2020 年 8 月份的签到情况，就可以按照下面的步骤进行操作。</p>
<ol>
<li><p>第一步，执行下面的命令，记录该用户 8 月 3 号已签到。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SETBIT uid:sign:3000:202008 2 1</span><br></pre></td></tr></table></figure></li>
<li><p>第二步，检查该用户 8 月 3 日是否签到。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GETBIT uid:sign:3000:202008 2</span><br></pre></td></tr></table></figure></li>
<li><p>第三步，统计该用户在 8 月份的签到次数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BITCOUNT uid:sign:3000:202008</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="具体例子2"><a href="#具体例子2" class="headerlink" title="具体例子2"></a>具体例子2</h3><p>&emsp;&emsp;：如果记录了 1 亿个用户 10 天的签到情况，你有办法统计出这 10 天连续签到的用户总数吗？<br>&emsp;&emsp;Bitmap 支持用 BITOP 命令对多个 Bitmap 按位做“与”“或”“异或”的操作，操作的结果会保存到一个新的 Bitmap 中。我以按位“与”操作为例来具体解释一下。从下图中，可以看到，三个 Bitmap bm1、bm2 和 bm3，对应 bit 位做“与”操作，结果保存到了一个新的 Bitmap 中（示例中，这个结果 Bitmap 的 key 被设为“resmap”）。<br><img lazyload src="/images/loading.svg" data-src="redis52.jpg" alt="avatar"><br>&emsp;&emsp;在统计 1 亿个用户连续 10 天的签到情况时，你可以把每天的日期作为 key，每个 key 对应一个 1 亿位的 Bitmap，每一个 bit 对应一个用户当天的签到情况。接下来，我们对 10 个 Bitmap 做“与”操作，得到的结果也是一个 Bitmap。在这个 Bitmap 中，只有 10 天都签到的用户对应的 bit 位上的值才会是 1。最后，我们可以用 BITCOUNT 统计下 Bitmap 中的 1 的个数，这就是连续签到 10 天的用户总数了。<br>&emsp;&emsp;现在，我们可以计算一下记录了 10 天签到情况后的内存开销。每天使用 1 个 1 亿位的 Bitmap，大约占 12MB 的内存（10^8/8/1024/1024），10 天的 Bitmap 的内存开销约为 120MB，内存压力不算太大。不过，在实际应用时，最好对 Bitmap 设置过期时间，让 Redis 自动删除不再需要的签到记录，以节省内存开销。</p>
<p>&emsp;&emsp;所以，如果只需要统计数据的二值状态，例如商品有没有、用户在不在等，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0 或 1。在记录海量数据时，Bitmap 能够有效地节省内存空间。</p>
<h2 id="基数统计（HyperLogLog）"><a href="#基数统计（HyperLogLog）" class="headerlink" title="基数统计（HyperLogLog）"></a>基数统计（HyperLogLog）</h2><p>&emsp;&emsp;基数统计就是指统计一个集合中不重复的元素个数。</p>
<h3 id="业务场景-3"><a href="#业务场景-3" class="headerlink" title="业务场景"></a>业务场景</h3><p>&emsp;&emsp;网页 UV 的统计有个独特的地方，就是需要去重，一个用户一天内的多次访问只能算作一次。在 Redis 的集合类型中，Set 类型默认支持去重，所以看到有去重需求时，我们可能第一时间就会想到用 Set 类型。</p>
<p>我们来结合一个例子看一看用 Set 的情况。</p>
<ol>
<li>有一个用户 user1 访问 page1 时，你把这个信息加到 Set 中：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SADD page1:uv user1</span><br></pre></td></tr></table></figure></li>
</ol>
<p>&emsp;&emsp;用户 1 再来访问时，Set 的去重功能就保证了不会重复记录用户 1 的访问次数，这样，用 户 1 就算是一个独立访客。当你需要统计 UV 时，可以直接用 SCARD 命令，这个命令会返回一个集合中的元素个数。<br>&emsp;&emsp;但是，如果 page1 非常火爆，UV 达到了千万，这个时候，一个 Set 就要记录千万个用户 ID。对于一个搞大促的电商网站而言，这样的页面可能有成千上万个，如果每个页面都用这样的一个 Set，就会消耗很大的内存空间。</p>
<p>当然，你也可以用 Hash 类型记录 UV。<br>例如，你可以把用户 ID 作为 Hash 集合的 key，当用户访问页面时，就用 HSET 命令（用 于设置 Hash 集合元素的值），对这个用户 ID 记录一个值“1”，表示一个独立访客，用 户 1 访问 page1 后，我们就记录为 1 个独立访客，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HSET page1:uv user1 1</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;即使用户 1 多次访问页面，重复执行这个 HSET 命令，也只会把 user1 的值设置为 1，仍然只记为 1 个独立访客。当要统计 UV 时，我们可以用 HLEN 命令统计 Hash 集合中的所有元素个数。但是，和 Set 类型相似，当页面很多时，Hash 类型也会消耗很大的内存空间。那么，有什么办法既能完成统计，还能节省内存吗？</p>
<h3 id="使用-HyperLogLog"><a href="#使用-HyperLogLog" class="headerlink" title="使用 HyperLogLog"></a>使用 HyperLogLog</h3><p>&emsp;&emsp;HyperLogLog 是一种用于统计基数的数据集合类型，它的最大优势就在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小。在 Redis 中，每个 HyperLogLog 只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数。和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p>
<ol>
<li><p>在统计 UV 时，可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PFADD page1:uv user1 user2 user3 user4 user5</span><br></pre></td></tr></table></figure></li>
<li><p>接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PFCOUNT page1:uv</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="HyperLogLog-的精度局限性"><a href="#HyperLogLog-的精度局限性" class="headerlink" title="HyperLogLog 的精度局限性"></a>HyperLogLog 的精度局限性</h3><p>&emsp;&emsp;不过，有一点需要你注意一下，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。这也就意味着，你使用HyperLogLog 统计的 UV 是 100 万，但实际的 UV 可能是 101 万。虽然误差率不算大，但是，如果你需要精确统计结果的话，最好还是继续用 Set 或 Hash 类型。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;在本结中，我们结合统计用户新增数和留存数、最新评论列表、签到统计以及网页独立访问量这 4 种典型场景，讨论了 4 种统计模式，分别是聚合统计、排序统计、二值状态统计和基数统计。下表是这 4 种统计模式对应 Redis 类型的解决策略：<br><img lazyload src="/images/loading.svg" data-src="redis53.jpg" alt="avatar"><br>&emsp;&emsp;可以看到，Set 和 Sorted Set 都支持多种聚合统计，不过，对于差集计算来说，只有 Set 支持。Bitmap 也能做多个 Bitmap 间的聚合计算，包括与、或和异或操作。</p>
<p>&emsp;&emsp;当需要进行排序统计时，List 中的元素虽然有序，但是一旦有新元素插入，原来的元素在 List 中的位置就会移动，那么，按位置读取的排序结果可能就不准确了。而 Sorted Set 本身是按照集合元素的权重排序，可以准确地按序获取结果，所以建议优先使用它。</p>
<p>&emsp;&emsp;如果我们记录的数据只有 0 和 1 两个值的状态，Bitmap 会是一个很好的选择，这主要归功于 Bitmap 对于一个数据只用 1 个 bit 记录，可以节省内存。</p>
<p>&emsp;&emsp;对于基数统计来说，如果集合元素量达到亿级别而且不需要精确统计时，建议你使用 HyperLogLog。</p>
<h1 id="GEO-类型"><a href="#GEO-类型" class="headerlink" title="GEO 类型"></a>GEO 类型</h1><p>&emsp;&emsp;在日常生活中，我们越来越依赖搜索“附近的餐馆”、在打车软件上叫车，这些都离不开基于位置信息服务（Location-Based Service，LBS）的应用。LBS 应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS 服务的场景中，我们来看一下它的底层结构。</p>
<h2 id="GEO-的底层结构"><a href="#GEO-的底层结构" class="headerlink" title="GEO 的底层结构"></a>GEO 的底层结构</h2><h3 id="GEO-要处理的数据的特点"><a href="#GEO-要处理的数据的特点" class="headerlink" title="GEO 要处理的数据的特点"></a>GEO 要处理的数据的特点</h3><p>&emsp;&emsp;我以叫车服务为例，来分析下 LBS 应用中经纬度的存取特点。</p>
<ol>
<li>每一辆网约车都有一个编号（例如 33），网约车需要将自己的经度信息（例如116.034579）和纬度信息（例如 39.000452 ）发给叫车应用。</li>
<li>用户在叫车的时候，叫车应用会根据用户的经纬度位置（例如经度 116.054579，纬度39.030452），查找用户的附近车辆，并进行匹配。</li>
<li>等把位置相近的用户和车辆匹配上以后，叫车应用就会根据车辆的编号，获取车辆的信息，并返回给用户。</li>
</ol>
<p>&emsp;&emsp;可以看到，一辆车（或一个用户）对应一组经纬度，并且随着车（或用户）的位置移动，相应的经纬度也会变化。这种数据记录模式属于一个 key（例如车 ID）对应一个 value（一组经纬度）。当有很多车辆信息要保存时，就需要有一个集合来保存一系列的 key 和 value。Hash 集合类型可以快速存取一系列的 key 和 value，正好可以用来记录一系列车辆 ID 和经纬度的对应关系， 所以，我们可以把不同车辆的 ID 和它们对应的经纬度信息存在 Hash 集合中，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis54.jpg" alt="avatra"><br>&emsp;&emsp;同时，Hash 类型的 HSET 操作命令，会根据 key 来设置相应的 value 值，所以，我们可以用它来快速地更新车辆变化的经纬度信息。<br>&emsp;&emsp;到这里，Hash 类型看起来是一个不错的选择。但问题是，对于一个 LBS 应用来说，除了记录经纬度信息，还需要根据用户的经纬度信息在车辆的 Hash 集合中进行范围查询。一 旦涉及到范围查询，就意味着集合中的元素需要有序，（<strong>如果无序那么只能全局遍历搜索，其时间代价是不能够接受的</strong>），但 Hash 类型的元素是无序的，显然不能满足我们的要求。</p>
<p>&emsp;&emsp;我们再来看看使用 Sorted Set 类型是不是合适。Sorted Set 类型也支持一个 key 对应一个 value 的记录模式，其中，key 就是 Sorted Set 中的元素，而 value 则是元素的权重分数。更重要的是，Sorted Set 可以根据元素的 权重分数排序，支持范围查询。这就能满足 LBS 服务中查找相邻位置的需求了。实际上，GEO 类型的底层数据结构就是用 Sorted Set 来实现的。咱们还是借着叫车应用的例子来加深下理解。<br>&emsp;&emsp;用 Sorted Set 来保存车辆的经纬度信息时，Sorted Set 的元素是车辆 ID，元素的权重分数是经纬度信息，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis55.jpg" alt="avatar"><br>&emsp;&emsp;这时问题来了，Sorted Set 元素的权重分数是一个浮点数（float 类型），而一组经纬度包含的是经度和纬度两个值，是没法直接保存为一个浮点数的，那具体该怎么进行保存呢？这就要用到 GEO 类型中的 GeoHash 编码了。</p>
<h3 id="GeoHash-的编码方法"><a href="#GeoHash-的编码方法" class="headerlink" title="GeoHash 的编码方法"></a>GeoHash 的编码方法</h3><p>&emsp;&emsp;为了能高效地对经纬度进行比较，Redis 采用了业界广泛使用的 GeoHash 编码方法，这个方法的基本原理就是“二分区间，区间编码”。当我们要对一组经纬度进行 GeoHash 编码时，我们要先对经度和纬度分别编码，然后再把经纬度各自的编码组合成一个最终编码。</p>
<ol>
<li>下经度和纬度的单独编码过程:<br>&emsp;&emsp;对于一个地理位置信息来说，它的经度范围是[-180,180]。GeoHash 编码会把一个经度值编码成一个 N 位的二进制值，我们来对经度范围[-180,180]做 N 次的二分区操作，其中 N 可以自定义。<br>&emsp;&emsp;在进行第一次二分区时，经度范围[-180,180]会被分成两个子区间：[-180,0) 和[0,180] （左、右分区）。此时，我们可以查看一下要编码的经度值落在了左分区还是右分区。如果是落在左分区，我们就用 0 表示；如果落在右分区，就用 1 表示。这样一来，每做完一次二分区，我们就可以得到 1 位编码值。然后，我们再对经度值所属的分区再做一次二分区，同时再次查看经度值落在了二分区后的左分区还是右分区，按照刚才的规则再做 1 位编码。当做完 N 次的二分区后，经度值就可以用一个 N bit 的数来表示了。</li>
</ol>
<p>&emsp;&emsp;举个例子，假设我们要编码的经度值是 116.37，我们用 5 位编码值（也就是 N=5，做 5 次分区）。<br><img lazyload src="/images/loading.svg" data-src="redis56.jpg" alt="avatar"><br>对纬度的编码方式，和对经度的一样，只是纬度的范围是[-90，90]，下面这张表显示了对 纬度值 39.86 的编码过程。<br><img lazyload src="/images/loading.svg" data-src="redis57.jpg" alt="avatar"></p>
<ol start="2">
<li>把它们的各自编码值组合在一起:<br>&emsp;&emsp;组合的规则是：最终编码值的偶数位上依次是经度的编码值，奇数位上依次是纬度的编码值，其中，偶数位从 0 开始，奇数位从 1 开始。我们刚刚计算的经纬度（116.37，39.86）的各自编码值是 11010 和 10111，组合之后，第 0 位是经度的第 0 位 1，第 1 位是纬度的第 0 位 1，第 2 位是经度的第 1 位 1，第 3 位是纬度的第 1 位 0，以此类推，就能得到最终编码值 1110011101，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis58.jpg" alt="avatar"><br>&emsp;&emsp;用了 GeoHash 编码后，原来无法用一个权重分数表示的一组经纬度（116.37，39.86）就可以用 1110011101 这一个值来表示，就可以保存为 Sorted Set 的权重分数了。当然，使用 GeoHash 编码后，我们相当于把整个地理空间划分成了一个个方格，每个方格对应了 GeoHash 中的一个分区。<br>&emsp;&emsp;举个例子。我们把经度区间[-180,180]做一次二分区，把纬度区间[-90,90]做一次二分区，就会得到 4 个分区。我们来看下它们的经度和纬度范围以及对应的 GeoHash 组合编码。</li>
</ol>
<ul>
<li>分区一：[-180,0) 和[-90,0)，编码 00；</li>
<li>分区二：[-180,0) 和[0,90]，编码 01；</li>
<li>分区三：[0,180]和[-90,0)，编码 10；</li>
<li>分区四：[0,180]和[0,90]，编码 11。</li>
</ul>
<p>&emsp;&emsp;这 4 个分区对应了 4 个方格，每个方格覆盖了一定范围内的经纬度值，分区越多，每个方格能覆盖到的地理空间就越小，也就越精准。我们把所有方格的编码值映射到一维空间时，相邻方格的 GeoHash 编码值基本也是接近的，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis59.jpg" alt="avatar"><br>&emsp;&emsp;所以，我们使用 Sorted Set 范围查询得到的相近编码值，在实际的地理空间上，也是相邻的方格，这就可以实现 LBS 应用“搜索附近的人或物”的功能了。不过，有的编码值虽然在大小上接近，但实际对应的方格却距离比较远。例如，我们用 4 位来做 GeoHash 编码，把经度区间[-180,180]和纬度区间[-90,90]各 分成了 4 个分区，一共 16 个分区，对应了 16 个方格。编码值为 0111 和 1000 的两个方格就离得比较远，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis60.jpg" alt="avatar"><br>&emsp;&emsp;所以，为了避免查询不准确问题，我们可以同时查询给定经纬度所在的方格周围的 4 个或 8 个方格。</p>
<h2 id="如何操作-GEO-类型"><a href="#如何操作-GEO-类型" class="headerlink" title="如何操作 GEO 类型"></a>如何操作 GEO 类型</h2><p>&emsp;&emsp;在使用 GEO 类型时，我们经常会用到两个命令，分别是 GEOADD 和 GEORADIUS。</p>
<ul>
<li>GEOADD 命令：用于把一组经纬度信息和相对应的一个 ID 记录到 GEO 类型集合中；</li>
<li>GEORADIUS 命令：会根据输入的经纬度位置，查找以这个经纬度为中心的一定范围内的其他元素。当然，我们可以自己定义这个范围。</li>
</ul>
<p>&emsp;&emsp;我还是以叫车应用的车辆匹配场景为例，介绍下具体如何使用这两个命令。假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。执行下面的这个命令，就可以 把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GEOADD cars:locations 116.034579 39.030452 33</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当用户想要寻找自己附近的网约车时，LBS 应用就可以使用 GEORADIUS 命令。例如，LBS 应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息 （116.054579，39.030452 ），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。当然，你可以修改“5”这个参数，来返回更大或更小范围内的车辆信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GEORADIUS cars:locations 116.054579 39.030452 5 km ASC COUNT 10</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;另外，我们还可以进一步限定返回的车辆信息。比如，我们可以使用 ASC 选项，让返回的车辆信息按照距离这个中心位置从近到远的方式来排序，以方便选择最近的车辆；还可以使用 COUNT 选项，指定返回的车辆信息的数量。毕竟，5 公里范围内的车辆可能有很多，如果返回全部信息，会占用比较多的数据带宽，这个选项可以帮助控制返回的数据量，节省带宽。</p>
<h1 id="自定义的数据类型"><a href="#自定义的数据类型" class="headerlink" title="自定义的数据类型"></a>自定义的数据类型</h1><h2 id="如何自定义数据类型"><a href="#如何自定义数据类型" class="headerlink" title="如何自定义数据类型"></a>如何自定义数据类型</h2><p>&emsp;&emsp;为了实现自定义数据类型，首先，我们需要了解 Redis 的基本对象结构 RedisObject，因 为 Redis 键值对中的每一个值都是用 RedisObject 保存的。RedisObject 包括元数据和指针。其中，元数据的一个功能就是用来区分不同的数据类型，指针用来指向具体的数据类型的值。所以，要想开发新数据类型，我们就先来了解下 RedisObject 的元数据和指针。</p>
<h2 id="Redis-的基本对象结构"><a href="#Redis-的基本对象结构" class="headerlink" title="Redis 的基本对象结构"></a>Redis 的基本对象结构</h2><p>&emsp;&emsp;RedisObject 的内部组成包括了 type,、encoding,、lru 和 refcount 4 个元数据，以及 1 个*ptr指针。</p>
<ul>
<li>type：表示值的类型，涵盖了我们前面学习的五大基本类型；</li>
<li>encoding：是值的编码方式，用来表示 Redis 中实现各个基本类型的底层数据结构，例如 SDS、压缩列表、哈希表、跳表等；</li>
<li>lru：记录了这个对象最后一次被访问的时间，用于淘汰过期的键值对；</li>
<li>refcount：记录了对象的引用计数；</li>
<li>*ptr：是指向数据的指针。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="redis61.jpg" alt="avatar"><br>&emsp;&emsp;RedisObject 结构借助*ptr指针，就可以指向不同的数据类型，例如，*ptr指向一个 SDS 或一个跳表，就表示键值对中的值是 String 类型或 Sorted Set 类型。所以，我们在定义了新的数据类型后，也只要在 RedisObject 中设置好新类型的 type 和 encoding，再 用*ptr指向新类型的实现，就行了。</p>
<h1 id="在-Redis-中保存时间序列数据"><a href="#在-Redis-中保存时间序列数据" class="headerlink" title="在 Redis 中保存时间序列数据"></a>在 Redis 中保存时间序列数据</h1><h2 id="需求概括"><a href="#需求概括" class="headerlink" title="需求概括"></a>需求概括</h2><p>&emsp;&emsp;我们现在做互联网产品的时候，都有这么一个需求：记录用户在网站或者 App 上的点击行为数据，来分析用户行为。这里的数据一般包括用户 ID、行为类型（例如浏览、登录、下单等）、行为发生的时间戳：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UserID, Type, TimeStamp</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;再比如做物联网项目，我们需要周期性地统计近万台设备的实时状态，包括设备 ID、压力、温度、湿度，以及对应的时间戳：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DeviceID, Pressure, Temperature, Humidity, TimeStamp</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这些<strong>与发生时间相关</strong>的一组数据，就是时间序列数据。这些数据的特点是没有严格的关系模型，记录的信息可以表示成键和值的关系（例如，一个设备 ID 对应一条记录），所以，并不需要专门用关系型数据库（例如 MySQL）来保存。而 Redis 的键值数据模型，正好可以满足这里的数据存取需求。</p>
<h2 id="时间序列数据的读写特点"><a href="#时间序列数据的读写特点" class="headerlink" title="时间序列数据的读写特点"></a>时间序列数据的读写特点</h2><ul>
<li><p>写数据<br>&emsp;&emsp;在实际应用中，时间序列数据通常是持续高并发写入的，例如，需要连续记录数万个设备的实时状态值。同时，时间序列数据的写入主要就是插入新数据，而不是更新一个已存在的数据，也就是说，一个时间序列数据被记录后通常就不会变了，因为它就代表了一个设备在某个时刻的状态值（例如，一个设备在某个时刻的温度测量值，一旦记录下来，这个值本身就不会再变了）。所以，<strong>这种数据的写入特点很简单，就是插入数据快，这就要求我们选择的数据类型，在进行数据插入时，复杂度要低，尽量不要阻塞</strong>。</p>
</li>
<li><p>读数据<br>&emsp;&emsp;我们在查询时间序列数据时，既有对单条记录的查询（例如查询某个设备在某一个时刻的运行状态信息，对应的就是这个设备的一条记录），也有对某个时间范围内的数据的查询（例如每天早上 8 点到 10 点的所有设备的状态信息）。除此之外，还有一些更复杂的查询，比如对某个时间范围内的数据做聚合计算。这里的聚合计算，就是对符合查询条件的所有数据做计算，包括计算均值、最大 / 最小值、求和等。例如，我们要计算某个时间段内的设备压力的最大值，来判断是否有故障发生。那用一个词概括时间序列数据的“读”，就是<strong>查询模式多</strong>。</p>
</li>
</ul>
<p>&emsp;&emsp;Redis 提供 了保存时间序列数据的两种方案，分别可以基于 Hash 和 Sorted Set 实现，以及基于 RedisTimeSeries 模块实现。</p>
<h2 id="基于-Hash-和-Sorted-Set-保存时间序列数据"><a href="#基于-Hash-和-Sorted-Set-保存时间序列数据" class="headerlink" title="基于 Hash 和 Sorted Set 保存时间序列数据"></a>基于 Hash 和 Sorted Set 保存时间序列数据</h2><h3 id="为什么要同时使用这两种类型"><a href="#为什么要同时使用这两种类型" class="headerlink" title="为什么要同时使用这两种类型"></a>为什么要同时使用这两种类型</h3><p>&emsp;&emsp;关于 Hash 类型，我们都知道，它有一个特点是，可以实现对单键的快速查询。这就满足了时间序列数据的单键查询需求。我们可以把时间戳作为 Hash 集合的 key，把记录的设备状态值作为 Hash 集合的 value。<br>可以看下用 Hash 集合记录设备的温度值的示意图：<br><img lazyload src="/images/loading.svg" data-src="redis62.jpg" alt="avatar"><br>&emsp;&emsp;当我们想要查询某个时间点或者是多个时间点上的温度数据时，直接使用 HGET 命令或者 HMGET 命令，就可以分别获得 Hash 集合中的一个 key 和多个 key 的 value 值了。</p>
<p>&emsp;&emsp;举个例子。我们用 HGET 命令查询 202008030905 这个时刻的温度值，使用 HMGET 查询 202008030905、202008030907、202008030908 这三个时刻的温度值，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HGET device:temperature 202008030905 </span><br><span class="line"><span class="string">&quot;25.1&quot;</span></span><br><span class="line"></span><br><span class="line">HMGET device:temperature 202008030905 202008030907 202008030908</span><br><span class="line">1) <span class="string">&quot;25.1&quot;</span></span><br><span class="line">2) <span class="string">&quot;25.9&quot;</span></span><br><span class="line">3) <span class="string">&quot;24.9&quot;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;用 Hash 类型来实现单键的查询很简单。但是，Hash 类型有个短板：<strong>它并不支持对数据进行范围查询</strong>。所以，如果要对 Hash 类型进行范围查询的话，就需要扫描 Hash 集合中的所有数据，再把这些数据取回到客户端进行排序，然后，才能在客户端得到所查询范围内的数据。显然，查询效率很低。</p>
<p>&emsp;&emsp;为了能同时支持按时间戳范围的查询，可以用 Sorted Set 来保存时间序列数据，因为它能够根据元素的权重分数来排序。我们可以把时间戳作为 Sorted Set 集合的元素分数，把时间点上记录的数据作为元素本身。<br><img lazyload src="/images/loading.svg" data-src="redis63.jpg" alt="avatar"></p>
<p>&emsp;&emsp;使用 Sorted Set 保存数据后，我们就可以使用 ZRANGEBYSCORE 命令，按照输入的最大时间戳和最小时间戳来查询这个时间范围内的温度值了。如下所示，我们来查询一下在 2020 年 8 月 3 日 9 点 7 分到 9 点 10 分间的所有温度值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ZRANGEBYSCORE device:temperature 202008030907 202008030910</span><br><span class="line">1) <span class="string">&quot;25.9&quot;</span></span><br><span class="line">2) <span class="string">&quot;24.9&quot;</span></span><br><span class="line">3) <span class="string">&quot;25.3&quot;</span></span><br><span class="line">4) <span class="string">&quot;25.2&quot;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;现在我们知道了，可以同时使用 Hash 和 Sorted Set，就能满足对单个时间点和一个时间范围内的数据查询需求。但是又会面临一个新的问题，也就是我们要解决的第二个问题：<strong>如何保证写入 Hash 和 Sorted Set 是一个原子性的操作呢</strong>？</p>
<h3 id="如何保证事务的原子性？"><a href="#如何保证事务的原子性？" class="headerlink" title="如何保证事务的原子性？"></a>如何保证事务的原子性？</h3><ul>
<li>MULTI 命令：表示一系列原子性操作的开始。收到这个命令后，Redis 就知道，接下来再收到的命令需要放到一个内部队列中，后续一起执行，保证原子性。</li>
<li>EXEC 命令：表示一系列原子性操作的结束。一旦 Redis 收到了这个命令，就表示所有要保证原子性的命令操作都已经发送完成了。此时，Redis 开始执行刚才放到内部队列中的所有命令操作。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="redis64.jpg" alt="avatar"><br>&emsp;&emsp;以保存设备状态信息的需求为例，我们执行下面的代码，把设备在 2020 年 8 月 3 日 9 时 5 分的温度，分别用 HSET 命令和 ZADD 命令写入 Hash 集合和 Sorted Set 集合。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI </span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; HSET device:temperature 202008030911 26.8 </span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZADD device:temperature 202008030911 26.8 </span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先，Redis 收到了客户端执行的 MULTI 命令。然后，客户端再执行 HSET 和 ZADD 命令后，Redis 返回的结果为“QUEUED”，表示这两个命令暂时入队，先不执行；执行了 EXEC 命令后，HSET 命令和 ZADD 命令才真正执行，并返回成功结果（结果值为 1）。<br>&emsp;&emsp;到这里，我们就解决了时间序列数据的单点查询、范围查询问题，并使用 MUTLI 和 EXEC 命令保证了 Redis 能原子性地把数据保存到 Hash 和 Sorted Set 中。接下来，我们需要继续解决第三个问题：<strong>如何对时间序列数据进行聚合计算</strong>？</p>
<h3 id="如何实现聚合计算"><a href="#如何实现聚合计算" class="headerlink" title="如何实现聚合计算"></a>如何实现聚合计算</h3><p>&emsp;&emsp;因为 Sorted Set 只支持范围查询，无法直接进行聚合计算，所以，我们只能先把时间范围内的数据取回到客户端，然后在客户端自行完成聚合计算。这个方法虽然能完成聚合计算，但是会带来一定的潜在风险，也就是<strong>大量数据在 Redis 实例和客户端间频繁传输，这会和其他操作命令竞争网络资源，导致其他操作变慢</strong>。<br>&emsp;&emsp;在我们这个物联网项目中，就需要每 3 分钟统计一下各个设备的温度状态，一旦设备温度超出了设定的阈值，就要进行报警。这是一个典型的聚合计算场景，我们可以来看看这个过程中的数据体量。<br>&emsp;&emsp;假设我们需要每 3 分钟计算一次的所有设备各指标的最大值，每个设备每 15 秒记录一个指标值，1 分钟就会记录 4 个值，3 分钟就会有 12 个值。我们要统计的设备指标数量有 33 个，所以，单个设备每 3 分钟记录的指标数据有将近 400 个（33 * 12 = 396），而设备总数量有 1 万台，这样一来，每 3 分钟就有将近 400 万条（396 * 1 万 = 396 万）数据需要在客户端和 Redis 实例间进行传输。<br>&emsp;&emsp;为了避免客户端和 Redis 实例间频繁的大量数据传输，我们可以使用 RedisTimeSeries 来保存时间序列数据。RedisTimeSeries 支持直接在 Redis 实例上进行聚合计算。还是以刚才每 3 分钟算一次最大值为例。在 Redis 实例上直接聚合计算，那么，对于单个设备的一个指标值来说，每 3 分钟记录的 12 条数据可以聚合计算成一个值，单个设备每 3 分钟也就只有 33 个聚合值需要传输，1 万台设备也只有 33 万条数据。数据量大约是在客户端做聚合计算的十分之一，很显然，可以减少大量数据传输对 Redis 实例网络的性能影响。<br>&emsp;&emsp;所以，如果我们只需要进行单个时间点查询或是对某个时间范围查询的话，适合使用 Hash 和 Sorted Set 的组合，它们都是 Redis 的内在数据结构，性能好，稳定性高。但是，如果我们需要进行大量的聚合计算，同时网络带宽条件不是太好时，Hash 和 Sorted Set 的组合就不太适合了。此时，使用 RedisTimeSeries 就更加合适一些。</p>
<h2 id="基于-RedisTimeSeries-模块保存时间序列数据"><a href="#基于-RedisTimeSeries-模块保存时间序列数据" class="headerlink" title="基于 RedisTimeSeries 模块保存时间序列数据"></a>基于 RedisTimeSeries 模块保存时间序列数据</h2><ul>
<li><input disabled type="checkbox"> TODO</li>
</ul>
<h1 id="Redis-对于消息队列需求的解决方案"><a href="#Redis-对于消息队列需求的解决方案" class="headerlink" title="Redis 对于消息队列需求的解决方案"></a>Redis 对于消息队列需求的解决方案</h1><h2 id="消息队列的存取需求"><a href="#消息队列的存取需求" class="headerlink" title="消息队列的存取需求"></a>消息队列的存取需求</h2><p>&emsp;&emsp;消息队列的本质是为组件间或者说系统间提供解耦的服务，使组件间的服务可以异步完成。如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis65.jpg" alt="avatar"><br>&emsp;&emsp;我们一般把消息队列中发送消息的组件称为生产者（例子中的组件 1），把接收消息的组件称为消费者（例子中的组件 2），下图展示了一个通用的消息队列的架构模型：<br><img lazyload src="/images/loading.svg" data-src="redis66.jpg" alt="avatar"><br>&emsp;&emsp;在使用消息队列时，消费者可以异步读取生产者消息，然后再进行处理。这样一来，即使生产者发送消息的速度远远超过了消费者处理消息的速度，生产者已经发送的消息也可以缓存在消息队列中，避免阻塞生产者，这是消息队列作为分布式组件通信的一大优势。</p>
<p>&emsp;&emsp;不过，消息队列在存取消息时，必须要满足三个需求，分别是<strong>消息保序</strong>、<strong>处理重复的消息</strong>和<strong>保证消息可靠性</strong>。</p>
<h3 id="需求一：消息保存"><a href="#需求一：消息保存" class="headerlink" title="需求一：消息保存"></a>需求一：消息保存</h3><p>&emsp;&emsp;虽然消费者是异步处理消息，但是，消费者仍然需要按照生产者发送消息的顺序来处理消息，避免后发送的消息被先处理了。对于要求消息保序的场景来说，一旦出现这种消息被乱序处理的情况，就可能会导致业务逻辑被错误执行，从而给业务方造成损失。<br>&emsp;&emsp;我们来看一个更新商品库存的场景。假设生产者负责接收库存更新请求，消费者负责实际更新库存，现有库存量是 10。生产者先后发送了消息 1 和消息 2，消息 1 要把商品 X 的库存记录更新为 5，消息 2 是把商品 X 库存更新为 3。如果消息 1 和 2 在消息队列中无法保序，出现消息 2 早于消息 1 被处理的情况，那么，很显然，库存更新就出错了。这是业务应用无法接受的。面对这种情况，你可能会想到一种解决方案：<strong>不要把更新后的库存量作为生产者发送的消息，而是把库存扣除值作为消息的内容</strong>。这样一来，消息 1 是扣减库存量 5，消息 2 是扣减库存量 2。如果消息 1 和消息 2 之间没有库存查询请求的话，即使消费者先处理消息 2，再处理消息 1，这个方案也能够保证最终的库存量是正确的，也就是库存量为 3。但是，我们还需要考虑这样一种情况：假如消费者收到了这样三条消息：消息 1 是扣减库 存量 5，消息 2 是读取库存量，消息 3 是扣减库存量 2，此时，如果消费者先处理了消息 3（把库存量扣减 2），那么库存量就变成了 8。然后，消费者处理了消息 2，读取当前的库存量是 8，这就会出现库存量查询不正确的情况。从业务应用层面看，消息 1、2、3 应该是顺序执行的，所以，消息 2 查询到的应该是扣减了 5 以后的库存量，而不是扣减了 2 以后的库存量。所以，用库存扣除值作为消息的方案，<strong>在消息中同时包含读写操作的场景下，会带来数据读取错误的问题</strong>。而且，这个方案还会面临一个问题，那就是<strong>重复消息处理</strong>。</p>
<h3 id="需求二：重复消息处理"><a href="#需求二：重复消息处理" class="headerlink" title="需求二：重复消息处理"></a>需求二：重复消息处理</h3><p>&emsp;&emsp;消费者从消息队列读取消息时，有时会因为网络堵塞而出现消息重传的情况。此时，消费者可能会收到多条重复的消息。对于重复的消息，消费者如果多次处理的话，就可能造成一个业务逻辑被多次执行，如果业务逻辑正好是要修改数据，那就会出现数据被多次修改的问题了。还是以库存更新为例，假设消费者收到了一次消息 1，要扣减库存量 5，然后又收到了一次消息 1，那么，如果消费者无法识别这两条消息实际是一条相同消息的话，就会执行两次扣减库存量 5 的操作，此时，库存量就不对了。这当然也是无法接受的。</p>
<h3 id="需求三：消息可靠性保证"><a href="#需求三：消息可靠性保证" class="headerlink" title="需求三：消息可靠性保证"></a>需求三：消息可靠性保证</h3><p>&emsp;&emsp;另外，消费者在处理消息的时候，还可能出现因为故障或宕机导致消息没有处理完成的情况。此时，消息队列需要能提供消息可靠性的保证，也就是说，当消费者重启后，可以重新读取消息再次进行处理，否则，就会出现消息漏处理的问题了。</p>
<p>&emsp;&emsp;Redis 的 List 和 Streams 两种数据类型，就可以满足消息队列的这三个需求。我们先来了解下基于 List 的消息队列实现方法。</p>
<h2 id="基于-List-的消息队列解决方案"><a href="#基于-List-的消息队列解决方案" class="headerlink" title="基于 List 的消息队列解决方案"></a>基于 List 的消息队列解决方案</h2><h3 id="消息保存"><a href="#消息保存" class="headerlink" title="消息保存"></a>消息保存</h3><p>&emsp;&emsp;List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。具体来说，生产者可以使用 LPUSH 命令把要发送的消息依次写入 List，而消费者则可以使 用 RPOP 命令，从 List 的另一端按照消息的写入顺序，依次读取消息并进行处理。<br>&emsp;&emsp;如下图所示，生产者先用 LPUSH 写入了两条库存消息，分别是 5 和 3，表示要把库存更新为 5 和 3；消费者则用 RPOP 把两条消息依次读出，然后进行相应的处理。<br><img lazyload src="/images/loading.svg" data-src="redis67.jpg" alt="avatar"><br>&emsp;&emsp;不过，在消费者读取数据时，有一个潜在的性能风险点。在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，<strong>如果消费者想要及时处理消息，就需要在程序中不停地调用 RPOP 命令</strong>（比如使用一个 while(1) 循环）。如果有新消息写入，RPOP 命令就会返回结果，否则，RPOP 命令返回空值，再继续循环。所以，即使没有新消息写入 List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。<br>&emsp;&emsp;为了解决这个问题，Redis 提供了 BRPOP 命令。BRPOP 命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。和消费者程序自己不停地调用 RPOP 命令相比，这种方式能节省 CPU 开销。</p>
<h3 id="重复消息处理"><a href="#重复消息处理" class="headerlink" title="重复消息处理"></a>重复消息处理</h3><p>&emsp;&emsp;消息保序的问题解决了，接下来，我们还需要考虑解决重复消息处理的问题，这里其实有一个要求：消费者程序本身能对重复消息进行判断。<br>&emsp;&emsp;一方面，消息队列要能给每一个消息提供全局唯一的 ID 号；另一方面，消费者程序要把已经处理过的消息的 ID 号记录下来。(<strong>在扣款业务中也是如此，生成唯一的订单号就是服务端只扣款一次的保证</strong>)当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID， 来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。这种处理特性也称为<strong>幂等性</strong>，幂等性就是指，对于同一条消息，消费者收到一次的处理结果和收到多次的处理结果是一致的。不过，List 本身是不会为每个消息生成 ID 号的，所以，消息的全局唯一 ID 号就需要生产者程序在发送消息前自行生成。生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。例如，我们执行以下命令，就把一条全局 ID 为 101030001、库存量为 5 的消息插入了消息队列：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LPUSH mq <span class="string">&quot;101030001:stock:5&quot;</span> </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h3 id="保证消息可靠性"><a href="#保证消息可靠性" class="headerlink" title="保证消息可靠性"></a>保证消息可靠性</h3><p>&emsp;&emsp;当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了<strong>故障或宕机</strong>，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。<br>&emsp;&emsp;为了留存消息，List 类型提供了 BRPOPLPUSH 命令，这个命令的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。<br><img lazyload src="/images/loading.svg" data-src="redis68.jpg" alt="avatar"></p>
<p>&emsp;&emsp;但是，在用 List 做消息队列时，还可能遇到过一个问题：生产者消息发送很 快，而消费者处理消息的速度比较慢，这就导致 List 中的消息越积越多，给 Redis 的内存带来很大压力。这个时候，我们希望启动多个消费者程序组成一个消费组，一起分担处理 List 中的消息。 但是，List 类型并不支持消费组的实现。那么，还有没有更合适的解决方案呢？这就要说 到 Redis 从 5.0 版本开始提供的 Streams 数据类型了。</p>
<h2 id="基于-Streams-的消息队列解决方案"><a href="#基于-Streams-的消息队列解决方案" class="headerlink" title="基于 Streams 的消息队列解决方案"></a>基于 Streams 的消息队列解决方案</h2><p>&emsp;&emsp;Streams 是 Redis 专门为消息队列设计的数据类型，它提供了丰富的消息队列操作命令。</p>
<ol>
<li>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</li>
<li>XREAD：用于读取消息，可以按 ID 读取数据；</li>
<li>XREADGROUP：按消费组形式读取消息；</li>
<li>XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。</li>
</ol>
<ul>
<li><p>XADD<br>&emsp;&emsp;XADD 命令可以往消息队列中插入新消息，消息的格式是键 - 值对形式。对于插入的每一条消息，Streams 可以自动为其生成一个全局唯一的 ID。<br>&emsp;&emsp;比如说，我们执行下面的命令，就可以往名称为 mqstream 的消息队列中插入一条消息， 消息的键是 repo，值是 5。其中，消息队列名称后面的*，表示让 Redis 为插入的数据自动生成一个全局唯一的 ID，例如“1599203861727-0”。当然，我们也可以不用*，直接在消息队列名称后自行设定一个 ID 号，只要保证这个 ID 号是全局唯一的就行。不过，相比自行设定 ID 号，使用*会更加方便高效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XADD mqstream * repo 5</span><br><span class="line"><span class="string">&quot;1599203861727-0&quot;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，消息的全局唯一 ID 由两部分组成，第一部分“1599203861727”是数据插入时，以毫秒为单位计算的当前服务器时间，第二部分表示插入消息在当前毫秒内的消息序号，这是从 0 开始编号的。例如，“1599203861727-0”就表示在“1599203861727”毫秒内的第 1 条消息。</p>
</li>
<li><p>XREAD<br>&emsp;&emsp;XREAD 在读取消息时，可以指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取。例如，我们可以执行下面的命令，从 ID 号为 1599203861727-0 的消息开始，读取后续的所有消息（示例中一共 3 条）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XREAD BLOCK 100 STREAMS mqstream 1599203861727-0</span><br><span class="line">1) 1) <span class="string">&quot;mqstream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1599274912765-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">            2) <span class="string">&quot;3&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;1599274925823-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">		    2) <span class="string">&quot;2&quot;</span></span><br><span class="line">      3) 1) <span class="string">&quot;1599274927910-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">            2) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>&emsp;&emsp;另外，消费者也可以在调用 XRAED 时设定 block 配置项，实现类似于 BRPOP 的阻塞读取操作。当消息队列中没有消息时，一旦设置了 block 配置项，XREAD 就会阻塞，阻塞的时长可以在 block 配置项进行设置。<br>&emsp;&emsp;举个例子，我们来看一下下面的命令，其中，命令最后的“$”符号表示读取最新的消息，同时，我们设置了 block 10000 的配置项，10000 的单位是毫秒，表明 XREAD 在读取最新消息时，如果没有消息到来，XREAD 将阻塞 10000 毫秒（即 10 秒），然后再返回。下面命令中的 XREAD 执行后，消息队列 mqstream 中一直没有消息，所以，XREAD 在10 秒后返回空值（nil）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XREAD block 10000 streams mqstream $ </span><br><span class="line">(nil) </span><br><span class="line">(10.00s)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;刚刚讲到的这些操作是 List 也支持的，接下来，我们再来学习下 Streams 特有的功能。<br>&emsp;&emsp;Streams 本身可以使用 XGROUP 创建消费组，创建消费组之后，Streams 可以使用 XREADGROUP 命令让消费组内的消费者读取消息，例如，我们执行下面的命令，创建一个名为 group1 的消费组，这个消费组消费的消息队列是 mqstream。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XGROUP create mqstream group1 0 </span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后，我们再执行一段命令，让 group1 消费组里的消费者 consumer1 从 mqstream 中读取所有消息，其中，命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取。 因为在 consumer1 读取消息前，group1 中没有其他消费者读取过消息，所以， consumer1 就得到 mqstream 消息队列中的所有消息了（一共 4 条）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XREADGROUP group group1 consumer1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mqstream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1599203861727-0&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">         2) <span class="string">&quot;5&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;1599274912765-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">            2) <span class="string">&quot;3&quot;</span></span><br><span class="line">      3) 1) <span class="string">&quot;1599274925823-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">            2) <span class="string">&quot;2&quot;</span></span><br><span class="line">      4) 1) <span class="string">&quot;1599274927910-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">            2) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;需要注意的是，消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了。比如说，我们执行完刚才的 XREADGROUP 命令后，再执行下面的命令，让 group1 内的 consumer2 读取消息时，consumer2 读到的就是空值，因为消息已经被 consumer1 读取完了，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XREADGROUP group group1 consumer2 streams mqstream 0</span><br><span class="line">1) 1) <span class="string">&quot;mqstream&quot;</span></span><br><span class="line">   2) (empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。例如，我们执行下列命令，让 group2 中的 consumer1、2、3 各自读取一条消息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XREADGROUP group group2 consumer1 count 1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mqstream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1599203861727-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">            2) <span class="string">&quot;5&quot;</span></span><br><span class="line">XREADGROUP group group2 consumer2 count 1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mqstream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1599274912765-0&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">         2) <span class="string">&quot;3&quot;</span></span><br><span class="line">XREADGROUP group group2 consumer3 count 1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mqstream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1599274925823-0&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;repo&quot;</span></span><br><span class="line">         2) <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为了保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息，Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams“消息已经处理完成”。如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。例如，我们来查看一下 group2 中各个消费者已读取、但尚未确认的消息个数。其中， XPENDING 返回结果的第二、三行分别表示 group2 中所有消费者读取的消息最小 ID 和 最大 ID。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XPENDING mqstream group2</span><br><span class="line">1) (<span class="built_in">integer</span>) 3</span><br><span class="line">2) <span class="string">&quot;1599203861727-0&quot;</span></span><br><span class="line">3) <span class="string">&quot;1599274925823-0&quot;</span></span><br><span class="line">4) 1) 1) <span class="string">&quot;consumer1&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;consumer2&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;consumer3&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果我们还需要进一步查看某个消费者具体读取了哪些数据，可以执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XPENDING mqstream group2 - + 10 consumer2</span><br><span class="line">1) 1) <span class="string">&quot;1599274912765-0&quot;</span></span><br><span class="line">   2) <span class="string">&quot;consumer2&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 513336</span><br><span class="line">   4) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看到，consumer2 已读取的消息的 ID 是 1599274912765-0。一旦消息 1599274912765-0 被 consumer2 处理了，consumer2 就可以使用 XACK 命令通知 Streams，然后这条消息就会被删除。当我们再使用 XPENDING 命令查看时，就可以看到，consumer2 已经没有已读取、但尚未确认处理的消息了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XACK mqstream group2 1599274912765-0 </span><br><span class="line">(<span class="built_in">integer</span>) 1 </span><br><span class="line">XPENDING mqstream group2 - + 10 consumer2 </span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure>

<h1 id="异步机制：如何避免单线程模型的阻塞"><a href="#异步机制：如何避免单线程模型的阻塞" class="headerlink" title="异步机制：如何避免单线程模型的阻塞"></a>异步机制：如何避免单线程模型的阻塞</h1><p>&emsp;&emsp;Redis 的操作基本可以分为 4 类：</p>
<ol>
<li>服务客户端请求的键值对增删改查操作；</li>
<li>网络 IO；</li>
<li>保证可靠性的持久化操作；</li>
<li>进行主从复制时的数据同步操作。</li>
</ol>
<h2 id="Redis-实例有哪些阻塞点"><a href="#Redis-实例有哪些阻塞点" class="headerlink" title="Redis 实例有哪些阻塞点"></a>Redis 实例有哪些阻塞点</h2><p>&emsp;&emsp;Redis 实例在运行时，要和许多对象进行交互，这些不同的交互就会涉及不同的操作，下面我们来看看和 Redis 实例交互的对象，以及交互时会发生的操作。</p>
<ul>
<li>客户端：网络 IO，键值对增删改查操作，数据库操作；</li>
<li>磁盘：生成 RDB 快照，记录 AOF 日志，AOF 日志重写；</li>
<li>主从节点：主库生成、传输 RDB 文件，从库接收 RDB 文件、清空数据库、加载 RDB 文件；</li>
<li>切片集群实例：向其他实例传输哈希槽信息，数据迁移。<br>如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis69.jpg" alt="avatar"></li>
</ul>
<h3 id="和客户端交互时的阻塞点"><a href="#和客户端交互时的阻塞点" class="headerlink" title="和客户端交互时的阻塞点"></a>和客户端交互时的阻塞点</h3><p>&emsp;&emsp;网络 IO 有时候会比较慢，但是 Redis 使用了 IO 多路复用机制，避免了主线程一直处在等待网络连接或请求到来的状态，所以，网络 IO 不是导致 Redis 阻塞的因素。</p>
<ol>
<li><p>潜在阻塞点一：复杂度高的操作<br>&emsp;&emsp;键值对的增删改查操作是 Redis 和客户端交互的主要部分，也是 Redis 主线程执行的主要任务。所以，复杂度高的增删改查操作肯定会阻塞 Redis。<br>&emsp;&emsp;那么，怎么判断操作复杂度是不是高呢？这里有一个最基本的标准，就是看操作的复杂度是否为 O(N)。Redis 中涉及集合的操作复杂度通常为 O(N)，我们要在使用时重视起来。例如集合元素全量查询操作 HGETALL、SMEMBERS，以及集合的聚合统计操作，例如求交、并和差集。这些操作可以作为 Redis 的第一个阻塞点：<strong>集合全量查询</strong>和<strong>聚合操作</strong>。</p>
</li>
<li><p>潜在阻塞点二：bigkey 的删除<br>&emsp;&emsp;除此之外，集合自身的删除操作同样也有潜在的阻塞风险。你可能会认为，删除操作很简单，直接把数据删除就好了，为什么还会阻塞主线程呢？其实，删除操作的本质是要释放键值对占用的内存空间。你可不要小瞧内存的释放过程。 释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，<strong>操作系统需要把释放掉的内存块插入一个空闲内存块的链表</strong>，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会<strong>阻塞当前释放内存的应用程序</strong>，所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞。<br>&emsp;&emsp;那么，什么时候会释放大量内存呢？其实就是在删除大量键值对数据的时候，最典型的就是删除包含了大量元素的集合，也称为 bigkey 删除。测试了不同元素数量的集合在进行删除操作时所消耗的时间，如下表所示：<br><img lazyload src="/images/loading.svg" data-src="redis70.jpg" alt="avatar"></p>
</li>
<li><p>潜在阻塞点三：清空数据库<br>&emsp;&emsp;既然频繁删除键值对都是潜在的阻塞点了，那么，在 Redis 的数据库级别操作中，清空数 据库（例如 FLUSHDB 和 FLUSHALL 操作）必然也是一个潜在的阻塞风险，因为它涉及到 删除和释放所有的键值对。所以，这就是 Redis 的第三个阻塞点：清空数据库。</p>
</li>
</ol>
<h3 id="和磁盘交互的阻塞点"><a href="#和磁盘交互的阻塞点" class="headerlink" title="和磁盘交互的阻塞点"></a>和磁盘交互的阻塞点</h3><ol start="4">
<li>潜在阻塞点四：AOF 日志同步写<br>&emsp;&emsp;Redis 开发者早已认识到磁盘 IO 会带来阻塞，所以就把 Redis 进一步设计为采用子进程的方式生成 RDB 快照文件，以及执行 AOF 日志重写操作。这样一来，这两个操作由子进程负责执行，慢速的磁盘 IO 就不会阻塞主线程了。但是，Redis 直接记录 AOF 日志时，会根据不同的写回策略对数据做落盘保存。一个同步写磁盘的操作的耗时大约是 1～2ms，如果有大量的写操作需要记录在 AOF 日志中，并同 步写回的话，就会阻塞主线程了。这就得到了 Redis 的第四个阻塞点了：AOF 日志同步写。</li>
</ol>
<h3 id="主从节点交互时的阻塞点"><a href="#主从节点交互时的阻塞点" class="headerlink" title="主从节点交互时的阻塞点"></a>主从节点交互时的阻塞点</h3><p>&emsp;&emsp;在主从集群中，主库需要生成 RDB 文件，并传输给从库。主库在复制的过程中，创建和传输 RDB 文件都是由子进程来完成的，不会阻塞主线程。但是，对于从库来说，它在接收了 RDB 文件后，需要使用 FLUSHDB 命令清空当前数据库，这就正好撞上了刚才我们分析的第三个阻塞点。</p>
<ol start="5">
<li>潜在阻塞点五：从节点加载 RDB 文件<br>&emsp;&emsp;此外，从库在清空当前数据库后，还需要把 RDB 文件加载到内存，这个过程的快慢和 RDB 文件的大小密切相关，RDB 文件越大，加载过程越慢，所以，加载 RDB 文件就成为了 Redis 的第五个阻塞点。</li>
</ol>
<h3 id="切片集群实例交互时的阻塞点"><a href="#切片集群实例交互时的阻塞点" class="headerlink" title="切片集群实例交互时的阻塞点"></a>切片集群实例交互时的阻塞点</h3><p>&emsp;&emsp;最后，当我们部署 Redis 切片集群时，每个 Redis 实例上分配的哈希槽信息需要在不同实例间进行传递，同时，当需要进行负载均衡或者有实例增删时，数据会在不同的实例间进行迁移。不过，哈希槽的信息量不大，而数据迁移是渐进式执行的，所以，一般来说，这两类操作对 Redis 主线程的阻塞风险不大。不过，如果你使用了 Redis Cluster 方案，而且同时正好迁移的是 bigkey 的话，就会造成主线程的阻塞，因为 Redis Cluster 使用了同步迁移。当没有 bigkey 时，切片集群的各实例在进行交互时不会阻塞主线程。</p>
<p>&emsp;&emsp;总结一下五个阻塞点：</p>
<ol>
<li>集合全量查询和聚合操作；</li>
<li>bigkey 删除；</li>
<li>清空数据库；</li>
<li>AOF 日志同步写；</li>
<li>从库加载 RDB 文件。</li>
</ol>
<p>&emsp;&emsp;如果在主线程中执行这些操作，必然会导致主线程长时间无法服务其他请求。为了避免阻塞式操作，Redis 提供了异步线程机制。所谓的异步线程机制，就是指，Redis 会启动一些子线程，然后把一些任务交给这些子线程，让它们在后台完成，而不再由主线程来执行这些任务。使用异步线程机制执行操作，可以避免阻塞主线程。</p>
<h2 id="哪些阻塞点可以异步执行"><a href="#哪些阻塞点可以异步执行" class="headerlink" title="哪些阻塞点可以异步执行"></a>哪些阻塞点可以异步执行</h2><p>&emsp;&emsp;如果一个操作能被异步执行，就意味着，它并不是 Redis 主线程的关键路径上的操作。关键路径上的操作就是客户端把请求发送给 Redis 后，等着 Redis 返回数据结果的操作。</p>
<p><img lazyload src="/images/loading.svg" data-src="redis71.jpg" alt="avatar"><br>&emsp;&emsp;主线程接收到操作 1 后，因为操作 1 并不用给客户端返回具体的数据，所以，主线程可以把它交给后台子线程来完成，同时只要给客户端返回一个“OK”结果就行。在子线程执行操作 1 的时候，客户端又向 Redis 实例发送了操作 2，而此时，客户端是需要使用操作 2 返回的数据结果的，如果操作 2 不返回结果，那么，客户端将一直处于等待状态。</p>
<ol>
<li><p>集合全量查询和聚合操作<br>&emsp;&emsp;对于 Redis 来说，读操作是典型的关键路径操作，因为客户端发送了读操作之后，就会等待读取的数据返回，以便进行后续的数据处理。而 Redis 的第一个阻塞点“集合全量查询和聚合操作”都涉及到了读操作，所以，它们是不能进行异步操作了。</p>
</li>
<li><p>bigkey 删除 &amp; 清空数据库<br>&emsp;&emsp;我们再来看看删除操作。删除操作并不需要给客户端返回具体的数据结果，所以不算是关键路径操作。而我们刚才总结的第二个阻塞点“bigkey 删除”，和第三个阻塞点“清空数据库”，都是对数据做删除，并不在关键路径上。因此，我们可以使用后台子线程来异步执行删除操作。</p>
</li>
<li><p>AOF 日志同步<br>&emsp;&emsp;对于第四个阻塞点“AOF 日志同步写”来说，为了保证数据可靠性，Redis 实例需要保证 AOF 日志中的操作记录已经落盘，这个操作虽然需要实例等待，但它并不会返回具体的数据结果给实例。所以，我们也可以启动一个子线程来执行 AOF 日志的同步写，而不用让主线程等待 AOF 日志的写完成。</p>
</li>
<li><p>从库加载 RDB 文件<br>&emsp;&emsp;最后，我们再来看下“从库加载 RDB 文件”这个阻塞点。从库要想对客户端提供数据存取服务，就必须把 RDB 文件加载完成。所以，这个操作也属于关键路径上的操作，我们必须让从库的主线程来执行。</p>
</li>
</ol>
<p>&emsp;&emsp;对于 Redis 的五大阻塞点来说，除了“集合全量查询和聚合操作”和“从库加载 RDB 文件”，其他三个阻塞点涉及的操作都不在关键路径上，所以，我们可以使用 Redis 的异步子线程机制来实现 bigkey 删除，清空数据库，以及 AOF 日志同步写。</p>
<h2 id="Redis-的异步子线程机制"><a href="#Redis-的异步子线程机制" class="headerlink" title="Redis 的异步子线程机制"></a>Redis 的异步子线程机制</h2><p>&emsp;&emsp;Redis 主线程启动后，会<strong>使用操作系统提供的 pthread_create 函数创建 3 个子线程</strong>，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。</p>
<ol>
<li>键值对删除子线程<br>&emsp;&emsp;主线程通过一个链表形式的任务队列和子线程进行交互。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成。但实际上，这个时候删除还没有执行，等到后台子线程从任务队列中读取任务后，才开始实际删除键值对，并释放相应的内存空间。因此，我们把这种异步删除也称为惰性删除（lazy free）。此时，删除或清空操作不会阻塞主线程，这就避免了对主线程的性能影响。<br>&emsp;&emsp;异步的键值对删除和数据库清空操作是 Redis 4.0 后提供的功能，Redis 也提供了新的命令来执行这两个操作。</li>
</ol>
<ul>
<li>键值对删除：当集合类型中有大量元素（例如有百万级别或千万级别元素）需要删除时，建议使用 UNLINK 命令。</li>
<li>清空数据库：可以在 FLUSHDB 和 FLUSHALL 命令后加上 ASYNC 选项，这样就可以让后台子线程异步地清空数据库，如下所示：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FLUSHDB ASYNC </span><br><span class="line">FLUSHALL ASYNC</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>AOF 日志同步<br>&emsp;&emsp;当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到任务队列中。后台子线程读取任务后，开始自行写入 AOF 日志，这样主线程就不用一直等待 AOF 日志写完了。</li>
</ol>
<p>&emsp;&emsp;下面这张图展示了 Redis 中的异步子线程执行机制:<br><img lazyload src="/images/loading.svg" data-src="redis72.jpg" alt="avatar"></p>
<h2 id="使用-scan-避免-keys-命令"><a href="#使用-scan-避免-keys-命令" class="headerlink" title="使用 scan 避免 keys 命令"></a>使用 scan 避免 keys 命令</h2><p>&emsp;&emsp;有时候需要从 Redis 实例成千上万的 key 中找出特定前缀的 key 列表来手动处理数据，可能是修改它的值，也可能是删除 key。这里就有一个问题，如何从海量的 key 中找出满足特定前缀的 key 列表来？Redis 提供了一个简单暴力的指令 keys 用来列出所有满足特定正则字符串规则的 key。这个指令使用非常简单，提供一个简单的正则字符串即可，但是有很明显的两个缺点。</p>
<ol>
<li>没有 offset、limit 参数，一次性吐出所有满足条件的 key，万一实例中有几百 w 个 key 满足条件，当你看到满屏的字符串刷的没有尽头时，你就知道难受了;</li>
<li>keys 算法是遍历算法，复杂度是 O(n)，如果实例中有千万级以上的 key，这个指令就会导致 Redis 服务卡顿，所有读写 Redis 的其它的指令都会被延后甚至会超时报错，因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续。</li>
</ol>
<p>&emsp;&emsp;因此在实际的生产环境中建议屏蔽掉 keys 命令。Redis 为了解决这个问题，它在 2.8 版本中加入了指令——scan。<br>&emsp;&emsp;scan 相比 keys 具备有以下特点：</p>
<ol>
<li>复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程；</li>
<li>提供 limit 参数，可以控制每次返回结果的最大条数，limit 只是对增量式迭代命令的一种提示(hint)，返回的结果可多可少；</li>
<li>同 keys 一样，它也提供模式匹配功能；</li>
<li>服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数；</li>
<li>返回的结果可能会有重复，需要客户端去重复，这点非常重要；</li>
<li>遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的；</li>
<li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零。</li>
</ol>
<h3 id="scan-基础使用"><a href="#scan-基础使用" class="headerlink" title="scan 基础使用"></a>scan 基础使用</h3><p><strong>SCAN cursor [MATCH pattern] [COUNT count]</strong><br>&emsp;&emsp;初始执行scan命令例如scan 0。SCAN命令是一个基于游标的迭代器。这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数，以此来延续之前的迭代过程。当SCAN命令的游标参数被设置为0时，服务器将开始一次新的迭代，而当redis服务器向用户返回值为0的游标时，表示迭代已结束，这是唯一迭代结束的判定方式，而不能通过返回结果集是否为空判断迭代结束。<br>&emsp;&emsp;scan 参数提供了三个参数，第一个是 cursor 整数值，第二个是 key 的正则模式，第三个是遍历的 limit hint。例如下面所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scan 0 match key99* count 1000</span><br><span class="line">1) <span class="string">&quot;13912&quot;</span> </span><br><span class="line">2) 1) <span class="string">&quot;key997&quot;</span> </span><br><span class="line">   2) <span class="string">&quot;key9906&quot;</span> </span><br><span class="line">   3) <span class="string">&quot;key9957&quot;</span> </span><br><span class="line">   4) <span class="string">&quot;key9902&quot;</span> </span><br><span class="line">   5) <span class="string">&quot;key9971&quot;</span> </span><br><span class="line">   6) <span class="string">&quot;key9935&quot;</span> </span><br><span class="line">   7) <span class="string">&quot;key9958&quot;</span> </span><br><span class="line">   8) <span class="string">&quot;key9928&quot;</span> </span><br><span class="line">   9) <span class="string">&quot;key9931&quot;</span> </span><br><span class="line">   10) <span class="string">&quot;key9961&quot;</span> </span><br><span class="line">   11) <span class="string">&quot;key9948&quot;</span> </span><br><span class="line">   12) <span class="string">&quot;key9965&quot;</span> </span><br><span class="line">   13) <span class="string">&quot;key9937&quot;</span></span><br><span class="line">   </span><br><span class="line">scan 13912 match key99* count 1000</span><br><span class="line">1) <span class="string">&quot;5292&quot;</span> </span><br><span class="line">2) 1) <span class="string">&quot;key996&quot;</span> </span><br><span class="line">   2) <span class="string">&quot;key9960&quot;</span> </span><br><span class="line">   3) <span class="string">&quot;key9973&quot;</span> </span><br><span class="line">   4) <span class="string">&quot;key9978&quot;</span> </span><br><span class="line">   5) <span class="string">&quot;key9927&quot;</span></span><br><span class="line">   6) <span class="string">&quot;key995&quot;</span> </span><br><span class="line">   7) <span class="string">&quot;key9992&quot;</span> </span><br><span class="line">   8) <span class="string">&quot;key9993&quot;</span> </span><br><span class="line">   9) <span class="string">&quot;key9964&quot;</span> </span><br><span class="line">   10) <span class="string">&quot;key9934&quot;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回结果分为两个部分：第一部分即 1) 就是下一次迭代游标，第二部分即 2) 就是本次迭代结果集。从上面的过程可以看到虽然提供的 limit 是 1000，但是返回的结果只有 10 个左右。因为这个 limit 不是限定返回结果的数量，而是限定服务器单次遍历的字典槽位数量(约等于)。如果将 limit 设置为 10，你会发现返回结果是空的，但是游标值不为零，意味着遍历还没结束。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scan 0 match key99* count 10</span><br><span class="line">1) <span class="string">&quot;15360&quot;</span> </span><br><span class="line">2) (empty list or <span class="built_in">set</span>)</span><br><span class="line">scan 15360 match key99* count 10</span><br><span class="line">1) <span class="string">&quot;2304&quot;</span> </span><br><span class="line">2) (empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure>

<h1 id="删除数据后为什么内存占用率还是很高？"><a href="#删除数据后为什么内存占用率还是很高？" class="headerlink" title="删除数据后为什么内存占用率还是很高？"></a>删除数据后为什么内存占用率还是很高？</h1><p>&emsp;&emsp;在使用 Redis 时，我们经常会遇到这样一个问题：明明做了数据删除，数据量已经不大 了，为什么使用 top 命令查看时，还会发现 Redis 占用了很多内存呢？首先要明白一个概念，那就是操作系统的内存碎片是什么。应用申请内存通常是一段连续的内存空间，以 64 位的系统为例，一个内存块的大小是 8 字节，当要保存一段 6 字节的数据时，会申请一块新的内存块，这样就会剩下 2 字节的内存没被占用并且也不会再被分配给其他的数据。这样就出现了 2 字节的内存碎片。<br><img lazyload src="/images/loading.svg" data-src="redis73.jpg" alt="avatar"></p>
<h2 id="出现内存碎片的原因"><a href="#出现内存碎片的原因" class="headerlink" title="出现内存碎片的原因"></a>出现内存碎片的原因</h2><h3 id="内因：内存分配器的分配策略"><a href="#内因：内存分配器的分配策略" class="headerlink" title="内因：内存分配器的分配策略"></a>内因：内存分配器的分配策略</h3><p>&emsp;&emsp;内存分配器的分配策略就决定了操作系统无法做到“按需分配”。这是因为，内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。<br>&emsp;&emsp;Redis 可以使用 libc、jemalloc、tcmalloc 多种内存分配器来分配内存，默认使用 jemalloc。接下来，就以 jemalloc 为例，来具体解释一下。其他分配器也存在类似的问题。<br>&emsp;&emsp;jemalloc 的分配策略之一，是按照一系列固定的大小划分内存空间，例如 8 字节、16 字节、32 字节、48 字节，…, 2KB、4KB、8KB 等。当程序申请的内存最接近某个固定值 ，jemalloc 会给它分配相应大小的空间。这样的分配方式本身是为了减少分配次数。例如，Redis 申请一个 20 字节的空间保存数据，jemalloc 就会分配 32 字节，此时，如果应用还要写入 10 字节的数据，Redis 就不用再向操作系统申请空间了，因为刚才分配的 32 字节已经够用了，这就避免了一次分配操作。但是，如果 Redis 每次向分配器申请的内存空间大小不一样，这种分配方式就会有形成碎片的风险，而这正好来源于 Redis 的外因了。</p>
<h3 id="外因：键值对大小不一样和删改操作"><a href="#外因：键值对大小不一样和删改操作" class="headerlink" title="外因：键值对大小不一样和删改操作"></a>外因：键值对大小不一样和删改操作</h3><p>&emsp;&emsp;Redis 通常作为共用的缓存系统或键值数据库对外提供服务，所以，不同业务应用的数据都可能保存在 Redis 中，这就会带来不同大小的键值对。这样一来，Redis 申请内存空间分配时，本身就会有大小不一的空间需求。这是第一个外因。<br>&emsp;&emsp;第二个外因是，这些键值对会被修改和删除，这会导致空间的扩容和释放。具体来说，一方面，如果修改后的键值对变大或变小了，就需要占用额外的空间或者释放不用的空间。另一方面，删除的键值对就不再需要内存空间了，此时，就会把空间释放出来，形成空闲空间。</p>
<h3 id="如何清理内存碎片？"><a href="#如何清理内存碎片？" class="headerlink" title="如何清理内存碎片？"></a>如何清理内存碎片？</h3><p>&emsp;&emsp;当 Redis 发生内存碎片后，一个“简单粗暴”的方法就是重启 Redis 实例。当然，这并不是一个“优雅”的方法，毕竟，重启 Redis 会带来两个后果：</p>
<ol>
<li>如果 Redis 中的数据没有持久化，那么，数据就会丢失；</li>
<li>即使 Redis 数据持久化了，我们还需要通过 AOF 或 RDB 进行恢复，恢复时长取决于 AOF 或 RDB 的大小，如果只有一个 Redis 实例，恢复阶段无法提供服务。</li>
</ol>
<p>清理过程如下：<br><img lazyload src="/images/loading.svg" data-src="redis74.jpg" alt="avatar"><br>&emsp;&emsp;不过，需要注意的是：碎片清理是有代价的，操作系统需要把多份数据拷贝到新位置，把原有空间释放出来，这会带来时间开销。因为 Redis 是单线程，在数据拷贝时，Redis 只能等着，这就导致 Redis 无法及时处理请求，性能就会降低。而且，有的时候，数据拷贝还需要注意顺序，就像刚刚说的清理内存碎片的例子，操作系统需要先拷贝 D，并释放 D 的空间后，才能拷贝 B。这种对顺序性的要求，会进一步增加 Redis 的等待时间，导致性能降低。那么，有什么办法可以尽量缓解这个问题吗？这就要提到，Redis 专门为自动内存碎片清理功机制设置的参数了。我们可以通过设置参数，来控制碎片清理的开始和结束时机，以及占用的 CPU 比例，从而减少碎片清理对 Redis 本身请求处理的性能影响。</p>
<p>&emsp;&emsp;首先，Redis 需要启用自动内存碎片清理，可以把 activedefrag 配置项设置为 yes，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config <span class="built_in">set</span> activedefrag yes</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;自动内存碎片清理机制在控制碎片清理启停的时机上，既考虑了碎片的空间占比、对 Redis 内存使用效率的影响，还考虑了清理机制本身的 CPU 时间占比、对 Redis 性能的影响。</p>
<h1 id="Redis-作为缓存的两种策略"><a href="#Redis-作为缓存的两种策略" class="headerlink" title="Redis 作为缓存的两种策略"></a>Redis 作为缓存的两种策略</h1><p>&emsp;&emsp;在商品大促的场景中，商品的库存信息会一直被修改。如果每次修改都需到数据库中处理，就会拖慢整个应用，此时，我们通常会选择读写缓存的模式。而在短视频 App 的场景中，虽然视频的属性有很多，但是，一般确定后，修改并不频繁，此时，在数据库中进行修改对缓存影响不大，所以只读缓存模式是一个合适的选择。</p>
<h2 id="只读缓存"><a href="#只读缓存" class="headerlink" title="只读缓存"></a>只读缓存</h2><p>&emsp;&emsp;当 Redis 用作只读缓存时，应用要读取数据的话，会先调用 Redis GET 接口，查询数据是否存在。而所有的数据写请求，会直接发往后端的数据库，在数据库中增删改。对于删 的数据来说，如果 Redis 已经缓存了相应的数据，应用需要把这些缓存的数据删除，Redis 中就没有这些数据了。当应用再次读取这些数据时，会发生缓存缺失，应用会把这些数据从数据库中读出来，并写到缓存中。这样一来，这些数据后续再被读取时，就可以直接从缓存中获取了，能起到加速访问的效果。举个例子。假设业务应用要修改数据 A，此时，数据 A 在 Redis 中也缓存了，那么，应用会先直接在数据库里修改 A，并把 Redis 中的 A 删除。等到应用需要读取数据 A 时，会发生缓存缺失，此时，应用从数据库中读取 A，并写入 Redis，以便后续请求从缓存中直接读取，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis75.jpg" alt="avatar"><br>&emsp;&emsp;只读缓存直接在数据库中更新数据的好处是，所有最新的数据都在数据库中，而数据库是提供数据可靠性保障的，这些数据不会有丢失的风险。当我们需要缓存图片、短视频这些用户只读的数据时，就可以使用只读缓存这个类型了。</p>
<h2 id="读写缓存"><a href="#读写缓存" class="headerlink" title="读写缓存"></a>读写缓存</h2><p>&emsp;&emsp;对于读写缓存来说，除了读请求会发送到缓存进行处理（直接在缓存中查询数据是否存在)，所有的写请求也会发送到缓存，在缓存中直接对数据进行增删改操作。此时，得益于 Redis 的高性能访问特性，数据的增删改操作可以在缓存中快速完成，处理结果也会快速返回给业务应用，这就可以提升业务应用的响应速度。但是，和只读缓存不一样的是，在使用读写缓存时，最新的数据是在 Redis 中，而 Redis 是内存数据库，一旦出现掉电或宕机，内存中的数据就会丢失。这也就是说，应用的最新数据可能会丢失，给应用业务带来风险。所以，根据业务应用对数据可靠性和缓存性能的不同要求，我们会有同步直写和异步写回两种策略。其中，同步直写策略优先保证数据可靠性，而异步写回策略优先提供快速响应。学习了解这两种策略，可以帮助我们根据业务需求，做出正确的设计选择。</p>
<p>&emsp;&emsp;关于是选择只读缓存，还是读写缓存，主要看我们对写请求是否有加速的需求。</p>
<ul>
<li>如果需要对写请求进行加速，我们选择读写缓存；</li>
<li>如果写请求很少，或者是只需要提升读请求的响应速度的话，我们选择只读缓存。</li>
</ul>
<h3 id="同步直写"><a href="#同步直写" class="headerlink" title="同步直写"></a>同步直写</h3><p>&emsp;&emsp;写请求发给缓存的同时，也会发给后端数据库进行处理，等到缓存和数据库都写完数据，才给客户端返回。这样，即使缓存宕机或发生故障，最新的数据仍然保存在数据库中，这就提供了数据可靠性保证。不过，同步直写会降低缓存的访问性能。这是因为缓存中处理写请求的速度是很快的，而数据库处理写请求的速度较慢。即使缓存很快地处理了写请求，也需要等待数据库处理完所有的写请求，才能给应用返回结果，这就增加了缓存的响应延迟。</p>
<h3 id="异步写回"><a href="#异步写回" class="headerlink" title="异步写回"></a>异步写回</h3><p>&emsp;&emsp;而异步写回策略，则是优先考虑了响应延迟。此时，所有写请求都先在缓存中处理。等到这些增改的数据要被从缓存中淘汰出来时，缓存将它们写回后端数据库。这样一来，处理这些数据的操作是在缓存中进行的，很快就能完成。只不过，如果发生了掉电，而它们还没有被写回数据库，就会有丢失的风险了。</p>
<h1 id="Redis-的缓存策略"><a href="#Redis-的缓存策略" class="headerlink" title="Redis 的缓存策略"></a>Redis 的缓存策略</h1><p><img lazyload src="/images/loading.svg" data-src="redis76.jpg" alt="avatar"></p>
<ol>
<li><p>noeviction<br>&emsp;&emsp;默认情况下，Redis 在使用的内存空间超过 maxmemory 值时，并不会淘汰数据，也就是设定的 noeviction 策略。对应到 Redis 缓存，也就是指，一旦缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误。Redis 用作缓存时，实际的数据集通常都是大于缓存容量的，总会有新的数据要写入缓存，这个策略本身不淘汰数据，也就不会腾出新的缓存空间，我们不把它用在 Redis 缓存中。</p>
</li>
<li><p>volatile：只在设置了过期时间的键值对中进行删除</p>
</li>
<li><ol>
<li>volatile-ttl 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除；</li>
</ol>
</li>
<li><ol start="2">
<li>volatile-random 在设置了过期时间的键值对中，进行随机删除；</li>
</ol>
</li>
<li><ol start="3">
<li>volatile-lru 使用 LRU 算法筛选设置了过期时间的键值对；</li>
</ol>
</li>
<li><ol start="4">
<li>volatile-lfu 使用 LFU 算法选择设置了过期时间的键值对。</li>
</ol>
</li>
</ol>
<p>&emsp;&emsp;如果一个键值对被删除策略选中了，即使它的过期时间还没到，也需要被删 除。当然，如果它的过期时间到了但未被策略选中，同样也会被删除。</p>
<ol start="3">
<li>allkeys：备选淘汰数据范围，扩大到了所有键值对，无论这些键值对是否设置了过期时间</li>
<li><ol>
<li>allkeys-random：从所有键值对中随机选择并删除数据；</li>
</ol>
</li>
<li><ol start="2">
<li>allkeys-lru：使用 LRU 算法在所有数据中进行筛选；</li>
</ol>
</li>
<li><ol start="3">
<li>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选。</li>
</ol>
</li>
</ol>
<h2 id="如何处理被淘汰的数据？"><a href="#如何处理被淘汰的数据？" class="headerlink" title="如何处理被淘汰的数据？"></a>如何处理被淘汰的数据？</h2><p>&emsp;&emsp;一般来说，一旦被淘汰的数据选定后，如果这个数据是干净数据，那么我们就直接删除；如果这个数据是脏数据，我们需要把它写回数据库，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis77.jpg" alt="avatar"><br>那怎么判断一个数据到底是干净的还是脏的呢？干净数据和脏数据的区别就在于，和最初从后端数据库里读取时的值相比，有没有被修改过。干净数据一直没有被修改，所以后端数据库里的数据也是最新值。在替换时，它可以被直接删除。而脏数据就是曾经被修改过的，已经和后端数据库中保存的数据不一致了。此时，如果不把脏数据写回到数据库中，这个数据的最新值就丢失了，就会影响应用的正常使用。</p>
<h1 id="缓存和数据库的数据一致问题"><a href="#缓存和数据库的数据一致问题" class="headerlink" title="缓存和数据库的数据一致问题"></a>缓存和数据库的数据一致问题</h1><h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><p>“一致性”包含了两种情况：</p>
<ol>
<li>缓存中有数据，那么，缓存的数据值需要和数据库中的值相同；</li>
<li>缓存中本身没有数据，那么，数据库中的值必须是最新值。</li>
</ol>
<h2 id="只读缓存的数据一致问题"><a href="#只读缓存的数据一致问题" class="headerlink" title="只读缓存的数据一致问题"></a>只读缓存的数据一致问题</h2><h3 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h3><p>&emsp;&emsp;如果是新增数据，数据会直接写到数据库中，不用对缓存做任何操作，此时，缓存中本身就没有新增数据，而数据库中是最新值，这种情况符合我们刚刚所说的一致性的第 2 种情况，所以，此时，缓存和数据库的数据是一致的。</p>
<h3 id="删改数据"><a href="#删改数据" class="headerlink" title="删改数据"></a>删改数据</h3><p>&emsp;&emsp;如果发生删改操作，应用既要更新数据库，也要在缓存中删除数据。这两个操作如果无法保证原子性，也就是说，要不都完成，要不都没完成，此时，就会出现数据不一致问题了。</p>
<ul>
<li><p>先删除缓存，再更新数据库<br>我们假设应用先删除缓存，再更新数据库，如果缓存删除成功，但是数据库更新失败，那么，应用再访问数据时，缓存中没有数据，就会发生缓存缺失。然后，应用再访问数据库，但是数据库中的值为旧值，应用就访问到旧值了。<br><img lazyload src="/images/loading.svg" data-src="redis78.jpg" alt="avatar"><br>&emsp;&emsp;应用要把数据 X 的值从 10 更新为 3，先在 Redis 缓存中删除了 X 的缓存值，但是更新数据库却失败了。如果此时有其他并发的请求访问 X，会发现 Redis 中缓存缺失，紧接着，请求就会访问数据库，读到的却是旧值 10。</p>
</li>
<li><p>先更新数据库，再删除缓存<br>&emsp;&emsp;如果应用先完成了数据库的更新，但是，在删除缓存时失败了，那么，数据库中的值是新值，而缓存中的是旧值，这肯定是不一致的。这个时候，如果有其他的并发请求来访问数据，按照正常的缓存访问流程，就会先在缓存中查询，但此时，就会读到旧值了。<br><img lazyload src="/images/loading.svg" data-src="redis79.jpg" alt="avatar"><br>&emsp;&emsp;应用要把数据 X 的值从 10 更新为 3，先成功更新了数据库，然后在 Redis 缓存中删除 X 的缓存，但是这个操作却失败了，这个时候，数据库中 X 的新值为 3，Redis 中的 X 的缓存值为 10，这肯定是不一致的。如果刚好此时有其他客户端也发送请求访问 X，会先在 Redis 中查询，该客户端会发现缓存命中，但是读到的却是旧值 10。</p>
</li>
</ul>
<p>&emsp;&emsp;我们可以看到，在更新数据库和删除缓存值的过程中，无论这两个操作的执行顺序谁先谁后，只要有一个操作失败了，就会导致客户端读取到旧值。下面这张表总结了刚刚所说的这两种情况。<br><img lazyload src="/images/loading.svg" data-src="redis80.jpg" alt="avatar"></p>
<h4 id="如何解决数据不一致问题？"><a href="#如何解决数据不一致问题？" class="headerlink" title="如何解决数据不一致问题？"></a>如何解决数据不一致问题？</h4><p><strong>重试机制</strong>：具体来说，可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用 Kafka 消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。<br>&emsp;&emsp;如果能够成功地删除或更新，我们就要把这些值从消息队列中去除，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了。否则的话，我们还需要再次进行重试。如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。<br><img lazyload src="/images/loading.svg" data-src="redis81.jpg" alt="avatar"></p>
<p><strong>并发情况下怎样解决</strong></p>
<ul>
<li>情况一：先删除缓存，再更新数据库<br>&emsp;&emsp;假设线程 A 删除缓存值后，还没有来得及更新数据库（比如说有网络延迟），线程 B 就开始读取数据了，那么这个时候，线程 B 会发现缓存缺失，就只能去数据库读取。这会带来两个问题：</li>
</ul>
<ol>
<li>线程 B 读取到了旧值；</li>
<li>线程 B 是在缓存缺失的情况下读取的数据库，所以，它还会把旧值写入缓存，这可能会导致其他线程从缓存中读到旧值。<br>&emsp;&emsp;等到线程 B 从数据库读取完数据、更新了缓存后，线程 A 才开始更新数据库，此时，缓存中的数据是旧值，而数据库中的是最新值，两者就不一致了。<br><img lazyload src="/images/loading.svg" data-src="redis82.jpg" alt="avatar"></li>
</ol>
<p><strong>解决方案</strong>：在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间，再进行一次缓存删除操作。<br>&emsp;&emsp;之所以要加上 sleep 的这段时间，就是为了让线程 B 能够先从数据库读取数据，再把缺失的数据写入缓存，然后，线程 A 再进行删除。所以，线程 A sleep 的时间，就需要大于线程 B 读取数据再写入缓存的时间。这个时间怎么确定呢？建议你在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，以此为基础来进行估算。这样一来，其它线程读取数据时，会发现缓存缺失，所以会从数据库中读取最新值。因为这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，所以我们也把它叫做“延迟双删”。下面的这段伪代码就是“延迟双删”方案的示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis.delKey(X) // 先删除缓存</span><br><span class="line">db.update(X)	// 再更新数据库</span><br><span class="line">Thread.sleep(N) // 睡眠一会儿</span><br><span class="line">redis.delKey(X) // 再删除一遍缓存，确保之后缓存中的数据是更新后的</span><br></pre></td></tr></table></figure>

<ul>
<li>情况二：先更新数据库值，再删除缓存值<br>&emsp;&emsp;如果线程 A 删除了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了，那么此时，线程 B 查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。不过，在这种情况下，如果其他线程并发读缓存的请求不多，那么，就不会有很多请求读取到旧值。而且，线程 A 一般也会很快删除缓存值，这样一来，其他线程再次读取时，就会发生缓存缺失，进而从数据库中读取最新值。所以，这种情况对业务的影响较小。<br><img lazyload src="/images/loading.svg" data-src="redis83.jpg" alt="avatar"></li>
</ul>
<p>&emsp;&emsp;总结一下上述的解决方案：</p>
<ol>
<li>删除缓存和更新数据库的“原子”操作：使用消息队列，当前一个事件完成后立即向消息队列中投递消息，只有当后续事件成功才消费掉这个消息，避免之后的事件因为失败而导致数据不一致；</li>
<li>如果采用先删除缓存，再更新数据库的策略，使用“延迟双删”方案：确保缓存中的数据最终一定和数据库一致。<br><img lazyload src="/images/loading.svg" data-src="redis84.jpg" alt="avatar"></li>
</ol>
<h2 id="读写缓存的数据一致问题"><a href="#读写缓存的数据一致问题" class="headerlink" title="读写缓存的数据一致问题"></a>读写缓存的数据一致问题</h2><p>&emsp;&emsp;这种情况删改操作同时操作数据库和缓存。</p>
<h3 id="新增数据-1"><a href="#新增数据-1" class="headerlink" title="新增数据"></a>新增数据</h3><p>&emsp;&emsp;同只读缓存</p>
<h3 id="删改数据-1"><a href="#删改数据-1" class="headerlink" title="删改数据"></a>删改数据</h3><ul>
<li><strong>重试机制</strong>：同只读缓存</li>
</ul>
<ol>
<li>先更新数据库，再更新缓存：如果更新数据库成功，但缓存更新失败，此时数据库中是最新值，但缓存中是旧值，后续的读请求会直接命中缓存，得到的是旧值。  </li>
<li>先更新缓存，再更新数据库：如果更新缓存成功，但数据库更新失败，此时缓存中是最新值，数据库中是旧值，后续读请求会直接命中缓存，但得到的是最新值，短期对业务影响不大。但是，一旦缓存过期或者满容后被淘汰，读请求就会从数据库中重新加载旧值到缓存中，之后的读请求会从缓存中得到旧值，对业务产生影响。  </li>
</ol>
<p>&emsp;&emsp;同样地，针对这种其中一个操作可能失败的情况，也可以使用重试机制解决，把第二步操作放入到消息队列中，消费者从消息队列取出消息，再更新缓存或数据库，成功后把消息从消息队列删除，否则进行重试，以此达到数据库和缓存的最终一致。</p>
<p><strong>并发情况下怎样解决</strong></p>
<ol>
<li><p>先更新数据库，再更新缓存，写+读并发：线程A先更新数据库，之后线程B读取数据，此时线程B会命中缓存，读取到旧值，之后线程A更新缓存成功，后续的读请求会命中缓存得到最新值。这种场景下，线程A未更新完缓存之前，在这期间的读请求会短暂读到旧值，对业务短暂影响。</p>
</li>
<li><p>先更新缓存，再更新数据库，写+读并发：线程A先更新缓存成功，之后线程B读取数据，此时线程B命中缓存，读取到最新值后返回，之后线程A更新数据库成功。这种场景下，虽然线程A还未更新完数据库，数据库会与缓存存在短暂不一致，但在这之前进来的读请求都能直接命中缓存，获取到最新值，所以对业务没影响。</p>
</li>
<li><p>先更新数据库，再更新缓存，写+写并发：线程A和线程B同时更新同一条数据，假如更新数据库的顺序是先A后B，但更新缓存时顺序是先B后A，这会导致数据库和缓存的不一致。</p>
</li>
<li><p>先更新缓存，再更新数据库，写+写并发：与场景3类似，线程A和线程B同时更新同一条数据，假如更新缓存的顺序是先A后B，但是更新数据库的顺序是先B后A，这也会导致数据库和缓存的不一致。</p>
</li>
</ol>
<p>总结：场景1和2对业务影响较小，场景3和4会造成数据库和缓存不一致，影响较大。也就是说，在读写缓存模式下，写+读并发对业务的影响较小，而写+写并发时，会造成数据库和缓存的不一致。针对场景3和4的解决方案是，对于写请求，需要配合分布式锁使用。写请求进来时，针对同一个资源的修改操作，先加分布式锁，这样同一时间只允许一个线程去更新数据库和缓存，没有拿到锁的线程把操作放入到队列中，延时处理。用这种方式保证多个线程操作同一资源的顺序性，以此保证一致性。综上，使用读写缓存同时操作数据库和缓存时，因为其中一个操作失败导致不一致的问题，同样可以通过<strong>消息队列</strong>重试来解决。而在并发的场景下，读+写并发对业务没有影响或者影响较小，而<strong>写+写并发时需要配合分布式锁</strong>的使用，才能保证缓存和数据库的一致性。</p>
<p>&emsp;&emsp;另外，读写缓存模式由于会同时更新数据库和缓存，优点是，缓存中一直会有数据，如果更新操作后会立即再次访问，可以直接命中缓存，能够降低读请求对于数据库的压力（没有了只读缓存的删除缓存导致缓存缺失和再加载的过程）。缺点是，如果更新后的数据，之后很少再被访问到，会导致缓存中保留的不是最热的数据，缓存利用率不高（只读缓存中保留的都是热数据），所以读写缓存比较适合用于读写相当的业务场景。</p>
<h1 id="如何解决缓存雪崩、击穿、穿透难题？"><a href="#如何解决缓存雪崩、击穿、穿透难题？" class="headerlink" title="如何解决缓存雪崩、击穿、穿透难题？"></a>如何解决缓存雪崩、击穿、穿透难题？</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>&emsp;&emsp;缓存雪崩是指大量的应用请求无法在 Redis 缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。缓存雪崩一般是由两个原因导致的，应对方案也有所不同，我们一个个来看。</p>
<ol>
<li>第一个原因是：缓存中有大量数据同时过期，导致大量请求无法得到处理。</li>
</ol>
<p><strong>如何避免</strong>：首先，我们可以避免给大量的数据设置相同的过期时间。如果业务层的确要求有些数据同时失效，你可以在用 EXPIRE 命令给每个数据设置过期时间时，给这些数据的过期时间增加一个较小的随机数（例如，随机增加 1~3 分钟），这样一来，不同数据的过期时间有所差别，但差别又不会太大，既避免了大量数据同时过期，同时也保证了这些数据基本在相近的时间失效，仍然能满足业务需求。除了微调过期时间，我们还可以通过<strong>服务降级</strong>，来应对缓存雪崩。所谓的服务降级，是指发生缓存雪崩时，针对不同的数据采取不同的处理方式。当业务应用访问的是非核心数据（例如电商商品属性）时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息；当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存 缺失，也可以继续通过数据库读取。<br>&emsp;&emsp;这样一来，只有部分过期数据的请求会发送到数据库，数据库的压力就没有那么大了。下面这张图显示的是服务降级时数据请求的执行情况：<br><img lazyload src="/images/loading.svg" data-src="redis85.jpg" alt="avatar"><br>2. Redis 缓存实例发生故障宕机了，无法处理请求，这就会导致大量请求一下子积压到数据库层，从而发生缓存雪崩。<br><strong>如何避免</strong>：<strong>在业务系统中实现服务熔断或请求限流机制</strong>，所谓的服务熔断，是指在发生缓存雪崩时，为了防止引发连锁的数据库雪崩，甚至是整个系统的崩溃，我们暂停业务应用对缓存系统的接口访问。再具体点说，就是业务应用调用缓存接口时，缓存客户端并不把请求发给 Redis 缓存实例，而是直接返回，等到 Redis 缓存实例重新恢复服务后，再允许应用请求发送到缓存系统。<br>&emsp;&emsp;服务熔断虽然可以保证数据库的正常运行，但是暂停了整个缓存系统的访问，对业务应用的影响范围大。为了尽可能减少这种影响，我们也可以进行请求限流。这里说的请求限流，就是指，我们在业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库。<br>&emsp;&emsp;<strong>事前预防</strong>： 通过主从节点的方式构建 Redis 缓存高可靠集群。如果 Redis 缓存的主节点故障宕机了，从节点还可以切换成为主节点，继续提供缓存服务，避免了由于缓存实例宕机而导致的缓存雪崩问题。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>&emsp;&emsp;缓存击穿是指，针对某个访问非常频繁的热点数据的请求，无法在缓存中进行处理，紧接着，访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力激增，会影响数据库处理其他请求。缓存击穿的情况，经常发生在热点数据过期失效时，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis86.jpg" alt="avatar"><br><strong>如何避免</strong>：为了避免缓存击穿给数据库带来的激增压力，我们的解决方法也比较直接，对于访问特别频繁的热点数据，我们就不设置过期时间了。这样一来，对热点数据的访问请求，都可以在缓存中进行处理，而 Redis 数万级别的高吞吐量可以很好地应对大量的并发请求访问。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>&emsp;&emsp;缓存穿透是指要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。此时，应用也无法从数据库中读取数据再写入缓存，来服务后续请求，这样一来，缓存也就成了“摆设”，如果应用持续有大量请求访问数据，就会同时给缓存和数据库带来巨大压力，如下图所示：<br><img lazyload src="/images/loading.svg" data-src="redis87.jpg" alt="avatar"><br>&emsp;&emsp;缓存穿透会发生在什么时候呢？一般来说，有两种情况。</p>
<ol>
<li>业务层误操作：缓存中的数据和数据库中的数据被误删除了，所以缓存和数据库中都没 有数据；</li>
<li>恶意攻击：专门访问数据库中没有的数据。</li>
</ol>
<p><strong>如何避免</strong>：</p>
<ol>
<li><strong>缓存空值或缺省值</strong>：一旦发生缓存穿透，我们就可以针对查询的数据，在 Redis 中缓存一个空值或是和业务层协商确定的缺省值（例如，库存的缺省值可以设为 0）。紧接着，应用发送的后续请求再进行查询时，就可以直接从 Redis 中读取空值或缺省值，返回给业务应用了，避免了把大量请求发送给数据库处理，保持了数据库的正常运行。</li>
<li>使用<strong>布隆过滤器</strong>快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。布隆过滤器由一个初值都为 0 的 bit 数组和 N 个哈希函数组成，可以用来快速判断某个数据是否存在。当我们想标记某个数据存在时（例如，数据已被写入数据库），布隆过滤器会通过三个操作完成标记：首先，使用 N 个哈希函数，分别计算这个数据的哈希值，得到 N 个哈希值；然后，我们把这 N 个哈希值对 bit 数组的长度取模，得到每个哈希值在数组中的对应位置；最后，我们把对应位置的 bit 位设置为 1，这就完成了在布隆过滤器中标记数据的操作。当需要查询某个数据时，我们就执行刚刚说的计算过程，先得到这个数据在 bit 数组中对应的 N 个位置。紧接着，我们查看 bit 数组中这 N 个位置上的 bit 值。只要这 N 个 bit 值 有一个不为 1，这就表明布隆过滤器没有对该数据做过标记，所以，查询的数据一定没有 在数据库中保存。<br><img lazyload src="/images/loading.svg" data-src="redis88.jpg" alt="avatar"><br>&emsp;&emsp;图中布隆过滤器是一个包含 10 个 bit 位的数组，使用了 3 个哈希函数，当在布隆过滤器中标记数据 X 时，X 会被计算 3 次哈希值，并对 10 取模，取模结果分别是 1、3、7。所 以，bit 数组的第 1、3、7 位被设置为 1。当应用想要查询 X 时，只要查看数组的第 1、 3、7 位是否为 1，只要有一个为 0，那么，X 就肯定不在数据库中。<br>&emsp;&emsp;正是基于布隆过滤器的快速检测特性，我们可以在把数据写入数据库时，使用布隆过滤器做个标记。当缓存缺失后，应用查询数据库时，可以通过查询布隆过滤器快速判断数据是否存在。如果不存在，就不用再去数据库中查询了。这样一来，即使发生缓存穿透了，大量请求只会查询 Redis 和布隆过滤器，而不会积压到数据库，也就不会影响数据库的正常 运行。布隆过滤器可以使用 Redis 实现，本身就能承担较大的并发访问压力。<strong>判断数据不在布隆过滤器中，一定不在数据库中，直接返回。判断在布隆过滤器中，可能误判，不一定在数据库中，若不在数据库中仍然发生缓存穿透，然后缓存空值或缺省值</strong>。</li>
<li>最后一种方案是，<strong>在请求入口的前端进行请求检测</strong>。缓存穿透的一个原因是有大量的恶意请求访问不存在的数据，所以，一个有效的应对方案是在请求入口前端，对业务系统接收到的请求进行合法性检测，把恶意的请求（例如请求参数不合理、请求参数是非法值、请 求字段不存在）直接过滤掉，不让它们访问后端缓存和数据库。这样一来，也就不会出现缓存穿透问题了。</li>
</ol>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img lazyload src="/images/loading.svg" data-src="redis89.jpg" alt="avatar"><br>&emsp;&emsp;，服务熔断、服务降级、请求限流这些方法都是属于“有损”方案，在保证数据库和整体系统稳定的同时，会对业务应用带来负面影响。例如使用服务降级时，有部分数据的请求就只能得到错误返回信息，无法正常处理。如果使用了服务熔断，那么，整个缓存系统的服务都被暂停了，影响的业务范围更大。而使用了请求限流机制后，整个业务系统的吞吐率会降低，能并发处理的用户请求会减少，会影响到用户体验。所以建议尽量使用尽量使用预防式方案：</p>
<ol>
<li>针对缓存雪崩，合理地设置数据过期时间，以及搭建高可靠缓存集群；</li>
<li>针对缓存击穿，在缓存访问非常频繁的热点数据时，不要设置过期时间；</li>
<li>针对缓存穿透，提前在入口前端实现恶意请求检测，或者规范数据库的数据删除操作，避免误删除。</li>
</ol>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>&emsp;&emsp;在提到缓存雪崩时，可以采用服务熔断、服务降级、请求限流的方式来应对。这三个机制可以用来应对混存穿透问题吗？还有没有其他策略来解决这一问题？</p>
<blockquote>
<p> 服务熔断、服务降级、请求限流这三个机制不适合来处理缓存穿透的场景。 三个机制都是在服务不可用时来减少影响的，缓存穿透的场景下，本质上服务是可用的， 如果使用上述三个机制会影响其他正常的请求。可以记录ip和穿透访问的次数，频率超过阈值的ip直接拉黑</p>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 重点问题</title>
    <url>/2022/02/09/Golang%20%E9%87%8D%E7%82%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Golang-Map-的底层实现"><a href="#Golang-Map-的底层实现" class="headerlink" title="Golang Map 的底层实现"></a>Golang Map 的底层实现</h1><h2 id="一般的-map-的实现"><a href="#一般的-map-的实现" class="headerlink" title="一般的 map 的实现"></a>一般的 map 的实现</h2><p>&emsp;&emsp;一般的Map会包含两个主要结构：</p>
<ul>
<li>数组：数组里的值指向一个链表，一般称为桶🪣位</li>
<li>链表：目的解决hash冲突的问题，并存放键值</li>
</ul>
<p>大致结构如下：<br><img lazyload src="/images/loading.svg" data-src="origin_map.jpg" alt="avatar"><br>读取一个key值的过程大致如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> 				  key</span><br><span class="line">				   |</span><br><span class="line">				   v                 </span><br><span class="line">+------------------------------------+</span><br><span class="line">|      key通过<span class="built_in">hash</span>函数得到key的<span class="built_in">hash</span>    |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">				   |</span><br><span class="line">				   v</span><br><span class="line">+------------------------------------+</span><br><span class="line">|       key的<span class="built_in">hash</span>通过取模或者位操作     |</span><br><span class="line">|          得到key在数组上的索引        |</span><br><span class="line">+------------------------------------+</span><br><span class="line">				   |</span><br><span class="line">				   v</span><br><span class="line">+------------------------------------+</span><br><span class="line">|         通过索引找到对应的链表         |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">				   |</span><br><span class="line">				   v</span><br><span class="line">+------------------------------------+</span><br><span class="line">|       遍历链表对比key和目标key        |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">				   |</span><br><span class="line">				   v</span><br><span class="line">+------------------------------------+</span><br><span class="line">|              相等则返回value         |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">                   |</span><br><span class="line">                   v </span><br><span class="line">                 value</span><br></pre></td></tr></table></figure>

<h2 id="Go-语言中-Map-的实现思路"><a href="#Go-语言中-Map-的实现思路" class="headerlink" title="Go 语言中 Map 的实现思路"></a>Go 语言中 Map 的实现思路</h2><p>&emsp;&emsp;Go语言解决hash冲突不是链表，实际<strong>主要</strong>用的数组(内存上的连续空间)，如下图所示：</p>
<p><img lazyload src="/images/loading.svg" data-src="go_map.png" alt="avatar"></p>
<p>&emsp;&emsp;但是并不是只使用一个数组(连续内存空间)存放键和值，而是使用了两个数组分别存储键和值，图示如下：<br><img lazyload src="/images/loading.svg" data-src="origin_map1.png" alt="avatar"><br>&emsp;&emsp;上图中：-   分别对应的是两个核心的结构体<code>hmap</code>和<code>bmap</code>， <code>bmap</code>里有两个数组分别存放key和value</p>
<p>&emsp;&emsp;我们通过一次<code>读操作</code>为例，看看读取某个key的值的一个<strong>大致过程</strong>：</p>
<ol>
<li>通过hash函数获取目标key的<strong>哈希</strong>，哈希和数组的长度通过位操作获取数组位置的<strong>索引</strong>(备注：获取索引值的方式一般有取模或位操作，位操作的性能好些)</li>
<li>遍历bmap里的键，和目标key对比获取<strong>key的索引</strong>(找不到则返回空值)</li>
<li>根据<strong>key的索引</strong>通过计算偏移量，获取到对应value<br><img lazyload src="/images/loading.svg" data-src="origin_map2.png" alt="avatar"></li>
</ol>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="核心结构体-hmap"><a href="#核心结构体-hmap" class="headerlink" title="核心结构体 hmap"></a>核心结构体 hmap</h3><p>&emsp;&emsp;<code>hmap</code>的结构其实刚开始看起来其实还是比较复杂的，有不少的字段，具体字段如下图所示：<br><img lazyload src="/images/loading.svg" data-src="hmap.png" alt="avatar"><br>字段释义如下：</p>
<ol>
<li>count：键值对的数量</li>
<li>B：2^B=len(buckets)</li>
<li>hash0：hash因子</li>
<li>buckets：指向一个数组(连续内存空间)，数组的类型为[]bmap，bmap类型就是存在键值对的结构下面会详细介绍，这个字段我们可以称之为正常桶。</li>
<li>oldbuckets：扩容时，存放之前的buckets(Map扩容相关字段)</li>
<li>extra：溢出桶结构，正常桶里面某个bmap存满了，会使用这里面的内存空间存放键值对</li>
<li>noverflow：溢出桶里bmap大致的数量</li>
<li>nevacuate：分流次数，成倍扩容分流操作计数的字段(Map扩容相关字段)</li>
<li>flags：状态标识，比如正在被写、buckets和oldbuckets在被遍历、等量扩容(Map扩容相关字段)</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="bmap.png" alt="avatar"><br>&emsp;&emsp;<code>buckets</code>指向了一个数组(连续的内存空间)，数组的元素是<code>bmap</code>类型，这个字段我们称之为正常桶。</p>
<h3 id="核心结构体-bmap"><a href="#核心结构体-bmap" class="headerlink" title="核心结构体 bmap"></a>核心结构体 bmap</h3><p>&emsp;&emsp;正常桶<code>hmap.buckets</code>的元素是一个<code>bmap</code>结构。<code>bmap</code>的具体字段如下图所示：<br><img lazyload src="/images/loading.svg" data-src="bmap1.png" alt="avatar"><br>字段释义如下：</p>
<ol>
<li>topbits：长度为8的数组，[]uint8，元素为：key获取的hash的高8位，遍历时对比使用，提高性能。<strong>如下图所示</strong></li>
<li>keys：长度为8的数组，[]keytype，元素为：具体的key值。<strong>如下图所示</strong></li>
<li>elems：长度为8的数组，[]elemtype，元素为：键值对的key对应的值。</li>
<li>overflow：指向的<code>hmap.extra.overflow</code>溢出桶里的<code>bmap</code>，上面的字段<code>topbits</code>、<code>keys</code>、<code>elems</code>长度为8，最多存8组键值对，存满了就往指向的这个<code>bmap</code>里存</li>
<li>pad：对齐内存使用的，不是每个bmap都有会这个字段，需要满足一定条件<br><img lazyload src="/images/loading.svg" data-src="bmap2.png" alt="avatar"></li>
</ol>
<p>&emsp;&emsp;<strong>结论：每个<code>bmap</code>结构最多存放8组键值对。</strong></p>
<h3 id="hmap-和-bmap-的基本结构合起来"><a href="#hmap-和-bmap-的基本结构合起来" class="headerlink" title="hmap 和 bmap 的基本结构合起来"></a>hmap 和 bmap 的基本结构合起来</h3><p>&emsp;&emsp;分别了解了<code>hmap</code>和<code>bmap</code>的基本结构后，我们把上面的内容合并起来，就得到如下的Map结构图：<br><img lazyload src="/images/loading.svg" data-src="combine_map.png" alt="avatar"></p>
<h3 id="溢出桶"><a href="#溢出桶" class="headerlink" title="溢出桶"></a>溢出桶</h3><p>&emsp;&emsp;上面讲<code>bmap</code>的时候，我们不是得到了个结论么“每个<code>bmap</code>结构最多存放8组键值对。”，所以问题来了：</p>
<blockquote>
<p>正常桶里的<code>bmap</code>存满了怎么办?</p>
</blockquote>
<p>&emsp;&emsp;解决这个问题我们就要说到<code>hmap.extra</code>结构了，<code>hmap.extra</code>是个结构体，结构图示和字段释义如下：<br><img lazyload src="/images/loading.svg" data-src="overflow.png" alt="avatar"></p>
<ol>
<li>overflow：称之为<strong>溢出桶</strong>。和<code>hmap.buckets</code>的类型一样也是数组<code>[]bmap</code>，当正常桶<code>bmap</code>存满了的时候就使用<code>hmap.extra.overflow</code>的<code>bmap</code>。</li>
<li>oldoverflow：扩容时存放之前的overflow(Map扩容相关字段)</li>
<li>nextoverflow：指向溢出桶里下一个可以使用的<code>bmap</code></li>
</ol>
<blockquote>
<p>问题：正常桶<code>hmap.buckets</code>里的<code>bmap</code>是<strong>怎么关联上</strong>溢出桶<code>hmap.extra.overflow</code>的<code>bmap</code>呢？</p>
</blockquote>
<p>答：就是我们介绍<code>bmap</code>结构时里的<code>bmap.overflow</code>字段(如下图所示)。<code>bmap.overflow</code>是个指针类型，存放了对应使用的溢出桶<code>hmap.extra.overflow</code>里的<code>bmap</code>的地址。</p>
<p><strong>问题又来了</strong>：</p>
<blockquote>
<p>正常桶<code>hmap.buckets</code>里的<code>bmap</code>是<strong>什么时候关联上</strong>溢出桶<code>hmap.extra.overflow</code>的<code>bmap</code>呢？</p>
</blockquote>
<p>答：Map写操作的时候。</p>
<p>&emsp;&emsp;<strong>当<code>hmap</code>存在溢出桶时，且当前溢出桶只被使用了一个bmap</strong>时，我们可以得到如下的关系图：<br><img lazyload src="/images/loading.svg" data-src="overflow1.png" alt="avatar"><br>&emsp;&emsp;同时我们可以看出正常桶的<code>bmap</code>和溢出桶的<code>bmap</code>实际构成了链表关系，所以这也解释了开篇我们说到的“Go里面Map的实现<strong>主要</strong>用到了数组”，其次还用到了链表。</p>
<h2 id="再次分析Map的读"><a href="#再次分析Map的读" class="headerlink" title="再次分析Map的读"></a>再次分析Map的读</h2><p>&emsp;&emsp;我们再次通过一次读操作为例，看看读取某个key的值的一个大致过程：<br><img lazyload src="/images/loading.svg" data-src="readmap.png" alt="avatar"><br>&emsp;&emsp;Go 语言中 map 采用的是哈希查找表，由一个 key 通过哈希函数得到哈希值，64 位系统中就生成一个 64bit 的哈希值，由这个哈希值将 key 对应到不同的桶 （bucket）中，当有多个哈希映射到相同的的桶中时，使用链表解决哈希冲 突。key 经过 hash 后共 64 位，根据 hmap 中 B 的值，计算它到底要落在哪个桶 时，桶的数量为 2^B，如 B=5，那么用 64 位最后 5 位表示第几号桶，在用 hash 值的高 8 位确定在 bucket 中的存储位置，当前 bmap 中的 bucket 未找到，则查 询对应的 overflow bucket，对应位置有数据则对比完整的哈希值，确定是否 是要查找的数据。 如果两个不同的 key 落在的同一个桶上，hash 冲突使用链表法接近，遍历 bucket 中的 key 如果当前处于 map 进行了扩容，处于数据搬移状态，则优先从 oldbuckets 查找。</p>
<h2 id="Golang-Map-如何扩容"><a href="#Golang-Map-如何扩容" class="headerlink" title="Golang Map 如何扩容"></a>Golang Map 如何扩容</h2><p>装载因子：count/2^B<br>触发条件：</p>
<ol>
<li>装填因子是否大于 6.5</li>
<li>overflow bucket 是否太多</li>
</ol>
<p>解决方法：</p>
<ol>
<li>双倍扩容：扩容采取了一种称为“渐进式”地方式，原有的 key 并不会一 次性搬迁完毕，每次最多只会搬迁 2 个 bucket</li>
<li>等量扩容：重新排列，极端情况下，重新排列也解决不了，map 成了链表，性能大大降低，此时哈希种子 hash0 的设置，可以降低此类极端场景的发生。</li>
</ol>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>&emsp;&emsp;在 Go 语言中，不要通过共享内存来通信，而要通过通信来实现内存共享。Go 的 CSP（Communicating Sequential Process）并发模型，中文叫做通信顺序进程，是通过 goroutine 和 channel 来实现的。所以 channel 收发遵循先进先出 FIFO，分为有缓存和无缓存，channel 中大致有 buffer(当缓冲区大小不为 0 时，是个 ring buffer)、sendq、recvq 当前 channel 因为缓冲区不足而阻塞的队列、使用双向链表存储、还有一个 mutex 锁控制并发、其他原属等。</p>
<h2 id="channel-的底层实现"><a href="#channel-的底层实现" class="headerlink" title="channel 的底层实现"></a>channel 的底层实现</h2><p><img lazyload src="/images/loading.svg" data-src="hchan.png" alt="avatar"><br>简单说明：<br><code>buf</code>是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表<br><code>sendx</code>和<code>recvx</code>用于记录<code>buf</code>这个循环链表中的 index<br><code>lock</code>是个互斥锁<br><code>recvq</code>和<code>sendq</code>分别是接收(&lt;-channel)或者发送(channel &lt;- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表</p>
<p>下面我们来详细介绍<code>hchan</code>中各部分是如何使用的。</p>
<ol>
<li><p>先从创建开始<br>我们首先创建一个channel：ch := make(chan int, 3)<br><img lazyload src="/images/loading.svg" data-src="hchan1.png" alt="avatar"><br>创建channel实际上就是在内存中实例化了一个<code>hchan</code>的结构体，并返回一个ch指针，我们使用过程中channel在函数之间的传递都是用的这个指针，这就是为什么函数传递中无需使用channel的指针，而直接用channel就行了，因为channel本身就是一个指针。</p>
</li>
<li><p>channel中发送send(ch &lt;- xxx)和recv(&lt;- ch)接收<br>先考虑一个问题，如果你想让goroutine以先进先出(FIFO)的方式进入一个结构体中，你会怎么操作？  加锁！对的！channel就是用了一个锁。hchan本身包含一个互斥锁<code>mutex</code></p>
</li>
</ol>
<ul>
<li>channel中队列是如何实现的<br>channel中有个缓存buf，是用来缓存数据的(假如实例化了带缓存的channel的话)队列。我们先来看看是如何实现“队列”的。当使用<code>send (ch &lt;- xx)</code>或者<code>recv ( &lt;-ch)</code>的时候，首先要锁住<code>hchan</code>这个结构体。<br>所以不难看出，Go中那句经典的话：<code>Do not communicate by sharing memory; instead, share memory by communicating.</code>的具体实现就是利用channel把数据从一端copy到了另一端！<br>还真是符合<code>channel</code>的英文含义：<br><img lazyload src="/images/loading.svg" data-src="hchan_channl.gif" alt="avatar"></li>
</ul>
<ol start="3">
<li>当channel缓存满了之后会发生什么？这其中的原理是怎样的？<br>使用的时候，我们都知道，当channel缓存满了，或者没有缓存的时候，我们继续send(ch &lt;- xxx)或者recv(&lt;- ch)会阻塞当前goroutine，但是，是如何实现的呢？我们知道，Go的goroutine是用户态的线程(<code>user-space threads</code>)，用户态的线程是需要自己去调度的，Go有运行时的scheduler去帮我们完成调度这件事情。goroutine的阻塞操作，实际上是调用<code>send (ch &lt;- xx)</code>或者<code>recv ( &lt;-ch)</code>的时候主动触发的，具体请看以下内容：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)  </span><br><span class="line">  </span><br><span class="line">ch &lt;- <span class="number">1</span>  </span><br><span class="line">ch &lt;- <span class="number">1</span>  </span><br><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure>
<img lazyload src="/images/loading.svg" data-src="hchan_block.png" alt="avatar"><br><img lazyload src="/images/loading.svg" data-src="hchan_block1.png" alt="avatar"><br>这个时候G1正在正常运行,当再次进行send操作(ch&lt;-1)的时候，会主动调用Go的调度器(G0)，通过 runtime.gopark 函数让G1等待，并从让出M，让其他G去使用<br><img lazyload src="/images/loading.svg" data-src="hchan_block2.png" alt="avatar"><br>同时G1也会被抽象成含有G1指针和send元素的<code>sudog</code>结构体保存到hchan的<code>sendq</code>中等待被唤醒。<br><img lazyload src="/images/loading.svg" data-src="hchan_blok3.gif" alt="avatar"><br>那么，G1什么时候被唤醒呢？这个时候G2隆重登场。<br><img lazyload src="/images/loading.svg" data-src="hchan_block4.png" alt="avatar"><br>G2执行了recv操作<code>p := &lt;-ch</code>，于是会发生以下的操作：<br><img lazyload src="/images/loading.svg" data-src="hchan_block5.gif" alt="avatar"><br>G2从缓存队列中取出数据，channel会将等待队列中的G1推出，将G1当时send的数据推到缓存中，然后调用Go的scheduler，唤醒G1(runtime.goready)，并把G1放到可运行的Goroutine队列中。通过这种协作式的调度来实现 goroutine 的调度。<br><img lazyload src="/images/loading.svg" data-src="hchan_block6.gif" alt="avatar"></li>
</ol>
<ul>
<li>假如是先进行执行recv操作的G2会怎么样？<br><img lazyload src="/images/loading.svg" data-src="hchan_block7_1.png" alt="avatar"><br>这个时候G2会主动调用Go的调度器,让G2等待，并从让出M，让其他G去使用。<br>G2还会被抽象成含有G2指针和recv空元素的<code>sudog</code>结构体保存到hchan的<code>recvq</code>中等待被唤醒<br><img lazyload src="/images/loading.svg" data-src="hchan_block7.gif" alt="avatar"><br>此时恰好有个goroutine G1开始向channel中推送数据 <code>ch &lt;- 1</code>。<br>此时，非常有意思的事情发生了：<br><img lazyload src="/images/loading.svg" data-src="hchan_block8.gif" alt="avatar"><br>G1并没有锁住channel，然后将数据放到缓存中，而是直接把数据从G1直接copy到了G2的栈中。这种方式非常的赞！在唤醒过程中，G2无需再获得channel的锁，然后从缓存中取数据。减少了内存的copy，提高了效率。<strong>当然这种方法只能在 runtime 下自动执行，需要 runtime 调度 G2 的栈上的变量直接去 G1 的栈上获取数据</strong>。<br><img lazyload src="/images/loading.svg" data-src="hchan_block9.gif" alt="avatar"><br>之后和之前一样，G2 变成 runnable 的状态，被挂到原始的 P 队列中。新版本进行了优化，为了避免 G2 被放到 P  队列末尾会被其他的 P 窃取（work-stealing），G2 会被优先挂载到当前队列正在执行的 goroutine 后面，很快就能得到执行。</li>
</ul>
<h2 id="channel-的特性"><a href="#channel-的特性" class="headerlink" title="channel 的特性"></a>channel 的特性</h2><ol>
<li>给一个 nil channel 发送数据，造成永远阻塞</li>
<li>从一个 nil channel 接收数据，造成永远阻塞</li>
<li>给一个已经关闭的 channel 发送数据，引起 panic</li>
<li>从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值</li>
<li>无缓冲的 channel 是同步的，而有缓冲的 channel 是非同步的</li>
<li>关闭一个 nil channel 将会发生 panic<br><img lazyload src="/images/loading.svg" data-src="channel.jpg" alt="avatar"></li>
</ol>
<h2 id="Channel-的-ring-buffer-实现"><a href="#Channel-的-ring-buffer-实现" class="headerlink" title="Channel 的 ring buffer 实现"></a>Channel 的 ring buffer 实现</h2><p>&emsp;&emsp;channel 中使用了 ring buffer(环形缓冲区) 来缓存写入的数据。ring buffer 有很多好处，而且非常适合用来实现 FIFO 式的固定长度队列。在 channel 中，ring buffer 的实现如下：<br><img lazyload src="/images/loading.svg" data-src="ring_buffer.jpg" alt="avatar"><br>&emsp;&emsp;有两个与 buffer 相关的变量:recvx 和 sendx。其中 sendx 表示 buffer 中可写的 index，recvx 表示 buffer 中可读的 index。 从 recvx 到 sendx 之间的元素，表示已正常存放入 buffer 中的数据。 我们可以直接使用 buf[recvx]来读取到队列的第一个元素，使用 buf[sendx] = x 来将元素放到队尾。</p>
<h1 id="Go-并发编程"><a href="#Go-并发编程" class="headerlink" title="Go 并发编程"></a>Go 并发编程</h1><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><h3 id="Mutex-的几种状态"><a href="#Mutex-的几种状态" class="headerlink" title="Mutex 的几种状态"></a>Mutex 的几种状态</h3><ol>
<li>mutexLocked — 表示互斥锁的锁定状态；</li>
<li>mutexWoken — 表示从正常模式被从唤醒；</li>
<li>mutexStarving — 当前的互斥锁进入饥饿状态；</li>
<li>waitersCount — 当前互斥锁上等待的 Goroutine 个数；</li>
</ol>
<h3 id="Mutex-正常模式和饥饿模式"><a href="#Mutex-正常模式和饥饿模式" class="headerlink" title="Mutex 正常模式和饥饿模式"></a>Mutex 正常模式和饥饿模式</h3><ul>
<li><p><strong>正常模式(非公平锁)</strong><br>&emsp;&emsp;正常模式下，所有等待锁的 goroutine 按照 FIFO(先进先出)顺序等待。唤醒的 goroutine 不会直接拥有锁，而是会和新请求锁的 goroutine 竞争锁的拥有。新请求锁的 goroutine 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的 goroutine 有很大可能在锁竞争中失败。在这种情况下，这个被 唤醒的 goroutine 会加入到等待队列的前面。 如果一个等待的 goroutine 超过 1ms 没有获取锁，那么它将会把锁转变为饥饿模式。</p>
</li>
<li><p><strong>饥饿模式(公平锁)</strong><br>&emsp;&emsp;为了解决了等待 G 队列的长尾问题。饥饿模式下，直接由 unlock 把锁交给等待队列中排在第一位的 G(队头)，同时，饥饿模式下，新进来的 G 不会参与抢锁也不会进入自旋状态，会直接进入等待队列的尾部，这样很好的解决了老的 G 一直抢不到锁的场景。 饥饿模式的触发条件，当一个 G 等待锁时间超过 1 毫秒时，或者当前队列只剩 下一个 G 的时候，Mutex 切换到饥饿模式。</p>
</li>
</ul>
<blockquote>
<p>总结：对于两种模式，正常模式下的性能是最好的，goroutine 可以连续多次获取 锁，饥饿模式解决了取锁公平的问题，但是性能会下降，其实是性能和公平的 一个平衡模式。</p>
</blockquote>
<h3 id="Mutex-允许自旋的条件"><a href="#Mutex-允许自旋的条件" class="headerlink" title="Mutex 允许自旋的条件"></a>Mutex 允许自旋的条件</h3><p>&emsp;&emsp;在1个协程获取锁时，另一个协程一直尝试，直到能够获取锁（不断循环），这就是自旋锁。</p>
<ol>
<li>锁已被占用，并且锁不处于饥饿模式。</li>
<li>积累的自旋次数小于最大自旋次数（active_spin=4）。</li>
<li>cpu 核数大于 1。</li>
<li>有空闲的 P。</li>
<li>当前 goroutine 所挂载的 P 下，本地待运行队列为空。</li>
</ol>
<h3 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h3><ul>
<li><p>实现原理<br>&emsp;&emsp;通过记录 readerCount 读锁的数量来进行控制，当有一个写锁的时候，会将读锁数量设置为负数 1&lt;&lt;30。目的是让新进入的读锁等待写锁之后释放通知读锁。同样的写锁也会等等待之前的读锁都释放完毕，才会开始进行后续的操作。 而等写锁释放完之后，会将值重新加上 1&lt;&lt;30, 并通知刚才新进入的读锁 (rw.readerSem)，两者互相限制。</p>
</li>
<li><p>注意事项</p>
</li>
</ul>
<ol>
<li>RWMutex 是单写多读锁，该锁可以加多个读锁或者一个写锁</li>
<li>读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁</li>
<li>写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占</li>
<li>适用于读多写少的场景</li>
<li>RWMutex 的一个写锁 Lock 去锁定临界区的共享资源，如果临界区的共享资源已被（读锁或写锁）锁定，这个写锁操作的 goroutine 将被阻塞直到 解锁。</li>
<li>RWMutex 的读锁或写锁在未锁定状态，解锁操作都会引发 panic</li>
<li>RWMutex 在首次被使用之后就不能再被拷贝</li>
<li>写锁被解锁后，所有因操作锁定读锁而被阻塞的 goroutine 会被唤醒，并都可以成功锁定读锁。</li>
<li>读锁被解锁后，在没有被其他读锁锁定的前提下，所有因操作锁定写锁而被阻塞的 goroutine，其中等待时间最长的一个 goroutine 会被唤醒。</li>
</ol>
<h2 id="sync-包中的两个对象"><a href="#sync-包中的两个对象" class="headerlink" title="sync 包中的两个对象"></a>sync 包中的两个对象</h2><h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><ol>
<li>Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。</li>
<li>Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测试资源。</li>
<li>sync.Once 只暴露了一个方法 Do，你可以多次调用 Do 方法，但是只有第一次调用 Do 方法时 f 参数才会执行，这里的 f 是一个无参数无返回值的函数。</li>
</ol>
<h3 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h3><p>&emsp;&emsp;对于很多需要重复分配、回收内存的地方，sync.Pool 是一个很好的选择。频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺，而 sync.Pool 可以将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。</p>
<h1 id="Switch-和-Select-的区别"><a href="#Switch-和-Select-的区别" class="headerlink" title="Switch 和 Select 的区别"></a>Switch 和 Select 的区别</h1><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p><code>select</code>只能应用于channel的操作，既可以用于channel的数据接收，也可以用于channel的数据发送。如果<code>select</code>的多个分支都满足条件，则会随机的选取其中一个满足条件的分支。<br><code>default</code>: select中的default是当select发现没有case满足,要block时的选择</p>
<h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p><code>switch</code>可以为各种类型进行分支操作， 设置可以为接口类型进行分支判断(通过i.(type))。<code>switch</code> 分支是顺序执行的，这和<code>select</code>不同。<br><code>default</code>:  switch中的default是默认的意思,当所有case不满足的时候,就会执行default</p>
<h1 id="Go-runtime"><a href="#Go-runtime" class="headerlink" title="Go runtime"></a>Go runtime</h1><h2 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h2><h3 id="Gorutine"><a href="#Gorutine" class="headerlink" title="Gorutine"></a>Gorutine</h3><p>&emsp;&emsp;Goroutine “Goroutine 是一个与其他 goroutines 并行运行在同一地址空间的 Go 函数或方法。一个运行的程序由一个或更多个 goroutine 组成。它与线程、协程、进 程等不同。它是一个 goroutine” —— Rob Pike<br>&emsp;&emsp;Goroutines 在同一个用户地址空间里并行独立执行 functions，channels 则用于 goroutines 间的通信和同步访问控制。</p>
<h3 id="GMP-模型"><a href="#GMP-模型" class="headerlink" title="GMP 模型"></a>GMP 模型</h3><ol>
<li>G（Goroutine）：我们所说的协程，为用户级的轻量级线程，每个 Goroutine 对象中的 sched 保存着其上下文信息.</li>
<li>M（Machine）：对内核级线程的封装，数量对应真实的 CPU 数（真正干活的对象）</li>
<li>P（Processor）：即为 G 和 M 的调度对象，用来调度 G 和 M 之间的关联关系， 其数量可通过 GOMAXPROCS()来设置，默认为核心数。</li>
</ol>
<p>&emsp;&emsp;调度器把 G 都分配到 M 上，不同的 G 在不同的 M 并发运行时，都需要向系统申请资源，比如堆栈内存等，因为资源是全局的，就会因为资源竞争照成很多性能损耗。为了解决这一的问题 go 从 1.1 版本引入，在运行时系统的时候加入 p 对象，让 P 去管理这个 G 对象，M 想要运行 G，必须绑定 P，才能运行 P 所管理的 G。单纯的 GM 模型会引起以下问题：</p>
<ol>
<li>单一全局互斥锁(Sched.Lock)和集中状态存储；</li>
<li>Goroutine 传递问题（M 经常在 M 之间传递”可运行”的 goroutine）</li>
<li>每个 M 做内存缓存，导致内存占用过高，数据局部性较差</li>
<li>频繁 syscall 调用，导致严重的线程阻塞/解锁，加剧额外的性能损耗。</li>
</ol>
<h4 id="GMP-调度流程"><a href="#GMP-调度流程" class="headerlink" title="GMP 调度流程"></a>GMP 调度流程</h4><p>&emsp;&emsp;在 Go 中，<strong>线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上</strong>。<br><img lazyload src="/images/loading.svg" data-src="goroutine.jpg" alt="avatar"></p>
<ol>
<li>全局队列（Global Queue）：存放等待运行的 G。</li>
<li>P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。</li>
<li>P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。</li>
<li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li>
</ol>
<p><strong>Goroutine 调度器和 OS 调度器是通过 M 结合起来的，每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行</strong>。</p>
<blockquote>
<p>有关 P 和 M 的个数问题</p>
<ol>
<li>P 的数量：由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。这意味着在程序执行的<strong>任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行</strong>。</li>
<li>M 的数量：（1） go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略。<br>（2） runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量<br>（3）一个 M 阻塞了，会创建新的 M</li>
</ol>
<p> <strong>M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。</strong></p>
</blockquote>
<blockquote>
<p>P 和 M 何时被创建</p>
<ol>
<li>P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。</li>
<li>M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。</li>
</ol>
</blockquote>
<h5 id="调度器的设计策略"><a href="#调度器的设计策略" class="headerlink" title="调度器的设计策略"></a>调度器的设计策略</h5><ol>
<li>work stealing 机制：当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。</li>
<li>hand off 机制：当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="gmp.jpg" alt="avatar"></p>
<ol>
<li>每个 P 有个局部队列，局部队列保存待执行的 goroutine(流程 2)，当 M 绑定的 P 的的局部队列已经满了之后就会把 goroutine 放到全局队列(流程 2-1)</li>
<li>每个 P 和一个 M 绑定，M 是真正的执行 P 中 goroutine 的实体(流程 3)，M 从绑定的 P 中的局部队列获取 G 来执行</li>
<li>当 M 绑定的 P 的局部队列为空时，M 会从全局队列获取到本地队列来执行 G(流程 3.1)，当从全局队列中没有获取到可执行的 G 时候，M 会从其他 P 的局部队列中偷取 G 来执行(流程 3.2)，这种从其他 P 偷的方式称为 work stealing</li>
<li>当 G 因系统调用(syscall)阻塞时会阻塞 M，此时 P 会和 M 解绑即 hand off，并寻找新的 idle 的 M，若没有 idle 的 M 就会新建一个 M(流程 5.1)。</li>
<li>当 G 因 channel 或者 network I/O 阻塞时，不会阻塞 M，M 会寻找其他 runnable 的 G；当阻塞的 G 恢复后会重新进入 runnable 进入 P 队列等待执行(流程 5.3)</li>
<li>当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中。</li>
</ol>
<h5 id="特殊的-M0-和-G0"><a href="#特殊的-M0-和-G0" class="headerlink" title="特殊的 M0 和 G0"></a>特殊的 M0 和 G0</h5><p>M0：启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。<br>G0：是每次启动一个 M 都会第一个创建的 goroutine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。</p>
<h3 id="Go-调度器调度场景过程全解析"><a href="#Go-调度器调度场景过程全解析" class="headerlink" title="Go 调度器调度场景过程全解析"></a>Go 调度器调度场景过程全解析</h3><ol>
<li><p>场景 1<br>P 拥有 G1，M1 获取 P 后开始运行 G1，G1 使用 <code>go func()</code> 创建了 G2，为了局部性 G2 优先加入到 P1 的本地队列。<br><img lazyload src="/images/loading.svg" data-src="q1.jpg" alt="avatar"></p>
</li>
<li><p>场景 2<br>G1 运行完成后 (函数：goexit)，M 上运行的 goroutine 切换为 G0，G0 负责调度时协程的切换（函数：schedule）。从 P 的本地队列取 G2，从 G0 切换到 G2，并开始运行 G2 (函数：execute)。实现了线程 M1 的复用。<br><img lazyload src="/images/loading.svg" data-src="q2.jpg" alt="avatar"></p>
</li>
<li><p>场景 3<br>假设每个 P 的本地队列只能存 3 个 G。G2 要创建了 6 个 G，前 3 个 G（G3, G4, G5）已经加入 p1 的本地队列，p1 本地队列满了。<br><img lazyload src="/images/loading.svg" data-src="q3.jpg" alt="avatar"></p>
</li>
<li><p>场景 4<br>G2 在创建 G7 的时候，发现 P1 的本地队列已满，需要执行<strong>负载均衡</strong> (把 P1 中本地队列中前一半的 G，还有新创建 G <strong>转移</strong>到全局队列)<br><img lazyload src="/images/loading.svg" data-src="q4.jpg" alt="avatar"></p>
</li>
<li><p>G2 创建 G8 时，P1 的本地队列未满，所以 G8 会被加入到 P1 的本地队列。G8 加入到 P1 点本地队列的原因还是因为 P1 此时在与 M1 绑定，而 G2 此时是 M1 在执行。所以 G2 创建的新的 G 会优先放置到自己的 M 绑定的 P 上。<br><img lazyload src="/images/loading.svg" data-src="q5.jpg" alt="avatar"></p>
</li>
<li><p>场景 6<br>规定：在创建 G 时，运行的 G 会尝试唤醒其他空闲的 P 和 M 组合去执行。<br><img lazyload src="/images/loading.svg" data-src="q6.jpg" alt="avatar"><br>假定 G2 唤醒了 M2，M2 绑定了 P2，并运行 G0，但 P2 本地队列没有 G，M2 此时为自旋线程<strong>（没有 G 但为运行状态的线程，不断寻找 G）</strong>。</p>
</li>
<li><p>场景 7<br>M2 尝试从全局队列 (简称 “GQ”) 取一批 G 放到 P2 的本地队列（函数：<code>findrunnable()</code>）。至少从全局队列取 1 个 g，但每次不要从全局队列移动太多的 g 到 p 本地队列，给其他 p 留点。这是<strong>从全局队列到 P 本地队列的负载均衡</strong>。<br><img lazyload src="/images/loading.svg" data-src="q7.jpg" alt="avatar"></p>
</li>
<li><p>场景 8<br>假设 G2 一直在 M1 上运行，经过 2 轮后，M2 已经把 G7、G4 从全局队列获取到了 P2 的本地队列并完成运行，全局队列和 P2 的本地队列都空了，如场景 8 图的左半部分。<br><img lazyload src="/images/loading.svg" data-src="q8.jpg" alt="avatar"></p>
</li>
<li><p>场景 9<br>G1 本地队列 G5、G6 已经被其他 M 偷走并运行完成，当前 M1 和 M2 分别在运行 G2 和 G8，M3 和 M4 没有 goroutine 可以运行，M3 和 M4 处于自旋状态，它们不断寻找 goroutine。<br><img lazyload src="/images/loading.svg" data-src="q9.jpg" alt="avatar"></p>
</li>
<li><p>场景 10<br>假定当前除了 M3 和 M4 为自旋线程，还有 M5 和 M6 为空闲的线程 (没有得到 P 的绑定，注意我们这里最多就只能够存在 4 个 P，所以 P 的数量应该永远是 M&gt;=P, 大部分都是 M 在抢占需要运行的 P)，G8 创建了 G9，G8 进行了阻塞的系统调用，M2 和 P2 立即解绑，P2 会执行以下判断：如果 P2 本地队列有 G、全局队列有 G 或有空闲的 M，P2 都会立马唤醒 1 个 M 和它绑定，否则 P2 则会加入到空闲 P 列表，等待 M 来获取可用的 p。本场景中，P2 本地队列有 G9，可以和其他空闲的线程 M5 绑定。<br><img lazyload src="/images/loading.svg" data-src="q10.jpg" alt="avatar"></p>
</li>
<li><p>场景 11<br>G8 创建了 G9，假如 G8 进行了<strong>非阻塞系统调用</strong>。<br><img lazyload src="/images/loading.svg" data-src="q11.jpg" alt="avatar"><br>M2 和 P2 会解绑，但 M2 会记住 P2，然后 G8 和 M2 进入系统调用状态。当 G8 和 M2 退出系统调用时，会尝试获取 P2，如果无法获取，则获取空闲的 P，如果依然没有，G8 会被记为可运行状态，并加入到全局队列，M2 因为没有 P 的绑定而变成休眠状态 (长时间休眠等待 GC 回收销毁)。</p>
</li>
</ol>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><h4 id="协作式的调度"><a href="#协作式的调度" class="headerlink" title="协作式的调度"></a>协作式的调度</h4><p>&emsp;&emsp;在 1.14 版本之前，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度，存在问题:</p>
<ol>
<li>某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿</li>
<li>垃圾回收需要暂停整个程序（Stop-the-world，STW），最长可能需要几分钟的时间，导致整个程序无法工作。</li>
</ol>
<h4 id="基于信号的抢占式调度"><a href="#基于信号的抢占式调度" class="headerlink" title="基于信号的抢占式调度"></a>基于信号的抢占式调度</h4><p>&emsp;&emsp;GO 的调度器是迟钝的，它很可能什么都没做，直到 M 阻塞了相当长时间以后，才会发现有一个 P/M 被 syscall 阻塞了。然后，才会用空闲的 M 来强这个 P。通过 sysmon 监控实现的抢占式调度，最快在 20us，最慢在 10-20ms 才 会发现有一个 M 持有 P 并阻塞了。操作系统在 1ms 内可以完成很多次线程调度（一般情况 1ms 可以完成几十次线程调度），Go 发起 IO/syscall 的时候执 行该 G 的 M 会阻塞然后被 OS 调度走，P 什么也不干，sysmon 最慢要 10-20ms 才能发现这个阻塞，说不定那时候阻塞已经结束了，宝贵的 P 资源就这么被阻塞的 M 浪费了。</p>
<h3 id="GMP-调度过程中存在哪些阻塞"><a href="#GMP-调度过程中存在哪些阻塞" class="headerlink" title="GMP 调度过程中存在哪些阻塞"></a>GMP 调度过程中存在哪些阻塞</h3><ol>
<li>I/O，select</li>
<li>block on syscall</li>
<li>channel</li>
<li>等待锁</li>
<li>runtime.Gosched() (G0 调度 goroutine)</li>
</ol>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="Golang-简要内存划分"><a href="#Golang-简要内存划分" class="headerlink" title="Golang 简要内存划分"></a>Golang 简要内存划分</h3><p><img lazyload src="/images/loading.svg" data-src="mem.jpg" alt="avatar"><br>&emsp;&emsp;可以简单的认为 Golang 程序在启动时，会向操作系统申请一定区域的内存，分为栈（Stack）和堆（Heap）。栈内存会随着函数的调用分配和回收；堆内存由程序申请分配，由垃圾回收器（Garbage Collector）负责回收。性能上，栈内存的使用和回收更迅速一些；尽管Golang 的 GC 很高效，但也不可避免的会带来一些性能损耗。因此，Go 优先使用栈内存进行内存分配。在不得不将对象分配到堆上时，才将特定的对象放到堆中。</p>
<h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h3><p><img lazyload src="/images/loading.svg" data-src="stackHeap.png" alt="avatar"><br>&emsp;&emnsp;上图展示了一个进程的虚拟内存划分，代码中使用的内存地址都是虚拟内存地址，而不是实际的物理内存地址。栈和堆只是虚拟内存上2块不同功能的内存区域：</p>
<ul>
<li>栈在高地址，从高地址向低地址增长。</li>
<li>堆在低地址，从低地址向高地址增长。</li>
</ul>
<blockquote>
<p><strong>栈和堆相比有这么几个好处</strong>：</p>
<ol>
<li> 栈的内存管理简单，分配比堆上快。</li>
<li>栈的内存不需要回收，而堆需要，无论是主动free，还是被动的垃圾回收，这都需要花费额外的CPU。 </li>
<li>栈上的内存有更好的局部性，堆上内存访问就不那么友好了，CPU访问的2块数据可能在不同的页上，CPU访问数据的时间可能就上去了。</li>
</ol>
</blockquote>
<h3 id="栈内存分配"><a href="#栈内存分配" class="headerlink" title="栈内存分配"></a>栈内存分配</h3><ol>
<li>以一段简单的代码作为示例，分析这段代码的内存分配过程。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">	n := <span class="number">4</span>  </span><br><span class="line">	n2 := square(n)  </span><br><span class="line">	fmt.Println(n2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> n * n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
&emsp;&emsp;代码的功能很简单，一个 main 函数作为程序入口，定义了一个变量n，定义了另一个函数 squire ，返回乘方操作后的 int 值。最后，将返回的值打印到控制台。程序输出为16。下面开始逐行进行分析，解析调用时，go 运行时是如何对内存进行分配的。<br><img lazyload src="/images/loading.svg" data-src="code1.jpg" alt="avatar"><br>&emsp;&emsp;当代码运行到第6行，进入 main 函数时，会在栈上创建一个 Stack frame，存放本函数中的变量信息。包括函数名称，变量等。</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="code2.jpg" alt="avatar"><br>&emsp;&emsp;当代码运行到第7行时，go 会在栈中压入一个新的 Stack Frame，用于存放调用 square 函数的信息；包括函数名、变量 n 的值等。此时，计算4 * 4 的值，并返回。</p>
<p><img lazyload src="/images/loading.svg" data-src="code3.jpg" alt="avatar"><br>&emsp;&emsp;当 square 函数调用完成，返回16到 main 函数后，将16赋值给 n2变量。注意，原来的 stack frame 并不会被 go 清理掉，而是如栈左侧的箭头所示，被标记为不合法。上图夹在红色箭头和绿色箭头之间的横线可以理解为 go 汇编代码中的 SP 栈寄存器的值，当程序申请或释放栈内存时，只需要修改 SP 寄存器的值，这种栈内存分配方式省掉了清理栈内存空间的耗时。</p>
<p><img lazyload src="/images/loading.svg" data-src="code4.jpg" alt="avatar"><br>&emsp;&emsp;接下来，调用 fmt.Println 时，SP 寄存器的值会进一步增加，覆盖掉原来 square 函数的 stack frame，完成 print 后，程序正常退出。</p>
<ol start="2">
<li>指针作为参数情况下的栈内存分配<br>还是同样的过程，看如下这段代码。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">	n := <span class="number">4</span>  </span><br><span class="line">	increase(&amp;n)  </span><br><span class="line">	fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increase</span><span class="params">(i *<span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">	*i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>&emsp;&emsp;main 作为程序入口，声明了一个变量 n，赋值为4。声明了一个函数   increase，使用一个 int 类型的指针 i 作为参数，increase 函数内，对指针 i 对应的值进行自增操作。最后 main 函数中打印了 n 的值。程序输出为5。</p>
<p><img lazyload src="/images/loading.svg" data-src="code5.jpg" alt="avatar"><br>&emsp;&emsp;当程序运行到 main 函数的第6行时，go 在栈上分配了一个 stack frame ，对变量 n 进行了赋值，n 在内存中对应的地址为0xc0008771，此时程序将继续向下执行，调用 increase 函数。</p>
<p><img lazyload src="/images/loading.svg" data-src="code6.jpg" alt="avatar"><br>&emsp;&emsp;这时，increase 函数对应的 stack fream 被创建，i 被赋值为变量 n对应的地址值0xc0008771，然后进行自增操作。</p>
<p><img lazyload src="/images/loading.svg" data-src="code7.jpg" alt="avatar"><br>&emsp;&emsp;当 increase 函数运行结束后，SP 寄存器会上移，将之前分配的 stack freme 标记为不合法。此时，程序运行正常，并没有因为 SP 寄存器的改动而影响程序的正确性，内存中的值也被正确的修改了。</p>
<ol start="3">
<li>指针作为返回值情况下的栈内存分配<br>&emsp;&emsp;之前的部分分别介绍了普通变量作为参数和将指针作为参数情况下的栈内存使用，本部分来介绍将指针作为返回值，返回给调用方的情况下，内存是如何分配的，并引出内存逃逸相关内容。来看这段代码：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">	n := initValue()  </span><br><span class="line">	fmt.Println(*n/<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initValue</span><span class="params">()</span> *<span class="title">int</span></span> &#123;  </span><br><span class="line">	i := <span class="number">4</span>  </span><br><span class="line">	<span class="keyword">return</span> &amp;i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
&emsp;&emsp;main 函数中，调用了 initValue 函数，该函数返回一个 int 指针并赋值给 n，指针对应的值为4。随后，main 函数调用 fmt.Println 打印了指针 n / 2对应的值。程序输出为2。</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="code8.jpg" alt="avatar"><br>&emsp;&emsp;程序调用 initValue 后，将 i 的地址赋值给变量 n 。注意，如果这时，变量 i 的位置在栈上，则可能会随时被覆盖掉。</p>
<p><img lazyload src="/images/loading.svg" data-src="code9.jpg" alt="avatar"><br>在调用 fmt.Println 时，Stack Frame 会被重新创建，变量 i 被赋值为*n/2也就是2，会覆盖掉原来 n 所指向的变量值。这会导致及其严重的问题。在面对 sharing up 场景时，go 通常会将变量分配到堆中，如下图所示：</p>
<p><img lazyload src="/images/loading.svg" data-src="code10.jpg" alt="avatar"><br>&emsp;&emsp;通过上面的分析，可以看到在面对被调用的函数返回一个指针类型时将对象分配到栈上会带来严重的问题，因此 Go 将变量分配到了堆上。这种分配方式保证了程序的安全性，但也不可避免的增加了堆内存创建，并需要在将来的某个时候，需要 GC 将不再使用的内存清理掉。</p>
<blockquote>
<p>栈上内存分配原则</p>
<ul>
<li>在调用方创建的变量或对象，通过参数的形式传递给被调用函数，这时，在调用方创建的内存空间通常在栈上。这种在调用方创建内存，在被调用方使用该内存的“内存共享”方式，称之为 Sharing down</li>
<li>在被调用函数内创建的对象，以指针的形式返回给调用方的情况下，通常，创建的内存空间在堆上。这种在被调用方创建，在调用方使用的“内存共享”方式，称之为 Sharing up。</li>
<li>总结：1. 因为栈比堆更高效，不需要 GC，因此 Go 会尽可能的将内存分配到栈上。<ol start="2">
<li>当分配到栈上可能引起非法内存访问等问题后，会使用堆，主要场景有：<br>（1）当一个值可能在函数被调用后访问，这个值极有可能被分配到堆上<br>（2）当编译器检测到某个值过大，这个值会被分配到堆上<br>（3）<strong>当编译时，编译器不知道这个值的大小（slice、map…）这个值会被分配到堆上</strong></li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h3><p><img lazyload src="/images/loading.svg" data-src="heapmacllo.png" alt="avatar"><br>&emsp;&emsp;当我们说内存管理的时候，主要是指堆内存的管理，因为栈的内存管理不需要程序去操心。这小节看下堆内存管理干的是啥，如上图所示主要是3部分：<strong>分配内存块，回收内存块和组织内存块</strong>。<br>&emsp;&emsp;在一个最简单的内存管理中，堆内存最初会是一个完整的大块，即未分配内存，当来申请的时候，就会从未分配内存，分割出一个小内存块(block)，然后用链表把所有内存块连接起来。需要一些信息描述每个内存块的基本信息，比如大小(size)、是否使用中(used)和下一个内存块的地址(next)，内存块实际数据存储在data中。<br><img lazyload src="/images/loading.svg" data-src="usemem.png" alt="avatar"><br>&emsp;&emsp;一个内存块包含了3类信息，如下图所示，元数据、用户数据和对齐字段，内存对齐是为了提高访问效率。下图申请5Byte内存的时候，就需要进行内存对齐。</p>
<p><img lazyload src="/images/loading.svg" data-src="malloc.png" alt="avatar"><br>&emsp;&emsp;释放内存实质是把使用的内存块从链表中取出来，然后标记为未使用，当分配内存块的时候，可以从未使用内存块中有先查找大小相近的内存块，如果找不到，再从未分配的内存中分配内存。上面这个简单的设计中还没考虑内存碎片的问题，因为随着内存不断的申请和释放，内存上会存在大量的碎片，降低内存的使用率。为了解决内存碎片，可以将2个连续的未使用的内存块合并，减少碎片。</p>
<h4 id="TCMalloc"><a href="#TCMalloc" class="headerlink" title="TCMalloc"></a>TCMalloc</h4><p>&emsp;&emsp;TCMalloc 是 Thread Cache Malloc 的简称，是 Go 内存管理的起源。引入虚拟内存后，让内存的并发访问问题的粒度从多进程级别，降低到多线程级别。同一进程的所有线程共享相同的内存空间，他们申请内存时需要加锁，如果不加锁就存在同一块内存被2个线程同时访问的问题。TCMalloc的做法是什么呢？<strong>为每个线程预分配一块缓存，线程申请小内存时，可以从缓存分配内存</strong>，这样有2个好处：</p>
<ol>
<li>为线程预分配缓存需要进行1次系统调用，后续线程申请小内存时，从缓存分配，都是在用户态执行，没有系统调用，<strong>缩短了内存总体的分配和释放时间，这是快速分配内存的第二个层次</strong>。</li>
<li>多个线程同时申请小内存时，从各自的缓存分配，访问的是不同的地址空间，无需加锁，<strong>把内存并发访问的粒度进一步降低了，这是快速分配内存的第三个层次</strong>。</li>
</ol>
<h2 id="Go-GC（垃圾回收）"><a href="#Go-GC（垃圾回收）" class="headerlink" title="Go GC（垃圾回收）"></a>Go GC（垃圾回收）</h2><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>&emsp;&emsp;程序在创建引用类型实体时会在虚拟内存中分配给他们一块空间（堆），如果该内存空间不再被任何引用变量引用就称为需要被回收的垃圾。操作系统会记录一个进程运行时的所占用的内存、CPU和寄存器等资源，当进程结束后便由操作系统能够自动回收资源。但是对于一个运行较长时间的程序，如果使用完内存资源后没有及时释放就会造成内存泄漏甚至系统错误。<br>&emsp;&emsp;以不支持自动垃圾回收的 C++ 为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">128</span>];</span><br><span class="line">  <span class="comment">// 对指针的使用</span></span><br><span class="line">  <span class="keyword">delete</span>[] p; <span class="comment">// delete语句释放对象数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果由于一场或者其他原因导致 delete 语句没有正常执行，且该函数被频繁调用，那么很容易占用所有的内存从而导致程序崩溃，如果泄漏的时系统资源还会导致系统崩溃。另一方面如果我们在不该释放内存的时候释放内存，那么仍然在使用这块内存的指针就会变成野指针 <code>wild pointer</code>，使用该指针对内存进行读写是未定义的行为。</p>
<ol>
<li><p>垃圾回收过程<br>&emsp;&emsp;用户程序<code>Mutator</code>通过内存分配器<code>Allocator</code>在堆<code>Heap</code>上申请内存，垃圾回收器<code>Collector</code>会定时清理堆上的内存。<br><img lazyload src="/images/loading.svg" data-src="collector.jpg" alt="avatar"></p>
</li>
<li><p>自动垃圾回收与手动垃圾回收<br>&emsp;&emsp;<code>C</code>语言这种较为传统的语言通过<code>malloc</code>和<code>free</code>手动向操作系统申请和释放内存，这种自由管理内存的方式给予程序员极大的自由度，但是也相应地提高了对程序员的要求。<code>C</code>语言的内存分配和回收方式主要包括三种：</p>
</li>
</ol>
<ul>
<li>函数体内的局部变量：在栈上创建，函数作用域结束后自动释放内存</li>
<li>静态变量：在静态存储区域上分配内存，整个程序运行结束后释放（全局生命周期）</li>
<li>动态分配内存的变量：在堆上分配，通过<code>malloc</code>申请，<code>free</code>释放</li>
</ul>
<p>&emsp;&emsp;<code>C</code>、<code>C++</code>等较早的语言采用的是手动垃圾回收，需要程序员通过向操作系统申请和释放内存来手动管理内存，程序员极容易忘记释放自己申请的内存，对于一个长期运行的程序往往是一个致命的缺点。<code>Python</code>、<code>Java</code>和<code>Golang</code>等较新的语言采取的都是自动垃圾回收方式，程序员只需要负责申请内存，垃圾回收器会周期性释放结束生命周期的变量所占用的内存空间。</p>
<ol start="3">
<li>垃圾回收目标<br>垃圾回收器主要包括三个目标：</li>
</ol>
<ul>
<li><strong>无内存泄漏</strong>：垃圾回收器最基本的目标就是减少防止程序员未及时释放导致的内存泄漏，垃圾回收器会识别并清理内存中的垃圾</li>
<li>自动<strong>回收无用内存</strong>：垃圾回收器作为独立的子任务，不需要程序员显式调用即可自动清理内存垃圾</li>
<li>内存整理：如果只是简单回收无用内存，那么堆上的内存空间会存在较多<strong>内存碎片</strong>而无法满足分配较大对象的需求，因此垃圾回收器需要重整内存空间，提高内存利用率</li>
</ul>
<h3 id="常见的垃圾回收方法"><a href="#常见的垃圾回收方法" class="headerlink" title="常见的垃圾回收方法"></a>常见的垃圾回收方法</h3><p>&emsp;&emsp;根据判断对象是否存活的方法，可以简单将<code>GC</code>算法分为“<strong>引用计数式</strong>”垃圾回收和“<strong>追踪回收式</strong>”垃圾回收。前者根据每个对象的引用计数器是否为<code>0</code>来判断该对象是否为未引用的垃圾对象，后者先判断哪些对象存活，然后将其余的所有对象作为垃圾进行回收。追踪回收本身包括标记-清除<code>Mark-Sweep</code>、标记-复制<code>Mark-Copy</code>和标记-整理<code>Mark-Compact</code>三种回收算法。</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>&emsp;&emsp;引用计数<code>Reference counting</code>会为每个对象维护一个计数器，当该对象被其他对象引用时加一，引用失效时减一，当引用次数归零后即可回收对象。使用这类<code>GC</code>方法的语言包括<code>python</code>、<code>php</code>、<code>objective-C</code>和<code>C++</code>标准库中的<code>std::shared_ptr</code>等。<br>优点：</p>
<ul>
<li>原理和实现都比较简单</li>
<li>回收的即时性：当对象的引用计数为<code>0</code>时立即回收，不像其他<code>GC</code>机制需要等待特定时机再回收，提高了内存的利用率</li>
<li>不需要暂停应用即可完成回收</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法解决循环引用的回收问题：当<code>ObjA</code>引用了<code>ObjB</code>，<code>ObjB</code>也引用<code>ObjA</code>时，这两个对象的引用次数使用大于<code>0</code>，从而占用的内存无法被回收</li>
<li>时间和空间成本较高：一方面是因为每个对象需要额外的空间存储引用计数器变量，另一方面是在栈上的赋值时修改引用次数时间成本较高（原本只需要修改寄存器中的值，现在计数器需要不断更新因此不是只读的，需要额外的原子操作来保证线程安全）</li>
<li>引用计数是一种摊销算法，会将内存的回收分摊到整个程序的运行过程，但是当销毁一个很大的树形结构时无法保证响应时间</li>
</ul>
<h4 id="追踪回收式"><a href="#追踪回收式" class="headerlink" title="追踪回收式"></a>追踪回收式</h4><p>追踪基础：可达性分析算法<br>&emsp;&emsp;尽管前面提到的三种追踪式垃圾回收算法实现起来各不相同，但是第一步都是通过可达性分析算法标记<code>Mark</code>对象是否“可达”。一般可到达的对象主要包括两类：</p>
<ul>
<li><code>GC Root</code>对象：包括全局对象、栈上的对象（函数参数与内部变量）</li>
<li>与<code>GC Root</code>对象通过引用链<code>Reference Chain</code>相连的对象</li>
</ul>
<p>对于“不可达”的对象，我们可以认为该对象为垃圾对象并回收对应的内存空间。<br><img lazyload src="/images/loading.svg" data-src="reachable.jpg" alt="avatar"></p>
<p>同引用计数法相比，追踪式算法具有如下优点：</p>
<ul>
<li>解决了循环引用对象的回收问题</li>
<li>占用空间更少</li>
</ul>
<p>缺点包括：</p>
<ul>
<li>同引用计数相比无法立刻识别出垃圾对象，需要依赖<code>GC</code>线程(下文的算法)</li>
<li>算法在标记时必须暂停整个程序，即<code>Stop The World, STW</code>，否则其他线程的代码会修改对象状态从而回收不该回收的对象</li>
</ul>
<ol>
<li>标记-清除算法<br>标记-清除<code>Mark-Sweep</code>算法是最基础的追踪式算法，分为“标记”和“清除”两个步骤：</li>
</ol>
<ul>
<li>标记：记录需要回收的垃圾对象</li>
<li>清除：在标记完成后回收垃圾对象的内存空间</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="mark-sweep.jpg" alt="avatar"><br>优点包括：</p>
<ul>
<li>算法吞吐量较高，即运行用户代码时间 / （运行用户代码时间 + 运行垃圾收集时间）较高</li>
<li>空间利用率高：同标记-复制相比不需要额外空间复制对象，也不需要像引用计数算法为每个对象设置引用计数器</li>
</ul>
<p>缺点：</p>
<ul>
<li>清除后会<strong>产生大量的内存碎片</strong>空间，导致程序在运行时可能没法为较大的对象分配内存空间，导致提前进行下一次垃圾回收</li>
</ul>
<ol start="2">
<li>标记-复制算法<br>标记-复制<code>Mark-Copy</code>算法将内存分成大小相同的两块，当某一块的内存使用完了之后就将使用中的对象挨个复制到另一块内存中，最后将当前内存恢复未使用的状态。<br><img lazyload src="/images/loading.svg" data-src="mark-copy.jpg" alt="avatar"></li>
</ol>
<p>优点：</p>
<ul>
<li>标记-清除法需要在清除阶段对大量垃圾对象进行扫描，标记-复制则只需要从<code>GC Root</code>对象出发，将“可到达”的对象复制到另一块内存后直接清理当前这块的内存，因此提升了垃圾回收的效率</li>
<li>解决了内存碎片化的问题，防止分配较大连续空间时的提前<code>GC</code>问题</li>
</ul>
<p>缺点：</p>
<ul>
<li>同标记-清除法相比，在“可达”对象占比较高的情况下有复制对象的开销</li>
<li>内存利用率较低，相当于可利用的内存仅有一半</li>
</ul>
<ol start="3">
<li>标记-整理算法<br>&emsp;&emsp;标记-整理<code>Mark-Compact</code>算法综合了标记-清除法和标记-复制法的优势，既不会产生内存碎片化的问题，也不会有一半内存空间浪费的问题。该方法首先标记出所有“可达”的对象，然后将存活的对象移动到内存空间的一端，最后清理掉端边界以外的内存。<br><img lazyload src="/images/loading.svg" data-src="mark-compact.jpg" alt="avatar"><br>优点包括：</li>
</ol>
<ul>
<li>避免了内存碎片化的问题</li>
<li>在对象存活率较高的情况下，标记-整理算法由于不需要复制对象效率更高，因此更加适合老年代算法</li>
</ul>
<p>缺点包括：</p>
<ul>
<li>整理过程较为复杂，需要多次遍历内存导致<code>STW</code>时间比标记-清除算法更长</li>
</ul>
<h3 id="Golang-的-GC-算法"><a href="#Golang-的-GC-算法" class="headerlink" title="Golang 的 GC 算法"></a>Golang 的 GC 算法</h3><h4 id="三色标记法（go-1-3）"><a href="#三色标记法（go-1-3）" class="headerlink" title="三色标记法（go 1.3）"></a>三色标记法（go 1.3）</h4><p>&emsp;&emsp;前面提到的“标记”类算法都有一个共同的瑕疵，即在进行垃圾回收的时候会暂停整个程序（<code>STW</code>问题）。三色标记法是对“标记”阶段的改进，在不暂停程序的情况下即可完成对象的可达性分析。<code>GC</code>线程将所有对象分为三类：</p>
<ul>
<li>白色：未搜索的对象，在回收周期开始时所有对象都是白色，在回收周期结束时所有的白色都是垃圾对象</li>
<li>灰色：正在搜索的对象，但是对象身上还有一个或多个引用没有扫描</li>
<li>黑色：已搜索完的对象，所有的引用已经被扫描完</li>
</ul>
<p>&emsp;&emsp;三色标记法属于增量式<code>GC</code>算法，回收器首先将所有的对象着色成白色，然后从<code>GC Root</code>出发，逐步把所有“可达”的对象变成灰色再到黑色，最终所有的白色对象即是“不可达”对象。</p>
<blockquote>
<p><code>GC Root</code> 对象包括：</p>
<ol>
<li>全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。</li>
<li>执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。</li>
<li> 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。</li>
</ol>
</blockquote>
<p>具体的实现如下：</p>
<ol>
<li>初始时所有对象都是白色对象</li>
<li>从<code>GC Root</code>对象出发，扫描所有可达对象并标记为灰色，放入待处理队列</li>
<li>从队列取出一个灰色对象并标记为黑色，将其引用对象标记为灰色放入队列</li>
<li>重复上一步骤，直到灰色对象队列为空</li>
<li>此时所有剩下的白色对象就是垃圾对象</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="three_color.gif" alt="gif"></p>
<p>优点：不需要暂停整个程序进行垃圾回收<br>缺点：</p>
<ul>
<li>如果程序垃圾对象的产生速度大于垃圾对象的回收速度时，可能导致程序中的垃圾对象越来越多而无法及时收集</li>
<li>线程切换和上下文转换的消耗会使得垃圾回收的总体成本上升，从而降低系统吞吐量</li>
</ul>
<h4 id="屏障机制"><a href="#屏障机制" class="headerlink" title="屏障机制"></a>屏障机制</h4><ol>
<li><p>STW<br>&emsp;&emsp;STW 可以是Stop The World的缩写，也可以是Start The World的缩写。通常意义上指的是从Stop The World到Start The World这一段时间间隔。垃圾回收过程中为了保证准确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图以完成垃圾回收。STW时间越长，对用户代码造成的影响越大。</p>
</li>
<li><p>No STW 存在的问题<br>&emsp;&emsp;假设下面的场景，已经被标记为灰色的对象2，未被标记的对象3被对象2用指针p引用；此时已经被标记为黑色的对象4创建指针q 指向未被标记的对象3，同时对象2将指针p移除；对象4已经被标记为黑色，对象3未被引用，对象2删除与对象3的引用，导致最后对象3被误清除；<br><img lazyload src="/images/loading.svg" data-src="stw.png" alt="avatar"></p>
</li>
</ol>
<ul>
<li>垃圾回收的原则是不应出现对象的丢失，也不应错误的回收还不需要回收的对象。如果同时满足下面两个条件会破坏回收器的正确性：<ul>
<li>条件 1: 赋值器修改对象图，导致某一黑色对象引用白色对象；（通俗的说就是A突然持有了B的指针，而B在并发标记的过程中已经被判定为白色对象要被清理掉的）</li>
<li>条件 2: 从灰色对象出发，到达白色对象且未经访问过的路径被赋值器破坏；（通俗的说就是A持有B的指针，这个持有关系被释放）</li>
</ul>
</li>
</ul>
<blockquote>
<p>只要能够避免其中任何一个条件，则不会出现对象丢失的情况，因为：</p>
<ul>
<li>  如果条件 1被避免，则所有白色对象均被灰色对象引用，没有白色对象会被遗漏；<strong>强三色不变性</strong></li>
<li>  如果条件 2 被避免，即便白色对象的指针被写入到黑色对象中，但从灰色对象出发，总存在一条没有访问过的路径，从而找到到达白色对象的路径，白色对象最终不会被遗漏。<strong>弱三色不变性</strong></li>
</ul>
</blockquote>
<p><strong>可能的解决方法：</strong> 整个过程STW，浪费资源，且对用户程序影响较大，由此引入了<strong>屏障机制</strong>；</p>
<ol start="3">
<li>屏障机制<br>&emsp;&emsp;把回收器视为对象，把赋值器视为影响回收器这一对象的实际行为（即影响 GC 周期的长短），从而引入赋值器的颜色：</li>
</ol>
<ul>
<li>黑色赋值器：已经由回收器扫描过，不会再次对其进行扫描。</li>
<li>灰色赋值器：尚未被回收器扫描过或尽管已经扫描过，但仍需要重新扫描。</li>
</ul>
<h5 id="Dijkstra插入写屏障（go-1-5）"><a href="#Dijkstra插入写屏障（go-1-5）" class="headerlink" title="Dijkstra插入写屏障（go 1.5）"></a>Dijkstra插入写屏障（go 1.5）</h5><p>&emsp;&emsp;<code>Dijkstra</code>插入写屏障避免了前面提到的条件1，即防止黑色对象指向白色对象。一个对象可以存储在内存中的“栈”或者“堆”，<strong>由于“栈”空间容量小且要求相应速度较高，因此“插入写屏障”不适合用于“栈”空间</strong>。在“插入写屏障”保护下的三色标记法执行例子如下：<br><img lazyload src="/images/loading.svg" data-src="step1.jpeg" alt="avatar"><br><img lazyload src="/images/loading.svg" data-src="step2.jpeg" alt="avatar"><br><img lazyload src="/images/loading.svg" data-src="step3.jpeg" alt="avatar"></p>
<p>&emsp;&emsp;尽管<code>Dijkstra</code>插入写屏障可以<strong>实现垃圾回收和用户程序的并发执行</strong>，但是它存在两个缺点。一方面它是一种比较保守的垃圾回收方法，<strong>把有可能存活的对象都标记成灰色了以满足“强三色不变性”</strong>。以下图为例，用户程序<code>Mutator</code>将对象A原本指向B对象的指针改成指向C对象，尽管在修改后B对象已经是一个垃圾对象，但是它在本轮垃圾回收过程中不会被回收。<br><img lazyload src="/images/loading.svg" data-src="dj.jpeg" alt="avatra"></p>
<h5 id="Yuasa删除屏障"><a href="#Yuasa删除屏障" class="headerlink" title="Yuasa删除屏障"></a>Yuasa删除屏障</h5><p>&emsp;&emsp;<code>Yuasa</code>删除写屏障避免了前面提到的条件2，防止丢失灰色对象到白色对象的可达路径。<strong>满足了弱三色不变性</strong><br><img lazyload src="/images/loading.svg" data-src="yuasa.jpeg" alt="avatar"></p>
<p>下图简单绘制了<code>Yuasa</code>删除写屏障是如何保证用户程序<code>Mutator</code>和垃圾回收器<code>Collector</code>的并发执行的：</p>
<ul>
<li>  第二步中<code>Mutator</code>将对象<code>A</code>原本指向对象<code>B</code>的指针指向<code>C</code>，由于对象<code>B</code>本身就是灰色的，因此不需要对它重新着色</li>
<li>  第三步中<code>Mutator</code>删除了对象<code>B</code>指向对象<code>C</code>的指针，删除写屏障将下游对象<code>C</code>标记为灰色<br><img lazyload src="/images/loading.svg" data-src="yuasa1.jpeg" alt="avatar"><br>&emsp;&emsp;<code>Yuasa</code>删除写屏障和<code>Dijkstra</code>插入写屏障相比优点在于不需要在一轮三色标记后对栈空间上的对象进行重新扫描，缺点在于<code>Collector</code>会悲观地认为所有被删除的对象都可能被黑色对象引用，比如上图中第三步<code>Mutator</code>删除了对象<code>B</code>指向对象<code>C</code>的指针，如果此时还有一个单独的对象<code>E</code>指向<code>C</code>，那么本该被删除的对象<code>E</code>却可以在本轮垃圾回收中存活。</li>
</ul>
<h5 id="混合写屏障（go-1-8）"><a href="#混合写屏障（go-1-8）" class="headerlink" title="混合写屏障（go 1.8）"></a>混合写屏障（go 1.8）</h5><blockquote>
<p><strong>混合写屏障也是仅在堆空间启动的，防止降低栈空间的运行效率</strong></p>
</blockquote>
<p>回顾一下之前提到的两种写屏障的劣势：</p>
<ul>
<li><code>Dijkstra</code>插入写屏障：一轮标记结束后需要<code>STW</code>重新扫描栈上对象</li>
<li><code>Yuasa</code>删除写屏障：回收精度低，在垃圾回收开始前使用<code>STW</code>扫描所有<code>GC Root</code>对象形成初始快照，用户程序<code>Mutator</code>从灰色/白色对象中删除白色指针时会将下游对象标记为灰色，相当于保护了所有初始快照中的白色对象不被删除</li>
</ul>
<h6 id="具体场景的实现"><a href="#具体场景的实现" class="headerlink" title="具体场景的实现"></a><strong>具体场景的实现</strong></h6><p><code>GC</code>开始阶段会将所有栈空间可达对象都标记为黑色：<br><img lazyload src="/images/loading.svg" data-src="s11.jpeg" alt="avatar"></p>
<p>场景一：某个对象从堆对象的下游变成栈对象的下游，这种情况下标记该对象为灰色，该对象就不会被错误地回收<br><img lazyload src="/images/loading.svg" data-src="s12.jpeg" alt="avatar"></p>
<p>场景二：某个对象从一个栈对象的下游变成另一个对象的下游，由于对象全都在栈空间对象的可达对象中，因此混合写屏障不会对这些对象着色。<br><img lazyload src="/images/loading.svg" data-src="s13.jpeg" alt="avatar"></p>
<p>场景三：某个对象从一个堆对象的下游变成另一个堆对象的下游，比如下图中对象G从F的下游移动到Y的下游，为了避免对象<code>G</code>被错误回收，我们需要将其标记为灰色<br><img lazyload src="/images/loading.svg" data-src="s14.jpeg" alt="avatar"></p>
<p>场景四：某个对象从栈对象的下游变成堆对象的下游，对于栈空间对象不触发写屏障，但是对于被删除的堆空间对象<code>G</code>需要标记成灰色以保护它和它的下游对象不被错误删除<br><img lazyload src="/images/loading.svg" data-src="s15.jpeg" alt="avatar"></p>
<ul>
<li>混合写屏障继承了插入写屏障的优点，起始无需 STW 打快照，直接并发扫描垃圾即可；</li>
<li>混合写屏障继承了删除写屏障的优点，赋值器是黑色赋值器，GC 期间，任何在栈上创建的新对象，均为黑色。扫描过一次就不需要扫描了，这样就消除了插入写屏障时期最后 STW 的重新扫描栈；</li>
<li>混合写屏障扫描精度继承了删除写屏障，比插入写屏障更低，随着带来的 是 GC 过程全程无 STW；</li>
<li>混合写屏障扫描栈虽然没有 STW，但是扫描某一个具体的栈的时候，还是 要停止这个 goroutine 赋值器的工作的</li>
</ul>
<h4 id="GC-触发时机"><a href="#GC-触发时机" class="headerlink" title="GC 触发时机"></a>GC 触发时机</h4><p>主动触发：调用 runtime.GC<br>被动触发： 使用系统监控，该触发条件由 runtime.forcegcperiod 变量控制，默认为 2 分钟。当超过两分钟没有产生任何 GC 时，强制触发 GC。 使用步调（Pacing）算法，其核心思想是控制内存增长的比例。如 Go 的 GC 是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC 存活堆大小成比例. 由 GOGC 控制, 默认 100, 即 2 倍的关系, 200 就是 3 倍, 当 Go 新创建的对象所占用的内存大小，除以上次 GC 结束后保留下来的对象占用内存大小。</p>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>channel 的 range 和 select 比较</title>
    <url>/2022/03/19/channel%20%E7%9A%84%20range%20%E5%92%8C%20select%20%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<blockquote>
<p>本文是对 <a class="link" href="http://golangtutorials.blogspot.com/2011/06/channels-in-go-range-and-select.html">Channels in Go - range and select<i class="fas fa-external-link-alt"></i></a> 的学习</p>
</blockquote>
<h1 id="range"><a href="#range" class="headerlink" title="range"></a>range</h1><p>&emsp;&emsp;在 goroutine 之间使用 channel 通信时，数据接收方总是面临这样的问题：什么时候停止等待数据？还会有更多的数据么，还是所有内容都完成了？我应该继续等待还是该做别的了？对于这个问题，一个可选的方式是，持续的访问数据源并检查channel是否已经关闭，但是这并不是高效的解决方式。Go提供了<code>range</code>关键字，将其使用在channel上时，会自动等待channel的动作一直到channel被关闭。</p>
<p>下面通过一段示例代码来说明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">(send <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, num <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=num; i++ &#123;  </span><br><span class="line">      send &lt;- i  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="built_in">close</span>(send)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">(recieve &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">for</span> num := <span class="keyword">range</span> recieve &#123;  </span><br><span class="line">      fmt.Printf(<span class="string">&quot;Now we recieve the number %v\n&quot;</span>, num)  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)  </span><br><span class="line">   <span class="keyword">go</span> a(c, <span class="number">8</span>)  </span><br><span class="line">   b(c)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出结果</span><br><span class="line">Now we recieve the number 1</span><br><span class="line">Now we recieve the number 2</span><br><span class="line">Now we recieve the number 3</span><br><span class="line">Now we recieve the number 4</span><br><span class="line">Now we recieve the number 5</span><br><span class="line">Now we recieve the number 6</span><br><span class="line">Now we recieve the number 7</span><br><span class="line">Now we recieve the number 8</span><br></pre></td></tr></table></figure>
<p>a 这个 goroutine 一直向 channel 内传递数据，直到这个 channel 被关闭前，b 这个 goroutine 都会通过 <code>range</code>  这个关键字阻塞在循环中一直等待 channel 中的数据。通过这个例子还可以看出，<code>for range</code> 可以接收 channel 中的数据，不然 c 作为一个无缓冲 channel，a 不可能向其中一直发送数据。</p>
<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p><code>select</code>关键字用于多个channel的结合，这些channel会通过类似于 <strong>are-you-ready polling</strong> 的机制来工作。<code>select</code>中会有<code>case</code>代码块，用于发送或接收数据——不论通过<code>&lt;-</code>操作符指定的发送还是接收操作准备好时，channel也就准备好了。在<code>select</code>中也可以有一个<code>default</code>代码块，其一直是准备好的。那么，在<code>select</code>中，哪一个代码块被执行的算法大致如下：</p>
<ul>
<li>检查每个<code>case</code>代码块</li>
<li>如果任意一个<code>case</code>代码块准备好发送或接收，执行对应内容</li>
<li>如果多于一个<code>case</code>代码块准备好发送或接收，<strong>随机</strong>选取一个并执行对应内容</li>
<li>如果任何一个<code>case</code>代码块都没有准备好，等待</li>
<li>如果有<code>default</code>代码块，并且没有任何<code>case</code>代码块准备好，执行<code>default</code>代码块对应内容</li>
</ul>
]]></content>
      <categories>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>早起刷题（Day 1）</title>
    <url>/2022/03/30/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%201%EF%BC%89/</url>
    <content><![CDATA[<h2 id="LeetCode179-最大数"><a href="#LeetCode179-最大数" class="headerlink" title="LeetCode179. 最大数"></a><a class="link" href="https://leetcode-cn.com/problems/largest-number/">LeetCode179. 最大数<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。<br>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [10,2]</span><br><span class="line">输出：&quot;210&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [3,30,34,5,9]</span><br><span class="line">输出：&quot;9534330&quot;</span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1).  本题需要按照字典序排序来生成最终的字符串；<br>(2). 当给定的数组中元素的最高位都不相等时，情况最简单，直接输出字典序即可；<br>(3). 当出现 $4$ 和 $42$ 这种类型的子序列时，如果按照字典序来排序只能得到 $424$，但实际上最大值是 $442$，因此可知根据字典序排序只能得到局部最大值 <code>ans</code>，我们要求的是全局最大值 <code>max</code>；<br>(4). 可以在排序的时候更改一下排序条件，不以字典序为排序条件，而是以两数拼接后的实际大小来排序。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(Nlog(N))。因为有排序算法。</p>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	sort.Slice(nums, <span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span><span class="title">bool</span></span> &#123;</span><br><span class="line">		x, y := nums[i], nums[j]</span><br><span class="line">		sx, sy := <span class="number">10</span>, <span class="number">10</span></span><br><span class="line">		<span class="keyword">for</span> sx &lt;= x &#123;</span><br><span class="line">			sx *= <span class="number">10</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> sy &lt;= y &#123;</span><br><span class="line">			sy *= <span class="number">10</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> sy*x+y &gt; sx*y+x</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> nums[<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		ret += strconv.Itoa(nums[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h3><p>&emsp;&emsp;在排序条件中，我们维护了两个变量 <code>sx</code> 和 <code>sy</code>，这两个变量会在拼接操作中为两个数留出对应的位置，方便我们的拼接操作，避免了转换成字符串后再进行拼接。</p>
<h2 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a><a class="link" href="https://leetcode-cn.com/problems/valid-sudoku/">36. 有效的数独<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>请你判断一个 <code>9 x 9</code> 的数独是否有效。只需要 <strong>根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p>
<ol>
<li> 数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li> 数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）<br>注意：<br>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>空白格用 <code>&#39;.&#39;</code> 表示。</li>
</ol>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure>
<p> <img lazyload src="/images/loading.svg" data-src="shudu.png" alt="avatar"><br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入：board &#x3D; </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：board &#x3D; </span><br><span class="line">[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">输出：false</span><br><span class="line">解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">board.length &#x3D;&#x3D; 9</span><br><span class="line">board[i].length &#x3D;&#x3D; 9</span><br><span class="line">board[i][j] 是一位数字（1-9）或者 &#39;.&#39;</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p> (1). 先判断行上是否符合标准；<br> (2). 再判断列上是否符合标准；<br> (3). 最后传递每个九宫格的左上角坐标来判断每个九宫格是否符合标准。</p>
<h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidSudoku</span><span class="params">(board [][]<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> checkRow <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">	checkRow = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		check := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">		row := board[index]</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(row); i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> row[i] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> check[<span class="keyword">int</span>(row[i])-<span class="string">&#x27;0&#x27;</span>] == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					check[<span class="keyword">int</span>(row[i])-<span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> checkColumn <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">	checkColumn = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		check := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> board[i][index] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> check[<span class="keyword">int</span>(board[i][index])-<span class="string">&#x27;0&#x27;</span>] == <span class="number">1</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					check[<span class="keyword">int</span>(board[i][index])-<span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> checkGrid <span class="function"><span class="keyword">func</span><span class="params">(r,c <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">	checkGrid = <span class="function"><span class="keyword">func</span><span class="params">(r,c <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		check := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">		<span class="keyword">for</span> i:=r; i&lt;r+<span class="number">3</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">for</span> j:=c; j&lt;c+<span class="number">3</span>; j++ &#123;</span><br><span class="line">				<span class="keyword">if</span> board[i][j] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> check[<span class="keyword">int</span>(board[i][j])-<span class="string">&#x27;0&#x27;</span>] == <span class="number">1</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						check[<span class="keyword">int</span>(board[i][j])-<span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> !checkRow(i) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !checkColumn(i) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=<span class="number">6</span>; i=i+<span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;=<span class="number">6</span>; j=j+<span class="number">3</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> !checkGrid(i,j) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a class="link" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">2 &lt;&#x3D; nums.length &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先我们要明确一点：相同的数字异或等于 0，并且异或操作具备交换性。所以整个数组的异或结果等于两个只出现一次的数的异或；<br>(2). 两个数的异或结果在某一个二进制位上是 $1$，说明这两个数在该位上不同，那么我们可以利用这一性质，将数组中所有的数字根据该二进制位上是 $1$  或 $0$ 分类为两组；<br>(3). 组内的元素再自行进行异或，那么最终两组的结果就是两个只出现过一次的数。</p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N).</p>
<h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumbers</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nums</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	x := nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		x ^= nums[i]</span><br><span class="line">	&#125;</span><br><span class="line">	c := x&amp;(-x)</span><br><span class="line">	</span><br><span class="line">	a, b := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		x = nums[i]</span><br><span class="line">		<span class="keyword">if</span> x&amp;c == c &#123;</span><br><span class="line">			a ^= nums[i]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			b ^= nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> []<span class="keyword">int</span>&#123;a,b&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码细节-1"><a href="#代码细节-1" class="headerlink" title="代码细节"></a>代码细节</h3><p>&emsp;&amp;emsp在找第一个不同的二进制位的操作中，我们使用了 <code>x&amp;(-x)</code> 的形式。首先明确一下，计算一个正数的相反数等于将其二进制表示全部<strong>取反再加 1</strong>，例如 $12 = 01100$，那么 $-12 = 10100$，再进行 <code>&amp;</code> 运算可得 $12 &amp; -12 = 00100$，这样就将最低位为 $1$ 的二进制数表示了出来。之后只要将数组中所有的数与该数进行 <code>&amp;</code> 操作就能完成分类。</p>
<h2 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a class="link" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：nums &#x3D; [3,4,3,3]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：nums &#x3D; [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; nums[i] &lt; 2^31</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 因为约定了除了一个数字外，别的数字都会出现 3 次，那么也就意味着每一个数的二进制位会出现 3 的倍数；<br>(2). 当某一个二进制位上不是 3 的倍数，那么也就意味着是那个只出现了一次的数字肯定占据了一次该二进制位；<br>(3). 利用 (2) 中找到的二进制位组成这个数。</p>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N).</p>
<h3 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	bitCount := [<span class="number">32</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		x := nums[i]</span><br><span class="line">		j := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> x != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> x ^ (x<span class="number">-1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">				bitCount[j]++</span><br><span class="line">			&#125;</span><br><span class="line">			j++</span><br><span class="line">			x &gt;&gt;= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(bitCount); i++ &#123;</span><br><span class="line">		x := bitCount[i]%<span class="number">3</span></span><br><span class="line">		ret += x*<span class="keyword">int</span>(math.Pow(<span class="number">2</span>,<span class="keyword">float64</span>(i)))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码细节-2"><a href="#代码细节-2" class="headerlink" title="代码细节"></a>代码细节</h3><p>&emsp;&emsp;根据本题的特性，我们很容易就能推广，对于某个数组，除了一个数只出现一次外，其余的数都出现了 $m$ 次，那么利用这种特性，我们也能很轻易地找到这个只出现了一次的数。</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>早起刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>早起刷题（Day 2）</title>
    <url>/2022/03/31/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%202%EF%BC%89/</url>
    <content><![CDATA[<h2 id="LeetCode63-不同路径-II"><a href="#LeetCode63-不同路径-II" class="headerlink" title="LeetCode63. 不同路径 II"></a><a class="link" href="https://leetcode-cn.com/problems/unique-paths-ii/">LeetCode63. 不同路径 II<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure>
<p><img lazyload src="/images/loading.svg" data-src="robot1.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br><span class="line"></span><br><span class="line">示例 2:</span><br></pre></td></tr></table></figure>
<p><img lazyload src="/images/loading.svg" data-src="robot2.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：obstacleGrid &#x3D; [[0,1],[0,0]]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">m &#x3D;&#x3D; obstacleGrid.length</span><br><span class="line">n &#x3D;&#x3D; obstacleGrid[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 100</span><br><span class="line">obstacleGrid[i][j] 为 0 或 1</span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 采用二维递归的思路，本题是<a class="link" href="https://leetcode-cn.com/problems/unique-paths/">LeetCode62. 不同路径<i class="fas fa-external-link-alt"></i></a>的变种，实际上是一道题；<br>(2). 在处理初始条件（第一行和第一列）遇到障碍物时，障碍物所在的格子即之后的格子都属于不可到达的坐标，退出循环；<br>(3). 在递归过程中，如果遇到障碍物，直接判断为不可到达 <code>dp[i][j]=0</code>，否则当前格子的路径数等于上面、左面的路径数之和。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O($N^2$).</p>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m, n := <span class="built_in">len</span>(obstacleGrid), <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, m)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;m; i++ &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;m; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span> &#123;</span><br><span class="line">			dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;n; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] != <span class="number">1</span> &#123;</span><br><span class="line">			dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;m; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;n; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">				dp[i][j] = <span class="number">0</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="498-对角线遍历"><a href="#498-对角线遍历" class="headerlink" title="498. 对角线遍历"></a><a class="link" href="https://leetcode-cn.com/problems/diagonal-traverse/">498. 对角线遍历<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给你一个大小为 <code>m x n</code> 的矩阵 <code>mat</code> ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure>
<p><img lazyload src="/images/loading.svg" data-src="diag1-grid.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,4,7,5,3,6,8,9]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：mat &#x3D; [[1,2],[3,4]]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 本题要处理的细节比较多。首先解决边界问题，当 <code>mat</code> 只有一行或一列的时候，直接输出这一行或一列；<br>(2). 要关注三个和转向有关的情况：<code>direction</code> 用于描述当前前进的方向，向右上是为 <code>true</code>，向左下时为 <code>false</code>；<code>rowHalf</code> 用于描述在右上方向前进到顶格时，接下来是要向右还是向下移动一格；<code>columnHalf</code> 用于描述在左下方向前进到顶格时接下来是要向下还是向右前进一格。实际上就是判断有没有分别在行和列上走过 <code>mat</code> 的一半位置。<br>(3). 可以观察到，当前位置的坐标和 <code>i+j</code> 在大于等于行号或列号的时候，走到顶格后转向的方向需要发生改变。</p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O($M*N$)</p>
<h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDiagonalOrder</span><span class="params">(mat [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	m, n := <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> m == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> mat[<span class="number">0</span>]</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;m; i++ &#123;</span><br><span class="line">			ret = <span class="built_in">append</span>(ret, mat[i][<span class="number">0</span>])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	direction := <span class="literal">true</span></span><br><span class="line">	rowHalf := <span class="literal">true</span></span><br><span class="line">	columnHalf := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i&lt;m &amp;&amp; j&lt;n &#123;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, mat[i][j])</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; direction &amp;&amp; rowHalf) || (j == n<span class="number">-1</span> &amp;&amp; direction &amp;&amp; !rowHalf) &#123;</span><br><span class="line">			<span class="keyword">if</span> rowHalf &#123;</span><br><span class="line">				<span class="keyword">if</span> j &lt; n<span class="number">-1</span> &#123;</span><br><span class="line">					j++</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					i++</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				i++</span><br><span class="line">			&#125;</span><br><span class="line">			direction = <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; !direction) || (i == m<span class="number">-1</span> &amp;&amp; !direction &amp;&amp; !columnHalf) &#123;</span><br><span class="line">			<span class="keyword">if</span> columnHalf &#123;</span><br><span class="line">				<span class="keyword">if</span> i &lt; m<span class="number">-1</span> &#123;</span><br><span class="line">					i++</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					j++</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				j++</span><br><span class="line">			&#125;</span><br><span class="line">			direction = <span class="literal">true</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> direction &#123;</span><br><span class="line">			i--</span><br><span class="line">			j++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			i++</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> i+j &gt;= m<span class="number">-1</span> &#123;</span><br><span class="line">			columnHalf = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i+j &gt;= n<span class="number">-1</span> &#123;</span><br><span class="line">			rowHalf = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a class="link" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给定一个已排序的链表的头 <code>head</code> ， 删除所有重复的元素，使每个元素只出现一次。返回已排序的链表 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：head &#x3D; [1,1,2]</span><br><span class="line">输出：[1,2]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：head &#x3D; [1,1,2,3,3]</span><br><span class="line">输出：[1,2,3]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">链表中节点数目在范围 [0, 300] 内</span><br><span class="line">100 &lt;&#x3D; Node.val &lt;&#x3D; 100</span><br><span class="line">题目数据保证链表已经按升序排列</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 要删除重复的节点，那么就要实时维护三个位置的节点 <code>pre</code>、<code>cur</code>、<code>next</code>，假设要删除 <code>cur</code>，那么删除之后还要将 <code>cur</code> 重新指向 <code>next</code>；<br>(2). 如果 <code>pre</code> 和 <code>cur</code> 的值不相等，那么同时向后移动一位。</p>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N).</p>
<h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 	Val int</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 	Next *ListNode</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> head</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pre, cur := head, head.Next</span><br><span class="line">	<span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := cur.Next</span><br><span class="line">		<span class="keyword">if</span> cur.Val == pre.Val &#123;</span><br><span class="line">			pre.Next = next</span><br><span class="line">			cur = next</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pre = cur</span><br><span class="line">			cur = next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>早起刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>早起刷题（Day 3）</title>
    <url>/2022/04/01/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%203%EF%BC%89/</url>
    <content><![CDATA[<h2 id="269-火星词典"><a href="#269-火星词典" class="headerlink" title="269. 火星词典"></a><a class="link" href="https://leetcode-cn.com/problems/alien-dictionary/">269. 火星词典<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>现有一种使用英语字母的火星语言，这门语言的字母顺序与英语顺序不同。给你一个字符串列表 words ，作为这门语言的词典，words 中的字符串已经 按这门新语言的字母顺序进行了排序 。请你根据该词典还原出此语言中已知的字母顺序，并 按字母递增顺序 排列。若不存在合法字母顺序，返回 “” 。若存在多种可能的合法字母顺序，返回其中 任意一种 顺序即可。<br>字符串 s 字典顺序小于 字符串 t 有两种情况：<br>1.在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t 中字母之前，那么 s 的字典顺序小于 t 。<br>2.如果前面 min(s.length, t.length) 字母都相同，那么 s.length &lt; t.length 时，s 的字典顺序也小于 t 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：words &#x3D; [&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]</span><br><span class="line">输出：&quot;wertf&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：words &#x3D; [&quot;z&quot;,&quot;x&quot;]</span><br><span class="line">输出：&quot;zx&quot;</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入：words &#x3D; [&quot;z&quot;,&quot;x&quot;,&quot;z&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：不存在合法字母顺序，因此返回 &quot;&quot; 。</span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先考虑什么情况下会出现不合法的情况：如果在之前判断字母 ‘x’ 的字典序应该大于 ‘y’，可是在后面又出现了 ‘y’ 的字典序应该大于 ‘x’ 的情况，那么此时就出现了矛盾，因此是不合法的；<br>(2). 对于这种只允许单向依赖的情况，考虑使用拓扑排序。首先就要构建邻接表和入度统计。在建立邻接表的时候要考虑一种情况，那就是如果出现在后面的字符串是前面字符串的前缀字符串，那么可以立即判定是不合法的；<br>(3). 在构建好两个数据结构后，使用广度优先搜索查找。将入度为 0 的字母放入队列中，然后再将其对应的邻接表中的字母入度减一，此时相当于在拓扑排序中消除了对该字母的依赖，也可以看作访问数 <code>visited</code> 加 1；<br>(4). 最后判断一下 <code>visited</code> 是否是全体出现过的字母数，相等则说明是一个拓扑排序，不存在循环依赖。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(words.length*words[i].length)</p>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alienOrder</span><span class="params">(words []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	adjacency := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>][]<span class="keyword">byte</span>) <span class="comment">// 邻接表</span></span><br><span class="line">	inDegree := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)	<span class="comment">// 入度统计</span></span><br><span class="line">	ret := <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> buildGraph <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">	buildGraph = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(words); i++ &#123;</span><br><span class="line">			<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(words[i]); j++ &#123;</span><br><span class="line">				adjacency[words[i][j]] = []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(words); i++ &#123;</span><br><span class="line">			w1, w2 := words[i<span class="number">-1</span>], words[i]</span><br><span class="line">			j := <span class="number">0</span></span><br><span class="line">			minLength := min(<span class="built_in">len</span>(w1),<span class="built_in">len</span>(w2))</span><br><span class="line">			<span class="keyword">for</span> ; j&lt;minLength; j++ &#123;</span><br><span class="line">				<span class="keyword">if</span> w1[j] != w2[j] &#123;</span><br><span class="line">					adjacency[w1[j]] = <span class="built_in">append</span>(adjacency[w1[j]], w2[j])</span><br><span class="line">					inDegree[w2[j]]++</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> j == minLength &amp;&amp; <span class="built_in">len</span>(w1) &gt; <span class="built_in">len</span>(w2) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> visitedCount <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line">	visitedCount = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		visited := <span class="number">0</span></span><br><span class="line">		q := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> k,_ := <span class="keyword">range</span> adjacency &#123;</span><br><span class="line">			<span class="keyword">if</span> inDegree[k] == <span class="number">0</span> &#123;</span><br><span class="line">				q = <span class="built_in">append</span>(q, k)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			p := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">				w := q[i]</span><br><span class="line">				<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(adjacency[w]); j++ &#123;</span><br><span class="line">					x := adjacency[w][j]</span><br><span class="line">					inDegree[x]--</span><br><span class="line">					<span class="keyword">if</span> inDegree[x] == <span class="number">0</span> &#123;</span><br><span class="line">						p = <span class="built_in">append</span>(p, x)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				visited++</span><br><span class="line">			&#125;</span><br><span class="line">			ret += <span class="keyword">string</span>(q)</span><br><span class="line">			q = p</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> visited</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !buildGraph() || visitedCount() != <span class="built_in">len</span>(adjacency) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a class="link" href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。<br>函数 myAtoi(string s) 的算法如下：<br>1.读入字符串并丢弃无用的前导空格<br>2.检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br>3.读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>4.将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。<br>5.如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。<br>6.返回整数作为最终结果。</p>
</blockquote>
<blockquote>
<p>注意：<br>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：s &#x3D; &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 42 。</span><br><span class="line">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：s &#x3D; &quot;   -42&quot;</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 2 步：&quot;   -42&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入：s &#x3D; &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 4193 。</span><br><span class="line">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; s.length &lt;&#x3D; 200</span><br><span class="line">s 由英文字母（大写和小写）、数字（0-9）、&#39; &#39;、&#39;+&#39;、&#39;-&#39; 和 &#39;.&#39; 组成</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 这是一道很典型的模拟题，对于模拟题，少不了条件判断，建议采用 switch 来代替大量的 if…else，这样代码的逻辑会清晰很多；<br>(2). 这道题唯一值得关心的点就是越界问题，那么就需要将合法数字字符串取出后先去除前导零，然后再根据符号分别判断是否越界。</p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p>
<h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAtoi</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	isNeg := <span class="literal">false</span></span><br><span class="line">	prefixLetter := <span class="literal">true</span></span><br><span class="line">	str := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">	maxNum, minNum := math.MaxInt32, <span class="number">-1</span>*math.MinInt32</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> prefixLetter &#123;</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> s[i] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">					isNeg = <span class="literal">true</span></span><br><span class="line">					prefixLetter = <span class="literal">false</span></span><br><span class="line">				<span class="keyword">case</span> s[i] == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">					prefixLetter = <span class="literal">false</span></span><br><span class="line">				<span class="keyword">case</span> s[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">				<span class="keyword">case</span> s[i] == <span class="string">&#x27;.&#x27;</span> || (s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>):</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">				<span class="keyword">case</span> s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">					prefixLetter = <span class="literal">false</span></span><br><span class="line">					str = <span class="built_in">append</span>(str, s[i])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">					str = <span class="built_in">append</span>(str, s[i])</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					i = <span class="built_in">len</span>(s)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(str) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	x := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> str[i] != <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">			x = i</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret := <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> !isNeg &#123;</span><br><span class="line">		<span class="keyword">for</span> i:=x; i&lt;<span class="built_in">len</span>(str) ;i++ &#123;</span><br><span class="line">			ret *= <span class="number">10</span></span><br><span class="line">			ret += <span class="keyword">int</span>(str[i])-<span class="string">&#x27;0&#x27;</span></span><br><span class="line">			<span class="keyword">if</span> ret &gt; maxNum &#123;</span><br><span class="line">				<span class="keyword">return</span> maxNum</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i:=x; i&lt;<span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">			ret *= <span class="number">10</span></span><br><span class="line">			ret += <span class="keyword">int</span>(str[i])-<span class="string">&#x27;0&#x27;</span></span><br><span class="line">			<span class="keyword">if</span> ret &gt; minNum &#123;</span><br><span class="line">				<span class="keyword">return</span> math.MinInt32</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ret *= <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>早起刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>早起刷题（Day 4）</title>
    <url>/2022/04/02/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%204%EF%BC%89/</url>
    <content><![CDATA[<h2 id="LeetCode856-括号的分数"><a href="#LeetCode856-括号的分数" class="headerlink" title="LeetCode856. 括号的分数"></a><a class="link" href="https://leetcode-cn.com/problems/score-of-parentheses/">LeetCode856. 括号的分数<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：<br>() 得 1 分。<br>AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。<br>(A) 得 2 * A 分，其中 A 是平衡括号字符串。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入：&quot;()&quot;</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：&quot;(())&quot;</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：&quot;()()&quot;</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：&quot;(()(()))&quot;</span><br><span class="line">输出：6</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1. S 是平衡括号字符串，且只含有 ( 和 ) 。</span><br><span class="line">2. 2 &lt;&#x3D; S.length &lt;&#x3D; 50</span><br></pre></td></tr></table></figure>
<p> </p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p> (1). 考虑采用递归 + 栈来解题。括号问题首先天然就会想到使用栈，由于本题不需要考虑括号字符串的合法性，所以栈可以当作一个状态的保存，在栈内部进行递归；<br> (2). 对于嵌套的括号，采用递归的策略，出递归前将递归栈中分数*2 即可；<br> (3). 注意遍历字符串要使用指针以及出递归的条件。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p> O(N).</p>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scoreOfParentheses</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> scoreCount <span class="function"><span class="keyword">func</span><span class="params">(start *<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">	scoreCount = <span class="function"><span class="keyword">func</span><span class="params">(start *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		ss := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">		sc := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> ; *start&lt;<span class="built_in">len</span>(s); (*start)++ &#123;</span><br><span class="line">			i := *start</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(ss) == <span class="number">0</span> &amp;&amp; s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">				ss = <span class="built_in">append</span>(ss, <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; <span class="built_in">len</span>(ss) == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; ss[<span class="built_in">len</span>(ss)<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">				sc++</span><br><span class="line">				ss = ss[:<span class="built_in">len</span>(ss)<span class="number">-1</span>]</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &amp;&amp; <span class="built_in">len</span>(ss) != <span class="number">0</span> &#123;</span><br><span class="line">				sc += <span class="number">2</span>*scoreCount(start)</span><br><span class="line">				ss = ss[:<span class="built_in">len</span>(ss)<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sc</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	score := <span class="number">0</span></span><br><span class="line">	stack := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">			stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">			score++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			score += <span class="number">2</span>*scoreCount(&amp;i)</span><br><span class="line">			stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> score</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a class="link" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：lists &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：lists &#x3D; [[]]</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">k &#x3D;&#x3D; lists.length</span><br><span class="line">0 &lt;&#x3D; k &lt;&#x3D; 10^4</span><br><span class="line">0 &lt;&#x3D; lists[i].length &lt;&#x3D; 500</span><br><span class="line">-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4</span><br><span class="line">lists[i] 按 升序 排列</span><br><span class="line">lists[i].length 的总和不超过 10^4</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>优先队列，直接看代码吧</p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(Nlog(N))，取决于堆排序的时间复杂度</p>
<h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 	Val int</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 	Next *ListNode</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a[h[i]]&lt;a[h[j]]</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	old := *h</span><br><span class="line">	n := <span class="built_in">len</span>(*h)</span><br><span class="line">	x := old[n<span class="number">-1</span>]</span><br><span class="line">	*h = old[:n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">	l := <span class="built_in">len</span>(lists)</span><br><span class="line">	<span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> h IntHeap</span><br><span class="line">	a = <span class="built_in">make</span>([]<span class="keyword">int</span>, l)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;l; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> lists[i] == <span class="literal">nil</span> &#123;</span><br><span class="line">			a[i] = <span class="number">-1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			a[i] = lists[i].Val</span><br><span class="line">			heap.Push(&amp;h, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(h) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	first := heap.Pop(&amp;h).(<span class="keyword">int</span>)</span><br><span class="line">	head := lists[first]</span><br><span class="line">	a[first] = math.MaxInt32</span><br><span class="line">	p := head</span><br><span class="line">	lists[first] = head.Next</span><br><span class="line">	p.Next = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> lists[first] != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 下面两行注意顺序不能反了，先更改 a，才能排序</span></span><br><span class="line">		a[first] = lists[first].Val</span><br><span class="line">		heap.Push(&amp;h, first)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(h) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		i := heap.Pop(&amp;h).(<span class="keyword">int</span>)</span><br><span class="line">		a[i] = math.MaxInt32</span><br><span class="line">		p.Next = lists[i]</span><br><span class="line">		p = p.Next</span><br><span class="line">		lists[i] = lists[i].Next</span><br><span class="line">		<span class="keyword">if</span> lists[i] != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 下面两行注意顺序不能反了，先更改 a，才能排序</span></span><br><span class="line">			a[i] = lists[i].Val</span><br><span class="line">			heap.Push(&amp;h, i)</span><br><span class="line">		&#125;</span><br><span class="line">		p.Next = <span class="literal">nil</span></span><br><span class="line">		<span class="comment">// fmt.Println(a,h,x,i)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>早起刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>早起刷题（Day 5）</title>
    <url>/2022/04/03/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%205%EF%BC%89/</url>
    <content><![CDATA[<p>今天早上复盘一下昨天晚上的双周赛</p>
<h2 id="LeetCode6033-转换数字的最少位翻转次数"><a href="#LeetCode6033-转换数字的最少位翻转次数" class="headerlink" title="LeetCode6033. 转换数字的最少位翻转次数"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-bit-flips-to-convert-number/">LeetCode6033. 转换数字的最少位翻转次数<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>一次 位翻转 定义为将数字 x 二进制中的一个位进行 翻转 操作，即将 0 变成 1 ，或者将 1 变成 0 。<br>比方说，x = 7 ，二进制表示为 111 ，我们可以选择任意一个位（包含没有显示的前导 0 ）并进行翻转。比方说我们可以翻转最右边一位得到 110 ，或者翻转右边起第二位得到 101 ，或者翻转右边起第五位（这一位是前导 0 ）得到 10111 等等。<br>给你两个整数 start 和 goal ，请你返回将 start 转变成 goal 的 最少位翻转 次数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：start &#x3D; 10, goal &#x3D; 7</span><br><span class="line">输出：3</span><br><span class="line">解释：10 和 7 的二进制表示分别为 1010 和 0111 。我们可以通过 3 步将 10 转变成 7 ：</span><br><span class="line">- 翻转右边起第一位得到：1010 -&gt; 1011 。</span><br><span class="line">- 翻转右边起第三位：1011 -&gt; 1111 。</span><br><span class="line">- 翻转右边起第四位：1111 -&gt; 0111 。</span><br><span class="line">我们无法在 3 步内将 10 转变成 7 。所以我们返回 3 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：start &#x3D; 3, goal &#x3D; 4</span><br><span class="line">输出：3</span><br><span class="line">解释：3 和 4 的二进制表示分别为 011 和 100 。我们可以通过 3 步将 3 转变成 4 ：</span><br><span class="line">- 翻转右边起第一位：011 -&gt; 010 。</span><br><span class="line">- 翻转右边起第二位：010 -&gt; 000 。</span><br><span class="line">- 翻转右边起第三位：000 -&gt; 100 。</span><br><span class="line">我们无法在 3 步内将 3 变成 4 。所以我们返回 3 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; start, goal &lt;&#x3D; 109</span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 本质上是判断两个数有多少个比特位值是不一样的（包含前导零）；<br>(2). 那就从最后一个比特位开始往前比较就好了。</p>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minBitFlips</span><span class="params">(start <span class="keyword">int</span>, goal <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> judgeLastBit <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">	judgeLastBit = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> x == <span class="number">0</span> || x^(x<span class="number">-1</span>) != <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> start &gt; <span class="number">0</span> || goal &gt; <span class="number">0</span> &#123;</span><br><span class="line">		x1 := judgeLastBit(start)</span><br><span class="line">		x2 := judgeLastBit(goal)</span><br><span class="line">		<span class="keyword">if</span> (x1 &amp;&amp; !x2) || (!x1 &amp;&amp; x2) &#123;</span><br><span class="line">			count++</span><br><span class="line">		&#125;</span><br><span class="line">		start &gt;&gt;= <span class="number">1</span></span><br><span class="line">		goal &gt;&gt;= <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="LeetCode6034-数组的三角和"><a href="#LeetCode6034-数组的三角和" class="headerlink" title="LeetCode6034. 数组的三角和"></a><a class="link" href="https://leetcode-cn.com/problems/find-triangular-sum-of-an-array/">LeetCode6034. 数组的三角和<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给你一个下标从 0 开始的整数数组 nums ，其中 nums[i] 是 0 到 9 之间（两者都包含）的一个数字。<br>nums 的 三角和 是执行以下操作以后最后剩下元素的值：<br>1.nums 初始包含 n 个元素。如果 n == 1 ，终止 操作。否则，创建 一个新的下标从 0 开始的长度为 n - 1 的整数数组 newNums 。<br>2.对于满足 0 &lt;= i &lt; n - 1 的下标 i ，newNums[i] 赋值 为 (nums[i] + nums[i+1]) % 10 ，% 表示取余运算。<br>3.将 newNums 替换 数组 nums 。<br>4.从步骤 1 开始 重复 整个过程。<br>5.请你返回 nums 的三角和。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br></pre></td></tr></table></figure>
<p><img lazyload src="/images/loading.svg" data-src="ex1drawio.png" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：8</span><br><span class="line">解释：</span><br><span class="line">上图展示了得到数组三角和的过程。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [5]</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">由于 nums 中只有一个元素，数组的三角和为这个元素自己。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; nums[i] &lt;&#x3D; 9</span><br></pre></td></tr></table></figure>


<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 太简单了。。没啥好说的</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p>
<h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">triangularSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(nums) &gt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">			nums[i] += nums[i+<span class="number">1</span>]</span><br><span class="line">			nums[i] %= <span class="number">10</span></span><br><span class="line">		&#125;</span><br><span class="line">		nums = nums[:<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="LeetCode6035-选择建筑的方案数"><a href="#LeetCode6035-选择建筑的方案数" class="headerlink" title="LeetCode6035. 选择建筑的方案数"></a><a class="link" href="https://leetcode-cn.com/problems/number-of-ways-to-select-buildings/">LeetCode6035. 选择建筑的方案数<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给你一个下标从 0 开始的二进制字符串 s ，它表示一条街沿途的建筑类型，其中：<br>s[i] = ‘0’ 表示第 i 栋建筑是一栋办公楼，<br>s[i] = ‘1’ 表示第 i 栋建筑是一间餐厅。<br>作为市政厅的官员，你需要随机 选择 3 栋建筑。然而，为了确保多样性，选出来的 3 栋建筑 相邻 的两栋不能是同一类型。<br>比方说，给你 s = “001101” ，我们不能选择第 1 ，3 和 5 栋建筑，因为得到的子序列是 “011” ，有相邻两栋建筑是同一类型，所以 不合 题意。<br>请你返回可以选择 3 栋建筑的 有效方案数 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;001101&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">以下下标集合是合法的：</span><br><span class="line">- [0,2,4] ，从 &quot;001101&quot; 得到 &quot;010&quot;</span><br><span class="line">- [0,3,4] ，从 &quot;001101&quot; 得到 &quot;010&quot;</span><br><span class="line">- [1,2,4] ，从 &quot;001101&quot; 得到 &quot;010&quot;</span><br><span class="line">- [1,3,4] ，从 &quot;001101&quot; 得到 &quot;010&quot;</span><br><span class="line">- [2,4,5] ，从 &quot;001101&quot; 得到 &quot;101&quot;</span><br><span class="line">- [3,4,5] ，从 &quot;001101&quot; 得到 &quot;101&quot;</span><br><span class="line">没有别的合法选择，所以总共有 6 种方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;11100&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：没有任何符合题意的选择。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">3 &lt;&#x3D; s.length &lt;&#x3D; 105</span><br><span class="line">s[i] 要么是 &#39;0&#39; ，要么是 &#39;1&#39; 。</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法一：暴力递归搜索（超时）<br>(1). 类似组合数这种类型的题目，不过要判断一下是否符合最终合法的约定；<br>(2). 当字符串剩下的长度不足以满足要求，剪枝。（实际上这个优化并没什么用，因为剪枝的长度最大也就 3，根本不影响最终的复杂度）</p>
<p>方法二：统计前缀数量（O(N)）<br>分别定义 5 个变量，<code>n1</code> 代表前缀为 1 的子序列数量，<code>n0</code> 代表前缀为 0 的子序列数量，<code>n01</code> 代表前缀为 01 的子序列数量,<code>n10</code> 代表前缀为 10 的子序列数量，<code>count</code>则是统计合法的子序列数量（<code>010</code> + <code>101</code>）</p>
<h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><p>方法一：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfWays</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> count <span class="keyword">int64</span></span><br><span class="line">	path := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> backTracking <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span>, rest <span class="keyword">int</span>)</span></span></span><br><span class="line">	backTracking = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span> ,rest <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> rest == <span class="number">0</span> &#123;</span><br><span class="line">			count++</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i:=start; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> rest &gt; <span class="built_in">len</span>(s[start:]) &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="number">0</span> &#123;</span><br><span class="line">				path = <span class="built_in">append</span>(path, s[i])</span><br><span class="line">				backTracking(i+<span class="number">1</span>, rest<span class="number">-1</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i] != path[<span class="built_in">len</span>(path)<span class="number">-1</span>] &#123;</span><br><span class="line">				path = <span class="built_in">append</span>(path, s[i])</span><br><span class="line">				backTracking(i+<span class="number">1</span>, rest<span class="number">-1</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	backTracking(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfWays</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> count <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">var</span> n0, n1, n01, n10 <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> s[i] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">			n01 += n0</span><br><span class="line">			n1++</span><br><span class="line">			count += n10</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			n10 += n1</span><br><span class="line">			n0++</span><br><span class="line">			count += n01</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>早起刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>早起刷题（Day 6）</title>
    <url>/2022/04/04/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%206%EF%BC%89/</url>
    <content><![CDATA[<p>本文是对第 287 场周赛的复盘总结</p>
<h2 id="6055-转化时间需要的最少操作数"><a href="#6055-转化时间需要的最少操作数" class="headerlink" title="6055. 转化时间需要的最少操作数"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-convert-time/">6055. 转化时间需要的最少操作数<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给你两个字符串 current 和 correct ，表示两个 24 小时制时间 。<br>24 小时制时间 按 “HH:MM” 进行格式化，其中 HH 在 00 和 23 之间，而 MM 在 00 和 59 之间。最早的 24 小时制时间为 00:00 ，最晚的是 23:59 。<br>在一步操作中，你可以将 current 这个时间增加 1、5、15 或 60 分钟。你可以执行这一操作 任意 次数。<br>返回将 current 转化为 correct 需要的 最少操作数 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：current &#x3D; &quot;02:30&quot;, correct &#x3D; &quot;04:35&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">可以按下述 3 步操作将 current 转换为 correct ：</span><br><span class="line">- 为 current 加 60 分钟，current 变为 &quot;03:30&quot; 。</span><br><span class="line">- 为 current 加 60 分钟，current 变为 &quot;04:30&quot; 。 </span><br><span class="line">- 为 current 加 5 分钟，current 变为 &quot;04:35&quot; 。</span><br><span class="line">可以证明，无法用少于 3 步操作将 current 转化为 correct 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：current &#x3D; &quot;11:00&quot;, correct &#x3D; &quot;11:01&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：只需要为 current 加一分钟，所以最小操作数是 1 。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">current 和 correct 都符合 &quot;HH:MM&quot; 格式</span><br><span class="line">current &lt;&#x3D; correct</span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 本题其实是变种的零钱问题。初始状态是 <code>current</code>，最终状态是 <code>correct</code>，可用“零钱”面额有 <code>[1,5,15,60]</code>；<br>(2). 现将初始、最终两种状态转换成和“零钱”面额一样的计数单位——“分钟”；<br>(3). 使用动态规划，从初始状态一步步向最终状态逼近。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N).</p>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertTime</span><span class="params">(current <span class="keyword">string</span>, correct <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	s1 := strings.Split(current, <span class="string">&quot;:&quot;</span>)</span><br><span class="line">	h1, m1 := s1[<span class="number">0</span>], s1[<span class="number">1</span>]</span><br><span class="line">	s2 := strings.Split(correct, <span class="string">&quot;:&quot;</span>)</span><br><span class="line">	h2, m2 := s2[<span class="number">0</span>], s2[<span class="number">1</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用分钟代表初始状态</span></span><br><span class="line">	nowh, _ := strconv.Atoi(h1)</span><br><span class="line">	nowm, _ := strconv.Atoi(m1)</span><br><span class="line">	now := nowh*<span class="number">60</span>+nowm</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用分钟代表最终状态</span></span><br><span class="line">	th, _ := strconv.Atoi(h2)</span><br><span class="line">	tm, _ := strconv.Atoi(m2)</span><br><span class="line">	t := th*<span class="number">60</span>+tm</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将状态归一化到 (0,diff) 区间</span></span><br><span class="line">	diff := abs(now, t)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 可用零钱面额</span></span><br><span class="line">	choose := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">60</span>&#125;</span><br><span class="line">	</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, diff+<span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=diff; i++ &#123;</span><br><span class="line">		dp[i] = math.MaxInt32</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="built_in">len</span>(choose)<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j-- &#123;</span><br><span class="line">			<span class="keyword">if</span> choose[j] &gt; i &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			dp[i] = min(dp[i], dp[i-choose[j]]+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> dp[diff]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a-b</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> b-a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5235-找出输掉零场或一场比赛的玩家"><a href="#5235-找出输掉零场或一场比赛的玩家" class="headerlink" title="5235. 找出输掉零场或一场比赛的玩家"></a><a class="link" href="https://leetcode-cn.com/problems/find-players-with-zero-or-one-losses/">5235. 找出输掉零场或一场比赛的玩家<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给你一个整数数组 matches 其中 matches[i] = [winneri, loseri] 表示在一场比赛中 winneri 击败了 loseri 。<br>返回一个长度为 2 的列表 answer ：<br>answer[0] 是所有 没有 输掉任何比赛的玩家列表。<br>answer[1] 是所有恰好输掉 一场 比赛的玩家列表。<br>两个列表中的值都应该按 递增 顺序返回。</p>
</blockquote>
<blockquote>
<p>注意：<br>只考虑那些参与 至少一场 比赛的玩家。<br>生成的测试用例保证 不存在 两场比赛结果 相同 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：matches &#x3D; [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]</span><br><span class="line">输出：[[1,2,10],[4,5,7,8]]</span><br><span class="line">解释：</span><br><span class="line">玩家 1、2 和 10 都没有输掉任何比赛。</span><br><span class="line">玩家 4、5、7 和 8 每个都输掉一场比赛。</span><br><span class="line">玩家 3、6 和 9 每个都输掉两场比赛。</span><br><span class="line">因此，answer[0] &#x3D; [1,2,10] 和 answer[1] &#x3D; [4,5,7,8] 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：matches &#x3D; [[2,3],[1,3],[5,4],[6,4]]</span><br><span class="line">输出：[[1,2,5,6],[]]</span><br><span class="line">解释：</span><br><span class="line">玩家 1、2、5 和 6 都没有输掉任何比赛。</span><br><span class="line">玩家 3 和 4 每个都输掉两场比赛。</span><br><span class="line">因此，answer[0] &#x3D; [1,2,5,6] 和 answer[1] &#x3D; [] 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; matches.length &lt;&#x3D; 105</span><br><span class="line">matches[i].length &#x3D;&#x3D; 2</span><br><span class="line">1 &lt;&#x3D; winneri, loseri &lt;&#x3D; 105</span><br><span class="line">winneri !&#x3D; loseri</span><br><span class="line">所有 matches[i] 互不相同</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 本题需要输出两个列表：其一是 <strong>入度</strong> 为 $0$ 且 <strong>出度</strong> 大于 $0$ 的编号，其二是 <strong>入度</strong> 恰好为 $1$ 的编号；<br>(2). 使用两个 <code>map</code> 分别保存每个编号的出度和入度；<br>(3). 首先遍历 <strong>入度</strong> <code>map</code>，只要发现其长度为 $1$，那就加入输出中；<br>(4). 然后遍历 <strong>出度</strong> <code>map</code>，检查对应编号的 <strong>入度</strong> 列表如果为 $0$，那么也加入输出中；<br>(5). 排序两个列表。</p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p>
<h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findWinners</span><span class="params">(matches [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>, <span class="number">0</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 遍历 matches，构建 出度 和 入度 map</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(matches); i++ &#123;</span><br><span class="line">		win, lose := matches[i][<span class="number">0</span>], matches[i][<span class="number">1</span>]</span><br><span class="line">		m1[lose] = <span class="built_in">append</span>(m1[lose], win)</span><br><span class="line">		m2[win] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">1</span> &#123;</span><br><span class="line">			ret[<span class="number">1</span>] = <span class="built_in">append</span>(ret[<span class="number">1</span>], k)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, _ := <span class="keyword">range</span> m2 &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(m1[k]) == <span class="number">0</span> &#123;</span><br><span class="line">			ret[<span class="number">0</span>] = <span class="built_in">append</span>(ret[<span class="number">0</span>], k)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sort.Ints(ret[<span class="number">0</span>])</span><br><span class="line">	sort.Ints(ret[<span class="number">1</span>])</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5219-每个小孩最多能分到多少糖果"><a href="#5219-每个小孩最多能分到多少糖果" class="headerlink" title="5219. 每个小孩最多能分到多少糖果"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-candies-allocated-to-k-children/">5219. 每个小孩最多能分到多少糖果<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给你一个 下标从 0 开始 的整数数组 candies 。数组中的每个元素表示大小为 candies[i] 的一堆糖果。你可以将每堆糖果分成任意数量的 子堆 ，但 无法 再将两堆合并到一起。<br>另给你一个整数 k 。你需要将这些糖果分配给 k 个小孩，使每个小孩分到 相同 数量的糖果。每个小孩可以拿走 至多一堆 糖果，有些糖果可能会不被分配。<br>返回每个小孩可以拿走的 最大糖果数目 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：candies &#x3D; [5,8,6], k &#x3D; 3</span><br><span class="line">输出：5</span><br><span class="line">解释：可以将 candies[1] 分成大小分别为 5 和 3 的两堆，然后把 candies[2] 分成大小分别为 5 和 1 的两堆。现在就有五堆大小分别为 5、5、3、5 和 1 的糖果。可以把 3 堆大小为 5 的糖果分给 3 个小孩。可以证明无法让每个小孩得到超过 5 颗糖果。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：candies &#x3D; [2,5], k &#x3D; 11</span><br><span class="line">输出：0</span><br><span class="line">解释：总共有 11 个小孩，但只有 7 颗糖果，但如果要分配糖果的话，必须保证每个小孩至少能得到 1 颗糖果。因此，最后每个小孩都没有得到糖果，答案是 0 。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; candies.length &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; candies[i] &lt;&#x3D; 10^7</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; 10^12</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先看一看数据量，明显暴力绝对会超时，那么别无选择，二分法搞起来；<br>(2). 首先判断一下边界情况，当 🍬总数 &lt; 🧒总数 时，显然大家都没得分，return 0；如果 🍬总数 == 🧒总数 ，return 1<br>(3) 二分查找的左边界是 $1$，右边界是 🍬总数/🧒总数 ；<br>(4) 要查找满足条件的右边界，二分超找模板套起来。</p>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(Nlog(N))</p>
<h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumCandies</span><span class="params">(candies []<span class="keyword">int</span>, k <span class="keyword">int64</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> total <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(candies); i++ &#123;</span><br><span class="line">		total += <span class="keyword">int64</span>(candies[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> total &lt; k &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> total == k &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> satisified <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">	satisified = <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> count <span class="keyword">int64</span></span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(candies); i++ &#123;</span><br><span class="line">			count += <span class="keyword">int64</span>(candies[i]/n)</span><br><span class="line">			<span class="keyword">if</span> count &gt;= k &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	l, r := <span class="number">1</span>, <span class="keyword">int</span>(total/k)</span><br><span class="line">	<span class="keyword">if</span> satisified(r) &#123;</span><br><span class="line">		<span class="keyword">return</span> r</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">		m := l+(r-l)&gt;&gt;<span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> satisified(m) &#123;</span><br><span class="line">			l = m+<span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> !satisified(m) &#123;</span><br><span class="line">			r = m</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> l<span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5302-加密解密字符串"><a href="#5302-加密解密字符串" class="headerlink" title="5302. 加密解密字符串"></a><a class="link" href="https://leetcode-cn.com/problems/encrypt-and-decrypt-strings/">5302. 加密解密字符串<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给你一个字符数组 keys ，由若干 互不相同 的字符组成。还有一个字符串数组 values ，内含若干长度为 2 的字符串。另给你一个字符串数组 dictionary ，包含解密后所有允许的原字符串。请你设计并实现一个支持加密及解密下标从 0 开始字符串的数据结构。<br>字符串 加密 按下述步骤进行：<br>1.对字符串中的每个字符 c ，先从 keys 中找出满足 keys[i] == c 的下标 i 。<br>2.在字符串中，用 values[i] 替换字符 c 。<br>字符串 解密 按下述步骤进行：<br>1.将字符串每相邻 2 个字符划分为一个子字符串，对于每个子字符串 s ，找出满足 values[i] == s 的一个下标 i 。如果存在多个有效的 i ，从中选择 任意 一个。这意味着一个字符串解密可能得到多个解密字符串。<br>2.在字符串中，用 keys[i] 替换 s 。<br>实现 Encrypter 类：<br>1.Encrypter(char[] keys, String[] values, String[] dictionary) 用 keys、values 和 dictionary 初始化 Encrypter 类。<br>2.String encrypt(String word1) 按上述加密过程完成对 word1 的加密，并返回加密后的字符串。<br>3.int decrypt(String word2) 统计并返回可以由 word2 解密得到且出现在 dictionary 中的字符串数目。</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 注意到 <code>values</code> 中有相同的字符串，因此不同的字符串加密后可能是一样的，从而一个字符串解密出的结果可能不是唯一的；<br>(2). 根据提示 1，直接解密较为复杂，不妨逆向思考，即加密 <code>dictionary</code> 中的每个字符串。用哈希表记录每个加密后的字符串的出现次数。这样每次调用 <code>decrypt</code> 时，返回哈希表中 <code>word2</code> 的出现次数即可。</p>
<h3 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Encrypter <span class="keyword">struct</span> &#123;</span><br><span class="line">	mp  [<span class="number">26</span>]<span class="keyword">string</span></span><br><span class="line">	cnt <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(keys []<span class="keyword">byte</span>, values, dictionary []<span class="keyword">string</span>)</span> <span class="title">Encrypter</span></span> &#123;</span><br><span class="line">	mp := [<span class="number">26</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		mp[key-<span class="string">&#x27;a&#x27;</span>] = values[i]</span><br><span class="line">	&#125;</span><br><span class="line">	e := Encrypter&#123;mp, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> dictionary &#123;</span><br><span class="line">		e.cnt[e.Encrypt(s)]++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Encrypter)</span> <span class="title">Encrypt</span><span class="params">(word1 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(word1)*<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> word1 &#123;</span><br><span class="line">		s := e.mp[ch-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">		<span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">		res = <span class="built_in">append</span>(res, s...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Encrypter)</span> <span class="title">Decrypt</span><span class="params">(word2 <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> e.cnt[word2] &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>早起刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.824 Lab 踩坑记录</title>
    <url>/2022/04/06/MIT6.824%20Lab%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h1><h2 id="go-plugin"><a href="#go-plugin" class="headerlink" title="go plugin"></a>go plugin</h2><h3 id="踩坑场景"><a href="#踩坑场景" class="headerlink" title="踩坑场景"></a>踩坑场景</h3><p>&emsp;&emsp;项目的初始化就是将 Map 和 Reduce 方法分别打包成插件的形式供 worker 端调用。这样设计的理由是测试用例中包含了不同的 Map 和 Reduce 方法，要通过所有的测试用例，使用插件的形式更加自由。<br>&emsp;&emsp;但是在启动项目的一开始就报错：<code>plugin was built with a different version of package runtime</code>。在网上查了很久，只能知道是作为 plugin 的插件文件和调用这个插件的文件编译环境不同导致的。但是问题是我都是在本地编译的，怎么还存在这个问题呢？</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>&emsp;&emsp;无他，重新装了 go 的环境。。。成功解决该问题。巨 tm 魔幻。<br>&emsp;&emsp;另外，<code>mr</code> 包下的任何改动都需要重新 <code>go build --plugin</code>，否则 worker 无法继续使用这个插件编译。</p>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>&emsp;&emsp;go plugin 目前还是一个不成熟的方案，受限因素太多，可能会出现各种莫名其妙的问题，建议之后自己的开发中还是避免是用 go plugin。</p>
<h2 id="for-select-中的break、continue、return"><a href="#for-select-中的break、continue、return" class="headerlink" title="for-select 中的break、continue、return"></a>for-select 中的break、continue、return</h2><h3 id="踩坑场景-1"><a href="#踩坑场景-1" class="headerlink" title="踩坑场景"></a>踩坑场景</h3><p>&emsp;&emsp;在 worker 内部实现 map task 的时候，写了一个外层的 for 函数，里面是一个 select，case 1 是当出现超时（10s），那么就直接返回 false，否则就是 default 执行操作；当读到文件末尾 <code>EOF</code>时，完成操作后需要 break 跳出 for 循环。此时就出现了问题：break只能跳出select，无法跳出for，导致出现死循环。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>方案一：标签<br>看如下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBreak</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	tick := time.Tick(time.Second)</span><br><span class="line"><span class="comment">//FOR是标签</span></span><br><span class="line">FOR:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> t := &lt;-tick:</span><br><span class="line">			fmt.Println(t)</span><br><span class="line">			<span class="comment">//break出FOR标签标识的代码</span></span><br><span class="line">			<span class="keyword">break</span> FOR</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案二：goto</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBreak</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	tick := time.Tick(time.Second)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> t := &lt;-tick:</span><br><span class="line">			fmt.Println(t)</span><br><span class="line">			<span class="comment">//跳到指定位置</span></span><br><span class="line">			<span class="keyword">goto</span> END</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">END:</span><br><span class="line">	fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这两种方式都能够成功跳出 for 循环，我选择了方案二。</p>
<blockquote>
<p>continue：单独在select中是不能使用continue，会编译错误，只能用在for-select中。  <strong>continue的语义就类似for中的语义，select后的代码不会被执行到。</strong><br>return：和函数中的return一样，跳出select，和for，后续代码都不执行</p>
</blockquote>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><h3 id="踩坑场景-2"><a href="#踩坑场景-2" class="headerlink" title="踩坑场景"></a>踩坑场景</h3><p>&emsp;&emsp;Map 任务需要打开文件后统计单词出现频率，此时有两种读文件的方式。第一种是打开文件后逐行读取，第二种是打开文件后直接全部加载到内存中。第一种方式是用时间换空间的做法，在文件是个超大型文件，但是内存不够的情况下只能使用这种方法，唯一的问题就是很慢，IO 操作相当密集，很影响速度；第二种方式需要占用较大的内存，但是只需要一次性将文件全部加载到内存中即可，时间上会快很多。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>&emsp;&emsp;在本 lab 的场景下，每个 job 只有 10s 的时间处理文件，那么显然应该采用第二种方式。我一开始就是采用的逐行读取的方式，发现有的文件在单 worker 运算时甚至完全无法在 10s 内统计完。<br>&emsp;&emsp;同时还采用了临时文件的方式，临时文件会默认保存在系统的<code>/tmp</code> 路径下，如果要放在当前目录下需要指定，每个临时文件的末尾会带上一串随机的数字，可以在命名的时候做一些约定，方便之后的处理。<br>&emsp;&emsp;对文件的命名带上了递增的 jobId，那么就避免了冲突问题。</p>
<h3 id="建议-1"><a href="#建议-1" class="headerlink" title="建议"></a>建议</h3><ul>
<li>因为命名规则可能存在缺陷，采用临时文件的形式可以避免任务失败后，任务被其他的 <code>worker</code> 接管造成的文件冲突；</li>
<li>还可以通过约定命名规则，比如带上自增的 JobId，那么在之后的流程中只会对成功的 JobId 的文件进行处理。</li>
</ul>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>常用排序算法</title>
    <url>/2022/04/07/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2>]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>早起刷题（Day 7）</title>
    <url>/2022/04/06/%E6%97%A9%E8%B5%B7%E5%88%B7%E9%A2%98%EF%BC%88Day%207%EF%BC%89/</url>
    <content><![CDATA[<p>今天没早起刷题，早起抢菜去了。淦！</p>
<h2 id="LeetCode253-会议室-II"><a href="#LeetCode253-会议室-II" class="headerlink" title="LeetCode253. 会议室 II"></a><a class="link" href="https://leetcode-cn.com/problems/meeting-rooms-ii/">LeetCode253. 会议室 II<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，返回 所需会议室的最小数量 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：intervals &#x3D; [[0,30],[5,10],[15,20]]</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：intervals &#x3D; [[7,10],[2,4]]</span><br><span class="line">输出：1</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; intervals.length &lt;&#x3D; 104</span><br><span class="line">0 &lt;&#x3D; starti &lt; endi &lt;&#x3D; 106</span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 按照最朴素的想法，要给公司部门安排会议，那么一定是优先考虑会议开始得早的部门，那么首先就是要排序。排序的条件就是开始时间越早越靠前；<br>(2). 安排新会议室的原则是所有已申请的会议室都被占用。那么就可以使用一个最小堆，堆中保存的是每场会议的结束时间；<br>(3). 当当前会议开始时，堆顶的会议还没结束，说明堆中所有的会议都不可能结束，那么就要申请新的会议室；<br>(4). 遍历完整个会议的记录，就可以得到要开辟的最大会议室数量。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(Nlog(N))</p>
<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> intHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h intHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h intHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h intHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> h[i] &lt; h[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *intHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *intHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	old := *h</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	x := old[n<span class="number">-1</span>]</span><br><span class="line">	*h = old[:n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMeetingRooms</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> intervals[i][<span class="number">0</span>] == intervals[j][<span class="number">0</span>] &#123;</span><br><span class="line">			<span class="keyword">return</span> intervals[i][<span class="number">1</span>] &lt; intervals[j][<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> intervals[i][<span class="number">0</span>] &lt; intervals[j][<span class="number">0</span>]</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> h intHeap</span><br><span class="line">	heap.Push(&amp;h, intervals[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">	room := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;= h[<span class="number">0</span>] &#123;</span><br><span class="line">			heap.Pop(&amp;h)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			room++</span><br><span class="line">		&#125;</span><br><span class="line">		heap.Push(&amp;h, intervals[i][<span class="number">1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> room</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode163-缺失的区间"><a href="#LeetCode163-缺失的区间" class="headerlink" title="LeetCode163. 缺失的区间"></a><a class="link" href="https://leetcode-cn.com/problems/missing-ranges/">LeetCode163. 缺失的区间<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给定一个排序的整数数组 _<strong>nums</strong>_ ，其中元素的范围在 <strong>闭区间</strong> <strong>[<em>lower, upper</em>]</strong> 当中，返回不包含在数组中的缺失区间。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入: nums &#x3D; [0, 1, 3, 50, 75], lower &#x3D; 0 和 upper &#x3D; 99,</span><br><span class="line">输出: [&quot;2&quot;, &quot;4-&gt;49&quot;, &quot;51-&gt;74&quot;, &quot;76-&gt;99&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 这道模拟题挺恶心的，边界处理是关键；<br>(2). 根据数据范围遍历 <code>nums</code>，不能按从 <code>lower</code> 到 <code>upper</code>。</p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p>
<h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMissingRanges</span><span class="params">(nums []<span class="keyword">int</span>, lower <span class="keyword">int</span>, upper <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ret := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> lower == upper &#123;</span><br><span class="line">			s := strconv.Itoa(lower)</span><br><span class="line">			ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			s := strconv.Itoa(lower) + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(upper)</span><br><span class="line">			ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pre := lower</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i] != pre &#123;</span><br><span class="line">				<span class="keyword">if</span> nums[i] == pre+<span class="number">1</span> &#123;</span><br><span class="line">					s = strconv.Itoa(pre)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					s = strconv.Itoa(pre) + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(nums[i]<span class="number">-1</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">				pre = nums[i]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i] == pre + <span class="number">2</span> &#123;</span><br><span class="line">				s = strconv.Itoa(nums[i]<span class="number">-1</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] == pre + <span class="number">1</span> &#123;</span><br><span class="line">				s = <span class="string">&quot;&quot;</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				s = strconv.Itoa(pre+<span class="number">1</span>) + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(nums[i]<span class="number">-1</span>)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pre = nums[i]</span><br><span class="line">			<span class="keyword">if</span> s != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">				ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> i == <span class="built_in">len</span>(nums)<span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i] != upper &#123;</span><br><span class="line">				<span class="keyword">if</span> nums[i] == upper<span class="number">-1</span> &#123;</span><br><span class="line">					s = strconv.Itoa(upper)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					s = strconv.Itoa(nums[i]+<span class="number">1</span>) + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(upper)</span><br><span class="line">				&#125;</span><br><span class="line">				ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode694-不同岛屿的数量"><a href="#LeetCode694-不同岛屿的数量" class="headerlink" title="LeetCode694. 不同岛屿的数量"></a><a class="link" href="https://leetcode-cn.com/problems/number-of-distinct-islands/">LeetCode694. 不同岛屿的数量<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给定一个非空 01 二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的 1 组成，你可以认为网格的四周被海水包围。<br>请你计算这个网格中共有多少个形状不同的岛屿。两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。</p>
</blockquote>
<p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00011</span><br><span class="line">00011</span><br><span class="line">给定上图，返回结果 1 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">11011</span><br><span class="line">10000</span><br><span class="line">00001</span><br><span class="line">11011</span><br><span class="line">给定上图，返回结果 3 。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">11</span><br><span class="line">1</span><br><span class="line">和</span><br><span class="line"></span><br><span class="line"> 1</span><br><span class="line">11</span><br><span class="line">是不同的岛屿，因为我们不考虑旋转、翻转操作。</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 海岛问题的拓展，一般思路就两种：dfs 或 bfs；<br>(2). 这道题要求输出的是不同形状海岛的数量，那么关键问题就是怎样表示海岛的形状；<br>(3). 回忆一下我们通过 dfs 找海岛的过程，每次都是先找到海岛最左上角的点，然后根据我们预设的方向数组来控制寻找的路径，那么通过这条寻找路径，就能确定海岛的形状；<br>(4). 要注意的是每个海岛左上角的起始点都是其坐标，要将其归零才可以在同一数值范围内进行判断，我们只需要在遍历 <code>grid</code> 的点的时候记录下此时的坐标，就可以计算该海岛上每个点相对于左上角点的坐标位置。</p>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N^2)</p>
<h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDistinctIslands</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	h_idx := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;</span><br><span class="line">	w_idx := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;</span><br><span class="line"></span><br><span class="line">	height, weight := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">	s := <span class="string">&quot;&quot;</span></span><br><span class="line">	bi, bj := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span></span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		grid[i][j] = <span class="number">0</span></span><br><span class="line">		s += fmt.Sprintf(<span class="string">&quot;-%d-%d&quot;</span>, i-bi, j-bj)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> k:=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++ &#123;</span><br><span class="line">			h, w := i+h_idx[k], j+w_idx[k]</span><br><span class="line">			<span class="keyword">if</span> h &gt;= <span class="number">0</span> &amp;&amp; h &lt; height &amp;&amp; w &gt;= <span class="number">0</span> &amp;&amp; w &lt; weight &amp;&amp; grid[h][w] == <span class="number">1</span> &#123;</span><br><span class="line">				dfs(h,w)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;height; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;weight; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> grid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">				bi, bj, s = i, j, <span class="string">&quot;&quot;</span></span><br><span class="line">				dfs(i,j)</span><br><span class="line">				m[s] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// for k, _ := range m &#123;</span></span><br><span class="line">	<span class="comment">// 		fmt.Println(k)</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="164-最大间距"><a href="#164-最大间距" class="headerlink" title="164. 最大间距"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-gap/">164. 最大间距<i class="fas fa-external-link-alt"></i></a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。<br>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。</p>
</blockquote>
<p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 示例 1:</span><br><span class="line">输入: nums &#x3D; [3,6,9,1]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums &#x3D; [10]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 数组元素个数小于 2，因此返回 0。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 105</span><br><span class="line">0 &lt;&#x3D; nums[i] &lt;&#x3D; 109</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>(1). 首先注意题目的要求：<strong>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。</strong> 这就对选择的算法有了限制。快排和堆排的时间复杂度都是 O(Nlog(N))，基数排序时间复杂度是 O(N)，空间复杂度是 O(N)，符合题目要求；<br>(2). 那么这道题就转化成一道基数排序的算法了。基数排序可以参考另一篇博客<a href="https://jiahaohong1997.github.io/2022/04/07/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">常用排序算法</a></p>
<h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)</p>
<h3 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumGap</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(ans <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    maxVal := max(nums...)</span><br><span class="line">    <span class="keyword">for</span> exp := <span class="number">1</span>; exp &lt;= maxVal; exp *= <span class="number">10</span> &#123;</span><br><span class="line">        cnt := [<span class="number">10</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            digit := v / exp % <span class="number">10</span></span><br><span class="line">            cnt[digit]++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            cnt[i] += cnt[i<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">            digit := nums[i] / exp % <span class="number">10</span></span><br><span class="line">            buf[cnt[digit]<span class="number">-1</span>] = nums[i]</span><br><span class="line">            cnt[digit]--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">copy</span>(nums, buf)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        ans = max(ans, nums[i]-nums[i<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> a[<span class="number">1</span>:] &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; res &#123;</span><br><span class="line">            res = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>早起刷题</tag>
      </tags>
  </entry>
</search>
