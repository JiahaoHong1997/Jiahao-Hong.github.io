<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>滑动窗口(Sliding Window)算法框架</title>
    <url>/2021/04/28/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(Sliding-Window)%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>&emsp;&emsp;滑动窗口主要应用于子串问题，遇到这类问题不要犹豫，直接考虑使用滑动窗口。作为双指针类问题最难掌握的技巧，其设计思路其实非常简单，就是通过两个指针维护一个窗口，通过前后指针的不断向前滑动，然后更新答案。该算法的大致逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">left := <span class="number">0</span></span><br><span class="line">right := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> right &lt; s.size() &#123;</span><br><span class="line">  <span class="comment">// 增大窗口</span></span><br><span class="line">  window.add(s[right])</span><br><span class="line">  right++</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> window needs shrink &#123;</span><br><span class="line">    <span class="comment">// 缩小窗口</span></span><br><span class="line">    window.remove(s[left])</span><br><span class="line">    left++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。其实困扰大家的，不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。</p>
<h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><h3 id="滑动窗口算法代码框架"><a href="#滑动窗口算法代码框架" class="headerlink" title="滑动窗口算法代码框架"></a>滑动窗口算法代码框架</h3><p>&emsp;&emsp;废话少说，直接上代码。下面的框架很适合给出了具体t，要求找出其在主串s中的排列或包含t的子串的问题，可以直接套用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slidingwindow</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span></span> &#123; <span class="comment">// s是主串，t是子串</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据题目条件灵活选择数据结构，其主要作用和目的是判断左边界是否要右移</span></span><br><span class="line">  need := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(t))  <span class="comment">// need用于记录t子串对字符的实际要求</span></span><br><span class="line">  window := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(t)) <span class="comment">// window用于检测当前窗口内满足t子串的要求字符的实际情况</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">    need[t[i]] = <span class="number">1</span>  <span class="comment">// 数量可以是任意数字，根据题目实际需求</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">  	left = <span class="number">0</span> <span class="comment">// 窗口左边界</span></span><br><span class="line">    right = <span class="number">0</span> <span class="comment">// 窗口右边界</span></span><br><span class="line">    valid = <span class="number">0</span> <span class="comment">// 满足条件的字符个数</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">    <span class="comment">// c是要移入窗口的字符</span></span><br><span class="line">    c := s[right]</span><br><span class="line">    <span class="comment">// 右移窗口</span></span><br><span class="line">    right++</span><br><span class="line">    <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">    <span class="comment">/********************/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">    <span class="keyword">for</span> window needs shrink &#123;</span><br><span class="line">      <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">      d := s[left]</span><br><span class="line">      <span class="comment">// 左移窗口</span></span><br><span class="line">      left++</span><br><span class="line">      <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串<i class="fas fa-external-link-alt"></i></a></h3><p><img lazyload src="/images/loading.svg" data-src="https://gblobscdn.gitbook.com/assets%2F-MZLBWp7285NJbpNV7Kv%2Fsync%2F3d5d2bc76cee1f2190a7dd4fcd17445164dc7273.png?alt=media" alt="avatar"></p>
<p>就是说要在 <code>S</code>(source) 中找到包含 <code>T</code>(target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。</p>
<p>如果我们使用暴力解法，代码大概是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">  <span class="keyword">for</span> j:=i+<span class="number">1</span>; j&lt;<span class="built_in">len</span>(s); j++ &#123;</span><br><span class="line">    <span class="keyword">if</span> s[i:j] 包含t中的所有字母 &#123;</span><br><span class="line">      更新答案</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路很直接，但是显然，这个算法的复杂度肯定大于 O(N^2) 了。</p>
<p><strong>滑动窗口算法的思路是这样</strong>：</p>
<p>1、我们在字符串 <code>S</code> 中使用双指针中的左右指针技巧，初始化 <code>left = right = 0</code>，把索引<strong>左闭右开</strong>区间 <code>[left, right)</code> 称为一个「窗口」。</p>
<p>2、我们先不断地增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code>，直到窗口中的字符串符合要求（包含了 <code>T</code> 中的所有字符）。</p>
<p>3、此时，我们停止增加 <code>right</code>，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含 <code>T</code> 中的所有字符了）。同时，每次增加 <code>left</code>，我们都要更新一轮结果。</p>
<p>4、重复第 2 和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</p>
<p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，</strong>也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p>
<p>下面画图理解一下，<code>needs</code> 和 <code>window</code> 相当于计数器，分别记录 <code>T</code> 中字符出现次数和「窗口」中的相应字符的出现次数。</p>
<p>初始状态：</p>
<p><img lazyload src="/images/loading.svg" data-src="image-20210429193510364.png" alt="image-20210429193510364"></p>
<p>增加 <code>right</code>，直到窗口 <code>[left, right]</code> 包含了 <code>T</code> 中所有字符：</p>
<p><img lazyload src="/images/loading.svg" data-src="image-20210429193608894.png" alt="image-20210429193608894"></p>
<p>现在开始增加 <code>left</code>，缩小窗口 <code>[left, right]</code>。</p>
<p><img lazyload src="/images/loading.svg" data-src="image-20210429193630917.png" alt="image-20210429193630917"></p>
<p>直到窗口中的字符串不再符合要求，<code>left</code> 不再继续移动。</p>
<p><img lazyload src="/images/loading.svg" data-src="image-20210429194033697.png" alt="image-20210429194033697"></p>
<p>之后重复上述过程，先移动 <code>right</code>，再移动 <code>left</code>…… 直到 <code>right</code> 指针到达字符串 <code>S</code> 的末端，算法结束。</p>
<p><strong>现在开始套模板，只需要思考以下四个问题</strong>：</p>
<p>1、当移动 <code>right</code> 扩大窗口，即加入字符时，应该更新哪些数据？</p>
<p>2、什么条件下，窗口应该暂停扩大，开始移动 <code>left</code> 缩小窗口？</p>
<p>3、当移动 <code>left</code> 缩小窗口，即移出字符时，应该更新哪些数据？</p>
<p>4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p>
<p>如果一个字符进入窗口，应该增加 <code>window</code> 计数器；如果一个字符将移出窗口的时候，应该减少 <code>window</code> 计数器；当 <code>valid</code> 满足 <code>need</code> 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    need := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125; <span class="comment">// 根据t子串记录实际的需求</span></span><br><span class="line">    window := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125; <span class="comment">// 记录窗口内满足要求的字符的情况</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(t); i++ &#123; <span class="comment">// 将子串t中字符的实际需求用need来记录</span></span><br><span class="line">        need[t[i]]++</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">  	    left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        valid = <span class="number">0</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 本题要求返回子串，所以引入start和length来记录子串的起始和长度</span></span><br><span class="line">        start = <span class="number">0</span> <span class="comment">// 记录最小覆盖子串的起始索引</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)+<span class="number">1</span> <span class="comment">//记录最小覆盖子串的长度</span></span><br><span class="line">    )</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="comment">// 加入窗口</span></span><br><span class="line">        c := s[right]</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 检查c是否在need的需求中，若在则加入window(进行窗口内数据的一系列更新)</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := need[c]; ok &#123;</span><br><span class="line">          window[c]++     </span><br><span class="line">          <span class="comment">// 若字符c的个数已经满足了need中的要求</span></span><br><span class="line">    	    <span class="keyword">if</span> window[c] == need[c] &#123;</span><br><span class="line">      	        valid++</span><br><span class="line">    	    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fmt.Printf(&quot;window1: [%d, %d)\n&quot;, left, right)  // debug专用</span></span><br><span class="line">        <span class="comment">// 当window内的所有字符都满足了需求，判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">for</span> valid == <span class="built_in">len</span>(need) &#123;</span><br><span class="line">            <span class="keyword">if</span> right - left &lt; length &#123;</span><br><span class="line">                start = left</span><br><span class="line">                length = right - left</span><br><span class="line">            &#125;</span><br><span class="line">      </span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            d := s[left]</span><br><span class="line">            <span class="comment">// 左边界右移缩小窗口</span></span><br><span class="line">            left++</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> _, ok := need[d]; ok &#123;</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d] &#123;</span><br><span class="line">                    valid--</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fmt.Printf(&quot;window2: [%d, %d)\n&quot;, left, right)  // debug专用      </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> length == <span class="built_in">len</span>(s)+<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s[start:start+length]</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a><a class="link" href="https://leetcode-cn.com/problems/permutation-in-string/">字符串的排列<i class="fas fa-external-link-alt"></i></a></h3><p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的 <strong>子串</strong> 。</p>
<p>示例 1：</p>
<p>输入: s1 = “ab” s2 = “eidbaooo”<br>输出: True<br>解释: s2 包含 s1 的排列之一 (“ba”).</p>
<p>示例 2：</p>
<p>输入: s1= “ab” s2 = “eidboaoo”<br>输出: False</p>
<p><strong>提示：</strong></p>
<ul>
<li>输入的字符串只包含小写字母</li>
<li>两个字符串的长度都在 <code>[1, 10,000]</code> 之间</li>
</ul>
<p>这种题目，是明显的滑动窗口算法，<strong>相当给你一个</strong> <strong><code>S1</code></strong> <strong>和一个</strong> **<code>S2</code>**，请问你 <strong><code>S2</code></strong> <strong>中是否存在一个子串，包含</strong> <strong><code>S1</code></strong> <strong>中所有字符且不包含其他字符</strong>？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkInclusion</span><span class="params">(s1 <span class="keyword">string</span>, s2 <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    need := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    window := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s1); i++ &#123;</span><br><span class="line">        need[s1[i]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        valid = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s2) &#123;</span><br><span class="line">        window[s2[right]]++</span><br><span class="line">				</span><br><span class="line">      	<span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := need[s2[right]]; ok &#123;</span><br><span class="line">            <span class="keyword">if</span> window[s2[right]] == need[s2[right]] &#123;</span><br><span class="line">                valid++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right++</span><br><span class="line">        </span><br><span class="line">      	<span class="comment">// 在这里判断是否找到了合法的子串</span></span><br><span class="line">        <span class="keyword">if</span> valid == <span class="built_in">len</span>(need) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right &gt;= <span class="built_in">len</span>(s1) &#123;</span><br><span class="line">            <span class="keyword">if</span> _, ok := need[s2[left]]; ok &#123;</span><br><span class="line">                <span class="keyword">if</span> window[s2[left]] == need[s2[left]] &#123;</span><br><span class="line">                    valid--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            window[s2[left]]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：</p>
<p>1、本题移动 <code>left</code> 缩小窗口的时机是窗口大小大于 <code>S1.size()</code> 时，应为排列嘛，显然长度应该是一样的。</p>
<p>2、当发现 <code>valid == len(need)</code> 时，就说明窗口中就是一个合法的排列，所以立即返回 <code>true</code>。</p>
<p>至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。</p>
<h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a><a class="link" href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p>
<p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p>
<p>说明：</p>
<p>字母异位词指字母相同，但排列不同的字符串。<br>不考虑答案输出的顺序。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br></pre></td></tr></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br></pre></td></tr></table></figure>

<p>和上一个示例几乎一模一样，只不过函数返回的东西不同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findAnagrams</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    need := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    window := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line">        need[p[i]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        valid = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        c := s[right]</span><br><span class="line">        window[c]++</span><br><span class="line">        right++</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> _,ok := need[c]; ok&#123;</span><br><span class="line">            <span class="keyword">if</span> window[c] == need[c] &#123;</span><br><span class="line">                valid++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> valid == <span class="built_in">len</span>(need) &#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, left)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right &gt;= <span class="built_in">len</span>(p) &#123;</span><br><span class="line">            d := s[left]</span><br><span class="line">            <span class="keyword">if</span> _,ok := need[d]; ok &#123;</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d] &#123;</span><br><span class="line">                    valid--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            window[d]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a class="link" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<p>&emsp;&emsp;这个题终于有了点新意，不是一套框架就出答案，不过反而更简单了，稍微改一改框架就行了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    window := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        c := s[right]</span><br><span class="line">        window[c]++</span><br><span class="line">        right++</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 每当新进入窗口的字符出现多次，窗口左边界便开始右移，知道窗口内没有重复字符</span></span><br><span class="line">        <span class="keyword">for</span> window[c]&gt;<span class="number">1</span> &#123; </span><br><span class="line">            d := s[left]</span><br><span class="line">            window[d]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        ret = max(ret, right-left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a&gt;b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS算法框架</title>
    <url>/2021/04/08/BFS%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>&emsp;&emsp;本系列文章是我在阅读<a class="link" href="https://labuladong.gitbook.io/algo/">《labuladong的算法小抄》<i class="fas fa-external-link-alt"></i></a>一书，再结合自己在Leetcode上刷题后的一些体会和总结。本系列文章的所有代码均由Golang语言实现，使用别的语言的读者不妨尝试转换成自己熟悉的语言实现。不过如果你选择用Python来刷算法题，有一个问题需要注意，Python的效率降低，在机试过程中可能出现同一道题，用C/C++或者Golang的人能暴力AC，而用Python却可能会运行超时，会吃不小的亏，还请结合自身情况来考虑选择哪门语言来实现。读者若需要了解更多的细节，还请阅读此书并结合实际多刷刷题。</p>
<h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><h3 id="BFS的应用场景"><a href="#BFS的应用场景" class="headerlink" title="BFS的应用场景"></a>BFS的应用场景</h3><p>&emsp;&emsp;此类问题的本质就是在一幅「图」(树是特殊的图)中找到起始点(start)到终点(target)的最近距离。实际上，此类问题利用DFS也能做到，但是DFS实质上就是回溯算法，时间复杂度很高。BFS的时间代价是O(N)，其代价就是空间复杂度很高。在二叉树中，BFS对应的就是二叉树的层序遍历。</p>
<p>&emsp;&emsp;这类问题可以有各种各样的变体，比如：1.走迷宫，迷宫中有的格子是围墙，不能通过，要求从起点到终点的最短距离是多少？2.两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？3.连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？这些问题都没啥奇技淫巧，本质上就是一幅「图」，让你从一个起点，走到终点，问最短路径。这就是 BFS 的本质，框架搞清楚了直接默写就好。</p>
<h3 id="算法思路-Golang"><a href="#算法思路-Golang" class="headerlink" title="算法思路(Golang)"></a>算法思路(Golang)</h3><p>&emsp;&emsp;所有的BFS问题的核心数据结构：队列q用于存储节点。用node指向当前要出队的节点，当该节点出队时，其相邻节点入队。对于非二叉树这种结构(没有子节点到父节点的指针，不会走回头路)的数据形式，还需要一个建立一个map类型来保存已经走过的节点，防止走回头路。</p>
<p>&emsp;&emsp;BFS最常见于二叉树中，先给一个二叉树的BFS(层序遍历)框架。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">二叉树：[3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层序遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFS</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ret := [][]<span class="keyword">int</span>&#123;&#125;  <span class="comment">// 因为该示例要按每层返回遍历结果，所以要初始化一个二维切片</span></span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  <span class="comment">// 如果根节点为空，返回空切片</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  q := []*TreeNode&#123;root&#125;  <span class="comment">// 初始化队列用于存储节点</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; <span class="built_in">len</span>(q)&gt;<span class="number">0</span>; i++ &#123;  <span class="comment">// 当队列不为空，说明还有节点没有遍历完，继续循环</span></span><br><span class="line">    ret = <span class="built_in">append</span>(ret, []<span class="keyword">int</span>&#123;&#125;)  <span class="comment">// 初始化用于存储树的每一层的切片</span></span><br><span class="line">    p := []*TreeNode&#123;&#125;  <span class="comment">// 切片p用于记录树的每一层节点</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(q); j++ &#123;</span><br><span class="line">      node := q[j]  <span class="comment">// 某一层的节点顺序出队</span></span><br><span class="line">      ret[i] = <span class="built_in">append</span>(ret[i], node.Val) <span class="comment">// 存入当前节点</span></span><br><span class="line">      <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123; <span class="comment">// 如果左节点不为空，左节点入队</span></span><br><span class="line">        p = <span class="built_in">append</span>(p, node.Left) </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123; <span class="comment">// 如果右节点不为空，右节点入队</span></span><br><span class="line">        p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    q = p; <span class="comment">// 更新队列q，保存下一层的节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果不要求用二维数组分别保存每一层的节点，可以不需要切片p，直接在每个节点出队时将其左右节点送入队列p即可。</p>
<p>&emsp;&emsp;通用框架，主要区别在于多了一个map类型用来记录已经遍历过的节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define num is the number of node</span></span><br><span class="line"><span class="comment"> * Define the Type of node if NodeType</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFS</span><span class="params">(start NodeType, target NodeType)</span></span> &#123;</span><br><span class="line">  q := []NodeType&#123;start&#125; <span class="comment">// 起始节点入队</span></span><br><span class="line">  m := <span class="built_in">make</span>(<span class="keyword">map</span>[NodeType]<span class="keyword">int</span>, num) <span class="comment">// 避免走回头路</span></span><br><span class="line">  m[start] = <span class="number">1</span> <span class="comment">// 记录起始节点</span></span><br><span class="line">  step := <span class="number">0</span>  <span class="comment">// 记录扩散的步数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(q)</span><br><span class="line">    p := []NodeType&#123;&#125;</span><br><span class="line">    <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">      node := q[i]</span><br><span class="line">      <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">      <span class="keyword">if</span> node = target &#123;</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 将 node 的相邻节点加入队列 */</span></span><br><span class="line">      <span class="keyword">for</span> Node x : node.adj() &#123; <span class="comment">// 判断node是否有相邻节点，根据数据形式自行更改</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := m[x]; !ok &#123; <span class="comment">// 如果节点没有被记录过，则可以入队</span></span><br><span class="line">          p = <span class="built_in">append</span>(p, x)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">    step++</span><br><span class="line">    q = p <span class="comment">// 该层所有节点遍历介绍，q保存下一层节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实际案例-二叉树"><a href="#实际案例-二叉树" class="headerlink" title="实际案例(二叉树)"></a>实际案例(二叉树)</h2><p>我们来看几道Leetcode上的题目。</p>
<h3 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a class="link" href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<pre><code>        3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回锯齿形层序遍历如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>​        怎么套到 BFS 的框架里呢？首先明确一下起点 start 和终点 target 是什么，怎么判断到达了终点？</p>
<p><strong>显然起点就是</strong> <strong>root</strong> <strong>根节点，终点就是最后一个叶子节点。</strong>不过在存储的过程中要注意，奇数行要倒序排列，偶数行正序排列。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    ret := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; <span class="built_in">len</span>(q)&gt;<span class="number">0</span>; i++ &#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">        p := []*TreeNode&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(q) ; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span> &#123; <span class="comment">// 如果是偶数行，则正序排列</span></span><br><span class="line">                node := q[j]</span><br><span class="line">                ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是奇数行，则倒叙排列</span></span><br><span class="line">                node := q[<span class="built_in">len</span>(q)<span class="number">-1</span>-j]</span><br><span class="line">                ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line">            &#125;</span><br><span class="line">            nodeInP := q[j]</span><br><span class="line">            <span class="keyword">if</span> nodeInP.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, nodeInP.Left)</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> nodeInP.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, nodeInP.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [2,null,3,null,4,null,5,null,6]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数的范围在 <code>[0, 105]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p><strong>显然起点就是</strong> <strong><code>root</code></strong> <strong>根节点，终点就是最靠近根节点的那个「叶子节点」</strong>，叶子节点就是两个子节点都是 <code>nil</code> 的节点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    step := <span class="number">1</span>  <span class="comment">// 记录层数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        p := []*TreeNode&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">            node := q[i]</span><br><span class="line">            <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123; <span class="comment">// 当遇到第一个子节点，就返回该节点所在层数</span></span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实际案例-其他数据结构方式"><a href="#实际案例-其他数据结构方式" class="headerlink" title="实际案例(其他数据结构方式)"></a>实际案例(其他数据结构方式)</h2><h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a class="link" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D;&#x3D; grid.length</span><br><span class="line">n &#x3D;&#x3D; grid[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 300</span><br><span class="line">grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39;</span><br></pre></td></tr></table></figure>

<p>算法思路：</p>
<p>&emsp;&emsp;遍历整个二维网格，当节点值为1时，以这个节点为起始进行广度优先搜索，当其相邻节点值为1时，进入队列，并将这些入队的节点值置为0。当不再有节点入队，说明已经达到了岛屿的边界，返回原始的循环。同时可以初始化一个map用于记录已经遍历过的节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>  <span class="comment">// 初始化map类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">len</span>(grid) <span class="comment">// 行数</span></span><br><span class="line">    c := <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="comment">// 列数</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, r*c) <span class="comment">// 用于记录已经遍历过的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;r; i++ &#123; <span class="comment">// 遍历整个二维网格</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;c; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;0&#x27;</span> || m[i*c+j] == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当节点值为&#x27;1&#x27;时以该节点为起始进行广度优先搜索</span></span><br><span class="line">                count++                </span><br><span class="line">                BFS(grid, i, j)</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span> <span class="comment">// 将当前遍历节点置&#x27;0&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFS</span><span class="params">(grid [][]<span class="keyword">byte</span>, i <span class="keyword">int</span>, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">len</span>(grid)</span><br><span class="line">    c := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    q := []<span class="keyword">int</span>&#123;i*c+j&#125; <span class="comment">// 队列中保存的是节点编号，以行优先的方式对所有节点编号</span></span><br><span class="line">    m[i*c+j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        p := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k:=<span class="number">0</span>; k&lt;<span class="built_in">len</span>(q); k++ &#123;</span><br><span class="line">            node := q[k]</span><br><span class="line">            nodeR := node/c <span class="comment">// 当前节点的行号</span></span><br><span class="line">            nodeC := node%c <span class="comment">// 当前节点的列号</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nodeR&gt;<span class="number">0</span> &amp;&amp; grid[nodeR<span class="number">-1</span>][nodeC] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的上方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[(nodeR<span class="number">-1</span>)*c+nodeC]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, (nodeR<span class="number">-1</span>)*c+nodeC)</span><br><span class="line">                    grid[nodeR<span class="number">-1</span>][nodeC] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[(nodeR<span class="number">-1</span>)*c+nodeC] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nodeR&lt;r<span class="number">-1</span> &amp;&amp; grid[nodeR+<span class="number">1</span>][nodeC] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的下方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[(nodeR+<span class="number">1</span>)*c+nodeC]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, (nodeR+<span class="number">1</span>)*c+nodeC)</span><br><span class="line">                    grid[nodeR+<span class="number">1</span>][nodeC] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[(nodeR+<span class="number">1</span>)*c+nodeC] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nodeC&gt;<span class="number">0</span> &amp;&amp; grid[nodeR][nodeC<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的左方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[nodeR*c+(nodeC<span class="number">-1</span>)]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, nodeR*c+(nodeC<span class="number">-1</span>))</span><br><span class="line">                    grid[nodeR][nodeC<span class="number">-1</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[nodeR*c+(nodeC<span class="number">-1</span>)] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nodeC&lt;c<span class="number">-1</span> &amp;&amp; grid[nodeR][nodeC+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的右方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[nodeR*c+(nodeC+<span class="number">1</span>)]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, nodeR*c+(nodeC+<span class="number">1</span>))</span><br><span class="line">                    grid[nodeR][nodeC+<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[nodeR*c+(nodeC+<span class="number">1</span>)] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p <span class="comment">// 进入下一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a class="link" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表<i class="fas fa-external-link-alt"></i></a></h3><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p>
<p>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p>
<p><strong>示例 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; numCourses &lt;&#x3D; 105</span><br><span class="line">0 &lt;&#x3D; prerequisites.length &lt;&#x3D; 5000</span><br><span class="line">prerequisites[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; ai, bi &lt; numCourses</span><br><span class="line">prerequisites[i] 中的所有课程对 互不相同</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;算法思路：我们使用一个队列来进行广度优先搜索。初始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。并初始化一个长度为numCourses的切片precourse，用于记录每个节点(课程)的入度。在广度优先搜索的每一步中，我们取出队首的节点 ，将该节点的相邻边(也就是将本课程作为预修课程的其他课程)减1(precource对应索引的值减1)。当节点入度为0时，将其作为下一层节点加入队列中。最后遍历precourse切片，若切片中所有元素为0，说明找到了一种拓扑排序，返回true，否则返回false。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    precourse := <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(prerequisites); i++ &#123; <span class="comment">// 初始化所有节点的入度(记录所有课程的预修课程数)</span></span><br><span class="line">        precourse[prerequisites[i][<span class="number">0</span>]]++</span><br><span class="line">    &#125;</span><br><span class="line">    q := []<span class="keyword">int</span>&#123;&#125; <span class="comment">// 初始化队列用于存储入度为0的节点(不需要预修课程的课)</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> precourse[i] == <span class="number">0</span> &#123; <span class="comment">// 将入度为0的节点入队</span></span><br><span class="line">            q = <span class="built_in">append</span>(q, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        p := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">            node := q[i]</span><br><span class="line">            <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(prerequisites); j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> prerequisites[j][<span class="number">1</span>] == node &#123; <span class="comment">// 查看所有以当前课程为预修课程的课</span></span><br><span class="line">                    precourse[prerequisites[j][<span class="number">0</span>]]-- <span class="comment">// 入度减1</span></span><br><span class="line">                    <span class="keyword">if</span> precourse[prerequisites[j][<span class="number">0</span>]] == <span class="number">0</span> &#123; <span class="comment">// 当入度为0，入队</span></span><br><span class="line">                        p = <span class="built_in">append</span>(p, prerequisites[j][<span class="number">0</span>])</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123; <span class="comment">// 查看是否所有节点入度为0</span></span><br><span class="line">        <span class="keyword">if</span> precourse[i] != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a class="link" href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 &#x3D; 4 + 4 + 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 &#x3D; 4 + 9</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 104</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;算法思路：本题可以采用贪心+BFS的策略，实际上是从上到下逐层构造 N 元树。我们以 BFS（广度优先搜索）的方式遍历它。在 N 元树的每一级，我们都在枚举相同大小的组合。其中每个节点表示数字 n 的余数减去一个完全平方数的组合，我们的任务是在树中找到一个节点，该节点满足两个条件：</p>
<p>(1) 节点的值（即余数）也是一个完全平方数。<br>(2) 在满足条件（1）的所有节点中，节点和根之间的距离应该最小。</p>
<p>下面是这棵树的样子：</p>
<p><img lazyload src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjc5LzI3OV9ncmVlZHlfdHJlZS5wbmc?x-oss-process=image/format,png" alt="avatar"></p>
<ul>
<li>首先，我们准备小于给定数字 n 的完全平方数列表（即 powlist）。</li>
<li>然后创建 q队列 遍历，该变量将保存所有剩余项在每个级别的枚举。在主循环中，我们迭代 q 变量。在每次迭代中，我们检查余数是否是一个完全平方数。如果余数不是一个完全平方数，就用其中一个完全平方数减去它，得到一个新余数，然后将新余数添加到 p 中，以进行下一级的迭代。一旦遇到一个完全平方数的余数，我们就会跳出循环，这也意味着我们找到了解。</li>
<li>注意：这里我们使用 set ，以消除同一级别中的剩余项的冗余。</li>
</ul>
<p>&emsp;&emsp;如果看文字难以理解，最好以n=12为例，画一画整个树的层级结构，能有更深的理解。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSquares</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    powlist := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i*i&lt;=n; i++ &#123; <span class="comment">// 完全平方数表</span></span><br><span class="line">        powlist = <span class="built_in">append</span>(powlist, i*i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">10000</span>) <span class="comment">// 用于记录冗余项，只需要在每层中第一次出现时保存，就能保证层数最少</span></span><br><span class="line">    level := <span class="number">0</span> <span class="comment">// 记录层级</span></span><br><span class="line">    q := []<span class="keyword">int</span>&#123;n&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        level++</span><br><span class="line">        p := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">            node := q[i] <span class="comment">// 当前节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _,value := <span class="keyword">range</span> powlist &#123; <span class="comment">// 贪心算法，构造树</span></span><br><span class="line">                <span class="keyword">if</span> value == node &#123; <span class="comment">// 第一次出现完全平方数，说明在这一层级就能解决问题，直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> level</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; node &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> set[node-value] == <span class="literal">false</span> &#123; <span class="comment">// 相当于剪枝操作</span></span><br><span class="line">                        p = <span class="built_in">append</span>(p, node-value) <span class="comment">// 记录下一层级的节点</span></span><br><span class="line">                        set[node-value] = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a class="link" href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/bfs-suan-fa/bfs-kuang-jia">BFS 算法解题套路框架<i class="fas fa-external-link-alt"></i></a></p>
<p>2.<a class="link" href="https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/">完全平方数<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>广度优先搜索(BFS)</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划(Dynamic Programming)算法框架</title>
    <url>/2021/04/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92(Dynamic-Programming)%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>&emsp;&emsp;在一开始学习算法的时候，我对动态规划和贪心算法一直都只有个模糊的概念，不明白两者到底有什么区别，感觉思路都差不太多。于是在本文的开头，我想对比一下贪心算法和动态规划的区别和联系。动态规划和贪心算法都是用来求最优化问题，且二者都必须具有最有子结构。动态规划的整体策略是一种自底向上的结构，贪心算法是自顶向下的结构。贪心算法可以解决的问题，动态规划都能解决，可以说，贪心算法是动态规划的一个特例。贪心算法和动态规划<strong>最大的不同</strong>在于，它并不是首先寻找子问题的最优解，然后在其中进行选择，而是首先做一次贪心选择——在当时（局部）看来最有选择——然后求解选出的子问题，从而不必费心求解所有可能相关的子问题。</p>
<p>&emsp;&emsp;动态规划具有两个性质：1）重叠子问题；2）<em><em><em>最优子结构*<strong>。贪心算法具有的两个性质：1）贪心选择性质；2）</strong></em>最优子结构</em>*</em>。动态规划就是为了消除其重叠子问题而设计的。<strong>其实贪心算法是一种特殊的动态规划，由于其具有贪心选择性质，保证了子问题只会被计算一次，不会被多次计算，因此贪心算法其实是最简单的动态规划。</strong></p>
<h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><h3 id="动态规划-DP-思维框架"><a href="#动态规划-DP-思维框架" class="headerlink" title="动态规划(DP)思维框架"></a>动态规划(DP)思维框架</h3><p>&emsp;&emsp;首先引用<a class="link" href="https://labuladong.gitbook.io/algo/">📋《labuladong的算法小抄》<i class="fas fa-external-link-alt"></i></a>中对动态规划问题的分析。</p>
<p>&emsp;&emsp;<strong>动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离等等。既然目标是求最值，那么<strong>DP的核心问题就是穷举</strong>。动态规划的穷举是很特别的，它存在以下三要素：</p>
<ul>
<li><strong>重叠子问题</strong>：如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</li>
<li><strong>最优子结构</strong>：动态规划问题一定具备最优子结构，才能通过子问题的最值得到原问题的最值。</li>
<li><strong>状态转移方程</strong>：动态规划问题的难点和关键，找到正确的状态转移方程，问题基本就能得到解决。</li>
</ul>
<p>&emsp;&emsp;由此可以得到一个基本的思维框架用于解决这类问题：<strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p>
<p>&emsp;&emsp;按上面的套路走，最后的结果就可以套这个框架：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"><span class="comment">// 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。</p>
<h3 id="动态规划杀手锏"><a href="#动态规划杀手锏" class="headerlink" title="动态规划杀手锏"></a>动态规划杀手锏</h3><h4 id="动态规划需要注意的要点："><a href="#动态规划需要注意的要点：" class="headerlink" title="动态规划需要注意的要点："></a>动态规划需要注意的要点：</h4><ul>
<li><p>“问5”法则判断问题是否是动态规划，例如最优解，最小或者最大等等；</p>
</li>
<li><p>如果判断属于动态规划的话，接下来我们可以根据“问4”法则求解：</p>
</li>
<li><ul>
<li>状态（小规模问题的数学表示）</li>
<li>状态转移方程（大规模问题如何转化为更小的问题）</li>
<li>最小状态（最小规模的问题）</li>
<li>要求的返回值是什么</li>
</ul>
</li>
</ul>
<h4 id="杀手锏"><a href="#杀手锏" class="headerlink" title="杀手锏"></a>杀手锏</h4><p><strong>1）建模：</strong></p>
<ul>
<li><p><strong>最优子结构</strong></p>
</li>
<li><p><strong>状态转移方程</strong></p>
</li>
<li><p><strong>边界</strong></p>
</li>
</ul>
<p><strong>2）实现：</strong></p>
<ul>
<li><p><strong>暴力递归</strong></p>
</li>
<li><p><strong>备忘录法（从上倒下，非全二叉树，hash保存！）</strong></p>
</li>
<li><p><strong>自底而上（迭代实现）</strong></p>
</li>
</ul>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>1.暴力递归</p>
<p>斐波那契数列的数学形式就是递归的，写成代码就是这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(N <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> N == <span class="number">1</span> || N==<span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fib(N<span class="number">-1</span>)+fib(N<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-24-30.jpg" alt="avatar"></p>
<p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p>
<p>&emsp;&emsp;这个递归树怎么理解？就是说想要计算原问题 <code>f(20)</code>，我就得先计算出子问题 <code>f(19)</code> 和 <code>f(18)</code>，然后要计算 <code>f(19)</code>，我就要先算出子问题 <code>f(18)</code> 和 <code>f(17)</code>，以此类推。最后遇到 <code>f(1)</code> 或者 <code>f(2)</code> 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。<strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p>
<p>&emsp;&emsp;观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p>
<p>&emsp;&emsp;这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p>
<p>2.带备忘录的递归解法</p>
<p>&emsp;&emsp;即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(N <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> N &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">  mem := <span class="built_in">make</span>([]<span class="keyword">int</span>, N+<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 进行带备忘录的递归</span></span><br><span class="line">  <span class="keyword">return</span> helper(mem, N)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(mem []<span class="keyword">int</span>, N <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">// base case</span></span><br><span class="line">  <span class="keyword">if</span> N == <span class="number">1</span> || N == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 已经计算过</span></span><br><span class="line">  <span class="keyword">if</span> mem[N] != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mem[N]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新备忘录</span></span><br><span class="line">  mem[N] = help(N<span class="number">-1</span>)+help[N<span class="number">-2</span>]</span><br><span class="line">  <span class="keyword">return</span> mem[N]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-25-26.jpg" alt="avatar"></p>
<p>&emsp;&emsp;实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p>
<p>&emsp;&emsp;至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p>
<p>&emsp;&emsp;啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-26-03.jpg" alt="avatar"></p>
<p>&emsp;&emsp;啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 <code>f(1)</code> 和 <code>f(2)</code> 开始往上推，直到推到我们想要的答案 <code>f(20)</code>，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p>
<p>3.DP数组的迭代解法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(N <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> N &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> N == <span class="number">1</span> || N == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, N+<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化base case</span></span><br><span class="line">  dp[<span class="number">1</span>], dp[<span class="number">2</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">3</span>; i&lt;=N; i++ &#123;</span><br><span class="line">    dp[i] = dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]  <span class="comment">// 状态转移方程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[N]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-26-32.jpg" alt="avatar"></p>
<p>&emsp;&emsp;画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p>
<p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-27-29.jpg" alt="avatar"></p>
<p>&emsp;&emsp;为啥叫「状态转移方程」？其实就是为了听起来高端。你把 <code>f(n)</code> 想做一个状态 <code>n</code>，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 相加转移而来，这就叫状态转移，仅此而已。</p>
<p>&emsp;&emsp;你会发现，上面的几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着暴力解法。</p>
<p>&emsp;&emsp;<strong>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong>。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p>
<p>&emsp;&emsp;这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(N <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> N &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> N == <span class="number">1</span> || N == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; </span><br><span class="line">  prev := <span class="number">1</span></span><br><span class="line">  curr := <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">3</span>; i&lt;=N; i++ &#123;</span><br><span class="line">    sum := prev + curr <span class="comment">// 新状态由前两个状态之和求得</span></span><br><span class="line">    prev = curr  <span class="comment">// 保存当前状态</span></span><br><span class="line">    curr = sum   <span class="comment">// 保存前一个状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> curr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个技巧就是所谓的「<strong>状态压缩</strong>」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 <code>n</code> 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。</p>
<p>&emsp;&emsp;至于动态规划的另一个重要特性「最优子结构」，下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。</p>
<h3 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h3><p>&emsp;&emsp;给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// coins 中是可选硬币面值，amount 是目标金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;这个问题是动态规划问题，因为它具有「最优子结构」的。<strong>要符合「最优子结构」，子问题间必须互相独立</strong>。为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p>
<p>1.暴力递归</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> dp(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dp</span><span class="params">(coins []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  res := n+<span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> _,value := <span class="keyword">range</span> coins &#123;</span><br><span class="line">    subproblem := dp [n-value]</span><br><span class="line">    <span class="keyword">if</span> subproblem == <span class="number">-1</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 <code>amount = 11, coins = &#123;1,2,5&#125;</code> 时画出递归树看看:</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-28-04.jpg" alt="avatar"></p>
<p><strong>递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间</strong>。</p>
<p>子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p>
<p>2.带备忘录的递归</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  mem := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(mem); i++ &#123;</span><br><span class="line">    mem[i] = amount+<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp(coins, amount, mem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dp</span><span class="params">(coins []<span class="keyword">int</span>, n <span class="keyword">int</span>, mem []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> mem[n] &lt; n+<span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mem[n]</span><br><span class="line">  &#125;</span><br><span class="line">  res := n+<span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> _,value := <span class="keyword">range</span> coins &#123;</span><br><span class="line">    subproblem := dp [coins, n-value, mem]</span><br><span class="line">    <span class="keyword">if</span> subproblem == <span class="number">-1</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line">  &#125;</span><br><span class="line">  mem[n] = res</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 <code>n</code>，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p>
<p>3.dp 数组的迭代解法(推荐)</p>
<p>&emsp;&emsp;迭代就是将递归转化成for循环。</p>
<p>&emsp;&emsp;<strong><code>dp</code></strong> <strong>数组的定义：当目标金额为</strong> <strong><code>i</code></strong> <strong>时，至少需要</strong> <strong><code>dp[i]</code></strong> <strong>枚硬币凑出</strong>。</p>
<p>根据我们文章开头给出的动态规划代码框架可以写出如下解法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> amount &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">  dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">    dp[i] = amount+<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// base case</span></span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 外层 for 循环在遍历所有状态的所有取值</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=amount; i++ &#123;</span><br><span class="line">    <span class="comment">// 内层 for 循环在求所有选择的最小值</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> coins &#123;</span><br><span class="line">      <span class="keyword">if</span> i-value &lt; <span class="number">0</span> &#123; <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      dp[i] = min(dp[i], <span class="number">1</span>+dp[i-value])  <span class="comment">// 状态转移方程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> dp[amount] == amount+<span class="number">1</span> &#123; <span class="comment">// 说明没有合适的方案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> a&lt;b &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;PS：为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。</p>
<h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定一个包含非负整数的 <code>m*n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-30-08.jpeg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[1,2,3],[4,5,6]]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D;&#x3D; grid.length</span><br><span class="line">n &#x3D;&#x3D; grid[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 200</span><br><span class="line">0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p>算法思路：由于路径的方向只能是向下或向右，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。</p>
<p>对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。</p>
<p>创建二维数组<em>dp</em>，与原始网格的大小相同，*dp[i] [j]<em>表示从左上角出发到(i,j)位置的最小路径和。显然，</em>dp[0] [0]=grid[0] [0]*。对于 <em>dp</em> 中的其余元素，通过以下状态转移方程计算元素值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当 i&gt;0 且 j&#x3D;0 时，dp[i][0]&#x3D;dp[i−1][0]+grid[i][0]。</span><br><span class="line">当 i&#x3D;0 且 j&gt;0 时，dp[0][j]&#x3D;dp[0][j−1]+grid[0][j]。</span><br><span class="line">当 i&gt;0 且 j&gt;0 时，dp[i][j]&#x3D;min(dp[i−1][j],dp[i][j−1])+grid[i][j]。</span><br></pre></td></tr></table></figure>

<p>最后得到 *dp[m−1] [n−1]*的值即为从网格左上角到网格右下角的最小路径和。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minPathSum</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(grid)) <span class="comment">// 初始化切片的行</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(grid); i++ &#123; <span class="comment">// 初始化切片的列</span></span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>] <span class="comment">// 初始化起始点值</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(grid[<span class="number">0</span>]); i++ &#123; <span class="comment">// 初始化第一行的值</span></span><br><span class="line">        dp[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i]+dp[<span class="number">0</span>][i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(grid); i++ &#123; <span class="comment">//初始化第一列的值</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">1</span> &amp;&amp; <span class="built_in">len</span>(grid[<span class="number">0</span>]) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="built_in">len</span>(grid[<span class="number">0</span>])<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid[<span class="number">0</span>]) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(grid)<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(grid); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;<span class="built_in">len</span>(grid[<span class="number">0</span>]); j++ &#123;</span><br><span class="line">            dp[i][j] = min(dp[i<span class="number">-1</span>][j]+grid[i][j],dp[i][j<span class="number">-1</span>]+grid[i][j]) <span class="comment">// 状态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(grid)<span class="number">-1</span>][<span class="built_in">len</span>(grid[<span class="number">0</span>])<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a&lt;b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a class="link" href="https://leetcode-cn.com/problems/trapping-rain-water/">接雨水<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="rainwatertrap.png" alt="rainwatertrap"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</span><br></pre></td></tr></table></figure>

<p>算法思路：对于下标 <em>i</em>，下雨后水能到达的最大高度等于下标 <em>i</em> 两边的最大高度的最小值，下标 <em>i</em> 处能接的雨水量等于下标 <em>i</em> 处的水能到达的最大高度减去 *height[i]*。</p>
<p>朴素的做法是对于数组 <em>height</em> 中的每个元素，分别向左和向右扫描并记录左边和右边的最大高度，然后计算每个下标位置能接的雨水量。假设数组 <em>height</em> 的长度为 <em>n</em>，该做法需要对每个下标位置使用 <em>O(n)</em> 的时间向两边扫描并得到最大高度，因此总时间复杂度是 *O(n<sup>2</sup>)*。</p>
<p>上述做法的时间复杂度较高是因为需要对每个下标位置都向两边扫描。如果已经知道每个位置两边的最大高度，则可以在 <em>O(n)</em> 的时间内得到能接的雨水总量。使用动态规划的方法，可以在 <em>O(n)</em> 的时间内预处理得到每个位置两边的最大高度。</p>
<p>创建两个长度为 <em>n</em> 的数组 <em>leftMax</em> 和 <em>rightMax</em>。对于 <em>0≤i&lt;n</em>，<em>leftMax[i]</em> 表示下标 <em>i</em> 及其左边的位置中，<em>height</em> 的最大高度，<em>rightMax[i]</em> 表示下标 <em>i</em> 及其右边的位置中，<em>height</em> 的最大高度。显然，*leftMax[0]=height[0]*，<br>*rightMax[n−1]=height[n−1]*。两个数组的其余元素的计算如下：</p>
<ul>
<li>当 <em>1≤i≤n−1</em> 时，*leftMax[i]=max(leftMax[i−1],height[i])*；</li>
<li>当 <em>0≤i≤n−2</em> 时，*rightMax[i]=max(rightMax[i+1],height[i])*。</li>
</ul>
<p>因此可以正向遍历数组 <em>height</em> 得到数组 <em>leftMax</em> 的每个元素值，反向遍历数组 <em>height</em> 得到数组 <em>rightMax</em> 的每个元素值。在得到数组 <em>leftMax</em> 和 <em>rightMax</em> 的每个元素值之后，对于 <em>0≤i&lt;n</em>，下标 <em>i</em> 处能接的雨水量等于<br>*min(leftMax[i],rightMax[i])−height[i]*。遍历每个下标位置即可得到能接的雨水总量。动态规划做法可以由下图体现。</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-29-30.jpg" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l := <span class="built_in">len</span>(height)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftMax := <span class="built_in">make</span>([]<span class="keyword">int</span>, l)</span><br><span class="line">    rightMax := <span class="built_in">make</span>([]<span class="keyword">int</span>, l)</span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">    rightMax[l<span class="number">-1</span>] = height[l<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;l; i++ &#123;  <span class="comment">// 从左向右遍历，得到i位置处左边的最高值</span></span><br><span class="line">        leftMax[i] = max(leftMax[i<span class="number">-1</span>],height[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=l<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i-- &#123; <span class="comment">// 从右向左遍历，得到i位置处右边的最高值</span></span><br><span class="line">        rightMax[i] = max(rightMax[i+<span class="number">1</span>],height[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;l; i++ &#123;</span><br><span class="line">        ret += min(leftMax[i],rightMax[i])-height[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a&lt;b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a&gt;b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;<strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a class="link" href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-ji-ben-ji-qiao/dong-tai-gui-hua-xiang-jie-jin-jie">动态规划解题套路框架<i class="fas fa-external-link-alt"></i></a></p>
<p>2.<a href="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB">动态规划和贪心算法的区别</a></p>
<p>3.<a class="link" href="https://www.jianshu.com/p/99327f542c8a">【数据结构】贪心算法和动态规划<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>动态规划(DP)</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针算法总结</title>
    <url>/2021/05/08/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="双指针算法类型"><a href="#双指针算法类型" class="headerlink" title="双指针算法类型"></a>双指针算法类型</h1><p>&emsp;&emsp;双指针的问题主要可以归为两类，一类是「快慢指针」，主要解决链表中的问题，比如典型的判定链表中是否包含环；另一类是「左右指针」，主要解决数组（或者字符串）中的问题，比如二分查找。</p>
<h2 id="快慢指针的常见算法"><a href="#快慢指针的常见算法" class="headerlink" title="快慢指针的常见算法"></a>快慢指针的常见算法</h2><p>&emsp;&emsp;快慢指针一般都初始化指向链表的头结点 <code>head</code>，前进时快指针 <code>fast</code> 在前，慢指针 <code>slow</code> 在后，巧妙解决一些链表中的问题。</p>
<h3 id="判断链表中是否有环"><a href="#判断链表中是否有环" class="headerlink" title="判断链表中是否有环"></a>判断链表中是否有环</h3><p>&emsp;&emsp;单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。如果链表中不含环，那么这个指针最终会遇到空指针 <code>nil</code> 表示链表到头了，这还好说，可以判断该链表不含环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">    head = head.Next</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 <code>nil</code> 指针作为尾部节点。经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 <code>nil</code>，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。</p>
<p><a class="link" href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="已知链表中含有环，返回这个环的起始位置"><a href="#已知链表中含有环，返回这个环的起始位置" class="headerlink" title="已知链表中含有环，返回这个环的起始位置"></a>已知链表中含有环，返回这个环的起始位置</h3><p><a class="link" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表 II<i class="fas fa-external-link-alt"></i></a></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-21-26.jpg" alt="avatar"></p>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<p>进阶：你是否可以使用 O(1) 空间解决此题？</p>
<p>&emsp;&emsp;当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？</p>
<p>第一次相遇时，假设慢指针 <code>slow</code> 走了 <code>k</code> 步，那么快指针 <code>fast</code> 一定走了 <code>2k</code> 步：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-56-07.jpg" alt="avatar"></p>
<p><strong><code>fast</code></strong> <strong>一定比</strong> <strong><code>slow</code></strong> <strong>多走了</strong> <strong><code>k</code></strong> <strong>步，这多走的</strong> <strong><code>k</code></strong> <strong>步其实就是</strong> <strong><code>fast</code></strong> <strong>指针在环里转圈圈，所以</strong> <strong><code>k</code></strong> <strong>的值就是环长度的「整数倍」</strong>。</p>
<p>说句题外话，之前还有读者争论为什么是环长度整数倍，我举个简单的例子你就明白了，我们想一想极端情况，假设环长度就是 1，如下图：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-57-52.jpg" alt="avatar"></p>
<p>那么 <code>fast</code> 肯定早早就进环里转圈圈了，而且肯定会转好多圈，这不就是环长度的整数倍嘛。</p>
<p>言归正传，设相遇点距环的起点的距离为 <code>m</code>，那么环的起点距头结点 <code>head</code> 的距离为 <code>k - m</code>，也就是说如果从 <code>head</code> 前进 <code>k - m</code> 步就能到达环起点。</p>
<p>巧的是，如果从相遇点继续前进 <code>k - m</code> 步，也恰好到达环起点。你甭管 <code>fast</code> 在环里到底转了几圈，反正走 <code>k</code> 步可以到相遇点，那走 <code>k - m</code> 步一定就是走到环起点了：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-59-23.jpg" alt="avatar"></p>
<p>所以，只要我们把快慢指针中的任一个重新指向 <code>head</code>，然后两个指针同速前进，<code>k - m</code> 步后就会相遇，相遇之处就是环的起点了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            slow = head</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 上面的代码类似 hasCycle 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="keyword">return</span> fast</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="链表的中间结点"><a href="#链表的中间结点" class="headerlink" title=" 链表的中间结点"></a><a class="link" href="https://leetcode-cn.com/problems/middle-of-the-linked-list/"> 链表的中间结点<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;类似上面的思路，我们可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleNode</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当链表的长度是奇数时，<code>slow</code> 恰巧停在中点位置；如果长度是偶数，<code>slow</code> 最终的位置是中间偏右：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-10_21-30-59.jpg" alt="avatar"></p>
<h3 id="查找链表的倒数第-N-个结点"><a href="#查找链表的倒数第-N-个结点" class="headerlink" title="查找链表的倒数第 N 个结点"></a><a class="link" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">查找链表的倒数第 N 个结点<i class="fas fa-external-link-alt"></i></a></h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-10_21-35-57.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1], n &#x3D; 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], n &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;还是使用快慢指针，让快指针先走 <code>n</code> 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 <code>nil</code> 时，慢指针所在的位置就是倒数第 <code>n</code> 个链表节点（<code>n</code> 不会超过链表长度）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123; <span class="comment">// 快指针先走n步</span></span><br><span class="line">        fast = fast.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;</span><br><span class="line">        head = head.Next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    slow.Next = slow.Next.Next  <span class="comment">// 删除这个节点</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a class="link" href="https://leetcode-cn.com/problems/palindrome-linked-list/">回文链表<i class="fas fa-external-link-alt"></i></a></h3><p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<p>&emsp;&emsp;这道题看似很简单，只需要将链表存到数组中，从数组两端开始向中间依次比较，只要有两端的数字不同，立即返回false。可是这样做的空间复杂度为O(n)，有什么办法能将空间复杂度控制为O(1)呢？</p>
<p>&emsp;&emsp;这道题集成了快慢指针，反转链表的操作，很具有代表性。我们要避免使用O(n)的额外空间，就要改变输入，我们可以通过反转后半部分链表，然后将前半部分与后半部分进行比较。该方法可以将空间复杂度降到O(1)，但是在并发环境下，该方法也有缺点，在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。</p>
<p><strong>算法流程：</strong></p>
<p>1.找到前半部分链表的尾节点：可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。若链表有奇数个节点，则中间的节点应该看作是前半部分。</p>
<p>2.反转后半部分链表：同<a class="link" href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表<i class="fas fa-external-link-alt"></i></a>的解决方案。</p>
<p>3.判断是否回文：比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。</p>
<p>4.返回结果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    fast, slow := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123; <span class="comment">// 快慢指针找到中间节点</span></span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123; <span class="comment">// 该链表有偶数个节点</span></span><br><span class="line">        s := reverse(slow)          </span><br><span class="line">        <span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> head.Val != s.Val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            s = s.Next</span><br><span class="line">            head = head.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 该链表有奇数个节点</span></span><br><span class="line">        s := reverse(slow.Next)</span><br><span class="line">        <span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> head.Val != s.Val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            s = s.Next</span><br><span class="line">            head = head.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(p *ListNode)</span> *<span class="title">ListNode</span></span> &#123;  <span class="comment">// 反转链表</span></span><br><span class="line">    h := p</span><br><span class="line">    q := p.Next</span><br><span class="line">    <span class="keyword">for</span> q != <span class="literal">nil</span> &#123;</span><br><span class="line">        temp := q.Next</span><br><span class="line">        q.Next = p</span><br><span class="line">        p = q</span><br><span class="line">        q = temp</span><br><span class="line">    &#125;</span><br><span class="line">    h.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="左右指针的常见算法"><a href="#左右指针的常见算法" class="headerlink" title="左右指针的常见算法"></a>左右指针的常见算法</h2><p>&emsp;&emsp;左右指针在数组中实际是指两个索引值，一般初始化为left:=0, right:=len(array)-1。常见的左右指针算法通常分为四类：1.二分查找；2.两数之和；3.反转数组；4.滑动窗口。其中以滑动窗口最为困难，已经有专门的专题<a href="https://jiahaohong1997.github.io/2021/04/28/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(Sliding-Window)%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/">滑动窗口(Sliding Window)算法框架</a>来介绍。其他三类只要掌握了基本框架，基本都能解决。</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h4 id="二分查找的三种基本框架"><a href="#二分查找的三种基本框架" class="headerlink" title="二分查找的三种基本框架"></a>二分查找的三种基本框架</h4><p>1.寻找某一个特定的数(最基本的二分查找)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		left := <span class="number">0</span></span><br><span class="line">  	right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">for</span> left &lt;= right &#123;  <span class="comment">// 注意符号</span></span><br><span class="line">  			mid := left + (right-left)/<span class="number">2</span>  <span class="comment">// 如果使用(left+right)/2的方式，可能导致溢出</span></span><br><span class="line">    		<span class="keyword">if</span> nums[mid] == target &#123;  <span class="comment">// 一旦找到。立即返回</span></span><br><span class="line">      			<span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">          	left = mid + <span class="number">1</span>  <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	right = mid - <span class="number">1</span>  <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的地方(也是区分于其他框架的地方)：</p>
<ul>
<li>循环中符号是&lt;=</li>
<li>一旦nums[mid]查找到，立即返回mid</li>
<li>left = mid + 1   right = mid - 1</li>
</ul>
<p>2.寻找左侧边界的二分查找</p>
<p>&emsp;&emsp;这个左边界不仅限于target存在于数组中，也可以找到其不在数组时的左边界。举例如下：</p>
<p>nums[] = {2,3,4,5,5,5,6,9,17} , target=5, 其左边界为索引3</p>
<p>nums[] = {2,2,3,4,4,4,6,7,7,8,9,456}, target=5, 其左边界索引为5</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">left_bound</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">-1</span> </span><br><span class="line">  	&#125;</span><br><span class="line">  	left := <span class="number">0</span></span><br><span class="line">  	right := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">for</span> left &lt; right &#123;  <span class="comment">// 注意符号</span></span><br><span class="line">      	mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">      	<span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">        		right = mid <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">          	left = mid + <span class="number">1</span> <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	right = mid <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">  	&#125; </span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> nums[left] == target &#123; <span class="comment">// 等于target，直接返回左边界</span></span><br><span class="line">    		<span class="keyword">return</span> left</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>] &lt; target &#123; <span class="comment">// 如果最后一个数都小于target，此时left指向的是最后一个数，此时将其最为左边界的话直接返回left。如果在一开始就对边界情况做了判断，就不需要对这一条件做判断。</span></span><br><span class="line">      <span class="keyword">return</span> left  <span class="comment">// left=len(nums)-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> left<span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的地方:</p>
<ul>
<li>循环中符号是&lt;，所以当数组只有一个元素时，不会进入for循环，要单独判断；因为是小于符号，所以出循环，left和right都不可能越界，这就意味着如果数组最后一个数 &lt; target，按理说要返回前一个数的索引，但是由于right卡在了数组末尾元素上，循环结束的条件是left=right，所以此时左边界直接返回left，而不需要left-1</li>
<li>查找到nums[mid]=target，不直接返回，让right=mid，锁定住</li>
<li>left = mid+1    right = mid</li>
<li>最终判断一下nums[left]是否等于target，等于说明target在数组中，直接返回left，否则返回left-1</li>
<li>找左边界的时候记得优先判断一下有序数组中最后一个数是否大于target，若最大的数都小于target，说明整个数组的左边界只能由最后一位数来担任，left=len(nums)-1</li>
</ul>
<p>3.寻找右侧边界的二分查找</p>
<p>&emsp;&emsp;这个右边界不仅限于target存在于数组中，也可以找到其不在数组时的右边界。举例如下：</p>
<p>nums[] = {2,3,4,5,5,5,6,9,17} , target=5, 其左边界为索引5</p>
<p>nums[] = {2,2,3,4,4,4,6,7,7,8,9,456}, target=5, 其左边界索引为6</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">right_bound</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">-1</span> </span><br><span class="line">  	&#125;</span><br><span class="line">  	left := <span class="number">0</span></span><br><span class="line">  	right := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">for</span> left &lt; right &#123;  <span class="comment">// 注意符号</span></span><br><span class="line">      	mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">      	<span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">        		left = mid + <span class="number">1</span> <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">          	left = mid + <span class="number">1</span> <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	right = mid <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">  	&#125; </span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">if</span> nums[left] == target &#123; <span class="comment">// 第一位数或最后一位数作为右边界，如果在一开始就对边界情况做了判断，可以不需要对这一个条件做判断</span></span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  	&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[left<span class="number">-1</span>] == target &#123;  <span class="comment">// 注意</span></span><br><span class="line">    		<span class="keyword">return</span> left<span class="number">-1</span></span><br><span class="line">  	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> left</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的地方:</p>
<ul>
<li>循环中符号是&lt;，所以当数组只有一个元素时，不会进入for循环，要单独判断；因为是小于符号，所以出循环，left和right都不可能越界，这就意味着如果数组第一个数 &gt; target，left一定会一直卡在索引0位置上，循环结束的条件是left=right，所以此时left=0，要判断nums[left-1]是否等于target，显然发生了越界，所以直接使用left(=0)作为右边界</li>
<li>查找到nums[mid]=target，不直接返回，让left = mid + 1，锁定住</li>
<li>left = mid + 1   right = mid</li>
<li>最终判断一下nums[left-1]是否等于target，等于说明target在数组中，直接返回left-1，否则返回left</li>
</ul>
<p>&emsp;&emsp;寻找左右边界这两个框架出来的left其实可以看成是一个永远指向target右侧的一个指针(不管这个target是否在数组中)，见下面示意：</p>
<p>··· ···, a,  a, a, [b, b, b, b,] c, c, c, ··· ···</p>
<ul>
<li><p>b是target，[]表示其可能存在在数组中，当找其左边界时，left指针所在位置如下：</p>
<p>  ··· ···, a,  a, a, [b(<em>left</em>), b, b, b,] c, c, c, ··· ···</p>
<p>  当b存在在数组中，则直接输出left，当b不在数组中，则a是其左边界，输出left-1</p>
</li>
<li><p>b是target，[]表示其可能存在在数组中，当找其右边界时，left指针所在位置如下：</p>
<p>  ··· ···, a,  a, a, [b, b, b, b,] c(<em>left</em>), c, c, ··· ···</p>
<p>  当b存在在数组中，则输出left-1，当b不在数组中，则c是其有边界，输出left</p>
</li>
</ul>
<table><tr><td bgcolor="yellow">&emsp;&emsp;总而言之，首先考虑数组只有一个元素或没有元素的情况。之后将target和首位元素做比较，看首位元素是否是其左右边界，或者target可能干脆就不在这个数组的范围内。之后再正式套用上述框架来找左右边界。</td></tr></table>

<h4 id="寻找旋转排序数组中的最小值-II"><a href="#寻找旋转排序数组中的最小值-II" class="headerlink" title="寻找旋转排序数组中的最小值 II"></a><a class="link" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">寻找旋转排序数组中的最小值 II<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]<br>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,5]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p>n == nums.length<br>1 &lt;= n &lt;= 5000<br>-5000 &lt;= nums[i] &lt;= 5000<br>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</p>
<p>&emsp;&emsp;该题相当于要找到数组中最小值的左边界(最小值可能不止一个)。left指针移动的条件是当mid指针所指的数大于right指针所指数，那么mid所指的数一定不可能是边界区域，left=mid+1。当出现nums[mid]&lt;nums[right]时，说明nums[mid]已经在最小值左边界的右方，此时固定住right指针，继续二分查找。有区别的是当出现nums[mid]=nums[right]的情况时，原先的二分查找是严格的赠序数组，可以直接让right=mid，锁定住右边界。但是如出现下面的情况：nums数组为**[3,3,1,3]**，直接让right=mid会跳过中间的小值，所以只需要让right指针减一，缩小搜索范围即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left&lt;right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[right] &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; nums[right] &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="搜索旋转排序数组-II"><a href="#搜索旋转排序数组-II" class="headerlink" title="搜索旋转排序数组 II"></a><a class="link" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组 II<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p>
<p>&emsp;&emsp;在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k（0 &lt;= k &lt; nums.length）</code>上进行了 旋转 ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如，<code> [0,1,2,4,4,4,5,6,6,7]</code> 在下标 5 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p>
<p>&emsp;&emsp;给你 旋转后 的数组 <code>nums</code> 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 5000</span><br><span class="line">-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</span><br><span class="line">题目数据保证 nums 在预先未知的某个下标上进行了旋转</span><br><span class="line">-104 &lt;&#x3D; target &lt;&#x3D; 104</span><br></pre></td></tr></table></figure>



<p>解题思路：</p>
<p>&emsp;&emsp;    找目标数，首先考虑二分查找。但是本题的数组在<code>[left,mid]</code>和<code>[mid,right]</code>两段区间内只有一段是有序的。要用二分查找找target，就必须在有序的区间查找。所以要理清可能出现的三种情况：</p>
<ul>
<li>第一类</li>
</ul>
<p>&emsp;&emsp;对于数组中有重复元素的情况，二分查找时可能会有 <code>nums[lelf]=nums[mid]=nums[right]</code>，此时无法判断区间 <code>[left,mid]</code> 和区间<code>[mid+1,right]</code>哪个是有序的。例如 <code>nums=[3,1,2,3,3,3,3]</code>，<code>target=2</code>，首次二分时无法判断区间 <code>[0,3]</code> 和区间 <code>[4,6] </code>哪个是有序的。对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。</p>
<ul>
<li>第二类</li>
</ul>
<p>&emsp;&emsp;<code>nums=[2,3,4,5,6,7,1]</code> 这种，也就是<code> nums[left] &lt; nums[mid]</code>。此例子中就是 2 &lt; 5；这种情况下，前半部分有序。因此如果 <code>nums[left]&lt;=target&lt;nums[mid]</code>，则在前半部分找，否则去后半部分找。</p>
<ul>
<li>第三类</li>
</ul>
<p>&emsp;&emsp;<code>nums=[6,7,1,2,3,4,5]</code>这种，也就是 <code>nums[left] &gt; nums[mid]</code>。此例子中就是 6 &gt; 2；这种情况下，后半部分有序。因此如果 <code>nums[mid]&lt;target&lt;=nums[right]</code>。则在后半部分找，否则去前半部分找。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;  <span class="comment">// 找具体的数，用&lt;=</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[left] == nums[mid] &amp;&amp; nums[mid] == nums[right] &#123;  <span class="comment">//第一类情况</span></span><br><span class="line">            left++</span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[left] &lt;= nums[mid] &#123;  <span class="comment">// 左边有序</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target &#123;</span><br><span class="line">                right = mid<span class="number">-1</span>  <span class="comment">// 在前半部分找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>   <span class="comment">// 在后半部分找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右边有序 </span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>   <span class="comment">// 在后半部分找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid<span class="number">-1</span>  <span class="comment">// 在前半部分找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="在-D-天内送达包裹的能力"><a href="#在-D-天内送达包裹的能力" class="headerlink" title="在 D 天内送达包裹的能力"></a><a class="link" href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">在 D 天内送达包裹的能力<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</p>
<p>&emsp;&emsp;传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>
<p>&emsp;&emsp;返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：weights &#x3D; [3,2,2,4,1,4], D &#x3D; 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：3, 2</span><br><span class="line">第 2 天：2, 4</span><br><span class="line">第 3 天：1, 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：weights &#x3D; [1,2,3,1,1], D &#x3D; 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第 1 天：1</span><br><span class="line">第 2 天：2</span><br><span class="line">第 3 天：3</span><br><span class="line">第 4 天：1, 1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; D &lt;&#x3D; weights.length &lt;&#x3D; 5 * 104</span><br><span class="line">1 &lt;&#x3D; weights[i] &lt;&#x3D; 500</span><br></pre></td></tr></table></figure>

<p>算法思路：</p>
<p>&emsp;&emsp;假设当船的运载能力为 <code>x</code> 时，我们可以在 <code>days</code> 天内运送完所有包裹，那么只要运载能力大于 <code>x</code>，我们同样可以在 <code>days</code> 天内运送完所有包裹：我们只需要使用运载能力为 <code>x</code> 时的运送方法即可。</p>
<p>&emsp;&emsp;这样一来，我们就得到了一个非常重要的结论：</p>
<p>存在一个运载能力的「下限」$$x _\text { ans }$$，使得当 <code>x</code> ≥ $$x _\text { ans }$$时，我们可以在 <code>days</code> 天内运送完所有包裹；当 <code>x</code>&lt;<br>$$x _\text { ans }$$时，我们无法在 <code>days</code> 天内运送完所有包裹。</p>
<p>&emsp;&emsp;同时，$$x _\text { ans }$$即为我们需要求出的答案。因此，我们就可以使用二分查找的方法找出 $$x _\text { ans }$$的值。在二分查找的每一步中，我们实际上需要解决一个判定问题：给定船的运载能力 <code>x</code>，我们是否可以在 <code>days</code> 天内运送完所有包裹呢？这个判定问题可以通过贪心的方法来解决：</p>
<p>&emsp;&emsp;由于我们必须按照数组 <code>weights</code> 中包裹的顺序进行运送，因此我们从数组 <code>weights</code> 的首元素开始遍历，将连续的包裹都安排在同一天进行运送。当这批包裹的重量大于运载能力 <code>x</code> 时，我们就需要将最后一个包裹拿出来，安排在新的一天，并继续往下遍历。当我们遍历完整个数组后，就得到了最少需要运送的天数。</p>
<p>&emsp;&emsp;我们将「最少需要运送的天数」与 <code>days</code> 进行比较，就可以解决这个判定问题。当其小于等于 <code>days</code> 时，我们就忽略二分的右半部分区间；当其大于 <code>days</code> 时，我们就忽略二分的左半部分区间。</p>
<p><strong>细节</strong></p>
<p>二分查找的初始左右边界应当如何计算呢？</p>
<p>对于左边界而言，由于我们不能「拆分」一个包裹，因此船的运载能力不能小于所有包裹中最重的那个的重量，即左边界为数组 <code>weights</code> 中元素的最大值。</p>
<p>对于右边界而言，船的运载能力也不会大于所有包裹的重量之和，即右边界为数组 <code>weights</code> 中元素的和。</p>
<p>我们从上述左右边界开始进行二分查找，就可以保证找到最终的答案。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shipWithinDays</span><span class="params">(weights []<span class="keyword">int</span>, days <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := weights[<span class="number">0</span>]</span><br><span class="line">    right := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(weights); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> weights[i] &gt; left &#123;  <span class="comment">// 设置运载能力左边界为货物中最大重量</span></span><br><span class="line">            left = weights[i]</span><br><span class="line">        &#125;</span><br><span class="line">        right += weights[i]			<span class="comment">// 设置运载能力有边界为货物总重量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> check <span class="function"><span class="keyword">func</span><span class="params">(<span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">    check = <span class="function"><span class="keyword">func</span><span class="params">(<span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        temp := <span class="number">0</span> <span class="comment">// 一天内运送货物重量的累积</span></span><br><span class="line">        day := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> weights &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">cap</span> &lt; temp+v &#123;  <span class="comment">// 超过🚢的运载能力，天数+1</span></span><br><span class="line">                day++</span><br><span class="line">                temp = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            temp += v</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> temp != <span class="number">0</span> &#123;</span><br><span class="line">            day++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> day&lt;=days &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123; <span class="comment">// 二分查找满足运送天数的🚢运载能力的左边界</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> check(mid) &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a><a class="link" href="https://leetcode-cn.com/problems/search-a-2d-matrix/">搜索二维矩阵<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-02_20-29-44.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-02_20-31-06.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D;&#x3D; matrix.length</span><br><span class="line">n &#x3D;&#x3D; matrix[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 100</span><br><span class="line">-104 &lt;&#x3D; matrix[i][j], target &lt;&#x3D; 104</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;对于本题，主要的思路就是先通过对每行的首个数字组成的序列进行二分查找，首先要判断target是否在最后一行中，如果是的话，直接在最后一行进行二分查找。这么做的目的是如果直接二分查找target的左边界，如果最后一行的首位数小于target，此时不能将接下来继续二分查找的行数定位left-1，要直接在left行(也就是最后一行)进行查找。简单来说，left的最大值只可能是<code>len(matrix)-1</code>，然而要找的左边界是<code>left-1</code>，这样最后一行永远都无法被选中。读者可以自己找一个实际的例子来看一看。</p>
<p>&emsp;&emsp;若不在最后一行，那么就进行二分查找找到target的左边界，这时会出现两种情况：</p>
<ul>
<li>左边界恰好是要找的target，直接返回true</li>
<li>左边界位于非最后一行，定位到target可能出现的那一行<code>row=left-1</code></li>
</ul>
<p>&emsp;&emsp;最后再在找到的行进行二分查找。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(matrix)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    r := <span class="built_in">len</span>(matrix) <span class="comment">// 行数</span></span><br><span class="line">    c := <span class="built_in">len</span>(matrix[<span class="number">0</span>])  <span class="comment">// 列数</span></span><br><span class="line">    <span class="keyword">var</span> row <span class="keyword">int</span></span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 边界情况：target超出了二维数组的范围，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[r<span class="number">-1</span>][c<span class="number">-1</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">1</span> &amp;&amp; matrix[r<span class="number">-1</span>][<span class="number">0</span>] &gt; target &#123; <span class="comment">// 当不止有一行并且target不在最后一行时</span></span><br><span class="line">        <span class="keyword">for</span> left &lt; right &#123; <span class="comment">// 找左边界，可以参考模板2</span></span><br><span class="line">            mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] == target &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] &lt; target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> matrix[left][<span class="number">0</span>] == target &#123; <span class="comment">// 如果left指向的数等于target，直接返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则可以定位target可能出现的行号</span></span><br><span class="line">            row = left<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> r == <span class="number">1</span> &#123;  <span class="comment">// 如果只有一行，则无需二分查找</span></span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果target可能出现在最后一行</span></span><br><span class="line">        row = r<span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leftRow := <span class="number">0</span></span><br><span class="line">    rightRow := c<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> leftRow &lt;= rightRow &#123; <span class="comment">// 使用二分查找在确定的行上查找</span></span><br><span class="line">        mid := leftRow + (rightRow-leftRow)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> matrix[row][mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[row][mid] &gt; target &#123;</span><br><span class="line">            rightRow = mid<span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftRow = mid+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="搜索二维矩阵-II"><a href="#搜索二维矩阵-II" class="headerlink" title="搜索二维矩阵 II"></a><a class="link" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">搜索二维矩阵 II<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-17_16-40-38.jpg" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">19</span>],[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">22</span>],[<span class="number">10</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">17</span>,<span class="number">24</span>],[<span class="number">18</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">26</span>,<span class="number">30</span>]], target = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-17_16-42-30.jpg" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">19</span>],[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">22</span>],[<span class="number">10</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">17</span>,<span class="number">24</span>],[<span class="number">18</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">26</span>,<span class="number">30</span>]], target = <span class="number">20</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m == matrix.length</span><br><span class="line">n == matrix[i].length</span><br><span class="line"><span class="number">1</span> &lt;= n, m &lt;= <span class="number">300</span></span><br><span class="line"><span class="number">-109</span> &lt;= matix[i][j] &lt;= <span class="number">109</span></span><br><span class="line">每行的所有元素从左到右升序排列</span><br><span class="line">每列的所有元素从上到下升序排列</span><br><span class="line"><span class="number">-109</span> &lt;= target &lt;= <span class="number">109</span></span><br></pre></td></tr></table></figure>

<p>算法思路：</p>
<p>&emsp;&emsp;不同于上一题每一行的第一个元素大于前一行的第一个元素，本题要暴力搜索的话需要对每一行进行二分查找。可以考虑先确定目标数可能存在于哪几行内，对这几行进行搜索即可。</p>
<ul>
<li>对每行的最后一个元素进行二分查找，寻找<code>target</code>的左边界，可以确定起始行号</li>
<li>对每一行第一个元素进行二分查找，寻找<code>target</code>的左边界，可以确定终止行号</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    r, c := <span class="built_in">len</span>(matrix)<span class="number">-1</span>,<span class="built_in">len</span>(matrix[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    row1 := <span class="number">0</span></span><br><span class="line">    row2 := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> matrix[r][c] &lt; target &#123; <span class="comment">// 如果最后一个元素小于target，直接返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[r][c] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left,right := <span class="number">0</span>,r</span><br><span class="line">        <span class="keyword">for</span> left&lt;right &#123;</span><br><span class="line">            mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[mid][c] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[mid][c] &gt; target &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        row2 = left <span class="comment">// 起始行号=左边界+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> matrix[r][<span class="number">0</span>] &lt; target &#123;</span><br><span class="line">        row1 = r</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[r][<span class="number">0</span>] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left,right := <span class="number">0</span>,r</span><br><span class="line">        <span class="keyword">for</span> left&lt;right &#123;</span><br><span class="line">            mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] &gt; target &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        row1 = left<span class="number">-1</span> <span class="comment">// 终止行号=左边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fmt.Println(row2)</span></span><br><span class="line">    <span class="comment">// fmt.Println(row1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> row2&gt;row1 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> row2 &lt;= row1 &#123;  <span class="comment">// 对可能的行内进行二分查找</span></span><br><span class="line">        left,right := <span class="number">0</span>,c</span><br><span class="line">        <span class="keyword">for</span> left&lt;=right &#123;</span><br><span class="line">            mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[row2][mid] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[row2][mid] &lt; target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 right = mid<span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        row2++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><a class="link" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p><strong>进阶：</strong></p>
<p>你可以设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题吗?</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [], target &#x3D; 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>&emsp;&emsp;本题直接找左右边界即可，首先判断边界情况：</p>
<ul>
<li>数组为空，直接返回<code>[-1,-1]</code></li>
<li>数组只有一个元素，若该元素=target，返回<code>[0,0]</code>；否则，返回<code>[-1,-1]</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">len</span>(nums) == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] != target) || <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123; <span class="comment">// 找左边界</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nums[left] == target &#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, left)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 找不到target，其左边界是数组中最大的比它小的数</span></span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;    <span class="comment">// 找右边界</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 因为在找左边界的时候已经判断过该数组中是否存在target，能到这一步肯定是存在的。不用顾虑第一个数大 于target的情况</span></span><br><span class="line">    <span class="keyword">if</span> nums[left] == target &#123; <span class="comment">// 右边界是数组第一个数</span></span><br><span class="line">        ret = <span class="built_in">append</span>(ret,left)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右边界是其他数</span></span><br><span class="line">        ret = <span class="built_in">append</span>(ret, left<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="两数之和类题目"><a href="#两数之和类题目" class="headerlink" title="两数之和类题目"></a>两数之和类题目</h3><h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a class="link" href="https://leetcode-cn.com/problems/two-sum/">两数之和<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target  的那两个整数，并返回它们的数组下标。</p>
<p>&emsp;&emsp;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>&emsp;&emsp;你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 &lt;&#x3D; nums.length &lt;&#x3D; 104</span><br><span class="line">-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</span><br><span class="line">-109 &lt;&#x3D; target &lt;&#x3D; 109</span><br><span class="line">只会存在一个有效答案</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	  sort.Ints(nums)  <span class="comment">// 给数组排序</span></span><br><span class="line">  	l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">  	ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;<span class="number">2</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> ret</span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">     		<span class="keyword">if</span> nums[l]&gt;target &#123;</span><br><span class="line">        		<span class="keyword">break</span></span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="keyword">if</span> nums[l]+nums[r] == target &#123;</span><br><span class="line">        		ret = <span class="built_in">append</span>(ret,l,r)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[l]+nums[r] &gt; target &#123;</span><br><span class="line">          	r--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	l++</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>本题也可使用map来做</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        another := target - value</span><br><span class="line">        _, ok := m[another]</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;index, m[another]&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m[value] = index      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a class="link" href="https://leetcode-cn.com/problems/3sum/">三数之和<i class="fas fa-external-link-alt"></i></a></h4><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; nums.length &lt;&#x3D; 3000</span><br><span class="line">-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</span><br></pre></td></tr></table></figure>



<p>算法思路：</p>
<p>&emsp;&emsp;整体思路和两数之和非常像，不过是通过遍历数组固定第一个数，后两个数使用双指针的方式进行查找。注意的是不能输出重复的三元组，所以在遍历的要判断一下是否和之前的数相等，相等则跳过该数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>]==<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;nums&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort.Ints(nums)  <span class="comment">// 排序数组</span></span><br><span class="line">    res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k:=<span class="number">0</span>; k&lt;<span class="built_in">len</span>(nums)<span class="number">-2</span>; k++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[k] &gt; <span class="number">0</span> &#123; <span class="comment">// 如果最小的数都大于0，直接结束循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> k&gt;<span class="number">0</span> &amp;&amp; nums[k] == nums[k<span class="number">-1</span>] &#123; <span class="comment">// 为避免重复，跳过已经出现的数</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tmp := nums[k]</span><br><span class="line">        i,j := k+<span class="number">1</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i&lt;j &#123;</span><br><span class="line">            <span class="keyword">if</span> tmp+nums[i]+nums[j] == <span class="number">0</span> &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res,[]<span class="keyword">int</span>&#123;tmp,nums[i],nums[j]&#125;)</span><br><span class="line">                i++</span><br><span class="line">                j--</span><br><span class="line">                <span class="keyword">for</span> i&lt;j &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123; <span class="comment">// 为避免重复，跳过已经出现的数</span></span><br><span class="line">                    i++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> i&lt;j &amp;&amp; nums[j] == nums[j+<span class="number">1</span>] &#123; <span class="comment">// 为避免重复，跳过已经出现的数</span></span><br><span class="line">                    j--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> tmp+nums[i]+nums[j] &gt; <span class="number">0</span> &#123;</span><br><span class="line">                j--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a><a class="link" href="https://leetcode-cn.com/problems/4sum/">四数之和<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的四元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [], target &#x3D; 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; nums.length &lt;&#x3D; 200</span><br><span class="line">-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</span><br><span class="line">-109 &lt;&#x3D; target &lt;&#x3D; 109</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;类似于三数之和，不过是在三数之和最外层再套一个for循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>]+nums[<span class="number">3</span>] == target&#123;</span><br><span class="line">            <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">3</span>]&#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    sort.Ints(nums)  <span class="comment">// 首先进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums)<span class="number">-3</span>; i++ &#123; <span class="comment">// 最外层循环，固定四元组的第一位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &#123; <span class="comment">// 过滤掉可能出现相同四元组的情况</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span>; j&lt;<span class="built_in">len</span>(nums)<span class="number">-2</span>; j++ &#123; <span class="comment">// 中层循环，遍历数组选择住四元组的第二位</span></span><br><span class="line">            <span class="keyword">if</span> j&gt;i+<span class="number">1</span> &amp;&amp; nums[j]==nums[j<span class="number">-1</span>] &#123; <span class="comment">// 过滤掉可能出现相同四元组的情况</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            l,r := j+<span class="number">1</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> l&lt;r &#123; <span class="comment">// 内层循环，双指针选择四元组的最后两位</span></span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j]+nums[l]+nums[r] == target &#123;</span><br><span class="line">                    res = <span class="built_in">append</span>(res,[]<span class="keyword">int</span>&#123;nums[i],nums[j],nums[l],nums[r]&#125;)</span><br><span class="line">                    l++</span><br><span class="line">                    r--</span><br><span class="line">                    <span class="keyword">for</span> l&lt;r &amp;&amp; nums[l]==nums[l<span class="number">-1</span>] &#123; <span class="comment">// 过滤掉可能出现相同四元组的情况</span></span><br><span class="line">                        l++</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> l&lt;r &amp;&amp; nums[r]==nums[r+<span class="number">1</span>] &#123; <span class="comment">//过滤掉可能出现相同四元组的情况</span></span><br><span class="line">                        r--</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j]+nums[l]+nums[r] &lt; target &#123;</span><br><span class="line">                    l++</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h3><h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a><a class="link" href="https://leetcode-cn.com/problems/reverse-string/">反转字符串<i class="fas fa-external-link-alt"></i></a></h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseString</span><span class="params">(s []<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">    l,r := <span class="number">0</span>,<span class="built_in">len</span>(s)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l&lt;r &#123;</span><br><span class="line">        s[l],s[r] = s[r],s[l]</span><br><span class="line">        l++</span><br><span class="line">        r--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="补充：剑指-Offer-24-反转链表"><a href="#补充：剑指-Offer-24-反转链表" class="headerlink" title="补充：剑指 Offer 24. 反转链表"></a>补充：<a class="link" href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。</p>
<p>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head.Next.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        p := head.Next</span><br><span class="line">        p.Next = head</span><br><span class="line">        head.Next = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line">    first,second,third := head,head.Next,head.Next.Next</span><br><span class="line">    first.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> third.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        second.Next = first</span><br><span class="line">        first = second</span><br><span class="line">        second = third</span><br><span class="line">        third = third.Next</span><br><span class="line">    &#125;</span><br><span class="line">    third.Next = second</span><br><span class="line">    second.Next = first</span><br><span class="line">    <span class="keyword">return</span> third</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><p>&emsp;&emsp;这个类型的题目是很有难度的，有专门的文章进行介绍。<a href="https://jiahaohong1997.github.io/2021/04/28/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(Sliding-Window)%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/">滑动窗口(Sliding Window)算法框架</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a class="link" href="https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-3/shuang-zhi-zhen-ji-qiao">双指针技巧总结<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Uniform Resource Locator (URL)</title>
    <url>/2021/06/09/Uniform%20Resource%20Locator(URL)/</url>
    <content><![CDATA[<h1 id="什么是URL？"><a href="#什么是URL？" class="headerlink" title="什么是URL？"></a>什么是URL？</h1><p>&emsp;&emsp;<strong>URL 代表着是统一资源定位符（*</strong>Uniform Resource Locator*<strong>）</strong>。URL 无非就是一个给定的独特资源在 Web 上的地址。理论上说，每个有效的 URL 都指向一个唯一的资源。这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像，等等。而在实际中，也有一些例外，最常见的情况就是一个 URL 指向了不存在的或是被移动过的资源。由于通过 URL 呈现的资源和 URL 本身由 Web 服务器处理，因此 web 服务器的拥有者需要认真地维护资源以及与它关联的URL。其基本格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">scheme:<span class="comment">//host[:port#]/path/.../[?query-string][#anchor]</span></span><br><span class="line">scheme         指定底层使用的协议(例如：http, https, ftp)</span><br><span class="line">host           HTTP 服务器的 IP 地址或者域名</span><br><span class="line">port#          HTTP 服务器的默认端口是 <span class="number">80</span>，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http:<span class="comment">//www.cnblogs.com:8080/</span></span><br><span class="line">path           访问资源的路径</span><br><span class="line">query-string   发送给 http 服务器的数据</span><br><span class="line">anchor         锚</span><br></pre></td></tr></table></figure>



<h1 id="深入探究"><a href="#深入探究" class="headerlink" title="深入探究"></a>深入探究</h1><p>下面是一些URL的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;developer.mozilla.org</span><br><span class="line">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Learn&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;search?q&#x3D;URL</span><br></pre></td></tr></table></figure>

<p>您可以将上面的这些网址输进您的浏览器地址栏来告诉浏览器加载相关联的页面（或资源）。</p>
<p>&emsp;&emsp;一个URL由不同的部分组成，其中一些是必须的，而另一些是可选的。让我们以下面这个URL为例看看其中最重要的部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.example.com:80&#x2F;path&#x2F;to&#x2F;myfile.html?key1&#x3D;value1&amp;key2&#x3D;value2#SomewhereInTheDocument</span><br></pre></td></tr></table></figure>

<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-14-08.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>http</code> 是协议。浏览器必须使用的协议通常都是<code>HTTP</code>协议或是<code>HTTP</code>协议的安全版，即<code>HTTPS</code>。Web需要它们二者之一，但浏览器也知道如何处理其他协议，比如<code>mailto</code>:（打开邮件客户端）或者<code>ftp</code>:（处理文件传输），所以当你看到这些协议时，不必惊讶。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-18-06.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>www.example.com</code> 是域名。 它表明正在请求哪个Web服务器。或者，可以直接使用<a class="link" href="https://developer.mozilla.org/zh-CN/docs/Glossary/IP_Address">IP address<i class="fas fa-external-link-alt"></i></a>, 但是因为它不太方便，所以它不经常在网络上使用。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-36-49.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>:80</code> 是端口。 它表示用于访问Web服务器上的资源的技术“门”。如果Web服务器使用HTTP协议的标准端口（HTTP为80，HTTPS为443）来授予其资源的访问权限，则通常会被忽略。否则是强制性的。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-52-10.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>/path/to/myfile.html</code> 是网络服务器上资源的路径。在Web的早期阶段，像这样的路径表示Web服务器上的物理文件位置。如今，它主要是由没有任何物理现实的Web服务器处理的抽象。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-53-21.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>?key1=value1&amp;key2=value2</code> 是提供给网络服务器的额外参数。 这些参数是用 <code>&amp; </code>符号分隔的键/值对列表。在返回资源之前，Web服务器可以使用这些参数来执行额外的操作。每个Web服务器都有自己关于参数的规则，唯一可靠的方式来知道特定Web服务器是否处理参数是通过询问Web服务器所有者。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-55-04.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>#SomewhereInTheDocument</code> 是资源本身的另一部分的锚点. 锚点表示资源中的一种“书签”，给浏览器显示位于该“加书签”位置的内容的方向。例如，在HTML文档上，浏览器将滚动到定义锚点的位置;在视频或音频文档上，浏览器将尝试转到锚代表的时间。值得注意的是，＃后面的部分（也称为片段标识符）从来没有发送到请求的服务器。</p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议详解</title>
    <url>/2021/06/17/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>本文主要参考来源<a class="link" href="https://learnku.com/docs/build-web-application-with-golang/031-web-working-mode/3168">《Go Web编程》<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="HTTP协议介绍"><a href="#HTTP协议介绍" class="headerlink" title="HTTP协议介绍"></a>HTTP协议介绍</h2><p>&emsp;&emsp;HTTP协议是一种让web服务器与浏览器(客户端)通过网络发送和接收数据的协议。它建立在TCP之上，默认采用TCP的80端口。浏览器(客户端)每发出一个请求，服务器响应这个请求。在HTTP中，浏览器(客户端)总是通过建立连接并发送一个HTTP请求来发起一个事务，服务端不能主动去和客户端联系，也不能给客户端发送一个回调连接。客户端与服务器端都可以提前终结一个连接。例如，当浏览器下载一个文件时，可以通过“停止键”来中断文件的下载，关闭与服务器的TCP连接。</p>
<p>&emsp;&emsp;HTTP协议是无状态的，同一个客户端的这次请求和上次请求是没有关系的，对于HTTP服务器来说，它并不知道这两个请求是否来自同一个客户端。为了解决这个问题，web程序引入了cookie机制来维护连接的可持续状态。</p>
<h2 id="HTTP请求包-浏览器信息"><a href="#HTTP请求包-浏览器信息" class="headerlink" title="HTTP请求包(浏览器信息)"></a>HTTP请求包(浏览器信息)</h2><p>&emsp;&emsp;请求包(Request)的结构包含3个部分：Request line(请求行)、Request header(请求头)、body(主体)。header 和 body 之间有个空行，请求包的例子所示:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">GET /domains/example/ HTTP/<span class="number">1.1</span>      <span class="comment">// 请求行: 请求方法 请求 URI HTTP 协议/协议版本</span></span><br><span class="line">Host：www.iana.org               <span class="comment">// 服务端的主机名</span></span><br><span class="line">User-Agent：Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.1</span>) AppleWebKit/<span class="number">537.4</span> (KHTML, like Gecko) Chrome/<span class="number">22.0</span><span class="number">.1229</span><span class="number">.94</span> Safari/<span class="number">537.4</span>          <span class="comment">// 浏览器信息</span></span><br><span class="line">Accept：text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*<span class="comment">/*;q=0.8  // 客户端能接收的 mine</span></span><br><span class="line"><span class="comment">Accept-Encoding：gzip,deflate,sdch       // 是否支持流压缩</span></span><br><span class="line"><span class="comment">Accept-Charset：UTF-8,*;q=0.5        // 客户端字符编码集</span></span><br><span class="line"><span class="comment">// 空行,用于分割请求头和消息体</span></span><br><span class="line"><span class="comment">// 消息体,请求资源参数,例如 POST 传递的参数</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;HTTP 协议定义了很多与服务器交互的请求方法，最基本的有 4 种，分别是 GET, POST, PUT, DELETE。一个 URL 地址用于描述一个网络上的资源，而 HTTP 中的 GET, POST, PUT, DELETE 就对应着对这个资源的查，增，改，删 4 个操作。我们最常见的就是 GET 和 POST 了。GET 一般用于获取 / 查询资源信息，而 POST 一般用于更新资源信息。</p>
<p>&emsp;&emsp;通过 fiddler 抓包可以看到如下请求信息:</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-17_10-48-21.jpg" width="70%" height="70%"></div>

<p>&emsp;&emsp;fiddler 抓取的 GET 信息:</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-17_11-05-48.jpg" width="70%" height="70%"></div>

<p>&emsp;&emsp;GET 和 POST 的区别:</p>
<ol>
<li>我们可以看到 GET 请求消息体为空，POST 请求带有消息体。</li>
<li>GET 提交的数据会放在 URL 之后，以 <code>?</code> 分割 URL 和传输数据，参数之间以 <code>&amp;</code>相连，如 <code>EditPosts.aspx?name=test1&amp;id=123456</code>。POST 方法是把提交的数据放在 HTTP 包的 body 中。</li>
<li>GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制。</li>
<li>GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li>
</ol>
<h2 id="HTTP-响应包（服务器信息）"><a href="#HTTP-响应包（服务器信息）" class="headerlink" title="HTTP 响应包（服务器信息）"></a>HTTP 响应包（服务器信息）</h2><p>&emsp;&emsp;我们再来看看 HTTP 的 response 包，他的结构如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK                     <span class="comment">// 状态行</span></span><br><span class="line">Server: nginx/<span class="number">1.0</span><span class="number">.8</span>                 <span class="comment">// 服务器使用的 WEB 软件名及版本</span></span><br><span class="line">Date: Tue, <span class="number">30</span> Oct <span class="number">2012</span> <span class="number">04</span>:<span class="number">14</span>:<span class="number">25</span> GMT     <span class="comment">// 发送时间</span></span><br><span class="line">Content-Type: text/html             <span class="comment">// 服务器发送信息的类型</span></span><br><span class="line">Transfer-Encoding: chunked          <span class="comment">// 表示发送 HTTP 包是分段发的</span></span><br><span class="line">Connection: keep-alive              <span class="comment">// 保持连接状态</span></span><br><span class="line">Content-Length: <span class="number">90</span>                  <span class="comment">// 主体内容长度</span></span><br><span class="line"><span class="comment">// 空行 用来分割消息头和主体</span></span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>... <span class="comment">// 消息体</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Response 包中的第一行叫做状态行，由 HTTP 协议版本号， 状态码， 状态消息三部分组成。</p>
<p>&emsp;&emsp;状态码用来告诉 HTTP 客户端，HTTP 服务器是否产生了预期的 Response。HTTP/1.1 协议中定义了 5 类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别:</p>
<ul>
<li>1XX 提示信息 - 表示请求已被成功接收，继续处理</li>
<li>2XX 成功 - 表示请求已被成功接收，理解，接受</li>
<li>3XX 重定向 - 要完成请求必须进行更进一步的处理</li>
<li>4XX 客户端错误 - 请求有语法错误或请求无法实现</li>
<li>5XX 服务器端错误 - 服务器未能实现合法的请求</li>
</ul>
<p>&emsp;&emsp;我们看下面这个图展示了详细的返回信息，左边可以看到有很多的资源返回码，200 是常用的，表示正常信息，302 表示跳转。response header 里面展示了详细的信息。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-17_11-23-14.jpg" width="70%" height="70%"></div>



<h2 id="HTTP-协议是无状态的和-Connection-keep-alive-的区别"><a href="#HTTP-协议是无状态的和-Connection-keep-alive-的区别" class="headerlink" title="HTTP 协议是无状态的和 Connection: keep-alive 的区别"></a>HTTP 协议是无状态的和 Connection: keep-alive 的区别</h2><p>&emsp;&emsp;无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。</p>
<p>&emsp;&emsp;&emsp;&emsp;HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（面对无连接）。</p>
<p>&emsp;&emsp;&emsp;&emsp;从 HTTP/1.1 起，默认都开启了 Keep-Alive 保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的 TCP 连接。</p>
<p>&emsp;&emsp;&emsp;&emsp;Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同服务器软件（如 Apache）中设置这个时间。</p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin框架源码解析</title>
    <url>/2021/05/25/Gin%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Go框架</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中自定义sort函数</title>
    <url>/2021/06/10/%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89sort%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="sort库基本介绍"><a href="#sort库基本介绍" class="headerlink" title="sort库基本介绍"></a>sort库基本介绍</h2><p>&emsp;&emsp;该包实现了四种基本的排序算法：插入排序、归并排序、堆排序和快速排序。 但是这四种排序方法是不公开的，它们只被用于 sort 包内部使用。所以在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了 sort.Interface 定义的三个方法：获取数据集合长度的 Len() 方法、比较两个元素大小的 Less() 方法和交换两个元素位置的 Swap() 方法，就可以顺利对数据集合进行排序。sort 包会根据实际数据自动选择高效的排序算法。  除此之外，为了方便对常用数据类型的操作，sort 包提供了对[]int 切片、[]float64 切片和[]string 切片完整支持，主要包括：</p>
<ul>
<li>对基本数据类型切片的排序支持</li>
<li>基本数据元素查找</li>
<li>判断基本数据类型切片是否已经排好序</li>
<li>对排好序的数据集合逆序</li>
</ul>
<h2 id="数据集合排序"><a href="#数据集合排序" class="headerlink" title="数据集合排序"></a>数据集合排序</h2><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="Sort-方法的实现方式"><a href="#Sort-方法的实现方式" class="headerlink" title="Sort()方法的实现方式"></a>Sort()方法的实现方式</h4><p>&emsp;&emsp;前面已经提到过，对数据集合（包括自定义数据类型的集合）排序需要实现 sort.Interface 接口的三个方法，我们看以下该接口的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A type, typically a collection, that satisfies sort.Interface can be</span></span><br><span class="line"><span class="comment">// sorted by the routines in this package. The methods require that the</span></span><br><span class="line"><span class="comment">// elements of the collection be enumerated by an integer index.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">		<span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">		Len() <span class="keyword">int</span></span><br><span class="line">		<span class="comment">// Less reports whether the element with</span></span><br><span class="line">		<span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">		Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">		<span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">		Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;当数据集合实现了上面三种方法后，即可调用该包的Sort()方法进行排序。Sort()方法的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sort sorts data.</span></span><br><span class="line"><span class="comment">// It makes one call to data.Len to determine n, and O(n*log(n)) calls to</span></span><br><span class="line"><span class="comment">// data.Less and data.Swap. The sort is not guaranteed to be stable.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span> &#123;</span><br><span class="line">		n := data.Len()</span><br><span class="line">		quickSort(data, <span class="number">0</span>, n, maxDepth(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;从注释中可以知道Sort()方法不能保证排序结果是稳定的。其唯一的参数就是带排序的数据集合。该包还提供了一个方法IsSorted()来判断数据集合是否已经排好顺序，该方法的内部实现依赖于我们自己实现的 Len() 和 Less() 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IsSorted reports whether data is sorted.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSorted</span><span class="params">(data Interface)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		n := data.Len()</span><br><span class="line">		<span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">			<span class="keyword">if</span> data.Less(i, i<span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Reverse-方法的实现方式"><a href="#Reverse-方法的实现方式" class="headerlink" title="Reverse()方法的实现方式"></a>Reverse()方法的实现方式</h4><p>&emsp;&emsp;此外，<em>sort</em>包提供了 Reverse() 方法，可以允许将数据按 Less() 定义的排序方式逆序排序，而不必修改 Less() 代码。方法定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span> <span class="title">Interface</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们可以看到 Reverse() 返回的一个 sort.Interface 接口类型，整个 Reverse() 的内部实现比较有趣：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> reverse <span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="comment">// This embedded Interface permits Reverse to use the methods of</span></span><br><span class="line">		<span class="comment">// another Interface implementation.</span></span><br><span class="line">		Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Less returns the opposite of the embedded implementation&#x27;s Less method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> r.Interface.Less(j, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reverse returns the reverse order for data.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span> <span class="title">Interface</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;reverse&#123;data&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Search()方法的实现方式</p>
<p>&emsp;&emsp;该方法会使用“二分查找”算法来找出能使 f(x)(0&lt;=x&lt;n) 返回 ture 的最小值 i。 前提条件 : f(x)(0&lt;=x&lt;i) 均返回 false, f(x)(i&lt;=x&lt;n) 均返回 ture。<font color="red"> 如果不存在 i 可以使 f(i) 返回 ture, 则返回 n</font>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// Define f(-1) == false and f(n) == true.</span></span><br><span class="line">	<span class="comment">// Invariant: f(i-1) == false, f(j) == true.</span></span><br><span class="line">	i, j := <span class="number">0</span>, n</span><br><span class="line">	<span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">		h := <span class="keyword">int</span>(<span class="keyword">uint</span>(i+j) &gt;&gt; <span class="number">1</span>) <span class="comment">// avoid overflow when computing h</span></span><br><span class="line">		<span class="comment">// i ≤ h &lt; j</span></span><br><span class="line">		<span class="keyword">if</span> !f(h) &#123;</span><br><span class="line">			i = h + <span class="number">1</span> <span class="comment">// preserves f(i-1) == false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			j = h <span class="comment">// preserves f(j) == true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.</span></span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以发现，其内部就是通过二分查找搜索元素是否在已经升序排好的切片中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">11</span></span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">45</span>&#125; <span class="comment">// 注意已经升序排序</span></span><br><span class="line">pos := sort.Search(<span class="built_in">len</span>(s), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s[i] &gt;= x &#125;)</span><br><span class="line"><span class="keyword">if</span> pos &lt; <span class="built_in">len</span>(s) &amp;&amp; s[pos] == x &#123;</span><br><span class="line">    fmt.Println(x, <span class="string">&quot; 在 s 中的位置为：&quot;</span>, pos)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;s 不包含元素 &quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;官方文档还给出了一个猜数字的小程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GuessingGame</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;Pick an integer from 0 to 100.\n&quot;</span>)</span><br><span class="line">		answer := sort.Search(<span class="number">100</span>, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Is your number &lt;= %d? &quot;</span>, i)</span><br><span class="line">			fmt.Scanf(<span class="string">&quot;%s&quot;</span>, &amp;s)</span><br><span class="line">			<span class="keyword">return</span> s != <span class="string">&quot;&quot;</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">&#x27;y&#x27;</span></span><br><span class="line">		&#125;)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Your number is %d.\n&quot;</span>, answer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用示例I"><a href="#使用示例I" class="headerlink" title="使用示例I"></a>使用示例I</h3><p>&emsp;&emsp;下面是一个使用 sort 包对学生成绩排序的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学生成绩结构体</span></span><br><span class="line"><span class="keyword">type</span> StuScore <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span>    <span class="comment">// 姓名</span></span><br><span class="line">    score <span class="keyword">int</span>   <span class="comment">// 成绩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StuScore []StuScore</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScore)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swap()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScore)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  	s[i],s[j] = s[j],s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Less():成绩从低到高排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScore)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> s[i].score &lt; s[j].score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stus := StuScores&#123;</span><br><span class="line">                &#123;<span class="string">&quot;alan&quot;</span>, <span class="number">95</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;hikerell&quot;</span>, <span class="number">91</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;acmfly&quot;</span>, <span class="number">96</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;leao&quot;</span>, <span class="number">90</span>&#125;,</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">		<span class="comment">// 打印未排序的 stus 数据</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Default:\n\t&quot;</span>,stus)</span><br><span class="line">    <span class="comment">//StuScores 已经实现了 sort.Interface 接口 , 所以可以调用 Sort 函数进行排序</span></span><br><span class="line">		sort.Sort(stus)</span><br><span class="line">		<span class="comment">// 判断是否已经排好顺序，将会打印 true</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;IS Sorted?\n\t&quot;</span>, sort.IsSorted(stus))</span><br><span class="line">		<span class="comment">// 打印排序后的 stus 数据</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Sorted:\n\t&quot;</span>,stus)		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;该示例程序的自定义类型 StuScores 实现了 sort.Interface 接口，所以可以将其对象作为 sort.Sort() 和 sort.IsSorted() 的参数传入。运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Default:</span><br><span class="line">     [&#123;alan <span class="number">95</span>&#125; &#123;hikerell <span class="number">91</span>&#125; &#123;acmfly <span class="number">96</span>&#125; &#123;leao <span class="number">90</span>&#125;]</span><br><span class="line">IS Sorted?</span><br><span class="line">     <span class="literal">true</span></span><br><span class="line">Sorted:</span><br><span class="line">     [&#123;leao <span class="number">90</span>&#125; &#123;hikerell <span class="number">91</span>&#125; &#123;alan <span class="number">95</span>&#125; &#123;acmfly <span class="number">96</span>&#125;]</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;可以在学生成绩排序示例中使用 Reverse() 来实现成绩降序排序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sort.Sort(sort.Reverse(stus))</span><br><span class="line">fmt.Println(stus)</span><br></pre></td></tr></table></figure>



<h3 id="使用示例II"><a href="#使用示例II" class="headerlink" title="使用示例II"></a>使用示例II</h3><p>&emsp;&emsp;下面是一个根据文件元信息中文件上传时间顺序进行排序的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">		<span class="string">&quot;sort&quot;</span></span><br><span class="line">  	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baseFormate = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FileMetas <span class="keyword">struct</span> &#123;</span><br><span class="line">  	FileSha1	<span class="keyword">string</span>	<span class="comment">// 文件的哈希值</span></span><br><span class="line">  	FileNames <span class="keyword">string</span></span><br><span class="line">  	FileSize	<span class="keyword">int64</span></span><br><span class="line">  	Location	<span class="keyword">string</span></span><br><span class="line">  	UploadAt	<span class="keyword">string</span>  <span class="comment">// 文件的上传时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByUploadTime []FileMetas</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b ByUploadTime)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">len</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b ByUploadTime)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	b[i],b[j] = b[j],b[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b ByUploadTime)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	iTime,_ := time.Parse(baseFormate,b[i].UploadAt)</span><br><span class="line">  	jTime,_ := time.Parse(baseFormate,b[j].UploadAt)</span><br><span class="line">  	<span class="keyword">return</span> iTime.UnixNano() &gt; jTime.UnixNano()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	fMetaArray := <span class="built_in">make</span>([]FileMetas,<span class="number">0</span>)</span><br><span class="line">  	<span class="keyword">for</span> _, v := <span class="keyword">range</span> fileMetas &#123;  <span class="comment">// 假设fileMetas是一个已经给定储存的文件元信息的map</span></span><br><span class="line">			fMetaArray = <span class="built_in">append</span>(fMetaArray, v)</span><br><span class="line">		&#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 将文件元信息列表按上传时间排序</span></span><br><span class="line">  	sort.Sort(ByUploadAt(fMetaArray))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="sort包已经支持的内部数据类型排序"><a href="#sort包已经支持的内部数据类型排序" class="headerlink" title="sort包已经支持的内部数据类型排序"></a>sort包已经支持的内部数据类型排序</h2><p>&emsp;&emsp;<em>sort</em>包原生支持[]int、[]float64 和[]string 三种内建数据类型切片的排序操作，即不必我们自己实现相关的 Len()、Less() 和 Swap() 方法。</p>
<h3 id="IntSlice-类型及-int-排序"><a href="#IntSlice-类型及-int-排序" class="headerlink" title="IntSlice 类型及[]int 排序"></a><strong>IntSlice 类型及[]int 排序</strong></h3><p>&emsp;&emsp;由于[]int 切片排序内部实现及使用方法与[]float64 和[]string 类似，所以只详细描述该部分。<em>sort</em>包定义了一个 IntSlice 类型，并且实现了 sort.Interface 接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sort sorts data.</span></span><br><span class="line"><span class="comment">// It makes one call to data.Len to determine n, and O(n*log(n)) calls to</span></span><br><span class="line"><span class="comment">// data.Less and data.Swap. The sort is not guaranteed to be stable.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span> &#123;</span><br><span class="line">		n := data.Len()</span><br><span class="line">		quickSort(data, <span class="number">0</span>, n, maxDepth(n))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// IntSlice attaches the methods of Interface to []int, sorting in increasing order.</span></span><br><span class="line"><span class="keyword">type</span> IntSlice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort is a convenience method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123; Sort(p) &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;并且提供的 sort.Ints() 方法使用了该 IntSlice 类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ints sorts a slice of ints in increasing order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ints</span><span class="params">(a []<span class="keyword">int</span>)</span></span> &#123; Sort(IntSlice(a)) &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;所以，对[]int 切片排序更常使用 sort.Ints()，而不是直接使用 IntSlice 类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125; <span class="comment">// 未排序的切片数据</span></span><br><span class="line">sort.Ints(s)</span><br><span class="line">fmt.Println(s) <span class="comment">// 将会输出[1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果要使用降序排序，可以用前面提到的 Reverse() 方法(当然也可以自己实现Len()、Swap()、Less()三个方法，使用sort.Sort()排序)。这里的Reverse()方法中的参数只能是sort.IntSlice()，而不能是sort.Ints()。因为sort.IntSlice()是将s强制类型转换成IntSlice类型，sort.Reverse()实质上改变了其内部的reverse结构存储的IntSlice类型(参考前面的Reverse方法源码)的Less方法，实现反向排序；而sort.Ints()则是实现升序排序的方法，二者有本质区别：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125; <span class="comment">// 未排序的切片数据</span></span><br><span class="line">sort.Sort(sort.Reverse(sort.IntSlice(s)))</span><br><span class="line">fmt.Println(s) <span class="comment">// 将会输出[6 5 4 3 2 1]</span></span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;与IsSorted()对应的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IntsAreSorted tests whether a slice of ints is sorted in increasing order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntsAreSorted</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> IsSorted(IntSlice(a)) &#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;如果要查找整数 x 在切片 a 中的位置，相对于前面提到的 Search() 方法，<em>sort</em>包提供了 SearchInts(),注意，SearchInts() 的使用条件为：<font color="red"><strong>切片 a 已经升序排序</strong></font>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SearchInts searches for x in a sorted slice of ints and returns the index</span></span><br><span class="line"><span class="comment">// as specified by Search. The return value is the index to insert x if x is</span></span><br><span class="line"><span class="comment">// not present (it could be len(a)).</span></span><br><span class="line"><span class="comment">// The slice must be sorted in ascending order.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchInts</span><span class="params">(a []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= x &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Float64Slice-类型及-float64-排序"><a href="#Float64Slice-类型及-float64-排序" class="headerlink" title="Float64Slice 类型及[]float64 排序"></a><strong>Float64Slice 类型及[]float64 排序</strong></h3><p>&emsp;&emsp;实现与 Ints 类似，只看一下其内部实现，要说明一下的是，在上面 Float64Slice 类型定义的 Less 方法中，有一个内部函数 isNaN()。 isNaN() 与<em>math</em>包中 IsNaN() 实现完全相同，<em>sort</em>包之所以不使用 math.IsNaN()，完全是基于包依赖性的考虑，应当看到，<em>sort</em>包的实现不依赖与其他任何包。：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Float64Slice []<span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] || isNaN(p[i]) &amp;&amp; !isNaN(p[j]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123; Sort(p) &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;与 Sort()、IsSorted()、Search() 对应的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64s</span><span class="params">(a []<span class="keyword">float64</span>)</span></span> &#123; Sort(Float64Slice(a)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64sAreSorted</span><span class="params">(a []<span class="keyword">float64</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> IsSorted(Float64Slice(a)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchFloat64s</span><span class="params">(a []<span class="keyword">float64</span>, x <span class="keyword">float64</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= x &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="StringSlice-类型及-string-排序"><a href="#StringSlice-类型及-string-排序" class="headerlink" title="StringSlice 类型及[]string 排序"></a><strong>StringSlice 类型及[]string 排序</strong></h3><p>&emsp;&emsp;两个 string 对象之间的大小比较是基于“字典序”的。实现与 Ints 类似，只看一下其内部实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123; Sort(p) &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;与 Sort()、IsSorted()、Search()对应的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Strings</span><span class="params">(a []<span class="keyword">string</span>)</span></span> &#123; Sort(StringSlice(a)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringsAreSorted</span><span class="params">(a []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> IsSorted(StringSlice(a)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchStrings</span><span class="params">(a []<span class="keyword">string</span>, x <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= x &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="interface-排序与查找"><a href="#interface-排序与查找" class="headerlink" title="[]interface 排序与查找"></a>[]interface 排序与查找</h2><p>&emsp;&emsp;通过前面的内容我们可以知道，只要实现了 <code>sort.Interface</code> 接口，即可通过 sort 包内的函数完成排序，查找等操作。并且 sort 包已经帮我们把<code>[]int</code>,<code>[]float64</code>,<code>[]string</code> 三种类型都实现了该接口，我们可以方便的调用。但是这种用法对于其它数据类型的 slice 不友好，可能我们需要为大量的 struct 定义一个单独的 []struct 类型，再为其实现 <code>sort.Interface</code> 接口，类似这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Persons []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persons)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persons)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persons)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里可以引申一个问题，为什么 sort 包可以完成 <code>[]int</code> 的排序，而不能完成 <code>[]struct</code> 的排序？因为排序涉及到比较两个变量的值，而 struct 可能包含多个属性，程序并不知道你想以哪一个属性或哪几个属性作为衡量大小的标准。如果你能帮助程序完成比较，并将结果返回， sort 包内的方法就可以完成排序，判断，查找等。sort 包提供了以下函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">(slice <span class="keyword">interface</span>&#123;&#125;, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceStable</span><span class="params">(slice <span class="keyword">interface</span>&#123;&#125;, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceIsSorted</span><span class="params">(slice <span class="keyword">interface</span>&#123;&#125;, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">bool</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;通过函数签名可以看到，排序相关的三个函数都接收 <code>[]interface</code>，并且需要传入一个比较函数，用于为程序比较两个变量的大小，因为函数签名和作用域的原因，这个函数只能是 <code>匿名函数</code>。</p>
<h3 id="sort-Slice"><a href="#sort-Slice" class="headerlink" title="sort.Slice"></a><strong>sort.Slice</strong></h3><p>该函数完成 []interface 的排序，举个栗子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">people := []<span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">	&#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">55</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Age &lt; people[j].Age &#125;) <span class="comment">// 按年龄升序排序</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Sort by age:&quot;</span>, people)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Sort by age: [&#123;Gopher <span class="number">7</span>&#125; &#123;Vera <span class="number">24</span>&#125; &#123;Alice <span class="number">55</span>&#125; &#123;Bob <span class="number">75</span>&#125;]</span><br></pre></td></tr></table></figure>



<h3 id="sort-SliceStable"><a href="#sort-SliceStable" class="headerlink" title="sort.SliceStable"></a><strong>sort.SliceStable</strong></h3><p>该函数完成 []interface 的稳定排序，举个栗子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">people := []<span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">	&#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">75</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.SliceStable(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Age &gt; people[j].Age &#125;) <span class="comment">// 按年龄降序排序</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Sort by age:&quot;</span>, people)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Sort by age: [&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">75</span>&#125;	&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>&#125;	&#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;	&#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">7</span>&#125;]</span><br></pre></td></tr></table></figure>



<h3 id="sort-SliceIsSorted"><a href="#sort-SliceIsSorted" class="headerlink" title="sort.SliceIsSorted"></a><strong>sort.SliceIsSorted</strong></h3><p>该函数判断 []interface 是否为有序，举个栗子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">people := []<span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">55</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Age &gt; people[j].Age &#125;) <span class="comment">// 按年龄降序排序</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Sort by age:&quot;</span>, people)</span><br><span class="line">fmt.Println(<span class="string">&quot;Sorted:&quot;</span>,sort.SliceIsSorted(people,<span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Age &lt; people[j].Age &#125;))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Sort by age: [&#123;Bob <span class="number">75</span>&#125; &#123;Alice <span class="number">55</span>&#125; &#123;Vera <span class="number">24</span>&#125; &#123;Gopher <span class="number">7</span>&#125;]</span><br><span class="line">Sorted: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;sort 包没有为 []interface 提供反序函数，但是从 1 和 2 可以看出，我们传入的比较函数已经决定了排序结果是升序还是降序。</p>
<p>&emsp;&emsp;判断 slice 是否为有序，同样取决于我们传入的比较函数，从 3 可以看出，虽然 slice 已经按年龄降序排序，但我们在判断 slice 是否为有序时给的比较函数是判断其是否为升序有序，所以最终得到的结果为 false。</p>
<h3 id="sort-Search"><a href="#sort-Search" class="headerlink" title="sort.Search"></a><strong>sort.Search</strong></h3><p>该函数判断 []interface 是否存在指定元素，举个栗子：</p>
<ul>
<li>升序 slice</li>
</ul>
<p>&emsp;&emsp;sort 包为 <code>[]int</code>,<code>[]float64</code>,<code>[]string</code> 提供的 Search 函数其实也是调用的该函数，因为该函数是使用的二分查找法，所以要求 slice 为升序排序状态。并且判断条件必须为 <code>&gt;=</code>，这也是官方库提供的三个查找相关函数的的写法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">21</span>, <span class="number">234</span>, <span class="number">56</span>&#125;</span><br><span class="line">x := <span class="number">21</span></span><br><span class="line"></span><br><span class="line">sort.Slice(a, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &lt; a[j] &#125;)   <span class="comment">// 升序排序</span></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= x &#125;) <span class="comment">// 查找元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span>(a) &amp;&amp; a[index] == x &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;found %d at index %d in %v\n&quot;</span>, x, index, a)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d not found in %v,index:%d\n&quot;</span>, x, a, index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">found <span class="number">21</span> at index <span class="number">3</span> in [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">21</span> <span class="number">56</span> <span class="number">100</span> <span class="number">200</span> <span class="number">234</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>降序 slice</li>
</ul>
<p>&emsp;&emsp;如果 slice 是降序状态，而我们又不想将其变为升序，只需将判断条件由 <code>&gt;=</code> 变更为 <code>&lt;=</code> 即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a class="link" href="https://github.com/golang/go">golang/go<i class="fas fa-external-link-alt"></i></a></p>
<p>2.<a class="link" href="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example/blob/master/chapter03/03.1.md">sort—排序算法<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Go语言标准库</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>在O(1)时间内删除或查找任意元素</title>
    <url>/2021/06/20/%E5%9C%A8O(1)%E6%97%B6%E9%97%B4%E5%86%85%E5%88%A0%E9%99%A4%E6%88%96%E6%9F%A5%E6%89%BE%E4%BB%BB%E6%84%8F%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>&emsp;&emsp;本文会介绍两道比较有技巧性的算法与数据结构题，都是和随机读取元素相关的。这些问题的技巧性子阿宇如何将哈希表和数组结合起来，使得数组的删除操作时间复杂度变成O(1)。</p>
<h2 id="实现随机集合"><a href="#实现随机集合" class="headerlink" title="实现随机集合"></a>实现随机集合</h2><p><a class="link" href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/">O(1) 时间插入、删除和获取随机元素<i class="fas fa-external-link-alt"></i></a></p>
<p>设计一个支持在<em>平均</em> 时间复杂度 <strong>O(1)</strong> 下，执行以下操作的数据结构。</p>
<ol>
<li>insert(val)：当元素 val 不存在时，向集合中插入该项。</li>
<li>remove(val)：元素 val 存在时，从集合中移除该项。</li>
<li>getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。</li>
</ol>
<p><strong>示例 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化一个空的集合。</span><br><span class="line">RandomizedSet randomSet &#x3D; new RandomizedSet();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span><br><span class="line">randomSet.insert(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回 false ，表示集合中不存在 2 。</span><br><span class="line">randomSet.remove(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom 应随机返回 1 或 2 。</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span><br><span class="line">randomSet.remove(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2 已在集合中，所以返回 false 。</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure>



<p>本题的难点在于两点：</p>
<p>**1、插入，删除，获取随机元素这三个操作的时间复杂度必须都是 O(1)**。</p>
<p><strong>2、**</strong><code>getRandom</code>** <strong>方法返回的元素必须等概率返回随机元素</strong>，也就是说，如果集合里面有 <code>n</code> 个元素，每个元素被返回的概率必须是 <code>1/n</code>。</p>
<p>我们先来分析一下：对于插入，删除，查找这几个操作，哪种数据结构的时间复杂度是 O(1)？</p>
<p><code>HashSet</code> 肯定算一个对吧。哈希集合的底层原理就是一个大数组，我们把元素通过哈希函数映射到一个索引上；如果用拉链法解决哈希冲突，那么这个索引可能连着一个链表或者红黑树。</p>
<p>那么请问对于这样一个标准的 <code>HashSet</code>，你能否在 O(1) 的时间内实现 <code>getRandom</code> 函数？</p>
<p>其实是不能的，因为根据刚才说到的底层实现，元素是被哈希函数「分散」到整个数组里面的，更别说还有拉链法等等解决哈希冲突的机制，基本做不到 O(1) 时间等概率随机获取元素。</p>
<p>根据上面的分析，对于 <code>getRandom</code> 方法，如果想「等概率」且「在 O(1) 的时间」取出元素，一定要满足：<strong>底层用数组实现，且数组必须是紧凑的</strong>。</p>
<p>这样我们就可以直接生成随机数作为索引，从数组中取出该随机索引对应的元素，作为随机元素。</p>
<p><strong>但如果用数组存储元素的话，插入，删除的时间复杂度怎么可能是 O(1) 呢</strong>？</p>
<p>可以做到！对数组尾部进行插入和删除操作不会涉及数据搬移，时间复杂度是 O(1)。</p>
<p><strong>所以，如果我们想在 O(1) 的时间删除数组中的某一个元素</strong> **<code>val</code>**<strong>，可以先把这个元素交换到数组的尾部，然后再</strong> <strong><code>pop</code></strong> <strong>掉</strong>。</p>
<p>交换两个元素必须通过索引进行交换对吧，那么我们需要一个哈希表 <code>m</code> 来记录每个元素值对应的索引。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RandomizedSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    nums []<span class="keyword">int</span></span><br><span class="line">    m    <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">RandomizedSet</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> RandomizedSet&#123;<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>),<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">0</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span> <span class="title">Insert</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.m[val];ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.nums = <span class="built_in">append</span>(this.nums,val) <span class="comment">// 在数组末尾插入val</span></span><br><span class="line">    this.m[val] = <span class="built_in">len</span>(this.nums)<span class="number">-1</span>    <span class="comment">// 将val作为key加入到map中，其value是其在数组中的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span> <span class="title">Remove</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.m[val];!ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    index := this.m[val]</span><br><span class="line">    this.nums[index] = this.nums[<span class="built_in">len</span>(this.nums)<span class="number">-1</span>]  <span class="comment">// 将数组最后一个元素移动到index的位置</span></span><br><span class="line">    this.m[this.nums[index]] = index                <span class="comment">// 更新移动后元素在map中的value值</span></span><br><span class="line">    <span class="built_in">delete</span>(this.m, val)															<span class="comment">// 删除val健值对</span></span><br><span class="line">    this.nums = this.nums[:<span class="built_in">len</span>(this.nums)<span class="number">-1</span>]        <span class="comment">// pop数组最后一个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get a random element from the set. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span> <span class="title">GetRandom</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	i := rand.Intn(<span class="built_in">len</span>(this.nums))    <span class="comment">// i取从0到len(this.nums)-1的随机数</span></span><br><span class="line">    <span class="keyword">return</span> this.nums[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Insert(val);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Remove(val);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.GetRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>用Go语言实现栈</title>
    <url>/2021/08/05/%E7%94%A8Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<h2 id="自定义栈的功能"><a href="#自定义栈的功能" class="headerlink" title="自定义栈的功能"></a>自定义栈的功能</h2><p>&emsp;&emsp;本文旨在通过Go语言来实现一个自定义的栈，其功能包括入栈、出栈、栈容量查询、栈内元素个数查询、栈顶元素查询、是否空栈查询。</p>
<h2 id="栈的初始化"><a href="#栈的初始化" class="headerlink" title="栈的初始化"></a>栈的初始化</h2><p>首先创建一个能保存数据的结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack []<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里声明Stack为空接口类型的切片（Go语言之中的切片可以理解为一个长度可变的数组）。由于Go语言所有类型都实现了空接口，因此任意类型的值都可以存储在Stack之中。</p>
<h2 id="栈的长度及容量"><a href="#栈的长度及容量" class="headerlink" title="栈的长度及容量"></a>栈的长度及容量</h2><p>&emsp;&emsp;由于Stack的底层数据类型是一个切片，我们可以为其实现<code>Len()</code>和<code>Cap()</code>方法用来获取其长度和容量（Go语言之中首字母大写的方法为包外可访问的，类似于Java或者C++之中类的public方法）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;  <span class="comment">// 栈的长度</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(stack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span></span> &#123;  <span class="comment">// 栈的容量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">cap</span>(stack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="查询是否是空栈"><a href="#查询是否是空栈" class="headerlink" title="查询是否是空栈"></a>查询是否是空栈</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="栈的关键方法的实现（Push-、Pop-、Top-）"><a href="#栈的关键方法的实现（Push-、Pop-、Top-）" class="headerlink" title="栈的关键方法的实现（Push()、Pop()、Top()）"></a>栈的关键方法的实现（Push()、Pop()、Top()）</h2><p>&emsp;&emsp;<code>Push()</code>方法的接收器为一个Stack类型的指针（Go指针的写法与C/C++类似，类型前面加上*号）。Go语言的所有方法参数都是值传递，接收器实际也是作为方法的一个参数传递进入方法的。如果传递一切片或者数组进方法，实际是将切片或数组的值拷贝了一份传入了方法之中，此时在方法之中对该切片或数组做的操作都不会影响方法之外的原始值。如果想要方法之中的操作影响到方法外的原始值，则应该使用指针作为参数，对指针的操作会直接反应到内存之中的原始值上去。在这里我们希望更改原始值（往原始的<code>stack</code>之中添加数据）， 所以接收器是一个指针。方法的参数是一个<code>interface&#123;&#125;</code>类型的值，也就是说该方法可以接受任意类型作为参数。方法的实现使用了内建函数<code>append()</code>，往切片对尾部中添加新值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Push</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  *stack = <span class="built_in">append</span>(*stack, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;<code>Top()</code>方法返回一个任意类型的值以及一个<code>error</code>（是的没错，Go语言的方法可以返回多个值）。当stack为空时，返回一个空值和一个<code>error</code>类型的值（这里使用<code>errors</code>包的<code>New()</code>函数创建）。当stack不为空时，返回底层切片的最后一个值和一个空的<code>error</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">Top</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;,error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;Out of index, len is 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>], <span class="literal">nil</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;<code>Pop()</code>方法的接收器同样是一个Stack的指针。其中<code>theStack[:len(theStack) - 1]</code>这种写法，是Go中取子切片的方法，<code>:</code>两边是起始index和结束index。起始index为0时可以省略。结束的index也可以省略，省略时结束index为切片的<code>len()</code>值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;,error)</span></span> &#123;</span><br><span class="line">  theStack := *stack</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(theStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, error.New(<span class="string">&quot;Out of index, len is 0&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  value := theStack[<span class="built_in">len</span>(theStack)<span class="number">-1</span>]</span><br><span class="line">  *stack = theStack[:<span class="built_in">len</span>(theStack)<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Go语言数据结构</category>
      </categories>
      <tags>
        <tag>自定义栈</tag>
      </tags>
  </entry>
  <entry>
    <title>递归算法解决二叉树问题</title>
    <url>/2021/08/18/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="递归算法的原理"><a href="#递归算法的原理" class="headerlink" title="递归算法的原理"></a>递归算法的原理</h1><p>&emsp;&emsp;一个递归函数的调用类似于多个函数的嵌套调用，只不过调用函数和被调函数都是同一个函数。在解决递归问题时，最重要的是不要陷入递归的逻辑中去，视角要以一个节点为根基来考虑整个问题。递归调用时内部的执行过程如下:</p>
<ol>
<li>首先为递归调用建立一个<font color="blue">工作栈</font>，其结构包括值参、局部变量和返回地址；</li>
<li>每次执行递归调用前，把<font color="red">递归函数的值参、局部变量的当前值</font>以及<font color="red">调用后的返回地址</font>压栈；</li>
<li>每次递归调用结束后，将栈顶元素推出，使相应的<font color="red">值参</font>和<font color="red">局部变量</font>恢复为<font color="blue">调用前的值</font>，然后转向返回地址的位置继续执行。</li>
</ol>
<p>&emsp;&emsp;在明确了递归函数的执行过程后，只要把握好如下3个步骤即可：</p>
<ol>
<li>明确递归函数的作用；</li>
<li>明确终止条件和相应的解决办法；</li>
<li>找出函数的等价关系式，提取重复的逻辑缩小问题规模。</li>
</ol>
<h1 id="递归三步走"><a href="#递归三步走" class="headerlink" title="递归三步走"></a>递归三步走</h1><h2 id="1-明确函数功能"><a href="#1-明确函数功能" class="headerlink" title="1.明确函数功能"></a>1.明确函数功能</h2><p>&emsp;&emsp;首先要确定这个函数的具体功能是什么？它的参数有哪些？它的全局变量是什么？递归的时候要根据题目的要求设置函数功能，再根据函数功能来设置函数的参数。</p>
<p>&emsp;&emsp;<font color="red">方法参数：</font>这个方法的参数最好由当前阶段的状态决定。</p>
<p>&emsp;&emsp;<font color="red">返回数据：</font>返回数据是我们遇到递归出口之后，需要告诉前一步递归的信息数据。</p>
<p>注意：</p>
<ul>
<li>递归函数的<strong>返回值</strong>最好设置为<strong>单个元素</strong>，比如说<strong>一个节点</strong>或者<strong>一个数值</strong>，告诉前一步递归我们现在的结果数据即可；</li>
<li>如果返回值是<strong>数组</strong>的话，我们将无法从中提取到任何有效信息来进行操作；</li>
<li>如果结果需要<strong>数组</strong>的话，我们可以将数组作为公共变量返回值为void，我们在方法体里面操作数组即可。</li>
</ul>
<h2 id="2-寻找递归出口"><a href="#2-寻找递归出口" class="headerlink" title="2.寻找递归出口"></a>2.寻找递归出口</h2><p>&emsp;&emsp;在递归函数的一开始，我们应该思考什么时候该结束递归。因此，递归一定要有结束条件，不然会永远的递归下去。<font color="red">递归出口</font>一般为某深度或叶子结点，或非叶子结点（包括根节点）、所有节点等。决定递归出去后要执行的操作。由于我们的节点状态可能需要多个参数来表示，所以我们的递归出口可能并不唯一，可能需要为每一个转台参数安排一个递归出口，确保我们的递归能够确实有效地出去。</p>
<p><font color="blue">特别注意的：</font>每次提交数组的集合（即<code>list(dst())</code>）的时候，要创建一个新的数组<code>copy()</code>来存放结果数组<code>dst()</code>，不然后面操作的都是加入集合<code>list()</code>的那个数组<code>dst()</code>。</p>
<p>&emsp;&emsp;我们的递归出口并不一定都是在最开头的位置，我们一般在最开头设置递归出口是希望递归能以最快的速度出去；但是<strong>有时候我们在对当前节点进行一些相关处理操作之后我们就希望判断一下能不能递归出口</strong>，所以<strong>递归出口有可能是在代码中间的</strong>，大家需要灵活应用。在这一步，我们需要思考题目需要的解在哪里？是<strong>在某一具体的深度</strong>、还是在<strong>叶子结点</strong>、还是在<strong>非叶子结点</strong>（包括<strong>根节点</strong>）、还是在<strong>每个节点</strong>、还是<strong>在从跟结点到叶子结点的路径</strong>？</p>
<ul>
<li>在某一具体深度：<code>if depth &gt;= n</code></li>
<li>在每个节点：<code>if root != nil </code></li>
</ul>
<h2 id="3-找出递推关系"><a href="#3-找出递推关系" class="headerlink" title="3.找出递推关系"></a>3.找出递推关系</h2><p>&emsp;&emsp;类比于数学归纳法。算n的阶乘：</p>
<ul>
<li>初始条件：<code>f(1) = 1</code></li>
<li>递推关系式：<code>f(n) = f(n-1) * n</code></li>
</ul>
<p>递归关系：</p>
<ul>
<li>递：<code>f(n) = n * f(n-1)</code>，将<strong>f(n)→f(n-1)<strong>了。这样，</strong>问题就由n缩小为了n-1</strong>，并且为了原函数<code>f(n)</code>不变，我们需要让<code>f(n-1)</code>乘以<code>n</code>。就这样慢慢从<code>f(n)</code>,<code>f(n-1)</code><strong>“递”</strong>到<code>f(1)</code>。</li>
<li>归：这样就可以从<code>n=1</code>，一步一步<strong>“归”</strong>到<code>n=2,n=3,...</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> n == <span class="number">1</span> &#123; <span class="comment">// 递归出口</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">return</span> f(n<span class="number">-1</span>)*n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="运用递归的二叉树算法题"><a href="#运用递归的二叉树算法题" class="headerlink" title="运用递归的二叉树算法题"></a>运用递归的二叉树算法题</h1><p>&emsp;&emsp;二叉树的递归框架无外乎二叉树的三种遍历方式：前序遍历、中序遍历、后序遍历。在想好递归出口后，就要考虑采用何种方式来遍历整个二叉树有助于我们解决问题。解决这类问题的核心难点是不要深入进递归细节中，不要把自己的大脑当计算机来用！只要着眼于根节点，在设置好递归出口的前提下就能顺利地解题。</p>
<h2 id="1-直接递归遍历整个二叉树后返回根节点"><a href="#1-直接递归遍历整个二叉树后返回根节点" class="headerlink" title="1.直接递归遍历整个二叉树后返回根节点"></a>1.直接递归遍历整个二叉树后返回根节点</h2><p>&emsp;&emsp;此类问题不需要引入一个用于记录和更新极值结果的中间全局变量，只需要对二叉树本身进行操作，所以在传入的方法参数上比较简单，只需要关注于节点本身（以根节点为视角和着眼点）。大多数题目都是针对树结构进行性重建，查找或删除等操作。</p>
<h3 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p><strong>示例 1:</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="tree.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: preorder &#x3D; [-1], inorder &#x3D; [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<p>对于任意一颗树而言，前序遍历的形式总是：</p>
<p><code>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</code><br>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是：</p>
<p><code>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</code></p>
<p>&emsp;&emsp;只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;  <span class="comment">// 递归出口</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  	&#125;</span><br><span class="line">		</span><br><span class="line">  	root := &amp;TreeNode&#123;preorder[<span class="number">0</span>],<span class="literal">nil</span>,<span class="literal">nil</span>&#125; <span class="comment">// 着眼于根节点</span></span><br><span class="line">  	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(inorder); i++ &#123;  <span class="comment">// 找到在中序遍历数组中根节点的位置</span></span><br><span class="line">      	<span class="keyword">if</span> inorder[i] == preorder[<span class="number">0</span>] &#123;</span><br><span class="line">        		<span class="keyword">break</span></span><br><span class="line">      	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	root.Left = buildTree(preorder[<span class="number">1</span>:i+<span class="number">1</span>], inorder[:i])  <span class="comment">// 构建左子树</span></span><br><span class="line">  	root.Right = buildTree(preorder[i+<span class="number">1</span>:], inorder[i+<span class="number">1</span>:])  <span class="comment">// 构建右子树</span></span><br><span class="line">  	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>翻转一棵二叉树。</p>
<p><strong>示例：</strong></p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   	 4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<p>废话少说，直接看代码吧，简单题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	left := invertTree(root.Left)</span><br><span class="line">  	right := invertTree(root.Right)  <span class="comment">// 后序遍历</span></span><br><span class="line">  	root.Left = right</span><br><span class="line">  	root.Right = left</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<p>简单题，直接上代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  <span class="comment">// 递归出口，空节点返回深度0</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	left := maxDepth(root.Left)  <span class="comment">// 左子树深度</span></span><br><span class="line">  	right := maxDepth(root.Right)  <span class="comment">// 右子树深度</span></span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">return</span> <span class="number">1</span>+max(left,right)  <span class="comment">// 返回最终深度=左右子树最大深度+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> a&gt;=b &#123;</span><br><span class="line">  	  <span class="keyword">return</span> a</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>      1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre>
<p> 但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;如果同时满足下面的条件，两个树互为镜像：</p>
<ul>
<li>它们的两个根结点具有相同的值；</li>
<li>每个树的右子树都与另一个树的左子树镜像对称。</li>
</ul>
<p>&emsp;&emsp;我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移；p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> check(root, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(q,p *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> q == <span class="literal">nil</span> &amp;&amp; p == <span class="literal">nil</span> &#123;  <span class="comment">// p，q均为空节点，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> q == <span class="literal">nil</span> || p == <span class="literal">nil</span> &#123; <span class="comment">// p，q只有其中一者为空节点，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 1.p，q节点的值相等；2.q的左节点与p的右节点相等；3.q的右节点与p的左节点相等。</span></span><br><span class="line">    <span class="keyword">return</span> q.Val == p.Val &amp;&amp; check(q.Left,p.Right) &amp;&amp; check(q.Right,p.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="2-设置全局变量实时记录并更新递归过程中的极值"><a href="#2-设置全局变量实时记录并更新递归过程中的极值" class="headerlink" title="2.设置全局变量实时记录并更新递归过程中的极值"></a>2.设置全局变量实时记录并更新递归过程中的极值</h2><p>&emsp;&emsp;此类题目最终的输出是一个单一的值，我们需要维护一个全局变量来记录这一个单一值，并在递归遍历二叉树的过程中实时地更新这个值。用于递归的辅助函数的返回结果不必与这个值直接联系，要着眼于构建二叉树的节点间的关系。</p>
<h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a class="link" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和<i class="fas fa-external-link-alt"></i></a></h3><p><strong>路径</strong>被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p><strong>路径和</strong>是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="exx1.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="exx2.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[1, 3 * 104]</code></li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<ol>
<li>首先考虑辅助函数的功能。考虑实现一个简化的函数 <code>maxGain(node)</code>，该函数计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。具体而言，该函数的计算如下:</li>
</ol>
<ul>
<li>空节点的最大贡献值等于 0。</li>
<li>非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）。</li>
</ul>
<p>例如，考虑如下二叉树。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> -10</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;叶节点 9、15、7 的最大贡献值分别为 9、15、7。得到叶节点的最大贡献值之后，再计算非叶节点的最大贡献值。节点 20 的最大贡献值等于 <code>20+max⁡(15,7)=35</code>。节点 −10 的最大贡献值等于 <code>−10+max⁡(9,35)=25</code>。上述计算过程是递归的过程，因此，对根节点调用函数 <code>maxGain</code>，即可得到每个节点的最大贡献值。</p>
<p>&emsp;&emsp;根据函数 <code>maxGain</code> 得到每个节点的最大贡献值之后，如何得到二叉树的最大路径和？对于二叉树中的一个节点，该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。维护一个全局变量 <code>maxSum</code> 存储最大路径和，在递归过程中更新 <code>maxSum</code> 的值，最后得到的 <code>maxSum</code> 的值即为二叉树中的最大路径和。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">maxPathSum</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	maxSum := math.MinInt32  <span class="comment">// 设置全局变量用于实时比较及更新每个节点作为根节点时的最大路径</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">var</span> gotMax <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span></span><br><span class="line">  	gotMax = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  <span class="comment">// 递归出口</span></span><br><span class="line">        		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      	&#125;</span><br><span class="line">      	</span><br><span class="line">      	left := max(gotMax(root.Left),<span class="number">0</span>)  <span class="comment">// 当前节点的左子树的最大贡献值（如果小于0则置0）</span></span><br><span class="line">      	right := max(gotMax(root.Right),<span class="number">0</span>)  <span class="comment">// 当前节点右子树的最大贡献值（如果小于0则置0）</span></span><br><span class="line">      	now := root.Val + left + right  <span class="comment">// 记录以当前节点作为根节点的最大路径</span></span><br><span class="line">      	maxSum = max(maxSum,now) <span class="comment">// 更新最大值</span></span><br><span class="line">      </span><br><span class="line">      	<span class="keyword">return</span> root.Val+max(left,right)  <span class="comment">// 返回当前节点的最大贡献值</span></span><br><span class="line">  	&#125;</span><br><span class="line">		</span><br><span class="line">  	gotMax(root)</span><br><span class="line">  	<span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> a&gt;=b &#123;</span><br><span class="line">    	<span class="keyword">return</span> a</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
</search>
