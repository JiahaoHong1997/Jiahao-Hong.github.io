<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>滑动窗口(Sliding Window)算法框架</title>
    <url>/2021/04/28/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(Sliding-Window)%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>&emsp;&emsp;滑动窗口主要应用于子串问题，遇到这类问题不要犹豫，直接考虑使用滑动窗口。作为双指针类问题最难掌握的技巧，其设计思路其实非常简单，就是通过两个指针维护一个窗口，通过前后指针的不断向前滑动，然后更新答案。该算法的大致逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">left := <span class="number">0</span></span><br><span class="line">right := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> right &lt; s.size() &#123;</span><br><span class="line">  <span class="comment">// 增大窗口</span></span><br><span class="line">  window.add(s[right])</span><br><span class="line">  right++</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> window needs shrink &#123;</span><br><span class="line">    <span class="comment">// 缩小窗口</span></span><br><span class="line">    window.remove(s[left])</span><br><span class="line">    left++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。其实困扰大家的，不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。</p>
<h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><h3 id="滑动窗口算法代码框架"><a href="#滑动窗口算法代码框架" class="headerlink" title="滑动窗口算法代码框架"></a>滑动窗口算法代码框架</h3><p>&emsp;&emsp;废话少说，直接上代码。下面的框架很适合给出了具体t，要求找出其在主串s中的排列或包含t的子串的问题，可以直接套用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slidingwindow</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span></span> &#123; <span class="comment">// s是主串，t是子串</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据题目条件灵活选择数据结构，其主要作用和目的是判断左边界是否要右移</span></span><br><span class="line">  need := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(t))  <span class="comment">// need用于记录t子串对字符的实际要求</span></span><br><span class="line">  window := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(t)) <span class="comment">// window用于检测当前窗口内满足t子串的要求字符的实际情况</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">    need[t[i]] = <span class="number">1</span>  <span class="comment">// 数量可以是任意数字，根据题目实际需求</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">  	left = <span class="number">0</span> <span class="comment">// 窗口左边界</span></span><br><span class="line">    right = <span class="number">0</span> <span class="comment">// 窗口右边界</span></span><br><span class="line">    valid = <span class="number">0</span> <span class="comment">// 满足条件的字符个数</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">    <span class="comment">// c是要移入窗口的字符</span></span><br><span class="line">    c := s[right]</span><br><span class="line">    <span class="comment">// 右移窗口</span></span><br><span class="line">    right++</span><br><span class="line">    <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">    <span class="comment">/********************/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">    <span class="keyword">for</span> window needs shrink &#123;</span><br><span class="line">      <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">      d := s[left]</span><br><span class="line">      <span class="comment">// 左移窗口</span></span><br><span class="line">      left++</span><br><span class="line">      <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串<i class="fas fa-external-link-alt"></i></a></h3><p><img lazyload src="/images/loading.svg" data-src="https://gblobscdn.gitbook.com/assets%2F-MZLBWp7285NJbpNV7Kv%2Fsync%2F3d5d2bc76cee1f2190a7dd4fcd17445164dc7273.png?alt=media" alt="avatar"></p>
<p>就是说要在 <code>S</code>(source) 中找到包含 <code>T</code>(target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。</p>
<p>如果我们使用暴力解法，代码大概是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">  <span class="keyword">for</span> j:=i+<span class="number">1</span>; j&lt;<span class="built_in">len</span>(s); j++ &#123;</span><br><span class="line">    <span class="keyword">if</span> s[i:j] 包含t中的所有字母 &#123;</span><br><span class="line">      更新答案</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路很直接，但是显然，这个算法的复杂度肯定大于 O(N^2) 了。</p>
<p><strong>滑动窗口算法的思路是这样</strong>：</p>
<p>1、我们在字符串 <code>S</code> 中使用双指针中的左右指针技巧，初始化 <code>left = right = 0</code>，把索引<strong>左闭右开</strong>区间 <code>[left, right)</code> 称为一个「窗口」。</p>
<p>2、我们先不断地增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code>，直到窗口中的字符串符合要求（包含了 <code>T</code> 中的所有字符）。</p>
<p>3、此时，我们停止增加 <code>right</code>，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含 <code>T</code> 中的所有字符了）。同时，每次增加 <code>left</code>，我们都要更新一轮结果。</p>
<p>4、重复第 2 和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</p>
<p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，</strong>也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p>
<p>下面画图理解一下，<code>needs</code> 和 <code>window</code> 相当于计数器，分别记录 <code>T</code> 中字符出现次数和「窗口」中的相应字符的出现次数。</p>
<p>初始状态：</p>
<p><img lazyload src="/images/loading.svg" data-src="image-20210429193510364.png" alt="image-20210429193510364"></p>
<p>增加 <code>right</code>，直到窗口 <code>[left, right]</code> 包含了 <code>T</code> 中所有字符：</p>
<p><img lazyload src="/images/loading.svg" data-src="image-20210429193608894.png" alt="image-20210429193608894"></p>
<p>现在开始增加 <code>left</code>，缩小窗口 <code>[left, right]</code>。</p>
<p><img lazyload src="/images/loading.svg" data-src="image-20210429193630917.png" alt="image-20210429193630917"></p>
<p>直到窗口中的字符串不再符合要求，<code>left</code> 不再继续移动。</p>
<p><img lazyload src="/images/loading.svg" data-src="image-20210429194033697.png" alt="image-20210429194033697"></p>
<p>之后重复上述过程，先移动 <code>right</code>，再移动 <code>left</code>…… 直到 <code>right</code> 指针到达字符串 <code>S</code> 的末端，算法结束。</p>
<p><strong>现在开始套模板，只需要思考以下四个问题</strong>：</p>
<p>1、当移动 <code>right</code> 扩大窗口，即加入字符时，应该更新哪些数据？</p>
<p>2、什么条件下，窗口应该暂停扩大，开始移动 <code>left</code> 缩小窗口？</p>
<p>3、当移动 <code>left</code> 缩小窗口，即移出字符时，应该更新哪些数据？</p>
<p>4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p>
<p>如果一个字符进入窗口，应该增加 <code>window</code> 计数器；如果一个字符将移出窗口的时候，应该减少 <code>window</code> 计数器；当 <code>valid</code> 满足 <code>need</code> 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    need := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125; <span class="comment">// 根据t子串记录实际的需求</span></span><br><span class="line">    window := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125; <span class="comment">// 记录窗口内满足要求的字符的情况</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(t); i++ &#123; <span class="comment">// 将子串t中字符的实际需求用need来记录</span></span><br><span class="line">        need[t[i]]++</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">  	    left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        valid = <span class="number">0</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 本题要求返回子串，所以引入start和length来记录子串的起始和长度</span></span><br><span class="line">        start = <span class="number">0</span> <span class="comment">// 记录最小覆盖子串的起始索引</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)+<span class="number">1</span> <span class="comment">//记录最小覆盖子串的长度</span></span><br><span class="line">    )</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="comment">// 加入窗口</span></span><br><span class="line">        c := s[right]</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 检查c是否在need的需求中，若在则加入window(进行窗口内数据的一系列更新)</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := need[c]; ok &#123;</span><br><span class="line">          window[c]++     </span><br><span class="line">          <span class="comment">// 若字符c的个数已经满足了need中的要求</span></span><br><span class="line">    	    <span class="keyword">if</span> window[c] == need[c] &#123;</span><br><span class="line">      	        valid++</span><br><span class="line">    	    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fmt.Printf(&quot;window1: [%d, %d)\n&quot;, left, right)  // debug专用</span></span><br><span class="line">        <span class="comment">// 当window内的所有字符都满足了需求，判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">for</span> valid == <span class="built_in">len</span>(need) &#123;</span><br><span class="line">            <span class="keyword">if</span> right - left &lt; length &#123;</span><br><span class="line">                start = left</span><br><span class="line">                length = right - left</span><br><span class="line">            &#125;</span><br><span class="line">      </span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            d := s[left]</span><br><span class="line">            <span class="comment">// 左边界右移缩小窗口</span></span><br><span class="line">            left++</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> _, ok := need[d]; ok &#123;</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d] &#123;</span><br><span class="line">                    valid--</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fmt.Printf(&quot;window2: [%d, %d)\n&quot;, left, right)  // debug专用      </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> length == <span class="built_in">len</span>(s)+<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s[start:start+length]</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a><a class="link" href="https://leetcode-cn.com/problems/permutation-in-string/">字符串的排列<i class="fas fa-external-link-alt"></i></a></h3><p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的 <strong>子串</strong> 。</p>
<p>示例 1：</p>
<p>输入: s1 = “ab” s2 = “eidbaooo”<br>输出: True<br>解释: s2 包含 s1 的排列之一 (“ba”).</p>
<p>示例 2：</p>
<p>输入: s1= “ab” s2 = “eidboaoo”<br>输出: False</p>
<p><strong>提示：</strong></p>
<ul>
<li>输入的字符串只包含小写字母</li>
<li>两个字符串的长度都在 <code>[1, 10,000]</code> 之间</li>
</ul>
<p>这种题目，是明显的滑动窗口算法，<strong>相当给你一个</strong> <strong><code>S1</code></strong> <strong>和一个</strong> **<code>S2</code>**，请问你 <strong><code>S2</code></strong> <strong>中是否存在一个子串，包含</strong> <strong><code>S1</code></strong> <strong>中所有字符且不包含其他字符</strong>？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkInclusion</span><span class="params">(s1 <span class="keyword">string</span>, s2 <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    need := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    window := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(s1); i++ &#123;</span><br><span class="line">        need[s1[i]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        valid = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s2) &#123;</span><br><span class="line">        window[s2[right]]++</span><br><span class="line">				</span><br><span class="line">      	<span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := need[s2[right]]; ok &#123;</span><br><span class="line">            <span class="keyword">if</span> window[s2[right]] == need[s2[right]] &#123;</span><br><span class="line">                valid++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right++</span><br><span class="line">        </span><br><span class="line">      	<span class="comment">// 在这里判断是否找到了合法的子串</span></span><br><span class="line">        <span class="keyword">if</span> valid == <span class="built_in">len</span>(need) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right &gt;= <span class="built_in">len</span>(s1) &#123;</span><br><span class="line">            <span class="keyword">if</span> _, ok := need[s2[left]]; ok &#123;</span><br><span class="line">                <span class="keyword">if</span> window[s2[left]] == need[s2[left]] &#123;</span><br><span class="line">                    valid--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            window[s2[left]]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：</p>
<p>1、本题移动 <code>left</code> 缩小窗口的时机是窗口大小大于 <code>S1.size()</code> 时，应为排列嘛，显然长度应该是一样的。</p>
<p>2、当发现 <code>valid == len(need)</code> 时，就说明窗口中就是一个合法的排列，所以立即返回 <code>true</code>。</p>
<p>至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。</p>
<h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a><a class="link" href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p>
<p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p>
<p>说明：</p>
<p>字母异位词指字母相同，但排列不同的字符串。<br>不考虑答案输出的顺序。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br></pre></td></tr></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br></pre></td></tr></table></figure>

<p>和上一个示例几乎一模一样，只不过函数返回的东西不同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findAnagrams</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    need := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    window := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line">        need[p[i]]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        valid = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        c := s[right]</span><br><span class="line">        window[c]++</span><br><span class="line">        right++</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> _,ok := need[c]; ok&#123;</span><br><span class="line">            <span class="keyword">if</span> window[c] == need[c] &#123;</span><br><span class="line">                valid++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> valid == <span class="built_in">len</span>(need) &#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, left)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right &gt;= <span class="built_in">len</span>(p) &#123;</span><br><span class="line">            d := s[left]</span><br><span class="line">            <span class="keyword">if</span> _,ok := need[d]; ok &#123;</span><br><span class="line">                <span class="keyword">if</span> window[d] == need[d] &#123;</span><br><span class="line">                    valid--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            window[d]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a class="link" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<p>&emsp;&emsp;这个题终于有了点新意，不是一套框架就出答案，不过反而更简单了，稍微改一改框架就行了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    window := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        c := s[right]</span><br><span class="line">        window[c]++</span><br><span class="line">        right++</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 每当新进入窗口的字符出现多次，窗口左边界便开始右移，知道窗口内没有重复字符</span></span><br><span class="line">        <span class="keyword">for</span> window[c]&gt;<span class="number">1</span> &#123; </span><br><span class="line">            d := s[left]</span><br><span class="line">            window[d]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        ret = max(ret, right-left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a&gt;b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS算法框架</title>
    <url>/2021/04/08/BFS%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>&emsp;&emsp;本系列文章是我在阅读<a class="link" href="https://labuladong.gitbook.io/algo/">《labuladong的算法小抄》<i class="fas fa-external-link-alt"></i></a>一书，再结合自己在Leetcode上刷题后的一些体会和总结。本系列文章的所有代码均由Golang语言实现，使用别的语言的读者不妨尝试转换成自己熟悉的语言实现。不过如果你选择用Python来刷算法题，有一个问题需要注意，Python的效率降低，在机试过程中可能出现同一道题，用C/C++或者Golang的人能暴力AC，而用Python却可能会运行超时，会吃不小的亏，还请结合自身情况来考虑选择哪门语言来实现。读者若需要了解更多的细节，还请阅读此书并结合实际多刷刷题。</p>
<h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><h3 id="BFS的应用场景"><a href="#BFS的应用场景" class="headerlink" title="BFS的应用场景"></a>BFS的应用场景</h3><p>&emsp;&emsp;此类问题的本质就是在一幅「图」(树是特殊的图)中找到起始点(start)到终点(target)的最近距离。实际上，此类问题利用DFS也能做到，但是DFS实质上就是回溯算法，时间复杂度很高。BFS的时间代价是O(N)，其代价就是空间复杂度很高。在二叉树中，BFS对应的就是二叉树的层序遍历。</p>
<p>&emsp;&emsp;这类问题可以有各种各样的变体，比如：1.走迷宫，迷宫中有的格子是围墙，不能通过，要求从起点到终点的最短距离是多少？2.两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？3.连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？这些问题都没啥奇技淫巧，本质上就是一幅「图」，让你从一个起点，走到终点，问最短路径。这就是 BFS 的本质，框架搞清楚了直接默写就好。</p>
<h3 id="算法思路-Golang"><a href="#算法思路-Golang" class="headerlink" title="算法思路(Golang)"></a>算法思路(Golang)</h3><p>&emsp;&emsp;所有的BFS问题的核心数据结构：队列q用于存储节点。用node指向当前要出队的节点，当该节点出队时，其相邻节点入队。对于非二叉树这种结构(没有子节点到父节点的指针，不会走回头路)的数据形式，还需要一个建立一个map类型来保存已经走过的节点，防止走回头路。</p>
<p>&emsp;&emsp;BFS最常见于二叉树中，先给一个二叉树的BFS(层序遍历)框架。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">二叉树：[3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层序遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFS</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ret := [][]<span class="keyword">int</span>&#123;&#125;  <span class="comment">// 因为该示例要按每层返回遍历结果，所以要初始化一个二维切片</span></span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  <span class="comment">// 如果根节点为空，返回空切片</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  q := []*TreeNode&#123;root&#125;  <span class="comment">// 初始化队列用于存储节点</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; <span class="built_in">len</span>(q)&gt;<span class="number">0</span>; i++ &#123;  <span class="comment">// 当队列不为空，说明还有节点没有遍历完，继续循环</span></span><br><span class="line">    ret = <span class="built_in">append</span>(ret, []<span class="keyword">int</span>&#123;&#125;)  <span class="comment">// 初始化用于存储树的每一层的切片</span></span><br><span class="line">    p := []*TreeNode&#123;&#125;  <span class="comment">// 切片p用于记录树的每一层节点</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(q); j++ &#123;</span><br><span class="line">      node := q[j]  <span class="comment">// 某一层的节点顺序出队</span></span><br><span class="line">      ret[i] = <span class="built_in">append</span>(ret[i], node.Val) <span class="comment">// 存入当前节点</span></span><br><span class="line">      <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123; <span class="comment">// 如果左节点不为空，左节点入队</span></span><br><span class="line">        p = <span class="built_in">append</span>(p, node.Left) </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123; <span class="comment">// 如果右节点不为空，右节点入队</span></span><br><span class="line">        p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    q = p; <span class="comment">// 更新队列q，保存下一层的节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果不要求用二维数组分别保存每一层的节点，可以不需要切片p，直接在每个节点出队时将其左右节点送入队列p即可。</p>
<p>&emsp;&emsp;通用框架，主要区别在于多了一个map类型用来记录已经遍历过的节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define num is the number of node</span></span><br><span class="line"><span class="comment"> * Define the Type of node if NodeType</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFS</span><span class="params">(start NodeType, target NodeType)</span></span> &#123;</span><br><span class="line">  q := []NodeType&#123;start&#125; <span class="comment">// 起始节点入队</span></span><br><span class="line">  m := <span class="built_in">make</span>(<span class="keyword">map</span>[NodeType]<span class="keyword">int</span>, num) <span class="comment">// 避免走回头路</span></span><br><span class="line">  m[start] = <span class="number">1</span> <span class="comment">// 记录起始节点</span></span><br><span class="line">  step := <span class="number">0</span>  <span class="comment">// 记录扩散的步数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(q)</span><br><span class="line">    p := []NodeType&#123;&#125;</span><br><span class="line">    <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">      node := q[i]</span><br><span class="line">      <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">      <span class="keyword">if</span> node = target &#123;</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 将 node 的相邻节点加入队列 */</span></span><br><span class="line">      <span class="keyword">for</span> Node x : node.adj() &#123; <span class="comment">// 判断node是否有相邻节点，根据数据形式自行更改</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := m[x]; !ok &#123; <span class="comment">// 如果节点没有被记录过，则可以入队</span></span><br><span class="line">          p = <span class="built_in">append</span>(p, x)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">    step++</span><br><span class="line">    q = p <span class="comment">// 该层所有节点遍历介绍，q保存下一层节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实际案例-二叉树"><a href="#实际案例-二叉树" class="headerlink" title="实际案例(二叉树)"></a>实际案例(二叉树)</h2><p>我们来看几道Leetcode上的题目。</p>
<h3 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a class="link" href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<pre><code>        3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回锯齿形层序遍历如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>​        怎么套到 BFS 的框架里呢？首先明确一下起点 start 和终点 target 是什么，怎么判断到达了终点？</p>
<p><strong>显然起点就是</strong> <strong>root</strong> <strong>根节点，终点就是最后一个叶子节点。</strong>不过在存储的过程中要注意，奇数行要倒序排列，偶数行正序排列。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    ret := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; <span class="built_in">len</span>(q)&gt;<span class="number">0</span>; i++ &#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">        p := []*TreeNode&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(q) ; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span> &#123; <span class="comment">// 如果是偶数行，则正序排列</span></span><br><span class="line">                node := q[j]</span><br><span class="line">                ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是奇数行，则倒叙排列</span></span><br><span class="line">                node := q[<span class="built_in">len</span>(q)<span class="number">-1</span>-j]</span><br><span class="line">                ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line">            &#125;</span><br><span class="line">            nodeInP := q[j]</span><br><span class="line">            <span class="keyword">if</span> nodeInP.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, nodeInP.Left)</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> nodeInP.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, nodeInP.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [2,null,3,null,4,null,5,null,6]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数的范围在 <code>[0, 105]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p><strong>显然起点就是</strong> <strong><code>root</code></strong> <strong>根节点，终点就是最靠近根节点的那个「叶子节点」</strong>，叶子节点就是两个子节点都是 <code>nil</code> 的节点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    step := <span class="number">1</span>  <span class="comment">// 记录层数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        p := []*TreeNode&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">            node := q[i]</span><br><span class="line">            <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123; <span class="comment">// 当遇到第一个子节点，就返回该节点所在层数</span></span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p>
<p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的<code>null</code>节点也计入长度）之间的长度。</p>
<p><strong>示例 1:</strong></p>
<p>输入: </p>
<pre><code>       1
     /   \
    3     2
   / \     \  
  5   3     9 
  
输出: 4
解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。
</code></pre>
<p><strong>示例 2:</strong></p>
<p>输入: </p>
<pre><code>      1
     /  
    3    
   / \       
  5   3     
  
输出: 2
解释: 最大值出现在树的第 3 层，宽度为 2 (5,3)。
</code></pre>
<p>示例 3:</p>
<p>输入: </p>
<pre><code>      1
     / \
    3   2 
   /        
  5      
  
输出: 2
解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。
</code></pre>
<p><strong>示例 4:</strong></p>
<p>输入: </p>
<pre><code>      1
     / \
    3   2
   /     \  
  5       9 
 /         \
6           7

输出: 8
解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。
</code></pre>
<p><strong>注意:</strong> 答案在32位有符号整数的表示范围内。</p>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;一开始很自然的想到利用层序遍历，遍历的节点存在以下情况：</p>
<ul>
<li>当前节点是空节点，则将两个空节点推入下一层的队列；</li>
<li>当前节点不是空节点：<ul>
<li>当前节点的左节点为空，则将一个空节点推入下一层的队列；左节点不为空，则将左节点推入下一层的队列；</li>
<li>当前节点的右节点为空，则将一个空节点推入下一层的队列；右节点不为空，则将右节点推入下一层的队列。</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;当一层遍历完之后，分别从收尾收缩下一层的队列，直到队首和队尾元素均不是空节点为止。然后将此时的队列长度和返回值做比较。</p>
<p>可是，在实际的测试过程中发现内存溢出了。这种方式对内存的占用时巨大的。</p>
<p>&emsp;&emsp;然后考虑到完全二叉树的性质，若按层序遍历的顺序给所有的节点编号，则对于每个节点<code>i</code>的左子树，其编号为<code>2*i</code>；其右子树编号为<code>2*i+1</code>，这样就可以为每一个节点编号，直接用每一层的最后一个节点的编号减去第一个节点的编号并加1就是每一层的宽度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> pair <span class="keyword">struct</span> &#123;</span><br><span class="line">    node        *TreeNode</span><br><span class="line">    position    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a&gt;=b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">widthOfBinaryTree</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    q := <span class="built_in">make</span>([]*pair,<span class="number">0</span>)</span><br><span class="line">    q = <span class="built_in">append</span>(q, &amp;pair&#123;root,<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; <span class="built_in">len</span>(q)&gt;<span class="number">0</span>; i++ &#123;</span><br><span class="line">        p := <span class="built_in">make</span>([]*pair,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        l := <span class="built_in">len</span>(q)</span><br><span class="line">        ret = max(ret, q[l<span class="number">-1</span>].position-q[<span class="number">0</span>].position+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;l; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> q[j].node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, &amp;pair&#123;q[j].node.Left,q[j].position*<span class="number">2</span>&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> q[j].node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, &amp;pair&#123;q[j].node.Right,q[j].position*<span class="number">2</span>+<span class="number">1</span>&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实际案例-其他数据结构方式"><a href="#实际案例-其他数据结构方式" class="headerlink" title="实际案例(其他数据结构方式)"></a>实际案例(其他数据结构方式)</h2><h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a class="link" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D;&#x3D; grid.length</span><br><span class="line">n &#x3D;&#x3D; grid[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 300</span><br><span class="line">grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39;</span><br></pre></td></tr></table></figure>

<p>算法思路：</p>
<p>&emsp;&emsp;遍历整个二维网格，当节点值为1时，以这个节点为起始进行广度优先搜索，当其相邻节点值为1时，进入队列，并将这些入队的节点值置为0。当不再有节点入队，说明已经达到了岛屿的边界，返回原始的循环。同时可以初始化一个map用于记录已经遍历过的节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>  <span class="comment">// 初始化map类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">len</span>(grid) <span class="comment">// 行数</span></span><br><span class="line">    c := <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="comment">// 列数</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, r*c) <span class="comment">// 用于记录已经遍历过的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;r; i++ &#123; <span class="comment">// 遍历整个二维网格</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;c; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;0&#x27;</span> || m[i*c+j] == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当节点值为&#x27;1&#x27;时以该节点为起始进行广度优先搜索</span></span><br><span class="line">                count++                </span><br><span class="line">                BFS(grid, i, j)</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span> <span class="comment">// 将当前遍历节点置&#x27;0&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFS</span><span class="params">(grid [][]<span class="keyword">byte</span>, i <span class="keyword">int</span>, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    r := <span class="built_in">len</span>(grid)</span><br><span class="line">    c := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    q := []<span class="keyword">int</span>&#123;i*c+j&#125; <span class="comment">// 队列中保存的是节点编号，以行优先的方式对所有节点编号</span></span><br><span class="line">    m[i*c+j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        p := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k:=<span class="number">0</span>; k&lt;<span class="built_in">len</span>(q); k++ &#123;</span><br><span class="line">            node := q[k]</span><br><span class="line">            nodeR := node/c <span class="comment">// 当前节点的行号</span></span><br><span class="line">            nodeC := node%c <span class="comment">// 当前节点的列号</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nodeR&gt;<span class="number">0</span> &amp;&amp; grid[nodeR<span class="number">-1</span>][nodeC] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的上方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[(nodeR<span class="number">-1</span>)*c+nodeC]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, (nodeR<span class="number">-1</span>)*c+nodeC)</span><br><span class="line">                    grid[nodeR<span class="number">-1</span>][nodeC] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[(nodeR<span class="number">-1</span>)*c+nodeC] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nodeR&lt;r<span class="number">-1</span> &amp;&amp; grid[nodeR+<span class="number">1</span>][nodeC] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的下方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[(nodeR+<span class="number">1</span>)*c+nodeC]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, (nodeR+<span class="number">1</span>)*c+nodeC)</span><br><span class="line">                    grid[nodeR+<span class="number">1</span>][nodeC] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[(nodeR+<span class="number">1</span>)*c+nodeC] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nodeC&gt;<span class="number">0</span> &amp;&amp; grid[nodeR][nodeC<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的左方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[nodeR*c+(nodeC<span class="number">-1</span>)]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, nodeR*c+(nodeC<span class="number">-1</span>))</span><br><span class="line">                    grid[nodeR][nodeC<span class="number">-1</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[nodeR*c+(nodeC<span class="number">-1</span>)] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nodeC&lt;c<span class="number">-1</span> &amp;&amp; grid[nodeR][nodeC+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &#123; <span class="comment">// 搜索当前节点的右方节点</span></span><br><span class="line">                <span class="keyword">if</span> _, ok := m[nodeR*c+(nodeC+<span class="number">1</span>)]; !ok &#123;</span><br><span class="line">                    p = <span class="built_in">append</span>(p, nodeR*c+(nodeC+<span class="number">1</span>))</span><br><span class="line">                    grid[nodeR][nodeC+<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">                    m[nodeR*c+(nodeC+<span class="number">1</span>)] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p <span class="comment">// 进入下一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a class="link" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表<i class="fas fa-external-link-alt"></i></a></h3><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p>
<p>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p>
<p><strong>示例 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; numCourses &lt;&#x3D; 105</span><br><span class="line">0 &lt;&#x3D; prerequisites.length &lt;&#x3D; 5000</span><br><span class="line">prerequisites[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; ai, bi &lt; numCourses</span><br><span class="line">prerequisites[i] 中的所有课程对 互不相同</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;算法思路：我们使用一个队列来进行广度优先搜索。初始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。并初始化一个长度为numCourses的切片precourse，用于记录每个节点(课程)的入度。在广度优先搜索的每一步中，我们取出队首的节点 ，将该节点的相邻边(也就是将本课程作为预修课程的其他课程)减1(precource对应索引的值减1)。当节点入度为0时，将其作为下一层节点加入队列中。最后遍历precourse切片，若切片中所有元素为0，说明找到了一种拓扑排序，返回true，否则返回false。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    precourse := <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(prerequisites); i++ &#123; <span class="comment">// 初始化所有节点的入度(记录所有课程的预修课程数)</span></span><br><span class="line">        precourse[prerequisites[i][<span class="number">0</span>]]++</span><br><span class="line">    &#125;</span><br><span class="line">    q := []<span class="keyword">int</span>&#123;&#125; <span class="comment">// 初始化队列用于存储入度为0的节点(不需要预修课程的课)</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> precourse[i] == <span class="number">0</span> &#123; <span class="comment">// 将入度为0的节点入队</span></span><br><span class="line">            q = <span class="built_in">append</span>(q, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        p := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">            node := q[i]</span><br><span class="line">            <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="built_in">len</span>(prerequisites); j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> prerequisites[j][<span class="number">1</span>] == node &#123; <span class="comment">// 查看所有以当前课程为预修课程的课</span></span><br><span class="line">                    precourse[prerequisites[j][<span class="number">0</span>]]-- <span class="comment">// 入度减1</span></span><br><span class="line">                    <span class="keyword">if</span> precourse[prerequisites[j][<span class="number">0</span>]] == <span class="number">0</span> &#123; <span class="comment">// 当入度为0，入队</span></span><br><span class="line">                        p = <span class="built_in">append</span>(p, prerequisites[j][<span class="number">0</span>])</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123; <span class="comment">// 查看是否所有节点入度为0</span></span><br><span class="line">        <span class="keyword">if</span> precourse[i] != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a class="link" href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 &#x3D; 4 + 4 + 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 &#x3D; 4 + 9</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 104</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;算法思路：本题可以采用贪心+BFS的策略，实际上是从上到下逐层构造 N 元树。我们以 BFS（广度优先搜索）的方式遍历它。在 N 元树的每一级，我们都在枚举相同大小的组合。其中每个节点表示数字 n 的余数减去一个完全平方数的组合，我们的任务是在树中找到一个节点，该节点满足两个条件：</p>
<p>(1) 节点的值（即余数）也是一个完全平方数。<br>(2) 在满足条件（1）的所有节点中，节点和根之间的距离应该最小。</p>
<p>下面是这棵树的样子：</p>
<p><img lazyload src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjc5LzI3OV9ncmVlZHlfdHJlZS5wbmc?x-oss-process=image/format,png" alt="avatar"></p>
<ul>
<li>首先，我们准备小于给定数字 n 的完全平方数列表（即 powlist）。</li>
<li>然后创建 q队列 遍历，该变量将保存所有剩余项在每个级别的枚举。在主循环中，我们迭代 q 变量。在每次迭代中，我们检查余数是否是一个完全平方数。如果余数不是一个完全平方数，就用其中一个完全平方数减去它，得到一个新余数，然后将新余数添加到 p 中，以进行下一级的迭代。一旦遇到一个完全平方数的余数，我们就会跳出循环，这也意味着我们找到了解。</li>
<li>注意：这里我们使用 set ，以消除同一级别中的剩余项的冗余。</li>
</ul>
<p>&emsp;&emsp;如果看文字难以理解，最好以n=12为例，画一画整个树的层级结构，能有更深的理解。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSquares</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    powlist := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i*i&lt;=n; i++ &#123; <span class="comment">// 完全平方数表</span></span><br><span class="line">        powlist = <span class="built_in">append</span>(powlist, i*i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">10000</span>) <span class="comment">// 用于记录冗余项，只需要在每层中第一次出现时保存，就能保证层数最少</span></span><br><span class="line">    level := <span class="number">0</span> <span class="comment">// 记录层级</span></span><br><span class="line">    q := []<span class="keyword">int</span>&#123;n&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q)&gt;<span class="number">0</span> &#123;</span><br><span class="line">        level++</span><br><span class="line">        p := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">            node := q[i] <span class="comment">// 当前节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _,value := <span class="keyword">range</span> powlist &#123; <span class="comment">// 贪心算法，构造树</span></span><br><span class="line">                <span class="keyword">if</span> value == node &#123; <span class="comment">// 第一次出现完全平方数，说明在这一层级就能解决问题，直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> level</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; node &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> set[node-value] == <span class="literal">false</span> &#123; <span class="comment">// 相当于剪枝操作</span></span><br><span class="line">                        p = <span class="built_in">append</span>(p, node-value) <span class="comment">// 记录下一层级的节点</span></span><br><span class="line">                        set[node-value] = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a class="link" href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/bfs-suan-fa/bfs-kuang-jia">BFS 算法解题套路框架<i class="fas fa-external-link-alt"></i></a></p>
<p>2.<a class="link" href="https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/">完全平方数<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>广度优先搜索(BFS)</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划(Dynamic Programming)算法框架</title>
    <url>/2021/04/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92(Dynamic-Programming)%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>&emsp;&emsp;在一开始学习算法的时候，我对动态规划和贪心算法一直都只有个模糊的概念，不明白两者到底有什么区别，感觉思路都差不太多。于是在本文的开头，我想对比一下贪心算法和动态规划的区别和联系。动态规划和贪心算法都是用来求最优化问题，且二者都必须具有最有子结构。动态规划的整体策略是一种自底向上的结构，贪心算法是自顶向下的结构。贪心算法可以解决的问题，动态规划都能解决，可以说，贪心算法是动态规划的一个特例。贪心算法和动态规划<strong>最大的不同</strong>在于，它并不是首先寻找子问题的最优解，然后在其中进行选择，而是首先做一次贪心选择——在当时（局部）看来最有选择——然后求解选出的子问题，从而不必费心求解所有可能相关的子问题。</p>
<p>&emsp;&emsp;动态规划具有两个性质：1）重叠子问题；2）<em><em><em>最优子结构*<strong>。贪心算法具有的两个性质：1）贪心选择性质；2）</strong></em>最优子结构</em>*</em>。动态规划就是为了消除其重叠子问题而设计的。<strong>其实贪心算法是一种特殊的动态规划，由于其具有贪心选择性质，保证了子问题只会被计算一次，不会被多次计算，因此贪心算法其实是最简单的动态规划。</strong></p>
<h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><h3 id="动态规划-DP-思维框架"><a href="#动态规划-DP-思维框架" class="headerlink" title="动态规划(DP)思维框架"></a>动态规划(DP)思维框架</h3><p>&emsp;&emsp;首先引用<a class="link" href="https://labuladong.gitbook.io/algo/">📋《labuladong的算法小抄》<i class="fas fa-external-link-alt"></i></a>中对动态规划问题的分析。</p>
<p>&emsp;&emsp;<strong>动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离等等。既然目标是求最值，那么<strong>DP的核心问题就是穷举</strong>。动态规划的穷举是很特别的，它存在以下三要素：</p>
<ul>
<li><strong>重叠子问题</strong>：如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</li>
<li><strong>最优子结构</strong>：动态规划问题一定具备最优子结构，才能通过子问题的最值得到原问题的最值。</li>
<li><strong>状态转移方程</strong>：动态规划问题的难点和关键，找到正确的状态转移方程，问题基本就能得到解决。</li>
</ul>
<p>&emsp;&emsp;由此可以得到一个基本的思维框架用于解决这类问题：<strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p>
<p>&emsp;&emsp;按上面的套路走，最后的结果就可以套这个框架：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"><span class="comment">// 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。</p>
<h3 id="动态规划杀手锏"><a href="#动态规划杀手锏" class="headerlink" title="动态规划杀手锏"></a>动态规划杀手锏</h3><h4 id="动态规划需要注意的要点："><a href="#动态规划需要注意的要点：" class="headerlink" title="动态规划需要注意的要点："></a>动态规划需要注意的要点：</h4><ul>
<li><p>“问5”法则判断问题是否是动态规划，例如最优解，最小或者最大等等；</p>
</li>
<li><p>如果判断属于动态规划的话，接下来我们可以根据“问4”法则求解：</p>
</li>
<li><ul>
<li>状态（小规模问题的数学表示）</li>
<li>状态转移方程（大规模问题如何转化为更小的问题）</li>
<li>最小状态（最小规模的问题）</li>
<li>要求的返回值是什么</li>
</ul>
</li>
</ul>
<h4 id="杀手锏"><a href="#杀手锏" class="headerlink" title="杀手锏"></a>杀手锏</h4><p><strong>1）建模：</strong></p>
<ul>
<li><p><strong>最优子结构</strong></p>
</li>
<li><p><strong>状态转移方程</strong></p>
</li>
<li><p><strong>边界</strong></p>
</li>
</ul>
<p><strong>2）实现：</strong></p>
<ul>
<li><p><strong>暴力递归</strong></p>
</li>
<li><p><strong>备忘录法（从上倒下，非全二叉树，hash保存！）</strong></p>
</li>
<li><p><strong>自底而上（迭代实现）</strong></p>
</li>
</ul>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>1.暴力递归</p>
<p>斐波那契数列的数学形式就是递归的，写成代码就是这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(N <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> N == <span class="number">1</span> || N==<span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fib(N<span class="number">-1</span>)+fib(N<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-24-30.jpg" alt="avatar"></p>
<p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p>
<p>&emsp;&emsp;这个递归树怎么理解？就是说想要计算原问题 <code>f(20)</code>，我就得先计算出子问题 <code>f(19)</code> 和 <code>f(18)</code>，然后要计算 <code>f(19)</code>，我就要先算出子问题 <code>f(18)</code> 和 <code>f(17)</code>，以此类推。最后遇到 <code>f(1)</code> 或者 <code>f(2)</code> 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。<strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p>
<p>&emsp;&emsp;观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p>
<p>&emsp;&emsp;这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p>
<p>2.带备忘录的递归解法</p>
<p>&emsp;&emsp;即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(N <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> N &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">  mem := <span class="built_in">make</span>([]<span class="keyword">int</span>, N+<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 进行带备忘录的递归</span></span><br><span class="line">  <span class="keyword">return</span> helper(mem, N)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(mem []<span class="keyword">int</span>, N <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">// base case</span></span><br><span class="line">  <span class="keyword">if</span> N == <span class="number">1</span> || N == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 已经计算过</span></span><br><span class="line">  <span class="keyword">if</span> mem[N] != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mem[N]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新备忘录</span></span><br><span class="line">  mem[N] = help(N<span class="number">-1</span>)+help[N<span class="number">-2</span>]</span><br><span class="line">  <span class="keyword">return</span> mem[N]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-25-26.jpg" alt="avatar"></p>
<p>&emsp;&emsp;实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p>
<p>&emsp;&emsp;至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p>
<p>&emsp;&emsp;啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-26-03.jpg" alt="avatar"></p>
<p>&emsp;&emsp;啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 <code>f(1)</code> 和 <code>f(2)</code> 开始往上推，直到推到我们想要的答案 <code>f(20)</code>，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p>
<p>3.DP数组的迭代解法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(N <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> N &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> N == <span class="number">1</span> || N == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, N+<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化base case</span></span><br><span class="line">  dp[<span class="number">1</span>], dp[<span class="number">2</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">3</span>; i&lt;=N; i++ &#123;</span><br><span class="line">    dp[i] = dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]  <span class="comment">// 状态转移方程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[N]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-26-32.jpg" alt="avatar"></p>
<p>&emsp;&emsp;画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p>
<p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-27-29.jpg" alt="avatar"></p>
<p>&emsp;&emsp;为啥叫「状态转移方程」？其实就是为了听起来高端。你把 <code>f(n)</code> 想做一个状态 <code>n</code>，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 相加转移而来，这就叫状态转移，仅此而已。</p>
<p>&emsp;&emsp;你会发现，上面的几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着暴力解法。</p>
<p>&emsp;&emsp;<strong>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong>。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p>
<p>&emsp;&emsp;这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(N <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> N &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> N == <span class="number">1</span> || N == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; </span><br><span class="line">  prev := <span class="number">1</span></span><br><span class="line">  curr := <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">3</span>; i&lt;=N; i++ &#123;</span><br><span class="line">    sum := prev + curr <span class="comment">// 新状态由前两个状态之和求得</span></span><br><span class="line">    prev = curr  <span class="comment">// 保存当前状态</span></span><br><span class="line">    curr = sum   <span class="comment">// 保存前一个状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> curr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个技巧就是所谓的「<strong>状态压缩</strong>」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 <code>n</code> 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。</p>
<p>&emsp;&emsp;至于动态规划的另一个重要特性「最优子结构」，下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。</p>
<h3 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h3><p>&emsp;&emsp;给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// coins 中是可选硬币面值，amount 是目标金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;这个问题是动态规划问题，因为它具有「最优子结构」的。<strong>要符合「最优子结构」，子问题间必须互相独立</strong>。为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p>
<p>1.暴力递归</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> dp(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dp</span><span class="params">(coins []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  res := n+<span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> _,value := <span class="keyword">range</span> coins &#123;</span><br><span class="line">    subproblem := dp [n-value]</span><br><span class="line">    <span class="keyword">if</span> subproblem == <span class="number">-1</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 <code>amount = 11, coins = &#123;1,2,5&#125;</code> 时画出递归树看看:</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-28-04.jpg" alt="avatar"></p>
<p><strong>递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间</strong>。</p>
<p>子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。</p>
<p>2.带备忘录的递归</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  mem := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(mem); i++ &#123;</span><br><span class="line">    mem[i] = amount+<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp(coins, amount, mem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dp</span><span class="params">(coins []<span class="keyword">int</span>, n <span class="keyword">int</span>, mem []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> mem[n] &lt; n+<span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mem[n]</span><br><span class="line">  &#125;</span><br><span class="line">  res := n+<span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> _,value := <span class="keyword">range</span> coins &#123;</span><br><span class="line">    subproblem := dp [coins, n-value, mem]</span><br><span class="line">    <span class="keyword">if</span> subproblem == <span class="number">-1</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line">  &#125;</span><br><span class="line">  mem[n] = res</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 <code>n</code>，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。</p>
<p>3.dp 数组的迭代解法(推荐)</p>
<p>&emsp;&emsp;迭代就是将递归转化成for循环。</p>
<p>&emsp;&emsp;<strong><code>dp</code></strong> <strong>数组的定义：当目标金额为</strong> <strong><code>i</code></strong> <strong>时，至少需要</strong> <strong><code>dp[i]</code></strong> <strong>枚硬币凑出</strong>。</p>
<p>根据我们文章开头给出的动态规划代码框架可以写出如下解法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> amount &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">  dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">    dp[i] = amount+<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// base case</span></span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 外层 for 循环在遍历所有状态的所有取值</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=amount; i++ &#123;</span><br><span class="line">    <span class="comment">// 内层 for 循环在求所有选择的最小值</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> coins &#123;</span><br><span class="line">      <span class="keyword">if</span> i-value &lt; <span class="number">0</span> &#123; <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      dp[i] = min(dp[i], <span class="number">1</span>+dp[i-value])  <span class="comment">// 状态转移方程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> dp[amount] == amount+<span class="number">1</span> &#123; <span class="comment">// 说明没有合适的方案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> a&lt;b &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;PS：为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。</p>
<h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a class="link" href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定一个包含非负整数的 <code>m*n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-30-08.jpeg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[1,2,3],[4,5,6]]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D;&#x3D; grid.length</span><br><span class="line">n &#x3D;&#x3D; grid[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 200</span><br><span class="line">0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p>算法思路：由于路径的方向只能是向下或向右，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。</p>
<p>对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。由于每个元素对应的最小路径和与其相邻元素对应的最小路径和有关，因此可以使用动态规划求解。</p>
<p>创建二维数组<em>dp</em>，与原始网格的大小相同，*dp[i] [j]<em>表示从左上角出发到(i,j)位置的最小路径和。显然，</em>dp[0] [0]=grid[0] [0]*。对于 <em>dp</em> 中的其余元素，通过以下状态转移方程计算元素值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当 i&gt;0 且 j&#x3D;0 时，dp[i][0]&#x3D;dp[i−1][0]+grid[i][0]。</span><br><span class="line">当 i&#x3D;0 且 j&gt;0 时，dp[0][j]&#x3D;dp[0][j−1]+grid[0][j]。</span><br><span class="line">当 i&gt;0 且 j&gt;0 时，dp[i][j]&#x3D;min(dp[i−1][j],dp[i][j−1])+grid[i][j]。</span><br></pre></td></tr></table></figure>

<p>最后得到 *dp[m−1] [n−1]*的值即为从网格左上角到网格右下角的最小路径和。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minPathSum</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(grid)) <span class="comment">// 初始化切片的行</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(grid); i++ &#123; <span class="comment">// 初始化切片的列</span></span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>] <span class="comment">// 初始化起始点值</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(grid[<span class="number">0</span>]); i++ &#123; <span class="comment">// 初始化第一行的值</span></span><br><span class="line">        dp[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i]+dp[<span class="number">0</span>][i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(grid); i++ &#123; <span class="comment">//初始化第一列的值</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">1</span> &amp;&amp; <span class="built_in">len</span>(grid[<span class="number">0</span>]) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="built_in">len</span>(grid[<span class="number">0</span>])<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid[<span class="number">0</span>]) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(grid)<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(grid); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;<span class="built_in">len</span>(grid[<span class="number">0</span>]); j++ &#123;</span><br><span class="line">            dp[i][j] = min(dp[i<span class="number">-1</span>][j]+grid[i][j],dp[i][j<span class="number">-1</span>]+grid[i][j]) <span class="comment">// 状态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(grid)<span class="number">-1</span>][<span class="built_in">len</span>(grid[<span class="number">0</span>])<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a&lt;b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a class="link" href="https://leetcode-cn.com/problems/trapping-rain-water/">接雨水<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="rainwatertrap.png" alt="rainwatertrap"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</span><br></pre></td></tr></table></figure>

<p>算法思路：对于下标 <em>i</em>，下雨后水能到达的最大高度等于下标 <em>i</em> 两边的最大高度的最小值，下标 <em>i</em> 处能接的雨水量等于下标 <em>i</em> 处的水能到达的最大高度减去 *height[i]*。</p>
<p>朴素的做法是对于数组 <em>height</em> 中的每个元素，分别向左和向右扫描并记录左边和右边的最大高度，然后计算每个下标位置能接的雨水量。假设数组 <em>height</em> 的长度为 <em>n</em>，该做法需要对每个下标位置使用 <em>O(n)</em> 的时间向两边扫描并得到最大高度，因此总时间复杂度是 *O(n<sup>2</sup>)*。</p>
<p>上述做法的时间复杂度较高是因为需要对每个下标位置都向两边扫描。如果已经知道每个位置两边的最大高度，则可以在 <em>O(n)</em> 的时间内得到能接的雨水总量。使用动态规划的方法，可以在 <em>O(n)</em> 的时间内预处理得到每个位置两边的最大高度。</p>
<p>创建两个长度为 <em>n</em> 的数组 <em>leftMax</em> 和 <em>rightMax</em>。对于 <em>0≤i&lt;n</em>，<em>leftMax[i]</em> 表示下标 <em>i</em> 及其左边的位置中，<em>height</em> 的最大高度，<em>rightMax[i]</em> 表示下标 <em>i</em> 及其右边的位置中，<em>height</em> 的最大高度。显然，*leftMax[0]=height[0]*，<br>*rightMax[n−1]=height[n−1]*。两个数组的其余元素的计算如下：</p>
<ul>
<li>当 <em>1≤i≤n−1</em> 时，*leftMax[i]=max(leftMax[i−1],height[i])*；</li>
<li>当 <em>0≤i≤n−2</em> 时，*rightMax[i]=max(rightMax[i+1],height[i])*。</li>
</ul>
<p>因此可以正向遍历数组 <em>height</em> 得到数组 <em>leftMax</em> 的每个元素值，反向遍历数组 <em>height</em> 得到数组 <em>rightMax</em> 的每个元素值。在得到数组 <em>leftMax</em> 和 <em>rightMax</em> 的每个元素值之后，对于 <em>0≤i&lt;n</em>，下标 <em>i</em> 处能接的雨水量等于<br>*min(leftMax[i],rightMax[i])−height[i]*。遍历每个下标位置即可得到能接的雨水总量。动态规划做法可以由下图体现。</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-29-30.jpg" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l := <span class="built_in">len</span>(height)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftMax := <span class="built_in">make</span>([]<span class="keyword">int</span>, l)</span><br><span class="line">    rightMax := <span class="built_in">make</span>([]<span class="keyword">int</span>, l)</span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">    rightMax[l<span class="number">-1</span>] = height[l<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;l; i++ &#123;  <span class="comment">// 从左向右遍历，得到i位置处左边的最高值</span></span><br><span class="line">        leftMax[i] = max(leftMax[i<span class="number">-1</span>],height[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=l<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i-- &#123; <span class="comment">// 从右向左遍历，得到i位置处右边的最高值</span></span><br><span class="line">        rightMax[i] = max(rightMax[i+<span class="number">1</span>],height[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;l; i++ &#123;</span><br><span class="line">        ret += min(leftMax[i],rightMax[i])-height[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a&lt;b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a&gt;b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;<strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a class="link" href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-ji-ben-ji-qiao/dong-tai-gui-hua-xiang-jie-jin-jie">动态规划解题套路框架<i class="fas fa-external-link-alt"></i></a></p>
<p>2.<a href="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%92%8C%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB">动态规划和贪心算法的区别</a></p>
<p>3.<a class="link" href="https://www.jianshu.com/p/99327f542c8a">【数据结构】贪心算法和动态规划<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>动态规划(DP)</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针算法总结</title>
    <url>/2021/05/08/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="双指针算法类型"><a href="#双指针算法类型" class="headerlink" title="双指针算法类型"></a>双指针算法类型</h1><p>&emsp;&emsp;双指针的问题主要可以归为两类，一类是「快慢指针」，主要解决链表中的问题，比如典型的判定链表中是否包含环；另一类是「左右指针」，主要解决数组（或者字符串）中的问题，比如二分查找。</p>
<h2 id="快慢指针的常见算法"><a href="#快慢指针的常见算法" class="headerlink" title="快慢指针的常见算法"></a>快慢指针的常见算法</h2><p>&emsp;&emsp;快慢指针一般都初始化指向链表的头结点 <code>head</code>，前进时快指针 <code>fast</code> 在前，慢指针 <code>slow</code> 在后，巧妙解决一些链表中的问题。</p>
<h3 id="判断链表中是否有环"><a href="#判断链表中是否有环" class="headerlink" title="判断链表中是否有环"></a>判断链表中是否有环</h3><p>&emsp;&emsp;单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。如果链表中不含环，那么这个指针最终会遇到空指针 <code>nil</code> 表示链表到头了，这还好说，可以判断该链表不含环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">    head = head.Next</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 <code>nil</code> 指针作为尾部节点。经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 <code>nil</code>，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。</p>
<p><a class="link" href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="已知链表中含有环，返回这个环的起始位置"><a href="#已知链表中含有环，返回这个环的起始位置" class="headerlink" title="已知链表中含有环，返回这个环的起始位置"></a>已知链表中含有环，返回这个环的起始位置</h3><p><a class="link" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表 II<i class="fas fa-external-link-alt"></i></a></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-21-26.jpg" alt="avatar"></p>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<p>进阶：你是否可以使用 O(1) 空间解决此题？</p>
<p>&emsp;&emsp;当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？</p>
<p>第一次相遇时，假设慢指针 <code>slow</code> 走了 <code>k</code> 步，那么快指针 <code>fast</code> 一定走了 <code>2k</code> 步：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-56-07.jpg" alt="avatar"></p>
<p><strong><code>fast</code></strong> <strong>一定比</strong> <strong><code>slow</code></strong> <strong>多走了</strong> <strong><code>k</code></strong> <strong>步，这多走的</strong> <strong><code>k</code></strong> <strong>步其实就是</strong> <strong><code>fast</code></strong> <strong>指针在环里转圈圈，所以</strong> <strong><code>k</code></strong> <strong>的值就是环长度的「整数倍」</strong>。</p>
<p>说句题外话，之前还有读者争论为什么是环长度整数倍，我举个简单的例子你就明白了，我们想一想极端情况，假设环长度就是 1，如下图：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-57-52.jpg" alt="avatar"></p>
<p>那么 <code>fast</code> 肯定早早就进环里转圈圈了，而且肯定会转好多圈，这不就是环长度的整数倍嘛。</p>
<p>言归正传，设相遇点距环的起点的距离为 <code>m</code>，那么环的起点距头结点 <code>head</code> 的距离为 <code>k - m</code>，也就是说如果从 <code>head</code> 前进 <code>k - m</code> 步就能到达环起点。</p>
<p>巧的是，如果从相遇点继续前进 <code>k - m</code> 步，也恰好到达环起点。你甭管 <code>fast</code> 在环里到底转了几圈，反正走 <code>k</code> 步可以到相遇点，那走 <code>k - m</code> 步一定就是走到环起点了：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-08_14-59-23.jpg" alt="avatar"></p>
<p>所以，只要我们把快慢指针中的任一个重新指向 <code>head</code>，然后两个指针同速前进，<code>k - m</code> 步后就会相遇，相遇之处就是环的起点了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            slow = head</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 上面的代码类似 hasCycle 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="keyword">return</span> fast</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="链表的中间结点"><a href="#链表的中间结点" class="headerlink" title=" 链表的中间结点"></a><a class="link" href="https://leetcode-cn.com/problems/middle-of-the-linked-list/"> 链表的中间结点<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;类似上面的思路，我们可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleNode</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当链表的长度是奇数时，<code>slow</code> 恰巧停在中点位置；如果长度是偶数，<code>slow</code> 最终的位置是中间偏右：</p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-10_21-30-59.jpg" alt="avatar"></p>
<h3 id="查找链表的倒数第-N-个结点"><a href="#查找链表的倒数第-N-个结点" class="headerlink" title="查找链表的倒数第 N 个结点"></a><a class="link" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">查找链表的倒数第 N 个结点<i class="fas fa-external-link-alt"></i></a></h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-05-10_21-35-57.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1], n &#x3D; 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], n &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;还是使用快慢指针，让快指针先走 <code>n</code> 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 <code>nil</code> 时，慢指针所在的位置就是倒数第 <code>n</code> 个链表节点（<code>n</code> 不会超过链表长度）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123; <span class="comment">// 快指针先走n步</span></span><br><span class="line">        fast = fast.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;</span><br><span class="line">        head = head.Next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    slow.Next = slow.Next.Next  <span class="comment">// 删除这个节点</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a class="link" href="https://leetcode-cn.com/problems/palindrome-linked-list/">回文链表<i class="fas fa-external-link-alt"></i></a></h3><p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<p>&emsp;&emsp;这道题看似很简单，只需要将链表存到数组中，从数组两端开始向中间依次比较，只要有两端的数字不同，立即返回false。可是这样做的空间复杂度为O(n)，有什么办法能将空间复杂度控制为O(1)呢？</p>
<p>&emsp;&emsp;这道题集成了快慢指针，反转链表的操作，很具有代表性。我们要避免使用O(n)的额外空间，就要改变输入，我们可以通过反转后半部分链表，然后将前半部分与后半部分进行比较。该方法可以将空间复杂度降到O(1)，但是在并发环境下，该方法也有缺点，在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。</p>
<p><strong>算法流程：</strong></p>
<p>1.找到前半部分链表的尾节点：可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。若链表有奇数个节点，则中间的节点应该看作是前半部分。</p>
<p>2.反转后半部分链表：同<a class="link" href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表<i class="fas fa-external-link-alt"></i></a>的解决方案。</p>
<p>3.判断是否回文：比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。</p>
<p>4.返回结果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    fast, slow := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123; <span class="comment">// 快慢指针找到中间节点</span></span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123; <span class="comment">// 该链表有偶数个节点</span></span><br><span class="line">        s := reverse(slow)          </span><br><span class="line">        <span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> head.Val != s.Val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            s = s.Next</span><br><span class="line">            head = head.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 该链表有奇数个节点</span></span><br><span class="line">        s := reverse(slow.Next)</span><br><span class="line">        <span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> head.Val != s.Val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            s = s.Next</span><br><span class="line">            head = head.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(p *ListNode)</span> *<span class="title">ListNode</span></span> &#123;  <span class="comment">// 反转链表</span></span><br><span class="line">    h := p</span><br><span class="line">    q := p.Next</span><br><span class="line">    <span class="keyword">for</span> q != <span class="literal">nil</span> &#123;</span><br><span class="line">        temp := q.Next</span><br><span class="line">        q.Next = p</span><br><span class="line">        p = q</span><br><span class="line">        q = temp</span><br><span class="line">    &#125;</span><br><span class="line">    h.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="左右指针的常见算法"><a href="#左右指针的常见算法" class="headerlink" title="左右指针的常见算法"></a>左右指针的常见算法</h2><p>&emsp;&emsp;左右指针在数组中实际是指两个索引值，一般初始化为left:=0, right:=len(array)-1。常见的左右指针算法通常分为四类：1.二分查找；2.两数之和；3.反转数组；4.滑动窗口。其中以滑动窗口最为困难，已经有专门的专题<a href="https://jiahaohong1997.github.io/2021/04/28/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(Sliding-Window)%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/">滑动窗口(Sliding Window)算法框架</a>来介绍。其他三类只要掌握了基本框架，基本都能解决。</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h4 id="二分查找的三种基本框架"><a href="#二分查找的三种基本框架" class="headerlink" title="二分查找的三种基本框架"></a>二分查找的三种基本框架</h4><p>1.寻找某一个特定的数(最基本的二分查找)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		left := <span class="number">0</span></span><br><span class="line">  	right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">for</span> left &lt;= right &#123;  <span class="comment">// 注意符号</span></span><br><span class="line">  			mid := left + (right-left)/<span class="number">2</span>  <span class="comment">// 如果使用(left+right)/2的方式，可能导致溢出</span></span><br><span class="line">    		<span class="keyword">if</span> nums[mid] == target &#123;  <span class="comment">// 一旦找到。立即返回</span></span><br><span class="line">      			<span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">          	left = mid + <span class="number">1</span>  <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	right = mid - <span class="number">1</span>  <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的地方(也是区分于其他框架的地方)：</p>
<ul>
<li>循环中符号是&lt;=</li>
<li>一旦nums[mid]查找到，立即返回mid</li>
<li>left = mid + 1   right = mid - 1</li>
</ul>
<p>2.寻找左侧边界的二分查找</p>
<p>&emsp;&emsp;这个左边界不仅限于target存在于数组中，也可以找到其不在数组时的左边界。举例如下：</p>
<p>nums[] = {2,3,4,5,5,5,6,9,17} , target=5, 其左边界为索引3</p>
<p>nums[] = {2,2,3,4,4,4,6,7,7,8,9,456}, target=5, 其左边界索引为5</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">left_bound</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">-1</span> </span><br><span class="line">  	&#125;</span><br><span class="line">  	left := <span class="number">0</span></span><br><span class="line">  	right := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">for</span> left &lt; right &#123;  <span class="comment">// 注意符号</span></span><br><span class="line">      	mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">      	<span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">        		right = mid <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">          	left = mid + <span class="number">1</span> <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	right = mid <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">  	&#125; </span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> nums[left] == target &#123; <span class="comment">// 等于target，直接返回左边界</span></span><br><span class="line">    		<span class="keyword">return</span> left</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>] &lt; target &#123; <span class="comment">// 如果最后一个数都小于target，此时left指向的是最后一个数，此时将其最为左边界的话直接返回left。如果在一开始就对边界情况做了判断，就不需要对这一条件做判断。</span></span><br><span class="line">      <span class="keyword">return</span> left  <span class="comment">// left=len(nums)-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> left<span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的地方:</p>
<ul>
<li>循环中符号是&lt;，所以当数组只有一个元素时，不会进入for循环，要单独判断；因为是小于符号，所以出循环，left和right都不可能越界，这就意味着如果数组最后一个数 &lt; target，按理说要返回前一个数的索引，但是由于right卡在了数组末尾元素上，循环结束的条件是left=right，所以此时左边界直接返回left，而不需要left-1</li>
<li>查找到nums[mid]=target，不直接返回，让right=mid，锁定住</li>
<li>left = mid+1    right = mid</li>
<li>最终判断一下nums[left]是否等于target，等于说明target在数组中，直接返回left，否则返回left-1</li>
<li>找左边界的时候记得优先判断一下有序数组中最后一个数是否大于target，若最大的数都小于target，说明整个数组的左边界只能由最后一位数来担任，left=len(nums)-1</li>
</ul>
<p>3.寻找右侧边界的二分查找</p>
<p>&emsp;&emsp;这个右边界不仅限于target存在于数组中，也可以找到其不在数组时的右边界。举例如下：</p>
<p>nums[] = {2,3,4,5,5,5,6,9,17} , target=5, 其右边界为索引5</p>
<p>nums[] = {2,2,3,4,4,4,6,7,7,8,9,456}, target=5, 其右边界索引为6</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">right_bound</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">-1</span> </span><br><span class="line">  	&#125;</span><br><span class="line">  	left := <span class="number">0</span></span><br><span class="line">  	right := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">for</span> left &lt; right &#123;  <span class="comment">// 注意符号</span></span><br><span class="line">      	mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">      	<span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">        		left = mid + <span class="number">1</span> <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">          	left = mid + <span class="number">1</span> <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	right = mid <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">  	&#125; </span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">if</span> nums[left] == target &#123; <span class="comment">// 第一位数或最后一位数作为右边界，如果在一开始就对边界情况做了判断，可以不需要对这一个条件做判断</span></span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  	&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[left<span class="number">-1</span>] == target &#123;  <span class="comment">// 注意</span></span><br><span class="line">    		<span class="keyword">return</span> left<span class="number">-1</span></span><br><span class="line">  	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> left</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的地方:</p>
<ul>
<li>循环中符号是&lt;，所以当数组只有一个元素时，不会进入for循环，要单独判断；因为是小于符号，所以出循环，left和right都不可能越界，这就意味着如果数组第一个数 &gt; target，left一定会一直卡在索引0位置上，循环结束的条件是left=right，所以此时left=0，要判断nums[left-1]是否等于target，显然发生了越界，所以直接使用left(=0)作为右边界</li>
<li>查找到nums[mid]=target，不直接返回，让left = mid + 1，锁定住</li>
<li>left = mid + 1   right = mid</li>
<li>最终判断一下nums[left-1]是否等于target，等于说明target在数组中，直接返回left-1，否则返回left</li>
</ul>
<p>&emsp;&emsp;寻找左右边界这两个框架出来的left其实可以看成是一个永远指向target右侧的一个指针(不管这个target是否在数组中)，见下面示意：</p>
<p>··· ···, a,  a, a, [b, b, b, b,] c, c, c, ··· ···</p>
<ul>
<li><p>b是target，[]表示其可能存在在数组中，当找其左边界时，left指针所在位置如下：</p>
<p>  ··· ···, a,  a, a, [b(<em>left</em>), b, b, b,] c, c, c, ··· ···</p>
<p>  当b存在在数组中，则直接输出left，当b不在数组中，则a是其左边界，输出left-1</p>
</li>
<li><p>b是target，[]表示其可能存在在数组中，当找其右边界时，left指针所在位置如下：</p>
<p>  ··· ···, a,  a, a, [b, b, b, b,] c(<em>left</em>), c, c, ··· ···</p>
<p>  当b存在在数组中，则输出left-1，当b不在数组中，则c是其有边界，输出left</p>
</li>
</ul>
<table><tr><td bgcolor="yellow">&emsp;&emsp;总而言之，首先考虑数组只有一个元素或没有元素的情况。之后将target和首位元素做比较，看首位元素是否是其左右边界，或者target可能干脆就不在这个数组的范围内。之后再正式套用上述框架来找左右边界。</td></tr></table>

<h4 id="寻找旋转排序数组中的最小值-II"><a href="#寻找旋转排序数组中的最小值-II" class="headerlink" title="寻找旋转排序数组中的最小值 II"></a><a class="link" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">寻找旋转排序数组中的最小值 II<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]<br>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,5]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p>n == nums.length<br>1 &lt;= n &lt;= 5000<br>-5000 &lt;= nums[i] &lt;= 5000<br>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</p>
<p>&emsp;&emsp;该题相当于要找到数组中最小值的左边界(最小值可能不止一个)。left指针移动的条件是当mid指针所指的数大于right指针所指数，那么mid所指的数一定不可能是边界区域，left=mid+1。当出现nums[mid]&lt;nums[right]时，说明nums[mid]已经在最小值左边界的右方，此时固定住right指针，继续二分查找。有区别的是当出现nums[mid]=nums[right]的情况时，原先的二分查找是严格的赠序数组，可以直接让right=mid，锁定住右边界。但是如出现下面的情况：nums数组为**[3,3,1,3]**，直接让right=mid会跳过中间的小值，所以只需要让right指针减一，缩小搜索范围即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left&lt;right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[right] &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; nums[right] &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="搜索旋转排序数组-II"><a href="#搜索旋转排序数组-II" class="headerlink" title="搜索旋转排序数组 II"></a><a class="link" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组 II<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p>
<p>&emsp;&emsp;在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k（0 &lt;= k &lt; nums.length）</code>上进行了 旋转 ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如，<code> [0,1,2,4,4,4,5,6,6,7]</code> 在下标 5 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p>
<p>&emsp;&emsp;给你 旋转后 的数组 <code>nums</code> 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 5000</span><br><span class="line">-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</span><br><span class="line">题目数据保证 nums 在预先未知的某个下标上进行了旋转</span><br><span class="line">-104 &lt;&#x3D; target &lt;&#x3D; 104</span><br></pre></td></tr></table></figure>



<p>解题思路：</p>
<p>&emsp;&emsp;    找目标数，首先考虑二分查找。但是本题的数组在<code>[left,mid]</code>和<code>[mid,right]</code>两段区间内只有一段是有序的。要用二分查找找target，就必须在有序的区间查找。所以要理清可能出现的三种情况：</p>
<ul>
<li>第一类</li>
</ul>
<p>&emsp;&emsp;对于数组中有重复元素的情况，二分查找时可能会有 <code>nums[lelf]=nums[mid]=nums[right]</code>，此时无法判断区间 <code>[left,mid]</code> 和区间<code>[mid+1,right]</code>哪个是有序的。例如 <code>nums=[3,1,2,3,3,3,3]</code>，<code>target=2</code>，首次二分时无法判断区间 <code>[0,3]</code> 和区间 <code>[4,6] </code>哪个是有序的。对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。</p>
<ul>
<li>第二类</li>
</ul>
<p>&emsp;&emsp;<code>nums=[2,3,4,5,6,7,1]</code> 这种，也就是<code> nums[left] &lt; nums[mid]</code>。此例子中就是 2 &lt; 5；这种情况下，前半部分有序。因此如果 <code>nums[left]&lt;=target&lt;nums[mid]</code>，则在前半部分找，否则去后半部分找。</p>
<ul>
<li>第三类</li>
</ul>
<p>&emsp;&emsp;<code>nums=[6,7,1,2,3,4,5]</code>这种，也就是 <code>nums[left] &gt; nums[mid]</code>。此例子中就是 6 &gt; 2；这种情况下，后半部分有序。因此如果 <code>nums[mid]&lt;target&lt;=nums[right]</code>。则在后半部分找，否则去前半部分找。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;  <span class="comment">// 找具体的数，用&lt;=</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[left] == nums[mid] &amp;&amp; nums[mid] == nums[right] &#123;  <span class="comment">//第一类情况</span></span><br><span class="line">            left++</span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[left] &lt;= nums[mid] &#123;  <span class="comment">// 左边有序</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target &#123;</span><br><span class="line">                right = mid<span class="number">-1</span>  <span class="comment">// 在前半部分找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>   <span class="comment">// 在后半部分找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右边有序 </span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span>   <span class="comment">// 在后半部分找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid<span class="number">-1</span>  <span class="comment">// 在前半部分找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="在-D-天内送达包裹的能力"><a href="#在-D-天内送达包裹的能力" class="headerlink" title="在 D 天内送达包裹的能力"></a><a class="link" href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">在 D 天内送达包裹的能力<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</p>
<p>&emsp;&emsp;传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>
<p>&emsp;&emsp;返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：weights &#x3D; [3,2,2,4,1,4], D &#x3D; 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：3, 2</span><br><span class="line">第 2 天：2, 4</span><br><span class="line">第 3 天：1, 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：weights &#x3D; [1,2,3,1,1], D &#x3D; 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第 1 天：1</span><br><span class="line">第 2 天：2</span><br><span class="line">第 3 天：3</span><br><span class="line">第 4 天：1, 1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; D &lt;&#x3D; weights.length &lt;&#x3D; 5 * 104</span><br><span class="line">1 &lt;&#x3D; weights[i] &lt;&#x3D; 500</span><br></pre></td></tr></table></figure>

<p>算法思路：</p>
<p>&emsp;&emsp;假设当船的运载能力为 <code>x</code> 时，我们可以在 <code>days</code> 天内运送完所有包裹，那么只要运载能力大于 <code>x</code>，我们同样可以在 <code>days</code> 天内运送完所有包裹：我们只需要使用运载能力为 <code>x</code> 时的运送方法即可。</p>
<p>&emsp;&emsp;这样一来，我们就得到了一个非常重要的结论：</p>
<p>存在一个运载能力的「下限」$$x _\text { ans }$$，使得当 <code>x</code> ≥ $$x _\text { ans }$$时，我们可以在 <code>days</code> 天内运送完所有包裹；当 <code>x</code>&lt;<br>$$x _\text { ans }$$时，我们无法在 <code>days</code> 天内运送完所有包裹。</p>
<p>&emsp;&emsp;同时，$$x _\text { ans }$$即为我们需要求出的答案。因此，我们就可以使用二分查找的方法找出 $$x _\text { ans }$$的值。在二分查找的每一步中，我们实际上需要解决一个判定问题：给定船的运载能力 <code>x</code>，我们是否可以在 <code>days</code> 天内运送完所有包裹呢？这个判定问题可以通过贪心的方法来解决：</p>
<p>&emsp;&emsp;由于我们必须按照数组 <code>weights</code> 中包裹的顺序进行运送，因此我们从数组 <code>weights</code> 的首元素开始遍历，将连续的包裹都安排在同一天进行运送。当这批包裹的重量大于运载能力 <code>x</code> 时，我们就需要将最后一个包裹拿出来，安排在新的一天，并继续往下遍历。当我们遍历完整个数组后，就得到了最少需要运送的天数。</p>
<p>&emsp;&emsp;我们将「最少需要运送的天数」与 <code>days</code> 进行比较，就可以解决这个判定问题。当其小于等于 <code>days</code> 时，我们就忽略二分的右半部分区间；当其大于 <code>days</code> 时，我们就忽略二分的左半部分区间。</p>
<p><strong>细节</strong></p>
<p>二分查找的初始左右边界应当如何计算呢？</p>
<p>对于左边界而言，由于我们不能「拆分」一个包裹，因此船的运载能力不能小于所有包裹中最重的那个的重量，即左边界为数组 <code>weights</code> 中元素的最大值。</p>
<p>对于右边界而言，船的运载能力也不会大于所有包裹的重量之和，即右边界为数组 <code>weights</code> 中元素的和。</p>
<p>我们从上述左右边界开始进行二分查找，就可以保证找到最终的答案。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shipWithinDays</span><span class="params">(weights []<span class="keyword">int</span>, days <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := weights[<span class="number">0</span>]</span><br><span class="line">    right := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(weights); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> weights[i] &gt; left &#123;  <span class="comment">// 设置运载能力左边界为货物中最大重量</span></span><br><span class="line">            left = weights[i]</span><br><span class="line">        &#125;</span><br><span class="line">        right += weights[i]			<span class="comment">// 设置运载能力有边界为货物总重量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> check <span class="function"><span class="keyword">func</span><span class="params">(<span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">    check = <span class="function"><span class="keyword">func</span><span class="params">(<span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        temp := <span class="number">0</span> <span class="comment">// 一天内运送货物重量的累积</span></span><br><span class="line">        day := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> weights &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">cap</span> &lt; temp+v &#123;  <span class="comment">// 超过🚢的运载能力，天数+1</span></span><br><span class="line">                day++</span><br><span class="line">                temp = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            temp += v</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> temp != <span class="number">0</span> &#123;</span><br><span class="line">            day++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> day&lt;=days &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123; <span class="comment">// 二分查找满足运送天数的🚢运载能力的左边界</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> check(mid) &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a><a class="link" href="https://leetcode-cn.com/problems/search-a-2d-matrix/">搜索二维矩阵<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-02_20-29-44.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-02_20-31-06.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D;&#x3D; matrix.length</span><br><span class="line">n &#x3D;&#x3D; matrix[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 100</span><br><span class="line">-104 &lt;&#x3D; matrix[i][j], target &lt;&#x3D; 104</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;对于本题，主要的思路就是先通过对每行的首个数字组成的序列进行二分查找，首先要判断target是否在最后一行中，如果是的话，直接在最后一行进行二分查找。这么做的目的是如果直接二分查找target的左边界，如果最后一行的首位数小于target，此时不能将接下来继续二分查找的行数定位left-1，要直接在left行(也就是最后一行)进行查找。简单来说，left的最大值只可能是<code>len(matrix)-1</code>，然而要找的左边界是<code>left-1</code>，这样最后一行永远都无法被选中。读者可以自己找一个实际的例子来看一看。</p>
<p>&emsp;&emsp;若不在最后一行，那么就进行二分查找找到target的左边界，这时会出现两种情况：</p>
<ul>
<li>左边界恰好是要找的target，直接返回true</li>
<li>左边界位于非最后一行，定位到target可能出现的那一行<code>row=left-1</code></li>
</ul>
<p>&emsp;&emsp;最后再在找到的行进行二分查找。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(matrix)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    r := <span class="built_in">len</span>(matrix) <span class="comment">// 行数</span></span><br><span class="line">    c := <span class="built_in">len</span>(matrix[<span class="number">0</span>])  <span class="comment">// 列数</span></span><br><span class="line">    <span class="keyword">var</span> row <span class="keyword">int</span></span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 边界情况：target超出了二维数组的范围，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[r<span class="number">-1</span>][c<span class="number">-1</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">1</span> &amp;&amp; matrix[r<span class="number">-1</span>][<span class="number">0</span>] &gt; target &#123; <span class="comment">// 当不止有一行并且target不在最后一行时</span></span><br><span class="line">        <span class="keyword">for</span> left &lt; right &#123; <span class="comment">// 找左边界，可以参考模板2</span></span><br><span class="line">            mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] == target &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] &lt; target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> matrix[left][<span class="number">0</span>] == target &#123; <span class="comment">// 如果left指向的数等于target，直接返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则可以定位target可能出现的行号</span></span><br><span class="line">            row = left<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> r == <span class="number">1</span> &#123;  <span class="comment">// 如果只有一行，则无需二分查找</span></span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果target可能出现在最后一行</span></span><br><span class="line">        row = r<span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leftRow := <span class="number">0</span></span><br><span class="line">    rightRow := c<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> leftRow &lt;= rightRow &#123; <span class="comment">// 使用二分查找在确定的行上查找</span></span><br><span class="line">        mid := leftRow + (rightRow-leftRow)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> matrix[row][mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[row][mid] &gt; target &#123;</span><br><span class="line">            rightRow = mid<span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftRow = mid+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="搜索二维矩阵-II"><a href="#搜索二维矩阵-II" class="headerlink" title="搜索二维矩阵 II"></a><a class="link" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">搜索二维矩阵 II<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-17_16-40-38.jpg" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">19</span>],[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">22</span>],[<span class="number">10</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">17</span>,<span class="number">24</span>],[<span class="number">18</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">26</span>,<span class="number">30</span>]], target = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-17_16-42-30.jpg" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">19</span>],[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">22</span>],[<span class="number">10</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">17</span>,<span class="number">24</span>],[<span class="number">18</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">26</span>,<span class="number">30</span>]], target = <span class="number">20</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m == matrix.length</span><br><span class="line">n == matrix[i].length</span><br><span class="line"><span class="number">1</span> &lt;= n, m &lt;= <span class="number">300</span></span><br><span class="line"><span class="number">-109</span> &lt;= matix[i][j] &lt;= <span class="number">109</span></span><br><span class="line">每行的所有元素从左到右升序排列</span><br><span class="line">每列的所有元素从上到下升序排列</span><br><span class="line"><span class="number">-109</span> &lt;= target &lt;= <span class="number">109</span></span><br></pre></td></tr></table></figure>

<p>算法思路：</p>
<p>&emsp;&emsp;不同于上一题每一行的第一个元素大于前一行的第一个元素，本题要暴力搜索的话需要对每一行进行二分查找。可以考虑先确定目标数可能存在于哪几行内，对这几行进行搜索即可。</p>
<ul>
<li>对每行的最后一个元素进行二分查找，寻找<code>target</code>的左边界，可以确定起始行号</li>
<li>对每一行第一个元素进行二分查找，寻找<code>target</code>的左边界，可以确定终止行号</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    r, c := <span class="built_in">len</span>(matrix)<span class="number">-1</span>,<span class="built_in">len</span>(matrix[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    row1 := <span class="number">0</span></span><br><span class="line">    row2 := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> matrix[r][c] &lt; target &#123; <span class="comment">// 如果最后一个元素小于target，直接返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[r][c] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left,right := <span class="number">0</span>,r</span><br><span class="line">        <span class="keyword">for</span> left&lt;right &#123;</span><br><span class="line">            mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[mid][c] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[mid][c] &gt; target &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        row2 = left <span class="comment">// 起始行号=左边界+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> matrix[r][<span class="number">0</span>] &lt; target &#123;</span><br><span class="line">        row1 = r</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[r][<span class="number">0</span>] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left,right := <span class="number">0</span>,r</span><br><span class="line">        <span class="keyword">for</span> left&lt;right &#123;</span><br><span class="line">            mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] &gt; target &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        row1 = left<span class="number">-1</span> <span class="comment">// 终止行号=左边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fmt.Println(row2)</span></span><br><span class="line">    <span class="comment">// fmt.Println(row1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> row2&gt;row1 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> row2 &lt;= row1 &#123;  <span class="comment">// 对可能的行内进行二分查找</span></span><br><span class="line">        left,right := <span class="number">0</span>,c</span><br><span class="line">        <span class="keyword">for</span> left&lt;=right &#123;</span><br><span class="line">            mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[row2][mid] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[row2][mid] &lt; target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 right = mid<span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        row2++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><a class="link" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p><strong>进阶：</strong></p>
<p>你可以设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题吗?</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [], target &#x3D; 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>&emsp;&emsp;本题直接找左右边界即可，首先判断边界情况：</p>
<ul>
<li>数组为空，直接返回<code>[-1,-1]</code></li>
<li>数组只有一个元素，若该元素=target，返回<code>[0,0]</code>；否则，返回<code>[-1,-1]</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">len</span>(nums) == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] != target) || <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123; <span class="comment">// 找左边界</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nums[left] == target &#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, left)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 找不到target，其左边界是数组中最大的比它小的数</span></span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;    <span class="comment">// 找右边界</span></span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 因为在找左边界的时候已经判断过该数组中是否存在target，能到这一步肯定是存在的。不用顾虑第一个数大 于target的情况</span></span><br><span class="line">    <span class="keyword">if</span> nums[left] == target &#123; <span class="comment">// 右边界是数组第一个数</span></span><br><span class="line">        ret = <span class="built_in">append</span>(ret,left)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右边界是其他数</span></span><br><span class="line">        ret = <span class="built_in">append</span>(ret, left<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="两数之和类题目"><a href="#两数之和类题目" class="headerlink" title="两数之和类题目"></a>两数之和类题目</h3><h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a class="link" href="https://leetcode-cn.com/problems/two-sum/">两数之和<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target  的那两个整数，并返回它们的数组下标。</p>
<p>&emsp;&emsp;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>&emsp;&emsp;你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 &lt;&#x3D; nums.length &lt;&#x3D; 104</span><br><span class="line">-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</span><br><span class="line">-109 &lt;&#x3D; target &lt;&#x3D; 109</span><br><span class="line">只会存在一个有效答案</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	  sort.Ints(nums)  <span class="comment">// 给数组排序</span></span><br><span class="line">  	l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">  	ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;<span class="number">2</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> ret</span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">     		<span class="keyword">if</span> nums[l]&gt;target &#123;</span><br><span class="line">        		<span class="keyword">break</span></span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="keyword">if</span> nums[l]+nums[r] == target &#123;</span><br><span class="line">        		ret = <span class="built_in">append</span>(ret,l,r)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[l]+nums[r] &gt; target &#123;</span><br><span class="line">          	r--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	l++</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>本题也可使用map来做</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        another := target - value</span><br><span class="line">        _, ok := m[another]</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;index, m[another]&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m[value] = index      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a class="link" href="https://leetcode-cn.com/problems/3sum/">三数之和<i class="fas fa-external-link-alt"></i></a></h4><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; nums.length &lt;&#x3D; 3000</span><br><span class="line">-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</span><br></pre></td></tr></table></figure>



<p>算法思路：</p>
<p>&emsp;&emsp;整体思路和两数之和非常像，不过是通过遍历数组固定第一个数，后两个数使用双指针的方式进行查找。注意的是不能输出重复的三元组，所以在遍历的要判断一下是否和之前的数相等，相等则跳过该数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>]==<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;nums&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort.Ints(nums)  <span class="comment">// 排序数组</span></span><br><span class="line">    res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k:=<span class="number">0</span>; k&lt;<span class="built_in">len</span>(nums)<span class="number">-2</span>; k++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[k] &gt; <span class="number">0</span> &#123; <span class="comment">// 如果最小的数都大于0，直接结束循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> k&gt;<span class="number">0</span> &amp;&amp; nums[k] == nums[k<span class="number">-1</span>] &#123; <span class="comment">// 为避免重复，跳过已经出现的数</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tmp := nums[k]</span><br><span class="line">        i,j := k+<span class="number">1</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i&lt;j &#123;</span><br><span class="line">            <span class="keyword">if</span> tmp+nums[i]+nums[j] == <span class="number">0</span> &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res,[]<span class="keyword">int</span>&#123;tmp,nums[i],nums[j]&#125;)</span><br><span class="line">                i++</span><br><span class="line">                j--</span><br><span class="line">                <span class="keyword">for</span> i&lt;j &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123; <span class="comment">// 为避免重复，跳过已经出现的数</span></span><br><span class="line">                    i++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> i&lt;j &amp;&amp; nums[j] == nums[j+<span class="number">1</span>] &#123; <span class="comment">// 为避免重复，跳过已经出现的数</span></span><br><span class="line">                    j--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> tmp+nums[i]+nums[j] &gt; <span class="number">0</span> &#123;</span><br><span class="line">                j--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a><a class="link" href="https://leetcode-cn.com/problems/4sum/">四数之和<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的四元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [], target &#x3D; 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; nums.length &lt;&#x3D; 200</span><br><span class="line">-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</span><br><span class="line">-109 &lt;&#x3D; target &lt;&#x3D; 109</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;类似于三数之和，不过是在三数之和最外层再套一个for循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>]+nums[<span class="number">3</span>] == target&#123;</span><br><span class="line">            <span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;[]<span class="keyword">int</span>&#123;nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">3</span>]&#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    sort.Ints(nums)  <span class="comment">// 首先进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums)<span class="number">-3</span>; i++ &#123; <span class="comment">// 最外层循环，固定四元组的第一位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &#123; <span class="comment">// 过滤掉可能出现相同四元组的情况</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span>; j&lt;<span class="built_in">len</span>(nums)<span class="number">-2</span>; j++ &#123; <span class="comment">// 中层循环，遍历数组选择住四元组的第二位</span></span><br><span class="line">            <span class="keyword">if</span> j&gt;i+<span class="number">1</span> &amp;&amp; nums[j]==nums[j<span class="number">-1</span>] &#123; <span class="comment">// 过滤掉可能出现相同四元组的情况</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            l,r := j+<span class="number">1</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> l&lt;r &#123; <span class="comment">// 内层循环，双指针选择四元组的最后两位</span></span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j]+nums[l]+nums[r] == target &#123;</span><br><span class="line">                    res = <span class="built_in">append</span>(res,[]<span class="keyword">int</span>&#123;nums[i],nums[j],nums[l],nums[r]&#125;)</span><br><span class="line">                    l++</span><br><span class="line">                    r--</span><br><span class="line">                    <span class="keyword">for</span> l&lt;r &amp;&amp; nums[l]==nums[l<span class="number">-1</span>] &#123; <span class="comment">// 过滤掉可能出现相同四元组的情况</span></span><br><span class="line">                        l++</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> l&lt;r &amp;&amp; nums[r]==nums[r+<span class="number">1</span>] &#123; <span class="comment">//过滤掉可能出现相同四元组的情况</span></span><br><span class="line">                        r--</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j]+nums[l]+nums[r] &lt; target &#123;</span><br><span class="line">                    l++</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h3><h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a><a class="link" href="https://leetcode-cn.com/problems/reverse-string/">反转字符串<i class="fas fa-external-link-alt"></i></a></h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseString</span><span class="params">(s []<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">    l,r := <span class="number">0</span>,<span class="built_in">len</span>(s)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l&lt;r &#123;</span><br><span class="line">        s[l],s[r] = s[r],s[l]</span><br><span class="line">        l++</span><br><span class="line">        r--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="补充：剑指-Offer-24-反转链表"><a href="#补充：剑指-Offer-24-反转链表" class="headerlink" title="补充：剑指 Offer 24. 反转链表"></a>补充：<a class="link" href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表<i class="fas fa-external-link-alt"></i></a></h4><p>&emsp;&emsp;定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<p>解题思路：</p>
<p>假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。</p>
<p>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head.Next.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        p := head.Next</span><br><span class="line">        p.Next = head</span><br><span class="line">        head.Next = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line">    first,second,third := head,head.Next,head.Next.Next</span><br><span class="line">    first.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> third.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        second.Next = first</span><br><span class="line">        first = second</span><br><span class="line">        second = third</span><br><span class="line">        third = third.Next</span><br><span class="line">    &#125;</span><br><span class="line">    third.Next = second</span><br><span class="line">    second.Next = first</span><br><span class="line">    <span class="keyword">return</span> third</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><p>&emsp;&emsp;这个类型的题目是很有难度的，有专门的文章进行介绍。<a href="https://jiahaohong1997.github.io/2021/04/28/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3(Sliding-Window)%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/">滑动窗口(Sliding Window)算法框架</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a class="link" href="https://labuladong.gitbook.io/algo/mu-lu-ye-1/mu-lu-ye-3/shuang-zhi-zhen-ji-qiao">双指针技巧总结<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Uniform Resource Locator (URL)</title>
    <url>/2021/06/09/Uniform%20Resource%20Locator(URL)/</url>
    <content><![CDATA[<h1 id="什么是URL？"><a href="#什么是URL？" class="headerlink" title="什么是URL？"></a>什么是URL？</h1><p>&emsp;&emsp;<strong>URL 代表着是统一资源定位符（*</strong>Uniform Resource Locator*<strong>）</strong>。URL 无非就是一个给定的独特资源在 Web 上的地址。理论上说，每个有效的 URL 都指向一个唯一的资源。这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像，等等。而在实际中，也有一些例外，最常见的情况就是一个 URL 指向了不存在的或是被移动过的资源。由于通过 URL 呈现的资源和 URL 本身由 Web 服务器处理，因此 web 服务器的拥有者需要认真地维护资源以及与它关联的URL。其基本格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">scheme:<span class="comment">//host[:port#]/path/.../[?query-string][#anchor]</span></span><br><span class="line">scheme         指定底层使用的协议(例如：http, https, ftp)</span><br><span class="line">host           HTTP 服务器的 IP 地址或者域名</span><br><span class="line">port#          HTTP 服务器的默认端口是 <span class="number">80</span>，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http:<span class="comment">//www.cnblogs.com:8080/</span></span><br><span class="line">path           访问资源的路径</span><br><span class="line">query-string   发送给 http 服务器的数据</span><br><span class="line">anchor         锚</span><br></pre></td></tr></table></figure>



<h1 id="深入探究"><a href="#深入探究" class="headerlink" title="深入探究"></a>深入探究</h1><p>下面是一些URL的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;developer.mozilla.org</span><br><span class="line">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Learn&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;search?q&#x3D;URL</span><br></pre></td></tr></table></figure>

<p>您可以将上面的这些网址输进您的浏览器地址栏来告诉浏览器加载相关联的页面（或资源）。</p>
<p>&emsp;&emsp;一个URL由不同的部分组成，其中一些是必须的，而另一些是可选的。让我们以下面这个URL为例看看其中最重要的部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.example.com:80&#x2F;path&#x2F;to&#x2F;myfile.html?key1&#x3D;value1&amp;key2&#x3D;value2#SomewhereInTheDocument</span><br></pre></td></tr></table></figure>

<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-14-08.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>http</code> 是协议。浏览器必须使用的协议通常都是<code>HTTP</code>协议或是<code>HTTP</code>协议的安全版，即<code>HTTPS</code>。Web需要它们二者之一，但浏览器也知道如何处理其他协议，比如<code>mailto</code>:（打开邮件客户端）或者<code>ftp</code>:（处理文件传输），所以当你看到这些协议时，不必惊讶。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-18-06.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>www.example.com</code> 是域名。 它表明正在请求哪个Web服务器。或者，可以直接使用<a class="link" href="https://developer.mozilla.org/zh-CN/docs/Glossary/IP_Address">IP address<i class="fas fa-external-link-alt"></i></a>, 但是因为它不太方便，所以它不经常在网络上使用。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-36-49.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>:80</code> 是端口。 它表示用于访问Web服务器上的资源的技术“门”。如果Web服务器使用HTTP协议的标准端口（HTTP为80，HTTPS为443）来授予其资源的访问权限，则通常会被忽略。否则是强制性的。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-52-10.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>/path/to/myfile.html</code> 是网络服务器上资源的路径。在Web的早期阶段，像这样的路径表示Web服务器上的物理文件位置。如今，它主要是由没有任何物理现实的Web服务器处理的抽象。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-53-21.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>?key1=value1&amp;key2=value2</code> 是提供给网络服务器的额外参数。 这些参数是用 <code>&amp; </code>符号分隔的键/值对列表。在返回资源之前，Web服务器可以使用这些参数来执行额外的操作。每个Web服务器都有自己关于参数的规则，唯一可靠的方式来知道特定Web服务器是否处理参数是通过询问Web服务器所有者。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-09_14-55-04.jpg" width="50%" height="50%"></div>

<p>&emsp;&emsp;<code>#SomewhereInTheDocument</code> 是资源本身的另一部分的锚点. 锚点表示资源中的一种“书签”，给浏览器显示位于该“加书签”位置的内容的方向。例如，在HTML文档上，浏览器将滚动到定义锚点的位置;在视频或音频文档上，浏览器将尝试转到锚代表的时间。值得注意的是，＃后面的部分（也称为片段标识符）从来没有发送到请求的服务器。</p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议详解</title>
    <url>/2021/06/17/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>本文主要参考来源<a class="link" href="https://learnku.com/docs/build-web-application-with-golang/031-web-working-mode/3168">《Go Web编程》<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="HTTP协议介绍"><a href="#HTTP协议介绍" class="headerlink" title="HTTP协议介绍"></a>HTTP协议介绍</h2><p>&emsp;&emsp;HTTP协议是一种让web服务器与浏览器(客户端)通过网络发送和接收数据的协议。它建立在TCP之上，默认采用TCP的80端口。浏览器(客户端)每发出一个请求，服务器响应这个请求。在HTTP中，浏览器(客户端)总是通过建立连接并发送一个HTTP请求来发起一个事务，服务端不能主动去和客户端联系，也不能给客户端发送一个回调连接。客户端与服务器端都可以提前终结一个连接。例如，当浏览器下载一个文件时，可以通过“停止键”来中断文件的下载，关闭与服务器的TCP连接。</p>
<p>&emsp;&emsp;HTTP协议是无状态的，同一个客户端的这次请求和上次请求是没有关系的，对于HTTP服务器来说，它并不知道这两个请求是否来自同一个客户端。为了解决这个问题，web程序引入了cookie机制来维护连接的可持续状态。</p>
<h2 id="HTTP请求包-浏览器信息"><a href="#HTTP请求包-浏览器信息" class="headerlink" title="HTTP请求包(浏览器信息)"></a>HTTP请求包(浏览器信息)</h2><p>&emsp;&emsp;请求包(Request)的结构包含3个部分：Request line(请求行)、Request header(请求头)、body(主体)。header 和 body 之间有个空行，请求包的例子所示:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">GET /domains/example/ HTTP/<span class="number">1.1</span>      <span class="comment">// 请求行: 请求方法 请求 URI HTTP 协议/协议版本</span></span><br><span class="line">Host：www.iana.org               <span class="comment">// 服务端的主机名</span></span><br><span class="line">User-Agent：Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.1</span>) AppleWebKit/<span class="number">537.4</span> (KHTML, like Gecko) Chrome/<span class="number">22.0</span><span class="number">.1229</span><span class="number">.94</span> Safari/<span class="number">537.4</span>          <span class="comment">// 浏览器信息</span></span><br><span class="line">Accept：text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*<span class="comment">/*;q=0.8  // 客户端能接收的 mine</span></span><br><span class="line"><span class="comment">Accept-Encoding：gzip,deflate,sdch       // 是否支持流压缩</span></span><br><span class="line"><span class="comment">Accept-Charset：UTF-8,*;q=0.5        // 客户端字符编码集</span></span><br><span class="line"><span class="comment">// 空行,用于分割请求头和消息体</span></span><br><span class="line"><span class="comment">// 消息体,请求资源参数,例如 POST 传递的参数</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;HTTP 协议定义了很多与服务器交互的请求方法，最基本的有 4 种，分别是 GET, POST, PUT, DELETE。一个 URL 地址用于描述一个网络上的资源，而 HTTP 中的 GET, POST, PUT, DELETE 就对应着对这个资源的查，增，改，删 4 个操作。我们最常见的就是 GET 和 POST 了。GET 一般用于获取 / 查询资源信息，而 POST 一般用于更新资源信息。</p>
<p>&emsp;&emsp;通过 fiddler 抓包可以看到如下请求信息:</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-17_10-48-21.jpg" width="70%" height="70%"></div>

<p>&emsp;&emsp;fiddler 抓取的 GET 信息:</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-17_11-05-48.jpg" width="70%" height="70%"></div>

<p>&emsp;&emsp;GET 和 POST 的区别:</p>
<ol>
<li>我们可以看到 GET 请求消息体为空，POST 请求带有消息体。</li>
<li>GET 提交的数据会放在 URL 之后，以 <code>?</code> 分割 URL 和传输数据，参数之间以 <code>&amp;</code>相连，如 <code>EditPosts.aspx?name=test1&amp;id=123456</code>。POST 方法是把提交的数据放在 HTTP 包的 body 中。</li>
<li>GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制。</li>
<li>GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li>
</ol>
<h2 id="HTTP-响应包（服务器信息）"><a href="#HTTP-响应包（服务器信息）" class="headerlink" title="HTTP 响应包（服务器信息）"></a>HTTP 响应包（服务器信息）</h2><p>&emsp;&emsp;我们再来看看 HTTP 的 response 包，他的结构如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK                     <span class="comment">// 状态行</span></span><br><span class="line">Server: nginx/<span class="number">1.0</span><span class="number">.8</span>                 <span class="comment">// 服务器使用的 WEB 软件名及版本</span></span><br><span class="line">Date: Tue, <span class="number">30</span> Oct <span class="number">2012</span> <span class="number">04</span>:<span class="number">14</span>:<span class="number">25</span> GMT     <span class="comment">// 发送时间</span></span><br><span class="line">Content-Type: text/html             <span class="comment">// 服务器发送信息的类型</span></span><br><span class="line">Transfer-Encoding: chunked          <span class="comment">// 表示发送 HTTP 包是分段发的</span></span><br><span class="line">Connection: keep-alive              <span class="comment">// 保持连接状态</span></span><br><span class="line">Content-Length: <span class="number">90</span>                  <span class="comment">// 主体内容长度</span></span><br><span class="line"><span class="comment">// 空行 用来分割消息头和主体</span></span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>... <span class="comment">// 消息体</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Response 包中的第一行叫做状态行，由 HTTP 协议版本号， 状态码， 状态消息三部分组成。</p>
<p>&emsp;&emsp;状态码用来告诉 HTTP 客户端，HTTP 服务器是否产生了预期的 Response。HTTP/1.1 协议中定义了 5 类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别:</p>
<ul>
<li>1XX 提示信息 - 表示请求已被成功接收，继续处理</li>
<li>2XX 成功 - 表示请求已被成功接收，理解，接受</li>
<li>3XX 重定向 - 要完成请求必须进行更进一步的处理</li>
<li>4XX 客户端错误 - 请求有语法错误或请求无法实现</li>
<li>5XX 服务器端错误 - 服务器未能实现合法的请求</li>
</ul>
<p>&emsp;&emsp;我们看下面这个图展示了详细的返回信息，左边可以看到有很多的资源返回码，200 是常用的，表示正常信息，302 表示跳转。response header 里面展示了详细的信息。</p>
<div align="center"><img lazyload src="/images/loading.svg" data-src="Xnip2021-06-17_11-23-14.jpg" width="70%" height="70%"></div>



<h2 id="HTTP-协议是无状态的和-Connection-keep-alive-的区别"><a href="#HTTP-协议是无状态的和-Connection-keep-alive-的区别" class="headerlink" title="HTTP 协议是无状态的和 Connection: keep-alive 的区别"></a>HTTP 协议是无状态的和 Connection: keep-alive 的区别</h2><p>&emsp;&emsp;无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。</p>
<p>&emsp;&emsp;&emsp;&emsp;HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（面对无连接）。</p>
<p>&emsp;&emsp;&emsp;&emsp;从 HTTP/1.1 起，默认都开启了 Keep-Alive 保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的 TCP 连接。</p>
<p>&emsp;&emsp;&emsp;&emsp;Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同服务器软件（如 Apache）中设置这个时间。</p>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin框架源码解析</title>
    <url>/2021/05/25/Gin%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Go框架</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言中自定义sort函数</title>
    <url>/2021/06/10/%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89sort%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="sort库基本介绍"><a href="#sort库基本介绍" class="headerlink" title="sort库基本介绍"></a>sort库基本介绍</h2><p>&emsp;&emsp;该包实现了四种基本的排序算法：插入排序、归并排序、堆排序和快速排序。 但是这四种排序方法是不公开的，它们只被用于 sort 包内部使用。所以在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了 sort.Interface 定义的三个方法：获取数据集合长度的 Len() 方法、比较两个元素大小的 Less() 方法和交换两个元素位置的 Swap() 方法，就可以顺利对数据集合进行排序。sort 包会根据实际数据自动选择高效的排序算法。  除此之外，为了方便对常用数据类型的操作，sort 包提供了对[]int 切片、[]float64 切片和[]string 切片完整支持，主要包括：</p>
<ul>
<li>对基本数据类型切片的排序支持</li>
<li>基本数据元素查找</li>
<li>判断基本数据类型切片是否已经排好序</li>
<li>对排好序的数据集合逆序</li>
</ul>
<h2 id="数据集合排序"><a href="#数据集合排序" class="headerlink" title="数据集合排序"></a>数据集合排序</h2><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="Sort-方法的实现方式"><a href="#Sort-方法的实现方式" class="headerlink" title="Sort()方法的实现方式"></a>Sort()方法的实现方式</h4><p>&emsp;&emsp;前面已经提到过，对数据集合（包括自定义数据类型的集合）排序需要实现 sort.Interface 接口的三个方法，我们看以下该接口的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A type, typically a collection, that satisfies sort.Interface can be</span></span><br><span class="line"><span class="comment">// sorted by the routines in this package. The methods require that the</span></span><br><span class="line"><span class="comment">// elements of the collection be enumerated by an integer index.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">	Len() <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// Less reports whether the element with</span></span><br><span class="line">	<span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">	Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">	Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;当数据集合实现了上面三种方法后，即可调用该包的Sort()方法进行排序。Sort()方法的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sort sorts data.</span></span><br><span class="line"><span class="comment">// It makes one call to data.Len to determine n, and O(n*log(n)) calls to</span></span><br><span class="line"><span class="comment">// data.Less and data.Swap. The sort is not guaranteed to be stable.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span> &#123;</span><br><span class="line">	n := data.Len()</span><br><span class="line">	quickSort(data, <span class="number">0</span>, n, maxDepth(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;从注释中可以知道Sort()方法不能保证排序结果是稳定的。其唯一的参数就是带排序的数据集合。该包还提供了一个方法IsSorted()来判断数据集合是否已经排好顺序，该方法的内部实现依赖于我们自己实现的 Len() 和 Less() 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IsSorted reports whether data is sorted.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSorted</span><span class="params">(data Interface)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	n := data.Len()</span><br><span class="line">	<span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="keyword">if</span> data.Less(i, i<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Reverse-方法的实现方式"><a href="#Reverse-方法的实现方式" class="headerlink" title="Reverse()方法的实现方式"></a>Reverse()方法的实现方式</h4><p>&emsp;&emsp;此外，<em>sort</em>包提供了 Reverse() 方法，可以允许将数据按 Less() 定义的排序方式逆序排序，而不必修改 Less() 代码。方法定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span> <span class="title">Interface</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们可以看到 Reverse() 返回的一个 sort.Interface 接口类型，整个 Reverse() 的内部实现比较有趣：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> reverse <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// This embedded Interface permits Reverse to use the methods of</span></span><br><span class="line">	<span class="comment">// another Interface implementation.</span></span><br><span class="line">	Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Less returns the opposite of the embedded implementation&#x27;s Less method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.Interface.Less(j, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reverse returns the reverse order for data.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span> <span class="title">Interface</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;reverse&#123;data&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Search()方法的实现方式</p>
<p>&emsp;&emsp;该方法会使用“二分查找”算法来找出能使 f(x)(0&lt;=x&lt;n) 返回 ture 的最小值 i。 前提条件 : f(x)(0&lt;=x&lt;i) 均返回 false, f(x)(i&lt;=x&lt;n) 均返回 ture。<font color="red"> 如果不存在 i 可以使 f(i) 返回 ture, 则返回 n</font>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// Define f(-1) == false and f(n) == true.</span></span><br><span class="line">	<span class="comment">// Invariant: f(i-1) == false, f(j) == true.</span></span><br><span class="line">	i, j := <span class="number">0</span>, n</span><br><span class="line">	<span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">		h := <span class="keyword">int</span>(<span class="keyword">uint</span>(i+j) &gt;&gt; <span class="number">1</span>) <span class="comment">// avoid overflow when computing h</span></span><br><span class="line">		<span class="comment">// i ≤ h &lt; j</span></span><br><span class="line">		<span class="keyword">if</span> !f(h) &#123;</span><br><span class="line">			i = h + <span class="number">1</span> <span class="comment">// preserves f(i-1) == false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			j = h <span class="comment">// preserves f(j) == true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以发现，其内部就是通过二分查找搜索元素是否在已经升序排好的切片中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="number">11</span></span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">45</span>&#125; <span class="comment">// 注意已经升序排序</span></span><br><span class="line">pos := sort.Search(<span class="built_in">len</span>(s), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s[i] &gt;= x &#125;)</span><br><span class="line"><span class="keyword">if</span> pos &lt; <span class="built_in">len</span>(s) &amp;&amp; s[pos] == x &#123;</span><br><span class="line">    fmt.Println(x, <span class="string">&quot; 在 s 中的位置为：&quot;</span>, pos)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;s 不包含元素 &quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;官方文档还给出了一个猜数字的小程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GuessingGame</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Pick an integer from 0 to 100.\n&quot;</span>)</span><br><span class="line">	answer := sort.Search(<span class="number">100</span>, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Is your number &lt;= %d? &quot;</span>, i)</span><br><span class="line">		fmt.Scanf(<span class="string">&quot;%s&quot;</span>, &amp;s)</span><br><span class="line">		<span class="keyword">return</span> s != <span class="string">&quot;&quot;</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">&#x27;y&#x27;</span></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Your number is %d.\n&quot;</span>, answer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用示例I"><a href="#使用示例I" class="headerlink" title="使用示例I"></a>使用示例I</h3><p>&emsp;&emsp;下面是一个使用 sort 包对学生成绩排序的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学生成绩结构体</span></span><br><span class="line"><span class="keyword">type</span> StuScore <span class="keyword">struct</span> &#123;</span><br><span class="line">    name  <span class="keyword">string</span>    <span class="comment">// 姓名</span></span><br><span class="line">    score <span class="keyword">int</span>   <span class="comment">// 成绩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StuScore []StuScore</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScore)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swap()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScore)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  	s[i],s[j] = s[j],s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Less():成绩从低到高排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScore)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> s[i].score &lt; s[j].score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stus := StuScores&#123;</span><br><span class="line">                &#123;<span class="string">&quot;alan&quot;</span>, <span class="number">95</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;hikerell&quot;</span>, <span class="number">91</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;acmfly&quot;</span>, <span class="number">96</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;leao&quot;</span>, <span class="number">90</span>&#125;,</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">		<span class="comment">// 打印未排序的 stus 数据</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Default:\n\t&quot;</span>,stus)</span><br><span class="line">    <span class="comment">//StuScores 已经实现了 sort.Interface 接口 , 所以可以调用 Sort 函数进行排序</span></span><br><span class="line">		sort.Sort(stus)</span><br><span class="line">		<span class="comment">// 判断是否已经排好顺序，将会打印 true</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;IS Sorted?\n\t&quot;</span>, sort.IsSorted(stus))</span><br><span class="line">		<span class="comment">// 打印排序后的 stus 数据</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Sorted:\n\t&quot;</span>,stus)		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;该示例程序的自定义类型 StuScores 实现了 sort.Interface 接口，所以可以将其对象作为 sort.Sort() 和 sort.IsSorted() 的参数传入。运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Default:</span><br><span class="line">     [&#123;alan <span class="number">95</span>&#125; &#123;hikerell <span class="number">91</span>&#125; &#123;acmfly <span class="number">96</span>&#125; &#123;leao <span class="number">90</span>&#125;]</span><br><span class="line">IS Sorted?</span><br><span class="line">     <span class="literal">true</span></span><br><span class="line">Sorted:</span><br><span class="line">     [&#123;leao <span class="number">90</span>&#125; &#123;hikerell <span class="number">91</span>&#125; &#123;alan <span class="number">95</span>&#125; &#123;acmfly <span class="number">96</span>&#125;]</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;可以在学生成绩排序示例中使用 Reverse() 来实现成绩降序排序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sort.Sort(sort.Reverse(stus))</span><br><span class="line">fmt.Println(stus)</span><br></pre></td></tr></table></figure>



<h3 id="使用示例II"><a href="#使用示例II" class="headerlink" title="使用示例II"></a>使用示例II</h3><p>&emsp;&emsp;下面是一个根据文件元信息中文件上传时间顺序进行排序的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">		<span class="string">&quot;sort&quot;</span></span><br><span class="line">  	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baseFormate = <span class="string">&quot;2006-01-02 15:04:05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FileMetas <span class="keyword">struct</span> &#123;</span><br><span class="line">  	FileSha1	<span class="keyword">string</span>	<span class="comment">// 文件的哈希值</span></span><br><span class="line">  	FileNames <span class="keyword">string</span></span><br><span class="line">  	FileSize	<span class="keyword">int64</span></span><br><span class="line">  	Location	<span class="keyword">string</span></span><br><span class="line">  	UploadAt	<span class="keyword">string</span>  <span class="comment">// 文件的上传时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByUploadTime []FileMetas</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b ByUploadTime)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">len</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b ByUploadTime)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	b[i],b[j] = b[j],b[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b ByUploadTime)</span> <span class="title">Less</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	iTime,_ := time.Parse(baseFormate,b[i].UploadAt)</span><br><span class="line">  	jTime,_ := time.Parse(baseFormate,b[j].UploadAt)</span><br><span class="line">  	<span class="keyword">return</span> iTime.UnixNano() &gt; jTime.UnixNano()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	fMetaArray := <span class="built_in">make</span>([]FileMetas,<span class="number">0</span>)</span><br><span class="line">  	<span class="keyword">for</span> _, v := <span class="keyword">range</span> fileMetas &#123;  <span class="comment">// 假设fileMetas是一个已经给定储存的文件元信息的map</span></span><br><span class="line">			fMetaArray = <span class="built_in">append</span>(fMetaArray, v)</span><br><span class="line">		&#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 将文件元信息列表按上传时间排序</span></span><br><span class="line">  	sort.Sort(ByUploadAt(fMetaArray))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="sort包已经支持的内部数据类型排序"><a href="#sort包已经支持的内部数据类型排序" class="headerlink" title="sort包已经支持的内部数据类型排序"></a>sort包已经支持的内部数据类型排序</h2><p>&emsp;&emsp;<em>sort</em>包原生支持[]int、[]float64 和[]string 三种内建数据类型切片的排序操作，即不必我们自己实现相关的 Len()、Less() 和 Swap() 方法。</p>
<h3 id="IntSlice-类型及-int-排序"><a href="#IntSlice-类型及-int-排序" class="headerlink" title="IntSlice 类型及[]int 排序"></a><strong>IntSlice 类型及[]int 排序</strong></h3><p>&emsp;&emsp;由于[]int 切片排序内部实现及使用方法与[]float64 和[]string 类似，所以只详细描述该部分。<em>sort</em>包定义了一个 IntSlice 类型，并且实现了 sort.Interface 接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sort sorts data.</span></span><br><span class="line"><span class="comment">// It makes one call to data.Len to determine n, and O(n*log(n)) calls to</span></span><br><span class="line"><span class="comment">// data.Less and data.Swap. The sort is not guaranteed to be stable.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span> &#123;</span><br><span class="line">	n := data.Len()</span><br><span class="line">	quickSort(data, <span class="number">0</span>, n, maxDepth(n))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// IntSlice attaches the methods of Interface to []int, sorting in increasing order.</span></span><br><span class="line"><span class="keyword">type</span> IntSlice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort is a convenience method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123; Sort(p) &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;并且提供的 sort.Ints() 方法使用了该 IntSlice 类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ints sorts a slice of ints in increasing order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ints</span><span class="params">(a []<span class="keyword">int</span>)</span></span> &#123; Sort(IntSlice(a)) &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;所以，对[]int 切片排序更常使用 sort.Ints()，而不是直接使用 IntSlice 类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125; <span class="comment">// 未排序的切片数据</span></span><br><span class="line">sort.Ints(s)</span><br><span class="line">fmt.Println(s) <span class="comment">// 将会输出[1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果要使用降序排序，可以用前面提到的 Reverse() 方法(当然也可以自己实现Len()、Swap()、Less()三个方法，使用sort.Sort()排序)。这里的Reverse()方法中的参数只能是sort.IntSlice()，而不能是sort.Ints()。因为sort.IntSlice()是将s强制类型转换成IntSlice类型，sort.Reverse()实质上改变了其内部的reverse结构存储的IntSlice类型(参考前面的Reverse方法源码)的Less方法，实现反向排序；而sort.Ints()则是实现升序排序的方法，二者有本质区别：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125; <span class="comment">// 未排序的切片数据</span></span><br><span class="line">sort.Sort(sort.Reverse(sort.IntSlice(s)))</span><br><span class="line">fmt.Println(s) <span class="comment">// 将会输出[6 5 4 3 2 1]</span></span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;与IsSorted()对应的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IntsAreSorted tests whether a slice of ints is sorted in increasing order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntsAreSorted</span><span class="params">(a []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> IsSorted(IntSlice(a)) &#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;如果要查找整数 x 在切片 a 中的位置，相对于前面提到的 Search() 方法，<em>sort</em>包提供了 SearchInts(),注意，SearchInts() 的使用条件为：<font color="red"><strong>切片 a 已经升序排序</strong></font>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SearchInts searches for x in a sorted slice of ints and returns the index</span></span><br><span class="line"><span class="comment">// as specified by Search. The return value is the index to insert x if x is</span></span><br><span class="line"><span class="comment">// not present (it could be len(a)).</span></span><br><span class="line"><span class="comment">// The slice must be sorted in ascending order.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchInts</span><span class="params">(a []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= x &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Float64Slice-类型及-float64-排序"><a href="#Float64Slice-类型及-float64-排序" class="headerlink" title="Float64Slice 类型及[]float64 排序"></a><strong>Float64Slice 类型及[]float64 排序</strong></h3><p>&emsp;&emsp;实现与 Ints 类似，只看一下其内部实现，要说明一下的是，在上面 Float64Slice 类型定义的 Less 方法中，有一个内部函数 isNaN()。 isNaN() 与<em>math</em>包中 IsNaN() 实现完全相同，<em>sort</em>包之所以不使用 math.IsNaN()，完全是基于包依赖性的考虑，应当看到，<em>sort</em>包的实现不依赖与其他任何包。：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Float64Slice []<span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] || isNaN(p[i]) &amp;&amp; !isNaN(p[j]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123; Sort(p) &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;与 Sort()、IsSorted()、Search() 对应的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64s</span><span class="params">(a []<span class="keyword">float64</span>)</span></span> &#123; Sort(Float64Slice(a)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64sAreSorted</span><span class="params">(a []<span class="keyword">float64</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> IsSorted(Float64Slice(a)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchFloat64s</span><span class="params">(a []<span class="keyword">float64</span>, x <span class="keyword">float64</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= x &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="StringSlice-类型及-string-排序"><a href="#StringSlice-类型及-string-排序" class="headerlink" title="StringSlice 类型及[]string 排序"></a><strong>StringSlice 类型及[]string 排序</strong></h3><p>&emsp;&emsp;两个 string 对象之间的大小比较是基于“字典序”的。实现与 Ints 类似，只看一下其内部实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123; Sort(p) &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;与 Sort()、IsSorted()、Search()对应的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Strings</span><span class="params">(a []<span class="keyword">string</span>)</span></span> &#123; Sort(StringSlice(a)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringsAreSorted</span><span class="params">(a []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> IsSorted(StringSlice(a)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchStrings</span><span class="params">(a []<span class="keyword">string</span>, x <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= x &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="interface-排序与查找"><a href="#interface-排序与查找" class="headerlink" title="[]interface 排序与查找"></a>[]interface 排序与查找</h2><p>&emsp;&emsp;通过前面的内容我们可以知道，只要实现了 <code>sort.Interface</code> 接口，即可通过 sort 包内的函数完成排序，查找等操作。并且 sort 包已经帮我们把<code>[]int</code>,<code>[]float64</code>,<code>[]string</code> 三种类型都实现了该接口，我们可以方便的调用。但是这种用法对于其它数据类型的 slice 不友好，可能我们需要为大量的 struct 定义一个单独的 []struct 类型，再为其实现 <code>sort.Interface</code> 接口，类似这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Persons []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persons)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persons)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persons)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里可以引申一个问题，为什么 sort 包可以完成 <code>[]int</code> 的排序，而不能完成 <code>[]struct</code> 的排序？因为排序涉及到比较两个变量的值，而 struct 可能包含多个属性，程序并不知道你想以哪一个属性或哪几个属性作为衡量大小的标准。如果你能帮助程序完成比较，并将结果返回， sort 包内的方法就可以完成排序，判断，查找等。sort 包提供了以下函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">(slice <span class="keyword">interface</span>&#123;&#125;, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceStable</span><span class="params">(slice <span class="keyword">interface</span>&#123;&#125;, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>)</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceIsSorted</span><span class="params">(slice <span class="keyword">interface</span>&#123;&#125;, less <span class="keyword">func</span>(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">bool</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;通过函数签名可以看到，排序相关的三个函数都接收 <code>[]interface</code>，并且需要传入一个比较函数，用于为程序比较两个变量的大小，因为函数签名和作用域的原因，这个函数只能是 <code>匿名函数</code>。</p>
<h3 id="sort-Slice"><a href="#sort-Slice" class="headerlink" title="sort.Slice"></a><strong>sort.Slice</strong></h3><p>该函数完成 []interface 的排序，举个栗子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">people := []<span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">	&#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">55</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Age &lt; people[j].Age &#125;) <span class="comment">// 按年龄升序排序</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Sort by age:&quot;</span>, people)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Sort by age: [&#123;Gopher <span class="number">7</span>&#125; &#123;Vera <span class="number">24</span>&#125; &#123;Alice <span class="number">55</span>&#125; &#123;Bob <span class="number">75</span>&#125;]</span><br></pre></td></tr></table></figure>



<h3 id="sort-SliceStable"><a href="#sort-SliceStable" class="headerlink" title="sort.SliceStable"></a><strong>sort.SliceStable</strong></h3><p>该函数完成 []interface 的稳定排序，举个栗子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">people := []<span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">	&#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">75</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.SliceStable(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Age &gt; people[j].Age &#125;) <span class="comment">// 按年龄降序排序</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Sort by age:&quot;</span>, people)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Sort by age: [&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">75</span>&#125;	&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>&#125;	&#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;	&#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">7</span>&#125;]</span><br></pre></td></tr></table></figure>



<h3 id="sort-SliceIsSorted"><a href="#sort-SliceIsSorted" class="headerlink" title="sort.SliceIsSorted"></a><strong>sort.SliceIsSorted</strong></h3><p>该函数判断 []interface 是否为有序，举个栗子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">people := []<span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">55</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">75</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Age &gt; people[j].Age &#125;) <span class="comment">// 按年龄降序排序</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Sort by age:&quot;</span>, people)</span><br><span class="line">fmt.Println(<span class="string">&quot;Sorted:&quot;</span>,sort.SliceIsSorted(people,<span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> people[i].Age &lt; people[j].Age &#125;))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Sort by age: [&#123;Bob <span class="number">75</span>&#125; &#123;Alice <span class="number">55</span>&#125; &#123;Vera <span class="number">24</span>&#125; &#123;Gopher <span class="number">7</span>&#125;]</span><br><span class="line">Sorted: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;sort 包没有为 []interface 提供反序函数，但是从 1 和 2 可以看出，我们传入的比较函数已经决定了排序结果是升序还是降序。</p>
<p>&emsp;&emsp;判断 slice 是否为有序，同样取决于我们传入的比较函数，从 3 可以看出，虽然 slice 已经按年龄降序排序，但我们在判断 slice 是否为有序时给的比较函数是判断其是否为升序有序，所以最终得到的结果为 false。</p>
<h3 id="sort-Search"><a href="#sort-Search" class="headerlink" title="sort.Search"></a><strong>sort.Search</strong></h3><p>该函数判断 []interface 是否存在指定元素，举个栗子：</p>
<ul>
<li>升序 slice</li>
</ul>
<p>&emsp;&emsp;sort 包为 <code>[]int</code>,<code>[]float64</code>,<code>[]string</code> 提供的 Search 函数其实也是调用的该函数，因为该函数是使用的二分查找法，所以要求 slice 为升序排序状态。并且判断条件必须为 <code>&gt;=</code>，这也是官方库提供的三个查找相关函数的的写法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">21</span>, <span class="number">234</span>, <span class="number">56</span>&#125;</span><br><span class="line">x := <span class="number">21</span></span><br><span class="line"></span><br><span class="line">sort.Slice(a, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &lt; a[j] &#125;)   <span class="comment">// 升序排序</span></span><br><span class="line">index := sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= x &#125;) <span class="comment">// 查找元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span>(a) &amp;&amp; a[index] == x &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;found %d at index %d in %v\n&quot;</span>, x, index, a)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d not found in %v,index:%d\n&quot;</span>, x, a, index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">found <span class="number">21</span> at index <span class="number">3</span> in [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">21</span> <span class="number">56</span> <span class="number">100</span> <span class="number">200</span> <span class="number">234</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>降序 slice</li>
</ul>
<p>&emsp;&emsp;如果 slice 是降序状态，而我们又不想将其变为升序，只需将判断条件由 <code>&gt;=</code> 变更为 <code>&lt;=</code> 即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a class="link" href="https://github.com/golang/go">golang/go<i class="fas fa-external-link-alt"></i></a></p>
<p>2.<a class="link" href="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example/blob/master/chapter03/03.1.md">sort—排序算法<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>Go语言标准库</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>在O(1)时间内删除或查找任意元素</title>
    <url>/2021/06/20/%E5%9C%A8O(1)%E6%97%B6%E9%97%B4%E5%86%85%E5%88%A0%E9%99%A4%E6%88%96%E6%9F%A5%E6%89%BE%E4%BB%BB%E6%84%8F%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>&emsp;&emsp;本文会介绍两道比较有技巧性的算法与数据结构题，都是和随机读取元素相关的。这些问题的技巧性子阿宇如何将哈希表和数组结合起来，使得数组的删除操作时间复杂度变成O(1)。</p>
<h2 id="实现随机集合"><a href="#实现随机集合" class="headerlink" title="实现随机集合"></a>实现随机集合</h2><p><a class="link" href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/">O(1) 时间插入、删除和获取随机元素<i class="fas fa-external-link-alt"></i></a></p>
<p>设计一个支持在<em>平均</em> 时间复杂度 <strong>O(1)</strong> 下，执行以下操作的数据结构。</p>
<ol>
<li>insert(val)：当元素 val 不存在时，向集合中插入该项。</li>
<li>remove(val)：元素 val 存在时，从集合中移除该项。</li>
<li>getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。</li>
</ol>
<p><strong>示例 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化一个空的集合。</span><br><span class="line">RandomizedSet randomSet &#x3D; new RandomizedSet();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span><br><span class="line">randomSet.insert(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回 false ，表示集合中不存在 2 。</span><br><span class="line">randomSet.remove(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom 应随机返回 1 或 2 。</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span><br><span class="line">randomSet.remove(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2 已在集合中，所以返回 false 。</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure>



<p>本题的难点在于两点：</p>
<p>**1、插入，删除，获取随机元素这三个操作的时间复杂度必须都是 O(1)**。</p>
<p><strong>2、**</strong><code>getRandom</code>** <strong>方法返回的元素必须等概率返回随机元素</strong>，也就是说，如果集合里面有 <code>n</code> 个元素，每个元素被返回的概率必须是 <code>1/n</code>。</p>
<p>我们先来分析一下：对于插入，删除，查找这几个操作，哪种数据结构的时间复杂度是 O(1)？</p>
<p><code>HashSet</code> 肯定算一个对吧。哈希集合的底层原理就是一个大数组，我们把元素通过哈希函数映射到一个索引上；如果用拉链法解决哈希冲突，那么这个索引可能连着一个链表或者红黑树。</p>
<p>那么请问对于这样一个标准的 <code>HashSet</code>，你能否在 O(1) 的时间内实现 <code>getRandom</code> 函数？</p>
<p>其实是不能的，因为根据刚才说到的底层实现，元素是被哈希函数「分散」到整个数组里面的，更别说还有拉链法等等解决哈希冲突的机制，基本做不到 O(1) 时间等概率随机获取元素。</p>
<p>根据上面的分析，对于 <code>getRandom</code> 方法，如果想「等概率」且「在 O(1) 的时间」取出元素，一定要满足：<strong>底层用数组实现，且数组必须是紧凑的</strong>。</p>
<p>这样我们就可以直接生成随机数作为索引，从数组中取出该随机索引对应的元素，作为随机元素。</p>
<p><strong>但如果用数组存储元素的话，插入，删除的时间复杂度怎么可能是 O(1) 呢</strong>？</p>
<p>可以做到！对数组尾部进行插入和删除操作不会涉及数据搬移，时间复杂度是 O(1)。</p>
<p><strong>所以，如果我们想在 O(1) 的时间删除数组中的某一个元素</strong> **<code>val</code>**<strong>，可以先把这个元素交换到数组的尾部，然后再</strong> <strong><code>pop</code></strong> <strong>掉</strong>。</p>
<p>交换两个元素必须通过索引进行交换对吧，那么我们需要一个哈希表 <code>m</code> 来记录每个元素值对应的索引。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RandomizedSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    nums []<span class="keyword">int</span></span><br><span class="line">    m    <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">RandomizedSet</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> RandomizedSet&#123;<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>),<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">0</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span> <span class="title">Insert</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.m[val];ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.nums = <span class="built_in">append</span>(this.nums,val) <span class="comment">// 在数组末尾插入val</span></span><br><span class="line">    this.m[val] = <span class="built_in">len</span>(this.nums)<span class="number">-1</span>    <span class="comment">// 将val作为key加入到map中，其value是其在数组中的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span> <span class="title">Remove</span><span class="params">(val <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.m[val];!ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    index := this.m[val]</span><br><span class="line">    this.nums[index] = this.nums[<span class="built_in">len</span>(this.nums)<span class="number">-1</span>]  <span class="comment">// 将数组最后一个元素移动到index的位置</span></span><br><span class="line">    this.m[this.nums[index]] = index                <span class="comment">// 更新移动后元素在map中的value值</span></span><br><span class="line">    <span class="built_in">delete</span>(this.m, val)															<span class="comment">// 删除val健值对</span></span><br><span class="line">    this.nums = this.nums[:<span class="built_in">len</span>(this.nums)<span class="number">-1</span>]        <span class="comment">// pop数组最后一个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get a random element from the set. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span> <span class="title">GetRandom</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	i := rand.Intn(<span class="built_in">len</span>(this.nums))    <span class="comment">// i取从0到len(this.nums)-1的随机数</span></span><br><span class="line">    <span class="keyword">return</span> this.nums[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Insert(val);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Remove(val);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.GetRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>用Go语言实现栈</title>
    <url>/2021/08/05/%E7%94%A8Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<h2 id="自定义栈的功能"><a href="#自定义栈的功能" class="headerlink" title="自定义栈的功能"></a>自定义栈的功能</h2><p>&emsp;&emsp;本文旨在通过Go语言来实现一个自定义的栈，其功能包括入栈、出栈、栈容量查询、栈内元素个数查询、栈顶元素查询、是否空栈查询。</p>
<h2 id="栈的初始化"><a href="#栈的初始化" class="headerlink" title="栈的初始化"></a>栈的初始化</h2><p>首先创建一个能保存数据的结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack []<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里声明Stack为空接口类型的切片（Go语言之中的切片可以理解为一个长度可变的数组）。由于Go语言所有类型都实现了空接口，因此任意类型的值都可以存储在Stack之中。</p>
<h2 id="栈的长度及容量"><a href="#栈的长度及容量" class="headerlink" title="栈的长度及容量"></a>栈的长度及容量</h2><p>&emsp;&emsp;由于Stack的底层数据类型是一个切片，我们可以为其实现<code>Len()</code>和<code>Cap()</code>方法用来获取其长度和容量（Go语言之中首字母大写的方法为包外可访问的，类似于Java或者C++之中类的public方法）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;  <span class="comment">// 栈的长度</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(stack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span></span> &#123;  <span class="comment">// 栈的容量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">cap</span>(stack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="查询是否是空栈"><a href="#查询是否是空栈" class="headerlink" title="查询是否是空栈"></a>查询是否是空栈</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="栈的关键方法的实现（Push-、Pop-、Top-）"><a href="#栈的关键方法的实现（Push-、Pop-、Top-）" class="headerlink" title="栈的关键方法的实现（Push()、Pop()、Top()）"></a>栈的关键方法的实现（Push()、Pop()、Top()）</h2><p>&emsp;&emsp;<code>Push()</code>方法的接收器为一个Stack类型的指针（Go指针的写法与C/C++类似，类型前面加上*号）。Go语言的所有方法参数都是值传递，接收器实际也是作为方法的一个参数传递进入方法的。如果传递一切片或者数组进方法，实际是将切片或数组的值拷贝了一份传入了方法之中，此时在方法之中对该切片或数组做的操作都不会影响方法之外的原始值。如果想要方法之中的操作影响到方法外的原始值，则应该使用指针作为参数，对指针的操作会直接反应到内存之中的原始值上去。在这里我们希望更改原始值（往原始的<code>stack</code>之中添加数据）， 所以接收器是一个指针。方法的参数是一个<code>interface&#123;&#125;</code>类型的值，也就是说该方法可以接受任意类型作为参数。方法的实现使用了内建函数<code>append()</code>，往切片对尾部中添加新值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Push</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  *stack = <span class="built_in">append</span>(*stack, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;<code>Top()</code>方法返回一个任意类型的值以及一个<code>error</code>（是的没错，Go语言的方法可以返回多个值）。当stack为空时，返回一个空值和一个<code>error</code>类型的值（这里使用<code>errors</code>包的<code>New()</code>函数创建）。当stack不为空时，返回底层切片的最后一个值和一个空的<code>error</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">Top</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;,error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;Out of index, len is 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>], <span class="literal">nil</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;<code>Pop()</code>方法的接收器同样是一个Stack的指针。其中<code>theStack[:len(theStack) - 1]</code>这种写法，是Go中取子切片的方法，<code>:</code>两边是起始index和结束index。起始index为0时可以省略。结束的index也可以省略，省略时结束index为切片的<code>len()</code>值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;,error)</span></span> &#123;</span><br><span class="line">  theStack := *stack</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(theStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, error.New(<span class="string">&quot;Out of index, len is 0&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  value := theStack[<span class="built_in">len</span>(theStack)<span class="number">-1</span>]</span><br><span class="line">  *stack = theStack[:<span class="built_in">len</span>(theStack)<span class="number">-1</span>]</span><br><span class="line">  <span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Go语言数据结构</category>
      </categories>
      <tags>
        <tag>自定义栈</tag>
      </tags>
  </entry>
  <entry>
    <title>递归算法解决二叉树问题</title>
    <url>/2021/08/18/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="递归算法的原理"><a href="#递归算法的原理" class="headerlink" title="递归算法的原理"></a>递归算法的原理</h1><p>&emsp;&emsp;一个递归函数的调用类似于多个函数的嵌套调用，只不过调用函数和被调函数都是同一个函数。在解决递归问题时，最重要的是不要陷入递归的逻辑中去，视角要以一个节点为根基来考虑整个问题。递归调用时内部的执行过程如下:</p>
<ol>
<li>首先为递归调用建立一个<font color="blue">工作栈</font>，其结构包括值参、局部变量和返回地址；</li>
<li>每次执行递归调用前，把<font color="red">递归函数的值参、局部变量的当前值</font>以及<font color="red">调用后的返回地址</font>压栈；</li>
<li>每次递归调用结束后，将栈顶元素推出，使相应的<font color="red">值参</font>和<font color="red">局部变量</font>恢复为<font color="blue">调用前的值</font>，然后转向返回地址的位置继续执行。</li>
</ol>
<p>&emsp;&emsp;在明确了递归函数的执行过程后，只要把握好如下3个步骤即可：</p>
<ol>
<li>明确递归函数的作用；</li>
<li>明确终止条件和相应的解决办法；</li>
<li>找出函数的等价关系式，提取重复的逻辑缩小问题规模。</li>
</ol>
<h1 id="递归三步走"><a href="#递归三步走" class="headerlink" title="递归三步走"></a>递归三步走</h1><h2 id="1-明确函数功能"><a href="#1-明确函数功能" class="headerlink" title="1.明确函数功能"></a>1.明确函数功能</h2><p>&emsp;&emsp;首先要确定这个函数的具体功能是什么？它的参数有哪些？它的全局变量是什么？递归的时候要根据题目的要求设置函数功能，再根据函数功能来设置函数的参数。</p>
<p>&emsp;&emsp;<font color="red">方法参数：</font>这个方法的参数最好由当前阶段的状态决定。</p>
<p>&emsp;&emsp;<font color="red">返回数据：</font>返回数据是我们遇到递归出口之后，需要告诉前一步递归的信息数据。</p>
<p>注意：</p>
<ul>
<li>递归函数的<strong>返回值</strong>最好设置为<strong>单个元素</strong>，比如说<strong>一个节点</strong>或者<strong>一个数值</strong>，告诉前一步递归我们现在的结果数据即可；</li>
<li>如果返回值是<strong>数组</strong>的话，我们将无法从中提取到任何有效信息来进行操作；</li>
<li>如果结果需要<strong>数组</strong>的话，我们可以将数组作为公共变量返回值为void，我们在方法体里面操作数组即可。</li>
</ul>
<h2 id="2-寻找递归出口"><a href="#2-寻找递归出口" class="headerlink" title="2.寻找递归出口"></a>2.寻找递归出口</h2><p>&emsp;&emsp;在递归函数的一开始，我们应该思考什么时候该结束递归。因此，递归一定要有结束条件，不然会永远的递归下去。<font color="red">递归出口</font>一般为某深度或叶子结点，或非叶子结点（包括根节点）、所有节点等。决定递归出去后要执行的操作。由于我们的节点状态可能需要多个参数来表示，所以我们的递归出口可能并不唯一，可能需要为每一个转台参数安排一个递归出口，确保我们的递归能够确实有效地出去。</p>
<p><font color="blue">特别注意的：</font>每次提交数组的集合（即<code>list(dst())</code>）的时候，要创建一个新的数组<code>copy()</code>来存放结果数组<code>dst()</code>，不然后面操作的都是加入集合<code>list()</code>的那个数组<code>dst()</code>。</p>
<p>&emsp;&emsp;我们的递归出口并不一定都是在最开头的位置，我们一般在最开头设置递归出口是希望递归能以最快的速度出去；但是<strong>有时候我们在对当前节点进行一些相关处理操作之后我们就希望判断一下能不能递归出口</strong>，所以<strong>递归出口有可能是在代码中间的</strong>，大家需要灵活应用。在这一步，我们需要思考题目需要的解在哪里？是<strong>在某一具体的深度</strong>、还是在<strong>叶子结点</strong>、还是在<strong>非叶子结点</strong>（包括<strong>根节点</strong>）、还是在<strong>每个节点</strong>、还是<strong>在从跟结点到叶子结点的路径</strong>？</p>
<ul>
<li>在某一具体深度：<code>if depth &gt;= n</code></li>
<li>在每个节点：<code>if root != nil </code></li>
</ul>
<h2 id="3-找出递推关系"><a href="#3-找出递推关系" class="headerlink" title="3.找出递推关系"></a>3.找出递推关系</h2><p>&emsp;&emsp;类比于数学归纳法。算n的阶乘：</p>
<ul>
<li>初始条件：<code>f(1) = 1</code></li>
<li>递推关系式：<code>f(n) = f(n-1) * n</code></li>
</ul>
<p>递归关系：</p>
<ul>
<li>递：<code>f(n) = n * f(n-1)</code>，将<strong>f(n)→f(n-1)<strong>了。这样，</strong>问题就由n缩小为了n-1</strong>，并且为了原函数<code>f(n)</code>不变，我们需要让<code>f(n-1)</code>乘以<code>n</code>。就这样慢慢从<code>f(n)</code>,<code>f(n-1)</code><strong>“递”</strong>到<code>f(1)</code>。</li>
<li>归：这样就可以从<code>n=1</code>，一步一步<strong>“归”</strong>到<code>n=2,n=3,...</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span> &#123; <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> f(n<span class="number">-1</span>)*n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="运用递归的二叉树算法题"><a href="#运用递归的二叉树算法题" class="headerlink" title="运用递归的二叉树算法题"></a>运用递归的二叉树算法题</h1><p>&emsp;&emsp;二叉树的递归框架无外乎二叉树的三种遍历方式：前序遍历、中序遍历、后序遍历。在想好递归出口后，就要考虑采用何种方式来遍历整个二叉树有助于我们解决问题。解决这类问题的核心难点是不要深入进递归细节中，不要把自己的大脑当计算机来用！只要着眼于根节点，在设置好递归出口的前提下就能顺利地解题。</p>
<h2 id="1-直接递归遍历整个二叉树后返回根节点"><a href="#1-直接递归遍历整个二叉树后返回根节点" class="headerlink" title="1.直接递归遍历整个二叉树后返回根节点"></a>1.直接递归遍历整个二叉树后返回根节点</h2><p>&emsp;&emsp;此类问题不需要引入一个用于记录和更新极值结果的中间全局变量，只需要对二叉树本身进行操作，所以在传入的方法参数上比较简单，只需要关注于节点本身（以根节点为视角和着眼点）。大多数题目都是针对树结构进行性重建，查找或删除等操作。</p>
<h3 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p><strong>示例 1:</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="tree.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: preorder &#x3D; [-1], inorder &#x3D; [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<p>对于任意一颗树而言，前序遍历的形式总是：</p>
<p><code>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</code><br>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是：</p>
<p><code>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</code></p>
<p>&emsp;&emsp;只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;  <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">		</span><br><span class="line">  root := &amp;TreeNode&#123;preorder[<span class="number">0</span>],<span class="literal">nil</span>,<span class="literal">nil</span>&#125; <span class="comment">// 着眼于根节点</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(inorder); i++ &#123;  <span class="comment">// 找到在中序遍历数组中根节点的位置</span></span><br><span class="line">  	<span class="keyword">if</span> inorder[i] == preorder[<span class="number">0</span>] &#123;</span><br><span class="line">    	<span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  	</span><br><span class="line">  root.Left = buildTree(preorder[<span class="number">1</span>:i+<span class="number">1</span>], inorder[:i])  <span class="comment">// 构建左子树</span></span><br><span class="line">  root.Right = buildTree(preorder[i+<span class="number">1</span>:], inorder[i+<span class="number">1</span>:])  <span class="comment">// 构建右子树</span></span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(inorder []<span class="keyword">int</span>, postorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(postorder) == <span class="number">0</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  	</span><br><span class="line">  root := &amp;TreeNode&#123;postorder[<span class="built_in">len</span>(postorder)<span class="number">-1</span>],<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">  i:=<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> ; i&lt;<span class="built_in">len</span>(inorder); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> inorder[i] == postorder[<span class="built_in">len</span>(postorder)<span class="number">-1</span>] &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  root.Left = build(inorder[:i],postorder[:i])</span><br><span class="line">  root.Right = build(inorder[i+<span class="number">1</span>:],postorder[i:<span class="built_in">len</span>(postorder)<span class="number">-1</span>])</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>翻转一棵二叉树。</p>
<p><strong>示例：</strong></p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<p>废话少说，直接看代码吧，简单题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  left := invertTree(root.Left)</span><br><span class="line">  right := invertTree(root.Right)  <span class="comment">// 后序遍历</span></span><br><span class="line">  root.Left = right</span><br><span class="line">  root.Right = left</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a class="link" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<p>简单题，直接上代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  <span class="comment">// 递归出口，空节点返回深度0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  left := maxDepth(root.Left)  <span class="comment">// 左子树深度</span></span><br><span class="line">  right := maxDepth(root.Right)  <span class="comment">// 右子树深度</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>+max(left,right)  <span class="comment">// 返回最终深度=左右子树最大深度+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> a&gt;=b &#123;</span><br><span class="line">  	<span class="keyword">return</span> a</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre>
<p> 但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;如果同时满足下面的条件，两个树互为镜像：</p>
<ul>
<li>它们的两个根结点具有相同的值；</li>
<li>每个树的右子树都与另一个树的左子树镜像对称。</li>
</ul>
<p>&emsp;&emsp;我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移；p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> check(root, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(q,p *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> q == <span class="literal">nil</span> &amp;&amp; p == <span class="literal">nil</span> &#123;  <span class="comment">// p，q均为空节点，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> q == <span class="literal">nil</span> || p == <span class="literal">nil</span> &#123; <span class="comment">// p，q只有其中一者为空节点，返回false</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 1.p，q节点的值相等；2.q的左节点与p的右节点相等；3.q的右节点与p的左节点相等。</span></span><br><span class="line">  <span class="keyword">return</span> q.Val == p.Val &amp;&amp; check(q.Left,p.Right) &amp;&amp; check(q.Right,p.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a class="link" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="binarytree.png" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="binarytree2.png" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">树中节点数目在范围 [2, 105] 内。</span><br><span class="line">-109 &lt;&#x3D; Node.val &lt;&#x3D; 109</span><br><span class="line">所有 Node.val 互不相同 。</span><br><span class="line">p !&#x3D; q</span><br><span class="line">p 和 q 均存在于给定的二叉树中。</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;我们递归遍历整棵二叉树，定义 $f_{x}$ 表示 $x$ 节点的子树中是否包含 $p$ 节点或 $q$ 节点，如果包含为<code>true</code>,否则为<code>false</code>。那么符合条件的最近公共祖先 $x$ 一定满足如下条件：</p>
<p>$\left(f_{\text {lson }} &amp; &amp; f_{\text {rson }}\right) |\left((x=p | x=q) &amp; &amp;\left(f_{\text {lson }} | f_{\text {rson }}\right)\right)$</p>
<p>其中 $<em>{\text{lson}}$ 和 $</em>{\text{rson}}$ 分别代表 $x$ 节点的左孩子和右孩子。$\left(f_{\text {lson }} &amp; &amp; f_{\text {rson }}\right)$ 说明左子树和右子树均包含 $p$ 节点或 $q$ 节点，如果左子树包含的是 $p$ 节点，那么右子树只能包含 $q$ 节点，反之亦然，因为 $p$ 节点和 $q$ 节点都是不同且唯一的节点，因此如果满足这个判断条件即可说明 $x$ 就是我们要找的最近公共祖先。再来看第二条判断条件，这个判断条件即是考虑了 $x$ 恰好是 $p$ 节点或 $q$ 节点且它的左子树或右子树有一个包含了另一个节点的情况，因此如果满足这个判断条件亦可说明 $x$ 就是我们要找的最近公共祖先。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> root == p || root == q &#123; <span class="comment">// 当遇到p或q节点时剪枝，不再向下递，开始归</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  left := lowestCommonAncestor(root.Left,p,q)</span><br><span class="line">  right := lowestCommonAncestor(root.Right,p,q) <span class="comment">// 后序遍历的框架</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123; <span class="comment">// p,q节点分别在左右子树，当前节点即是共同祖先</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> left == <span class="literal">nil</span> &#123; <span class="comment">// 左子树中不包含p，q节点，右子树包含其中之一，该节点本身是p，q中的另一个</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> left <span class="comment">// 右子树中不包含p，q节点，左子树包含其中之一，该节点本身是p，q中的另一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a class="link" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树<i class="fas fa-external-link-alt"></i></a></h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 合并必须从两个树的根节点开始。</p>
<p><strong>解题思路：</strong></p>
<p>方法一：深度优先搜索</p>
<p>可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。</p>
<p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。</p>
<ul>
<li>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</li>
<li>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</li>
<li>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。<br>  对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(root1 *TreeNode, root2 *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root1 == <span class="literal">nil</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> root2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> root2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  root1.Val += root2.Val</span><br><span class="line">  root1.Left = mergeTrees(root1.Left, root2.Left)</span><br><span class="line">  root1.Right = mergeTrees(root1.Right, root2.Right)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：广度优先搜索</p>
<p>也可以使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。</p>
<p>如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。</p>
<p>使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。</p>
<p>如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：</p>
<ul>
<li>如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；</li>
<li>如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。</li>
</ul>
<p>对于右子节点和右子树，处理方法与左子节点和左子树相同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(root1 *TreeNode, root2 *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">	q1 := []*TreeNode&#123;root1&#125;</span><br><span class="line"> 	q2 := []*TreeNode&#123;root2&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> root1 == <span class="literal">nil</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> root2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> root2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  root3 := &amp;TreeNode&#123;root1.Val+root2.Val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">  q3 := []*TreeNode&#123;root3&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(q1)&gt;<span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(q2)&gt;<span class="number">0</span> &#123;</span><br><span class="line">    node1 := q1[<span class="number">0</span>]</span><br><span class="line">    q1 = q1[<span class="number">1</span>:]</span><br><span class="line">    node2 := q2[<span class="number">0</span>]</span><br><span class="line">    q2 = q2[<span class="number">1</span>:]</span><br><span class="line">    node3 := q3[<span class="number">0</span>]</span><br><span class="line">    q3 = q3[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node1.Left != <span class="literal">nil</span> &amp;&amp; node2.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">    	q1 = <span class="built_in">append</span>(q1, node1.Left)</span><br><span class="line">      q2 = <span class="built_in">append</span>(q2, node2.Left)</span><br><span class="line">      node3.Left = &amp;TreeNode&#123;node1.Left.Val+node2.Left.Val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">      q3 = <span class="built_in">append</span>(q3, node3.Left)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> node1.Left == <span class="literal">nil</span> &amp;&amp; node2.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">      	node3.Left = node2.Left <span class="comment">// node1没有左子树，直接用node2的左子树接到新树上</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> node1.Left != <span class="literal">nil</span> &amp;&amp; node2.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">        node3.Left = node1.Left <span class="comment">// node2没有左子树，直接用node1的左子树接到新树上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node1.Right != <span class="literal">nil</span> &amp;&amp; node2.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">    	q1 = <span class="built_in">append</span>(q1, node1.Right)</span><br><span class="line">      q2 = <span class="built_in">append</span>(q2, node2.Right)</span><br><span class="line">      node3.Right = &amp;TreeNode&#123;node1.Right.Val+node2.Right.Val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">      q3 = <span class="built_in">append</span>(q3, node3.Right)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> node1.Right == <span class="literal">nil</span> &amp;&amp; node2.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">      node3.Right = node2.Right <span class="comment">// node1没有右子树，直接用node2的右子树接到新树上</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> node1.Right != <span class="literal">nil</span> &amp;&amp; node2.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">      node3.Right = node1.Right <span class="comment">// node2没有右子树，直接用node1的右子树接到新树上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-返回bool类型的结果-一般要求对二叉树是否符合某种性质做判别"><a href="#2-返回bool类型的结果-一般要求对二叉树是否符合某种性质做判别" class="headerlink" title="2.返回bool类型的结果(一般要求对二叉树是否符合某种性质做判别)"></a>2.返回bool类型的结果(一般要求对二叉树是否符合某种性质做判别)</h2><p>&emsp;&emsp;此类问题一般只在递归出口处可能返回<code>true</code>，而在一般节点的判别时只返回<code>false</code>的情形。返回<code>true</code>表明递的过程结束，然而后续的节点不一定判别完了，会出现不应该的剪枝的情况。可以直接返回<code>false</code>的情形是因为遇到了不符合要求的情况，下面的节点不用继续判断了，就直接返回<code>false</code>。一般而言有下面这样的模板：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="comment">// 递归出口</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"> 	&#125;</span><br><span class="line">  <span class="keyword">if</span> [判别情形<span class="number">1</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> [判别情形<span class="number">2</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> helper(root.Left) &amp;&amp; helper(root.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a class="link" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列<i class="fas fa-external-link-alt"></i></a></h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<p>参考以下这颗二叉搜索树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   6</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>数组长度 &lt;= 1000</code></li>
</ol>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;二叉搜索树的后续遍历数组满足如下定义：</p>
<ul>
<li>后序遍历： <code>[ 左子树 | 右子树 | 根节点 ]</code> ，即遍历顺序为 “左、右、根” 。</li>
<li><strong>二叉搜索树定义：</strong> 左子树中所有节点的值 &lt; 根节点的值；右子树中所有节点的值 &gt; 根节点的值；其左、右子树也分别为二叉搜索树。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="11.png" alt="avatar"></p>
<p><strong>递归解析：</strong></p>
<ul>
<li>递归出口：<code>len(postorder)==0</code>时，返回<code>true</code>。</li>
<li>递：</li>
</ul>
<ol>
<li><p><strong>划分左右子树</strong>： 遍历后序遍历的元素，寻找 <strong>第一个大于根节点</strong> 的节点，索引记为 <code>flag</code>。此时，可划分出左子树区间 <code>[:flag]</code> 、右子树区间 <code>[flag,len(postorder)−1]</code> 、根节点索引为<code>len(postorder)-1</code> 。</p>
</li>
<li><p><strong>判断是否为二叉搜索树：</strong> 左子树区间 <code>[0,flag−1]</code> 内的所有节点都应 &lt; <code>postorder[len(postorder)-1]</code>。而第 <code>1.划分左右子树</code> 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。</p>
<p> 右子树区间<code>[flag,len(postorder)-1]</code>内所有节点都应 &gt; <code>postorder[len(postorder)-1]</code>。实现方式为遍历，当遇到 &lt; <code>postorder[len(postorder)-1]</code>的节点则跳出。</p>
</li>
</ol>
<ul>
<li>归： 所有子树都需正确才可判定正确，因此使用 <strong>与逻辑符</strong> <code>&amp;&amp;</code> 连接。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyPostorder</span><span class="params">(postorder []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(postorder) == <span class="number">0</span> &#123; <span class="comment">// 递归出口</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  i := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> ; i&lt;<span class="built_in">len</span>(postorder); i++ &#123;</span><br><span class="line">  	<span class="keyword">if</span> postorder[i] &gt;= postorder[<span class="built_in">len</span>(postorder)<span class="number">-1</span>] &#123;</span><br><span class="line">    	<span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  flag := i  <span class="comment">// 用于记录左右子树分界处的索引号</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ; i&lt;<span class="built_in">len</span>(postorder); i++ &#123;</span><br><span class="line">  	<span class="keyword">if</span> postorder[i] &lt; postorder[<span class="built_in">len</span>(postorder)<span class="number">-1</span>] &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>  <span class="comment">// 右子树出现小于根节点的数，直接返回false跳出递的过程</span></span><br><span class="line">    &#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 左右子树分别满足上述条件才返回true</span></span><br><span class="line">  <span class="keyword">return</span> verifyPostorder(postorder[:flag]) &amp;&amp; verifyPostorder(postorder[flag:<span class="built_in">len</span>(postorder)<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a class="link" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构<i class="fas fa-external-link-alt"></i></a></h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:<br>给定的树 A:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>

<p>给定的树 B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; 节点个数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<ul>
<li><p>两个函数</p>
<ul>
<li><strong>isSubStructure()</strong><ul>
<li>用于递归遍历 A 中的所有节点，并判断当前节点 A 是否与 B 的根节点相同，相同则调用 helper( ) 进一步校验</li>
</ul>
</li>
<li><strong>helper()</strong><ul>
<li>用于校验 B 是否与 A 的一个子树拥有相同的结构和节点值</li>
</ul>
</li>
</ul>
</li>
<li><p>函数内容</p>
<ul>
<li><p><strong>isSubStructure()</strong></p>
<ul>
<li>如果当前节点 A == nil &amp;&amp; B == nil ，返回true。</li>
<li>如果当前节点 A == nil | | B == nil ，返回 false。（由题目可知，空树不是任意一个树的子结构）</li>
<li>当在当前结点 A 中找到 B 的根节点时，进入helper () 递归校验</li>
<li>ret == false，说明 B 的根节点不在当前 A 中，进入 A 的左子树进行递归查找</li>
<li>ret 仍等于 false，则说明 B 的根节点不在当前 A 和左子树中，进入 A 的右子树进行递归查找。</li>
</ul>
</li>
<li><p><strong>helper()</strong></p>
<ul>
<li><p>如果 B == nil ，说明 B 已遍历完，返回 true</p>
</li>
<li><p>在 B != nil 的情况下，如果 A == nil ,说明 A 中节点不足以构成子结构 B ，返回 false</p>
</li>
<li><p>如果 A.Val != B.Val，不满足节点值相等条件，返回 false</p>
</li>
<li><p>A.Val == B.Val 继续递归校验 A B 左子树和右子树的结构和节点是否相同</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubStructure</span><span class="params">(A *TreeNode, B *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> A == <span class="literal">nil</span> || B == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> A.Val == B.Val &#123;</span><br><span class="line">        ret = helper(A, B)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ret &#123; <span class="comment">// B 的根节点不在当前 A 中，进入 A 的左子树进行递归查找</span></span><br><span class="line">        ret = isSubStructure(A.Left, B)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ret &#123; <span class="comment">// ret 仍等于 false，则说明 B 的根节点不在当前 A 和左子树中，进入 A 的右子树进行递归查找。</span></span><br><span class="line">        ret = isSubStructure(A.Right, B)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(A *TreeNode, B *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> B == <span class="literal">nil</span> &#123; <span class="comment">// 如果 B == nil ，说明 B 已遍历完，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> A == <span class="literal">nil</span> &#123; <span class="comment">// 在 B != nil 的情况下，如果 A == nil ,说明 A 中节点不足以构成子结构 B ，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> A.Val != B.Val &#123; <span class="comment">//  A.Val != B.Val，不满足节点值相等条件，返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(A.Left, B.Left) &amp;&amp; helper(A.Right, B.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="331-验证二叉树的前序序列化"><a href="#331-验证二叉树的前序序列化" class="headerlink" title="331. 验证二叉树的前序序列化"></a><a class="link" href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/">331. 验证二叉树的前序序列化<i class="fas fa-external-link-alt"></i></a></h3><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     2</span><br><span class="line">  &#x2F; \   &#x2F; \</span><br><span class="line"> 4   1  #  6</span><br><span class="line">&#x2F; \ &#x2F; \   &#x2F; \</span><br><span class="line"># # # #   # #</span><br></pre></td></tr></table></figure>

<p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 # 代表一个空节点。</p>
<p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p>
<p>每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的<code>&#39;#&#39;</code>。</p>
<p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;1,#&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;9,#,#,1&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;我们可以定义一个概念，叫做槽位。一个槽位可以被看作「当前二叉树中正在等待被节点填充」的那些位置。</p>
<p>二叉树的建立也伴随着槽位数量的变化。每当遇到一个节点时：</p>
<ul>
<li>如果遇到了空节点，则要消耗一个槽位；</li>
<li>如果遇到了非空节点，则除了消耗一个槽位外，还要再补充两个槽位。</li>
</ul>
<p>此外，还需要将根节点作为特殊情况处理。</p>
<p>&emsp;&emsp;我们使用栈来维护槽位的变化。栈中的每个元素，代表了对应节点处剩余槽位的数量，而栈顶元素就对应着下一步可用的槽位数量。当遇到空节点时，仅将栈顶元素减 1；当遇到非空节点时，将栈顶元素减 1 后，再向栈中压入一个 2。无论何时，如果栈顶元素变为 0，就立刻将栈顶弹出。遍历结束后，若栈为空，说明没有待填充的槽位，因此是一个合法序列；否则若栈不为空，则序列不合法。此外，在遍历的过程中，若槽位数量不足，则序列不合法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidSerialization</span><span class="params">(preorder <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(preorder)</span><br><span class="line">    stk := []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125; <span class="comment">// 初始化一个槽位给根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stk) == <span class="number">0</span> &#123; <span class="comment">// 已经没有足够的槽位，但序列还未结束，说明序列不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> preorder[i] == <span class="string">&#x27;,&#x27;</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> preorder[i] == <span class="string">&#x27;#&#x27;</span> &#123; <span class="comment">// 出现空节点</span></span><br><span class="line">            stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>]--  <span class="comment">// 消耗栈顶一个槽位</span></span><br><span class="line">            <span class="keyword">if</span> stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>] == <span class="number">0</span> &#123; <span class="comment">// 若栈顶槽位置零，则出栈</span></span><br><span class="line">                stk = stk[:<span class="built_in">len</span>(stk)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i&lt;n &amp;&amp; preorder[i] != <span class="string">&#x27;,&#x27;</span> &#123; <span class="comment">// 读取数字</span></span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>]-- <span class="comment">// 消耗栈顶一个槽位</span></span><br><span class="line">            <span class="keyword">if</span> stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>] == <span class="number">0</span> &#123; <span class="comment">// 若栈顶槽位置零，则出栈</span></span><br><span class="line">                stk = stk[:<span class="built_in">len</span>(stk)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            stk = <span class="built_in">append</span>(stk,<span class="number">2</span>) <span class="comment">// 每出现一个新非空节点，入栈一个有2个槽位的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stk) == <span class="number">0</span>  <span class="comment">// 遍历结束后，没有空槽位说明序列合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-设置全局变量实时记录并更新递归过程中的极值"><a href="#3-设置全局变量实时记录并更新递归过程中的极值" class="headerlink" title="3.设置全局变量实时记录并更新递归过程中的极值"></a>3.设置全局变量实时记录并更新递归过程中的极值</h2><p>&emsp;&emsp;此类题目最终的输出是一个单一的值，我们需要维护一个全局变量来记录这一个单一值，并在递归遍历二叉树的过程中实时地更新这个值。用于递归的辅助函数的返回结果不必与这个值直接联系，要着眼于构建二叉树的节点间的关系。</p>
<h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a class="link" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和<i class="fas fa-external-link-alt"></i></a></h3><p><strong>路径</strong>被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p><strong>路径和</strong>是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="exx1.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="exx2.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[1, 3 * 104]</code></li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<ol>
<li>首先考虑辅助函数的功能。考虑实现一个简化的函数 <code>maxGain(node)</code>，该函数计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。具体而言，该函数的计算如下:</li>
</ol>
<ul>
<li>空节点的最大贡献值等于 0。</li>
<li>非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）。</li>
</ul>
<p>例如，考虑如下二叉树。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> -10</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;叶节点 9、15、7 的最大贡献值分别为 9、15、7。得到叶节点的最大贡献值之后，再计算非叶节点的最大贡献值。节点 20 的最大贡献值等于 <code>20+max⁡(15,7)=35</code>。节点 −10 的最大贡献值等于 <code>−10+max⁡(9,35)=25</code>。上述计算过程是递归的过程，因此，对根节点调用函数 <code>maxGain</code>，即可得到每个节点的最大贡献值。</p>
<p>&emsp;&emsp;根据函数 <code>maxGain</code> 得到每个节点的最大贡献值之后，如何得到二叉树的最大路径和？对于二叉树中的一个节点，该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。维护一个全局变量 <code>maxSum</code> 存储最大路径和，在递归过程中更新 <code>maxSum</code> 的值，最后得到的 <code>maxSum</code> 的值即为二叉树中的最大路径和。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">maxPathSum</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	maxSum := math.MinInt32  <span class="comment">// 设置全局变量用于实时比较及更新每个节点作为根节点时的最大路径</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">var</span> gotMax <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span></span><br><span class="line">  	gotMax = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  <span class="comment">// 递归出口</span></span><br><span class="line">        		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      	&#125;</span><br><span class="line">      	</span><br><span class="line">      	left := max(gotMax(root.Left),<span class="number">0</span>)  <span class="comment">// 当前节点的左子树的最大贡献值（如果小于0则置0）</span></span><br><span class="line">      	right := max(gotMax(root.Right),<span class="number">0</span>)  <span class="comment">// 当前节点右子树的最大贡献值（如果小于0则置0）</span></span><br><span class="line">      	now := root.Val + left + right  <span class="comment">// 记录以当前节点作为根节点的最大路径</span></span><br><span class="line">      	maxSum = max(maxSum,now) <span class="comment">// 更新最大值</span></span><br><span class="line">      </span><br><span class="line">      	<span class="keyword">return</span> root.Val+max(left,right)  <span class="comment">// 返回当前节点的最大贡献值</span></span><br><span class="line">  	&#125;</span><br><span class="line">		</span><br><span class="line">  	gotMax(root)</span><br><span class="line">  	<span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> a&gt;=b &#123;</span><br><span class="line">    	<span class="keyword">return</span> a</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a class="link" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径<i class="fas fa-external-link-alt"></i></a></h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p><strong>示例 :</strong><br>给定二叉树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5   </span><br></pre></td></tr></table></figure>

<p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。假设我们知道对于某节点的左儿子向下遍历经过最多的节点数 $L$ （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 $R$ （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 $L+R+1$ 。</p>
<p>&emsp;&emsp;最后的算法流程为：我们定义一个递归函数 <code>depth(node)</code> 计算 $d_{node}$，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 $L$ 和 $R$ ，则该节点为根的子树的深度即为 $\max (L, R)+1$, 该节点的 $d_{node}$ 值为$L+R+1$。递归搜索每个节点并设一个全局变量 <code>maxSum</code> 来记录并随时更新最大直径。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxSum <span class="keyword">int</span>  <span class="comment">// 全局变量用于记录最大直径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">diameterOfBinaryTree</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	naxSum = <span class="number">0</span></span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	depth(root)</span><br><span class="line">  	<span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">depth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123; <span class="comment">// 该辅助函数用于返回每个节点的深度</span></span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	left := depth(root.Left)</span><br><span class="line">  	right := depth(root.Right)</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> left+right+<span class="number">1</span> &gt; maxSum &#123; <span class="comment">// 更新最大直径的值</span></span><br><span class="line">    		maxSum = left + right + <span class="number">1</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">return</span> <span class="number">1</span>+max(left,right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">    	<span class="keyword">return</span> a</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-结果要求返回数组"><a href="#4-结果要求返回数组" class="headerlink" title="4.结果要求返回数组"></a>4.结果要求返回数组</h2><p>&emsp;&emsp;由于递归算法本身在递归的过程中没法返回数组，所以可以通过设置全局变量的方式，在递归过程中动态的更新数组。</p>
<h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a class="link" href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II<i class="fas fa-external-link-alt"></i></a></h3><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="pathsumii1.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="pathsumii2.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], targetSum &#x3D; 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">树中节点总数在范围 [0, 5000] 内</span><br><span class="line">-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</span><br><span class="line">-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSym</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">  	ret := <span class="built_in">make</span>([][]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">  	path := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	helper(root,targetSum,&amp;ret,path)</span><br><span class="line">  	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>, ret *[][]<span class="keyword">int</span>, path []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	sum := targetSum - root.Val</span><br><span class="line">  	path = <span class="built_in">append</span>(path,root.Val)</span><br><span class="line">  	<span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; sum == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// / 创建一个辅助数组用于保存path的当前值，否则path会随递归操作而回溯</span></span><br><span class="line">    	dst := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>(path))  </span><br><span class="line">    	<span class="built_in">copy</span>(dst,path)</span><br><span class="line">    	*ret = <span class="built_in">append</span>(*ret, dst)</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	helper(root.Left, targetSum-root.Val, ret, path)</span><br><span class="line">  	helper(root.Right, targetSum-root.Val, ret, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a><a class="link" href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和<i class="fas fa-external-link-alt"></i></a></h3><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p>
<p>每条从根节点到叶节点的路径都代表一个数字：</p>
<ul>
<li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li>
</ul>
<p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p>
<p><strong>叶节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="num1tree.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3]</span><br><span class="line">输出：25</span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13</span><br><span class="line">因此，数字总和 &#x3D; 12 + 13 &#x3D; 25</span><br></pre></td></tr></table></figure>

<p><strong>示例 2</strong>：</p>
<p><img lazyload src="/images/loading.svg" data-src="num2tree.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,9,0,5,1]</span><br><span class="line">输出：1026</span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40</span><br><span class="line">因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>树的深度不超过 <code>10</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;深度优先搜索是很直观的做法。从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumNumbers</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    nodeArray := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    helper(root, &amp;nodeArray, path)</span><br><span class="line"></span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> nodeArray &#123;</span><br><span class="line">        ret += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, array *[]<span class="keyword">int</span>, path []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path = <span class="built_in">append</span>(path, root.Val)</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        node := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i:=<span class="built_in">len</span>(path)<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">            node += path[i]* <span class="keyword">int</span>(math.Pow10(<span class="built_in">len</span>(path)-i<span class="number">-1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        *array = <span class="built_in">append</span>(*array,node)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    helper(root.Left, array, path)</span><br><span class="line">    helper(root.Right, array, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a class="link" href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径<i class="fas fa-external-link-alt"></i></a></h3><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="paths-tree.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,null,5]</span><br><span class="line">输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[&quot;1&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<ul>
<li>当遍历到根节点时，将根节点的值转化成字符串后贴到路径串中，并将该条路径存入<code>ret</code>中；</li>
<li>当不是根节点时，将根节点的值转化成字符串后贴到路径串中，并在其后加入符号<code>-&gt;</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binaryTreePaths</span><span class="params">(root *TreeNode)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    ret := <span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">0</span>)</span><br><span class="line">    path := <span class="string">&quot;&quot;</span></span><br><span class="line">    helper(root,&amp;ret,path)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, ret *[]<span class="keyword">string</span>, path <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123; <span class="comment">// 当是根节点时，该条路径遍历结束，存入ret</span></span><br><span class="line">        path = path + strconv.Itoa(root.Val)</span><br><span class="line">        dst := <span class="string">&quot;&quot;</span></span><br><span class="line">        dst = path        </span><br><span class="line">        *ret = <span class="built_in">append</span>(*ret, dst)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        path = path + strconv.Itoa(root.Val) + <span class="string">&quot;-&gt;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    helper(root.Left, ret, path)</span><br><span class="line">    helper(root.Right, ret, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="863-二叉树中所有距离为-K-的结点"><a href="#863-二叉树中所有距离为-K-的结点" class="headerlink" title="863. 二叉树中所有距离为 K 的结点"></a><a class="link" href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点<i class="fas fa-external-link-alt"></i></a></h3><p>给定一个二叉树（具有根结点 <code>root</code>）， 一个目标结点 <code>target</code> ，和一个整数值 <code>K</code> 。</p>
<p>返回到目标结点 <code>target</code> 距离为 <code>K</code> 的所有结点的值的列表。 答案可以以任何顺序返回。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], target &#x3D; 5, K &#x3D; 2</span><br><span class="line">输出：[7,4,1]</span><br><span class="line">解释：</span><br><span class="line">所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1</span><br><span class="line"></span><br><span class="line">注意，输入的 &quot;root&quot; 和 &quot;target&quot; 实际上是树上的结点。</span><br><span class="line">上面的输入仅仅是对这些对象进行了序列化描述。</span><br></pre></td></tr></table></figure>

<p><img lazyload src="/images/loading.svg" data-src="sketch0.png" alt="avatar"></p>
<p>提示：</p>
<ul>
<li>给定的树是非空的。</li>
<li>树上的每个结点都具有唯一的值 0 &lt;= node.val &lt;= 500 。</li>
<li>目标结点 target 是树上的结点。</li>
<li>0 &lt;= K &lt;= 1000.</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>若将 <code>target</code> 当作树的根结点，我们就能从 <code>target</code> 出发，使用深度优先搜索去寻找与 <code>target</code> 距离为 <code>k</code> 的所有结点，即深度为 <code>k</code> 的所有结点。</p>
<p>由于输入的二叉树没有记录父结点，为此，我们从根结点 <code>root</code> 出发，使用深度优先搜索遍历整棵树，同时用一个哈希表记录每个结点的父结点。</p>
<p>然后从 <code>target</code> 出发，使用深度优先搜索遍历整棵树，除了搜索左右儿子外，还可以顺着父结点向上搜索。</p>
<p>代码实现时，由于每个结点值都是唯一的，哈希表的键可以用结点值代替。此外，为避免在深度优先搜索时重复访问结点，递归时额外传入来源结点 <code>from</code>，在递归前比较目标结点是否与来源结点相同，不同的情况下才进行递归。通过标记源结点，如图结点2遍历到7时，由于存在7-&gt;2的边，可能会重复遍历。由于存在我们预先标记的源节点只有当<code>cur != from</code>的时候才能继续遍历。</p>
<p><img lazyload src="/images/loading.svg" data-src="1627477357-OBWKQM-image.png" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distanceK</span><span class="params">(root *TreeNode, target *TreeNode, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*TreeNode,<span class="number">0</span>) <span class="comment">// 初始化map用于存储父节点</span></span><br><span class="line">    <span class="keyword">var</span> parent <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span> </span><br><span class="line">    parent = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123; <span class="comment">// 递归存储每个节点的父节点</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            m[root.Left.Val] = root</span><br><span class="line">            parent(root.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            m[root.Right.Val] = root</span><br><span class="line">            parent(root.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parent(root)</span><br><span class="line"></span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> disK <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode,*TreeNode,<span class="keyword">int</span>)</span> // // 从 <span class="title">target</span> 出发 <span class="title">DFS</span>，寻找所有深度为 <span class="title">k</span> 的结点</span></span><br><span class="line">    disK = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, from *TreeNode, depth <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> depth == k &#123; <span class="comment">// 距离等于k，存入ret并剪枝</span></span><br><span class="line">            ret = <span class="built_in">append</span>(ret, root.Val)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Left != from &#123; <span class="comment">// 左节点</span></span><br><span class="line">            disK(root.Left, root, depth+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Right != from &#123; <span class="comment">// 右节点</span></span><br><span class="line">            disK(root.Right, root, depth+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> m[root.Val] != from &#123; <span class="comment">// 父节点</span></span><br><span class="line">            disK(m[root.Val], root, depth+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    disK(target,<span class="literal">nil</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树(BST)"></a>二叉搜索树(BST)</h1><h2 id="二叉搜索树-BST-的特性"><a href="#二叉搜索树-BST-的特性" class="headerlink" title="二叉搜索树(BST)的特性"></a>二叉搜索树(BST)的特性</h2><ol>
<li>对于 BST 的每一个节点 <code>node</code>，左子树节点的值都比 <code>node</code> 的值要小，右子树节点的值都比 <code>node</code> 的值大。</li>
<li>对于 BST 的每一个节点 <code>node</code>，它的左侧子树和右侧子树都是 BST。</li>
<li><strong>从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）</strong>。</li>
</ol>
<h2 id="BST必知必会题"><a href="#BST必知必会题" class="headerlink" title="BST必知必会题"></a>BST必知必会题</h2><h3 id="1-判断BST的合法性-98-验证二叉搜索树"><a href="#1-判断BST的合法性-98-验证二叉搜索树" class="headerlink" title="1. 判断BST的合法性(98. 验证二叉搜索树)"></a>1. 判断BST的合法性(<a class="link" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树<i class="fas fa-external-link-alt"></i></a>)</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。   </li>
</ul>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>

<p><strong>解题思路：</strong></p>
<p>对于每一个节点 **<code>root</code><strong>，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，</strong><code>root</code>**的整个左子树都要小于 **<code>root.val</code>**，整个右子树都要大于 **<code>root.val</code>**。</p>
<p>问题是，对于某一个节点 <code>root</code>，他只能管得了自己的左右子节点，怎么把 <code>root</code> 的约束传递给左右子树呢？<strong>我们通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉树算法的一个小技巧吧</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span> <span class="title">boll</span></span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> helper(root, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, max *TreeNode, min *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> min != <span class="literal">nil</span> &amp;&amp; root.Val &lt;= min.Val &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">if</span> max != <span class="literal">nil</span> &amp;&amp; root.Val &gt;= max.Val &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">return</span> helper(root.Left, root, min) &amp;&amp; helper(root.Right, max, root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-在BST中搜索一个数"><a href="#2-在BST中搜索一个数" class="headerlink" title="2. 在BST中搜索一个数"></a>2. 在BST中搜索一个数</h3><p>&emsp;&emsp;直接利用BST的性质前序遍历二叉搜索树，当当前节点值等于<code>target</code>，直接返回<code>true</code>，如果当前节点值大于<code>target</code>，则在其左子树中寻找；如果小于<code>target</code>，在其右子树中寻找。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isInBST</span><span class="params">(root *TreeNode, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">if</span> root.Val == target &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">if</span> root.Val &gt; target &#123;</span><br><span class="line">    		<span class="keyword">return</span> isInBST(root.Left, target)</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">if</span> root.Val &lt; target &#123;</span><br><span class="line">    		<span class="keyword">return</span> isInBST(root.Right, target)</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-在BST中插入一个数"><a href="#3-在BST中插入一个数" class="headerlink" title="3. 在BST中插入一个数"></a>3. 在BST中插入一个数</h3><p>&emsp;&emsp;涉及到“改”这一操作，就要返回<code>TreeNode</code>类型了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  <span class="comment">// 找到空位置插入新节点</span></span><br><span class="line">    		node := &amp;TreeNode&#123;val,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">    		<span class="keyword">return</span> node</span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> root.Val &lt; val &#123; <span class="comment">// 在右子树的叶节点中插入val</span></span><br><span class="line">    		root.Right = insertIntoBST(root.Right,val)</span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> root.Val &gt; val &#123; <span class="comment">// 在左子树的叶节点中插入val</span></span><br><span class="line">    		root.Left = insertIntoBST(root.Left,val)</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-在BST中删除一个数"><a href="#4-在BST中删除一个数" class="headerlink" title="4. 在BST中删除一个数"></a>4. 在BST中删除一个数</h3><p>&emsp;&emsp;这个问题稍微复杂，跟插入操作类似，先「找」再「改」。找到目标节点了，比方说是节点 <code>A</code>，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。</p>
<ul>
<li>情况1: <code>A</code> 恰好是末端节点，两个子节点都为空，那么可以直接将其删除。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="case1.png" alt="avatar"></p>
<ul>
<li>情况2: <code>A</code> 只有一个非空子节点，那么它要让这个孩子接替自己的位置。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="case2.png" alt="avatar"></p>
<ul>
<li>情况 3：<code>A</code> 有两个子节点，麻烦了，为了不破坏 BST 的性质，<code>A</code> 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="case3.png" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> root.Val == key &#123;</span><br><span class="line">    		<span class="comment">// 下面两个if把case1和case2都处理了</span></span><br><span class="line">    		<span class="keyword">if</span> root.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">      			<span class="keyword">return</span> root.Right</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">      			<span class="keyword">return</span> root.Left</span><br><span class="line">    		&#125;</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">// case3</span></span><br><span class="line">    		minNode := getNode(root.Right)</span><br><span class="line">      	root.Val = minNode.Val <span class="comment">// 将当前根节点的值用右子树最小值(一定是叶节点)替换</span></span><br><span class="line">    		root.Right = deletNode(root.Right, minNode.Val) <span class="comment">// 删除掉被替换后的叶节点</span></span><br><span class="line">  	&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &gt; key &#123;</span><br><span class="line">    		root.Left = deleteNode(root.Left,key)</span><br><span class="line">  	&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &lt; key &#123;</span><br><span class="line">    		root.Right = deleteNode(root.Left,key)</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMin</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  	<span class="keyword">for</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">    		root = root.Left</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BST高频题"><a href="#BST高频题" class="headerlink" title="BST高频题"></a>BST高频题</h2><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a class="link" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树<i class="fas fa-external-link-alt"></i></a></h3><p>&emsp;&emsp;给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="uniquebstn3.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 19</code></li>
</ul>
<p><strong>解题思路：</strong>(搬运自<a class="link" href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/">不同的二叉搜索树<i class="fas fa-external-link-alt"></i></a>)</p>
<p>&emsp;&emsp;给定一个有序序列 $1⋯n$，为了构建出一棵二叉搜索树，我们可以遍历每个数字 $i$，将该数字作为树根，将 $1⋯(i−1)$ 序列作为左子树，将 $(i+1)⋯n$ 序列作为右子树。接着我们可以按照同样的方式递归构建左子树和右子树。</p>
<p>&emsp;&emsp;在上述构建的过程中，由于根的值不同，因此我们能保证每棵二叉搜索树是唯一的。由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用。因此，我们可以想到使用动态规划来求解本题。</p>
<p>&emsp;&emsp;题目要求是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：</p>
<ol>
<li>$G(n)$: 长度为 $n$ 的序列能构成的不同二叉搜索树的个数。</li>
<li>$F(i,n)$: 以 $i$ 为根、序列长度为 $n$ 的不同二叉搜索树个数 $(1≤i≤n)$。</li>
</ol>
<p>&emsp;&emsp;可见，$G(n)$ 是我们求解需要的函数。稍后我们将看到，$G(n)$ 可以从 $F(i,n)$ 得到，而 $F(i,n)$ 又会递归地依赖于 $G(n)$。</p>
<p>&emsp;&emsp;首先，根据上一节中的思路，不同的二叉搜索树的总数 $G(n)$，是对遍历所有 $(1≤i≤n)$ 的 $F(i,n)$ 之和。换言之：</p>
<p>$G(n)=\sum_{i=1}^{n} F(i, n)$</p>
<p>&emsp;&emsp;对于边界情况，当序列长度为 11（只有根）或为 00（空树）时，只有一种情况，即：</p>
<p>$G(0)=1, \quad G(1)=1$</p>
<p>&emsp;&emsp;给定序列 $1⋯n$，我们选择数字 $i$ 作为根，则根为 $i$ 的所有二叉搜索树的集合是左子树集合和右子树集合的笛卡尔积，对于笛卡尔积中的每个元素，加上根节点之后形成完整的二叉搜索树，如下图所示：</p>
<p><img lazyload src="/images/loading.svg" data-src="96_fig1.png" alt="avatar"></p>
<p>&emsp;&emsp;举例而言，创建以 3 为根、长度为 7 的不同二叉搜索树，整个序列是 $[1,2,3,4,5,6,7]$，我们需要从左子序列 $[1,2]$ 构建左子树，从右子序列 $[4,5,6,7]$ 构建右子树，然后将它们组合（即笛卡尔积）。对于这个例子，不同二叉搜索树的个数为 $F(3,7)$。我们将 $[1,2]$ 构建不同左子树的数量表示为 $G(2)$, 从 $[4,5,6,7]$ 构建不同右子树的数量表示为 $G(4)$，注意到 $G(n)$ 和序列的内容无关，只和序列的长度有关。于是，$F(3,7)=G(2)⋅G(4)$。 因此，我们可以得到以下公式：</p>
<p>$F(i, n)=G(i-1) \cdot G(n-i)$</p>
<p>将公式结合，可以得到 $G(n)$ 的递归表达式：</p>
<p>$G(n)=\sum_{i=1}^{n} G(i-1) \cdot G(n-i)$</p>
<p>至此，我们从小到大计算 $G$ 函数即可，因为 $G(n)$ 的值依赖于 $G(0)⋯G(n−1)$。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numTrees</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	m := <span class="built_in">make</span>([][]<span class="keyword">int</span>,n)  <span class="comment">// 初始化一个二维数组充当记事本</span></span><br><span class="line">  	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">    		m[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> count(<span class="number">1</span>,n,m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(l <span class="keyword">int</span>, r <span class="keyword">int</span>, m [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> l &gt; r &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> m[l<span class="number">-1</span>][r<span class="number">-1</span>] != <span class="number">0</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> m[l<span class="number">-1</span>][r<span class="number">-1</span>]</span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">for</span> i:=l; i&lt;=r; i++ &#123;</span><br><span class="line">    		left := count(l,i<span class="number">-1</span>,m)</span><br><span class="line">    		right := count(i+<span class="number">1</span>,r,m)</span><br><span class="line">				ret += left*right  <span class="comment">// 笛卡尔乘积</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	m[l<span class="number">-1</span>][r<span class="number">-1</span>] = ret</span><br><span class="line">  	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a class="link" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II<i class="fas fa-external-link-alt"></i></a></h3><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code>互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="uniquebstn.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>二叉搜索树关键的性质是根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。因此在生成所有可行的二叉搜索树的时候，假设当前序列长度为 n，如果我们枚举根节点的值为 i，那么根据二叉搜索树的性质我们可以知道左子树的节点值的集合为 [1…i−1]，右子树的节点值的集合为 [i+1…n]。而左子树和右子树的生成相较于原问题是一个序列长度缩小的子问题，因此我们可以想到用回溯的方法来解决这道题目。</p>
<p>我们定义 <code>generateTrees(start, end)</code> 函数表示当前值的集合为 <code>[start,end]</code>，返回序列 <code>[start,end]</code> 生成的所有可行的二叉搜索树。按照上文的思路，我们考虑枚举 <code>[start,end]</code> 中的值 i 为当前二叉搜索树的根，那么序列划分为了 <code>[start,i−1]</code> 和 <code>[i+1,end]</code> 两部分。我们递归调用这两部分，即 <code>generateTrees(start, i - 1)</code> 和 <code>generateTrees(i + 1, end)</code>，获得所有可行的左子树和可行的右子树，那么最后一步我们只要从可行左子树集合中选一棵，再从可行右子树集合中选一棵拼接到根节点上，并将生成的二叉搜索树放入答案数组即可。</p>
<p>递归的入口即为 <code>generateTrees(1, n)</code>，出口为当 start&gt;end 的时候，当前二叉搜索树为空，返回空节点即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateTrees</span><span class="params">(n <span class="keyword">int</span>)</span> []*<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getBST(<span class="number">1</span>,n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBST</span><span class="params">(l <span class="keyword">int</span>, r <span class="keyword">int</span>)</span> []*<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> l &gt; r &#123;</span><br><span class="line">      	<span class="keyword">return</span> []*TreeNode&#123;<span class="literal">nil</span>&#125; </span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">  	ret := <span class="built_in">make</span>([]*TrrNode,<span class="number">0</span>)</span><br><span class="line">  	<span class="comment">// 枚举可行根节点</span></span><br><span class="line">  	<span class="keyword">for</span> i:=l; i&lt;=r; i++ &#123;</span><br><span class="line">      	<span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">    		leftTree := getBST(l,i<span class="number">-1</span>)</span><br><span class="line">      <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">    		tightTree := getBST(i+<span class="number">1</span>,r)</span><br><span class="line">    		<span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">    		<span class="keyword">for</span> _,left := <span class="keyword">range</span> leftTree &#123;</span><br><span class="line">      			<span class="keyword">for</span> _,right := <span class="keyword">range</span> rightTree &#123;</span><br><span class="line">        				root := &amp;TreeNode&#123;i,<span class="literal">nil</span>,<span class="literal">nil</span>&#125;</span><br><span class="line">        				root.Left = left</span><br><span class="line">        				root.Right = right</span><br><span class="line">        				ret = <span class="built_in">append</span>(ret,root)</span><br><span class="line">      			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a><a class="link" href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树<i class="fas fa-external-link-alt"></i></a></h3><p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>
<p>进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="recover1.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,3,null,null,2]</span><br><span class="line">输出：[3,1,null,null,2]</span><br><span class="line">解释：3 不能是 1 左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="recover2.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,1,4,null,null,2]</span><br><span class="line">输出：[2,1,4,null,null,3]</span><br><span class="line">解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树上节点的数目在范围 <code>[2, 1000]</code> 内</li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;我们需要考虑两个节点被错误地交换后对原二叉搜索树造成了什么影响。对于二叉搜索树，我们知道如果对其进行中序遍历，得到的值序列是递增有序的，而如果我们错误地交换了两个节点，等价于在这个值序列中交换了两个值，破坏了值序列的递增性。</p>
<p>&emsp;&emsp;我们来看下如果在一个递增的序列中交换两个值会造成什么影响。假设有一个递增序列 <code>a=[1,2,3,4,5,6,7]</code>。如果我们交换两个不相邻的数字，例如 2 和 6，原序列变成了 <code>a=[1,6,3,4,5,2,7]</code>，那么显然序列中有两个位置不满足 $a_{i}$&lt;$a_{i+1}$，在这个序列中体现为6&gt;3，5&gt;2，因此只要我们找到这两个位置，即可找到被错误交换的两个节点。如果我们交换两个相邻的数字，例如 2 和 3，此时交换后的序列只有一个位置不满足  $a_{i}$&lt;$a_{i+1}$。因此整个值序列中不满足条件的位置或者有两个，或者有一个。</p>
<p>&emsp;&emsp;至此，解题方法已经呼之欲出了：</p>
<ol>
<li>找到二叉搜索树中序遍历得到值序列的不满足条件的位置。</li>
<li>如果有两个，我们记为 i 和 j（i&lt;j 且  $a_{i}$&gt;$a_{i+1}$ &amp;&amp;  $a_{j}$&gt;$a_{j+1}$，那么对应被错误交换的节点即为$a_{i}$对应的节点和$a_{i+1}$对应的节点，我们分别记为 x 和 y。</li>
<li>如果有一个，我们记为 i，那么对应被错误交换的节点即为$a_{i}$对应的节点和$a_{i+1}$对应的节点，我们分别记为 x 和 y。</li>
<li>交换 x 和 y 两个节点即可。</li>
</ol>
<p>&emsp;&emsp;实现部分，本方法开辟一个新数组 <code>nums</code> 来记录中序遍历得到的值序列，然后线性遍历找到两个位置 i 和 j，并重新遍历原二叉搜索树修改对应节点的值完成修复，具体实现可以看下面的代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverTree</span><span class="params">(root *TreeNode)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    nums := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> inorder <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span> // 中序遍历保存序列</span></span><br><span class="line">    inorder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.Left)</span><br><span class="line">        nums = <span class="built_in">append</span>(nums,root.Val)</span><br><span class="line">        inorder(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root)</span><br><span class="line">    A, B := helper(nums)</span><br><span class="line">    fmt.Println(A,B)</span><br><span class="line">    <span class="built_in">recover</span>(A, B, <span class="number">2</span>, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 返回两个顺序错误的节点的值</span></span><br><span class="line">    x,y := math.MinInt32, <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i+<span class="number">1</span>] &lt; nums[i] &#123;</span><br><span class="line">            y = nums[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> x == math.MinInt32 &#123;</span><br><span class="line">                x = nums[i]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x,y</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">(A <span class="keyword">int</span>, B <span class="keyword">int</span>, count <span class="keyword">int</span>, root *TreeNode)</span></span> &#123; <span class="comment">// 遍历二叉树，改变这两个节点值</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val == A || root.Val == B &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val == A &#123;</span><br><span class="line">            root.Val = B </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.Val = A</span><br><span class="line">        &#125;</span><br><span class="line">        count-- <span class="comment">// 用于计数，当两个节点都被改变后，直接跳出递的过程，剪枝</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">recover</span>(A, B, count, root.Left)</span><br><span class="line">    <span class="built_in">recover</span>(A, B, count, root.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀树(Trie)</title>
    <url>/2021/09/02/%E5%89%8D%E7%BC%80%E6%A0%91(Trie)/</url>
    <content><![CDATA[<h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a class="link" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)<i class="fas fa-external-link-alt"></i></a></h2><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p><img lazyload src="/images/loading.svg" data-src="500px-Trie_example.svg.png" alt="avatar"></p>
<p>请你实现 Trie 类：</p>
<ul>
<li>Trie() 初始化前缀树对象。</li>
<li>void insert(String word) 向前缀树中插入字符串 word 。</li>
<li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li>
<li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</li>
</ul>
<p><strong>示例：</strong></p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 True</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= word.length, prefix.length &lt;= 2000</li>
<li>word 和 prefix 仅由小写英文字母组成</li>
<li>insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次</li>
</ul>
<p><strong>解题思路：</strong>（来源于<a class="link" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/">实现 Trie (前缀树)<i class="fas fa-external-link-alt"></i></a>）</p>
<p>Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：</p>
<ul>
<li>指向子节点的指针数组 <code>child</code>。对于本题而言，数组长度为 26，即小写英文字母的数量。此时 <code>child[0]</code> 对应小写字母 a，<code>child[1]</code> 对应小写字母 b，…，<code>child[25]</code> 对应小写字母 z。</li>
<li>布尔字段 <code>isEnd</code>，表示该节点是否为字符串的结尾。</li>
</ul>
<p><strong>插入字符串</strong></p>
<p>我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：</p>
<ul>
<li>子节点存在。沿着指针移动到子节点，继续处理下一个字符。</li>
<li>子节点不存在。创建一个新的子节点，记录在 <code>child</code> 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。</li>
<li>重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。</li>
</ul>
<p><strong>查找前缀</strong></p>
<p>我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：</p>
<ul>
<li>子节点存在。沿着指针移动到子节点，继续搜索下一个字符。</li>
<li>子节点不存在。说明字典树中不包含该前缀，返回空指针。</li>
<li>重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。</li>
</ul>
<p>若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的 <code>isEnd</code>为真，则说明字典树中存在该字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    child   [<span class="number">26</span>]*Trie</span><br><span class="line">    isEnd   <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">Trie</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Trie&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">Insert</span><span class="params">(word <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> this.child[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">            this.child[ch] = &amp;Trie&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this = this.child[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    this.isEnd = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">Search</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> this.child[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;  </span><br><span class="line">        this = this.child[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> this.isEnd == <span class="literal">false</span> &#123; <span class="comment">// 上述for循环结束只能表明存在该前缀，还要判断有没有结束符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">StartsWith</span><span class="params">(prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> prefix &#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> this.child[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        this = this.child[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Insert(word);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Search(word);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.StartsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>一些有趣的算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>循转数组相关题目</title>
    <url>/2021/09/12/%E5%BE%AA%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>&emsp;&emsp;本文是对旋转数组类型的题目的总结，一共6道，基本都是二分法的套路。</p>
<h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a class="link" href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组<i class="fas fa-external-link-alt"></i></a></h2><p>给定一个数组，将数组中的元素向右移动 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<p>进阶：</p>
<ul>
<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>
<li>你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2</span><br><span class="line">输出：[3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= k &lt;= 105</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>方法一：使用额外的数组</p>
<p>&emsp;&emsp;可以使用额外的数组来将每个元素放至正确的位置。用 <code>n</code> 表示数组的长度，我们遍历原数组，将原数组下标为 <code>i</code> 的元素放至新数组下标为 <code>(i+k)%n</code> 的位置，最后将新数组拷贝至原数组即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    newNums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        newNums[(i+k)%<span class="built_in">len</span>(nums)] = v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(nums, newNums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法二：环状替换</p>
<p>&emsp;&emsp;从另一个角度，我们可以将被替换的元素保存在变量 <code>temp</code> 中，从而避免了额外数组的开销。我们从位置 0 开始，最初令 <code>temp=nums[0]</code>。根据规则，位置 0 的元素会放至 <code>(0+k)%n</code>的位置，令 <code>x=(0+k)%n</code>，此时交换 <code>temp </code>和 <code>nums[x]</code>，完成位置 x 的更新。然后，我们考察位置 x，并交换 <code>temp</code> 和 <code>nums[(x+k)%n]</code>，从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置 0。</p>
<p>&emsp;&emsp;容易发现，当回到初始位置 0 时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？我们不妨先考虑这样一个问题：从 0 开始不断遍历，最终回到起点 0 的过程中，我们遍历了多少个元素？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    k %= n</span><br><span class="line">    <span class="keyword">for</span> start, count := <span class="number">0</span>, gcd(k, n); start &lt; count; start++ &#123;</span><br><span class="line">        pre, cur := nums[start], start</span><br><span class="line">        <span class="keyword">for</span> ok := <span class="literal">true</span>; ok; ok = cur != start &#123;</span><br><span class="line">            next := (cur + k) % n</span><br><span class="line">            nums[next], pre, cur = pre, nums[next], next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">// 需要遍历的次数是n和k的最大公约数</span></span><br><span class="line">    <span class="keyword">for</span> a != <span class="number">0</span> &#123;</span><br><span class="line">        a, b = b%a, a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法三：数组翻转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums &#x3D; &quot;-----&gt;--&gt;&quot;; k &#x3D;3</span><br><span class="line">result &#x3D; &quot;--&gt;-----&gt;&quot;;</span><br><span class="line"></span><br><span class="line">reverse &quot;-----&gt;--&gt;&quot; we can get &quot;&lt;--&lt;-----&quot;</span><br><span class="line">reverse &quot;&lt;--&quot; we can get &quot;--&gt;&lt;-----&quot;</span><br><span class="line">reverse &quot;&lt;-----&quot; we can get &quot;--&gt;-----&gt;&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    k %= <span class="built_in">len</span>(nums)</span><br><span class="line">    reverse(nums)</span><br><span class="line">    reverse(nums[:k])</span><br><span class="line">    reverse(nums[k:])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(a []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n/<span class="number">2</span>; i++ &#123;</span><br><span class="line">        a[i], a[n-i<span class="number">-1</span>] = a[n-i<span class="number">-1</span>], a[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="在旋转数组里寻找最小值"><a href="#在旋转数组里寻找最小值" class="headerlink" title="在旋转数组里寻找最小值"></a>在旋转数组里寻找最小值</h1><p>&emsp;&emsp;可以看作寻找最小值左边界问题(直接解决又重复元素的情况)。</p>
<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a class="link" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值<i class="fas fa-external-link-alt"></i></a></h2><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组<code> [a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组<code> [a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>。</p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>n == nums.length</li>
<li>1 &lt;= n &lt;= 5000</li>
<li>-5000 &lt;= nums[i] &lt;= 5000</li>
<li>nums 中的所有整数 互不相同</li>
<li>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;本题可以看作是找数组中的最小数。如果更改一下题目条件，数组中的元素是可以重复的，那么可以看作找最小数的左边界即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] &gt; nums[mid] &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[right] &lt; nums[mid] &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 可能因为重复元素使得两者相等，缩小查找范围</span></span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a class="link" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II<i class="fas fa-external-link-alt"></i></a></h2><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,4]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,4,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,5]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>n == nums.length</li>
<li>1 &lt;= n &lt;= 5000</li>
<li>-5000 &lt;= nums[i] &lt;= 5000</li>
<li>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;同上题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] &gt; nums[mid] &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[right] &lt; nums[mid] &#123;</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="在旋转数组里寻找指定的值"><a href="#在旋转数组里寻找指定的值" class="headerlink" title="在旋转数组里寻找指定的值"></a>在旋转数组里寻找指定的值</h1><p>&emsp;&emsp;上面两道题是在旋转数组里寻找最小值，下面两道题是在旋转数组里寻找指定的值，这两道题的区别也是存不存在重复值。</p>
<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a class="link" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组<i class="fas fa-external-link-alt"></i></a></h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k（0 &lt;= k &lt; nums.length）</code>上进行了 旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 3 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code>。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 5000</li>
<li>-10^4 &lt;= nums[i] &lt;= 10^4</li>
<li>nums 中的每个值都 独一无二</li>
<li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li>
<li>-10^4 &lt;= target &lt;= 10^4</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;其实方法还是类似于上题，不过对于寻找特定的数，需要判断该数可能存在于什么区间内。</p>
<ul>
<li>如果 <code>[l, mid - 1]</code> 是有序数组，且 <code>target</code> 的大小满足 <code>[nums[l],nums[mid])</code>，则我们应该将搜索范围缩小至 <code>[l, mid - 1]</code>，否则在 <code>[mid + 1, r]</code> 中寻找。</li>
<li>如果 <code>[mid, r]</code> 是有序数组，且 <code>target</code> 的大小满足 <code>(nums[mid+1],nums[r]]</code>，则我们应该将搜索范围缩小至 <code>[mid + 1, r]</code>，否则在<code>[l, mid - 1]</code> 中寻找。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[right] &gt;= nums[mid] &#123; <span class="comment">// 右半部分是有序的</span></span><br><span class="line">          <span class="comment">// 此处若出现nums[right] = nums[mid]的情况，说明mid=right，因为数组不重复</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[right] &lt;= nums[mid] &#123; <span class="comment">// 左半部分是有序的</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target &#123;</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a class="link" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II<i class="fas fa-external-link-alt"></i></a></h2><p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 <code>k（0 &lt;= k &lt; nums.length</code>）上进行了 旋转 ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 5 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p>
<p>给你 旋转后 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 5000</li>
<li>-104 &lt;= nums[i] &lt;= 104</li>
<li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li>
<li>-104 &lt;= target &lt;= 104</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;大体上同上题思路是一致的，只需要在遇到<code>nums[mid]==nums[right]</code>时缩小查找范围即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] == nums[right] || nums[left] == nums[right] &#123;</span><br><span class="line">          <span class="comment">// 当收尾元素相等或中值与末尾元素相等时，缩小查找范围</span></span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; nums[right] &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; nums[right] &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target &#123;</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="面试题-10-03-搜索旋转数组"><a href="#面试题-10-03-搜索旋转数组" class="headerlink" title="面试题 10.03. 搜索旋转数组"></a><a class="link" href="https://leetcode-cn.com/problems/search-rotate-array-lcci/">面试题 10.03. 搜索旋转数组<i class="fas fa-external-link-alt"></i></a></h2><p>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: arr &#x3D; [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target &#x3D; 5</span><br><span class="line">输出: 8（元素5在该数组中的索引）</span><br></pre></td></tr></table></figure>

<p><strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target &#x3D; 11</span><br><span class="line"> 输出：-1 （没有找到）</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ol>
<li>arr 长度范围在[1, 1000000]之间</li>
</ol>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;本题是上一题的一个小进阶，不仅要确认是否有<code>target</code>值，还要输出其左边界，在上一题的基础上套用二分法查找左边界的方法即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(arr []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span>(</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(arr)<span class="number">-1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target &#123; <span class="comment">// 找到目标后用右边界锁定住</span></span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[left] == arr[right] || arr[mid] == arr[right] &#123; <span class="comment">// 排除重复数，缩小搜索范围</span></span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[right] &gt; arr[mid] &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[mid] &lt; target &amp;&amp; arr[right] &gt;= target &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[right] &lt; arr[mid] &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[left] &lt;= target &amp;&amp; arr[mid] &gt; target &#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> arr[left] == target &#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库三大范式</title>
    <url>/2021/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><h2 id="为什么需要数据库规范化？"><a href="#为什么需要数据库规范化？" class="headerlink" title="为什么需要数据库规范化？"></a>为什么需要数据库规范化？</h2><ul>
<li>信息重复</li>
<li>更新异常</li>
<li>插入异常<ul>
<li>无法正常显示信息</li>
</ul>
</li>
<li>删除异常<ul>
<li>丢失有效信息</li>
</ul>
</li>
</ul>
<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h3><p>&emsp;&emsp;第一范式是最基本的范式。如果数据库表中的<font color="red">所有字段值都是不可分解的原子值</font>，就说明该数据库表满足了第一范式。</p>
<p>&emsp;&emsp;第一范式的合理遵循需要根据系统的<strong>实际需求</strong>来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。</p>
<p><img lazyload src="/images/loading.svg" data-src="1.png" alt="avatar"></p>
<p>&emsp;&emsp;上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p>
<h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h3><p>&emsp;&emsp;前提：满足第一范式</p>
<p>&emsp;&emsp;第二范式在第一范式的基础之上更进一层。第二范式需要<strong>确保表中的每列都和主键相关</strong>，而不能只与主键的某一部分相关（主要针对联合主键而言）。<font color="red">也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</font>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。</p>
<p> <strong>订单信息表</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="2.png" alt="avatar"></p>
<p>&emsp;&emsp;这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。</p>
<p><img lazyload src="/images/loading.svg" data-src="3.png" alt="avatar"></p>
<p>&emsp;&emsp;这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。</p>
<h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h3><p>&emsp;&emsp;前提：满足第一和第二范式</p>
<p>&emsp;&emsp;第三范式需要确保数据表中的<font color="red">每一列数据都和主键直接相关，而不能间接相关</font>。</p>
<p>&emsp;&ensp;比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。</p>
<p><img lazyload src="/images/loading.svg" data-src="4.png" alt="avatar"></p>
<p>&emsp;&emsp;这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。</p>
<h2 id="规范性和性能的问题"><a href="#规范性和性能的问题" class="headerlink" title="规范性和性能的问题"></a>规范性和性能的问题</h2><p>关联查询的表不得超过三张表（阿里的规则）</p>
<ul>
<li>考虑商业化的需求和目标（成本，用户体验），数据库的性能更加重要</li>
<li>在规范性能的问题的时候，适当的考虑规范性</li>
<li>有时候会故意给某些表增加一下冗余的字段（从多表查询变为单表查询）</li>
<li>有时候会故意增加一些计算列（从大数据量降低为小数据量的查询：索引）</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>SQL数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>图算法</title>
    <url>/2021/09/14/%E5%9B%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="图论基础"><a href="#图论基础" class="headerlink" title="图论基础"></a>图论基础</h1><h2 id="图的逻辑结构和具体实现"><a href="#图的逻辑结构和具体实现" class="headerlink" title="图的逻辑结构和具体实现"></a>图的逻辑结构和具体实现</h2><ol>
<li>图的逻辑结构</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="1.jpg" alt="avatar"></p>
<p>&emsp;&emsp;为了方便研究图，我们将图可以抽象为下面的形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">  	id					<span class="keyword">int</span></span><br><span class="line">  	neighbors		[]*Vertex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可见，这个结构和多叉树节点是一样的。所以可以认为图是比较特殊的多叉树。不过呢，上面的这种实现是「逻辑上的」，实际上我们很少用这个 <code>Vertex</code> 类实现图，而是用常说的<strong>邻接表和邻接矩阵</strong>来实现。</p>
<ol start="2">
<li>具体实现方式</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="2.jpg" alt="avatar"></p>
<ul>
<li>邻接表：邻接表很直观，我把每个节点 <code>x</code> 的邻居都存到一个列表里，然后把 <code>x</code> 和这个列表关联起来，这样就可以通过一个节点 <code>x</code> 找到它的所有相邻节点。</li>
<li>邻接矩阵：邻接矩阵是一个二维布尔数组，将其称为<code>matrix</code>，如果节点 <code>x</code> 和 <code>y</code> 是相连的，那么就把 <code>matrix[x][y]</code> 设为 <code>true</code>（上图中绿色的方格代表 <code>true</code>）。如果想找节点 <code>x</code>的邻居，去扫一圈 <code>matrix[x][..]</code> 就行了。</li>
</ul>
<ol start="3">
<li>邻接表和邻接矩阵的优劣</li>
</ol>
<ul>
<li>邻接表<ul>
<li>好处是占用的空间少。</li>
<li>坏处是邻接表无法快速判断两个节点是否相邻。</li>
</ul>
</li>
<li>邻接矩阵<ul>
<li>好处是可以快速判断两个节点是否相邻。</li>
<li>坏处是占用空间大。</li>
</ul>
</li>
</ul>
<h2 id="更复杂的图"><a href="#更复杂的图" class="headerlink" title="更复杂的图"></a>更复杂的图</h2><ul>
<li>有向加权图<ul>
<li>如果使用邻接表，我们不仅仅存储某个节点 <code>x</code> 的所有邻居节点，还存储 <code>x</code> 到每个邻居的权重。</li>
<li>如果使用邻接矩阵，<code>matrix[x][y]</code> 不再是布尔值，而是一个 int 值，0 表示没有连接，其他值表示权重。</li>
</ul>
</li>
<li>无向图<ul>
<li>所谓的「无向」，也等同于「双向」。</li>
<li>如果连接无向图中的节点 <code>x</code> 和 <code>y</code>，把 <code>matrix[x][y]</code> 和 <code>matrix[y][x]</code> 都变成 <code>true</code>。</li>
<li>如果使用邻接表，则<code>list[x]</code>和<code>list[y]</code>中各自填入<code>y</code> 和<code>x</code>。</li>
</ul>
</li>
</ul>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>&emsp;&emsp;图和多叉树最大的区别是，图是可能包含环的，你从图的某一个节点开始遍历，有可能走了一圈又回到这个节点。所以，如果图包含环，遍历框架就要一个 <code>visited</code> 数组进行辅助：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">graph *Vertex</span><br><span class="line">visited <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(graph *Vertex, s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  	<span class="keyword">if</span> visited[s] == <span class="literal">true</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span>  <span class="comment">// 经过节点s</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	visited[s] = <span class="literal">true</span></span><br><span class="line">  	<span class="keyword">for</span> _,v := <span class="keyword">range</span> s.neighbor &#123;</span><br><span class="line">    	traverse(graph, s)</span><br><span class="line">  	&#125;</span><br><span class="line">  	visited[s] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;这个 <code>visited</code> 数组的操作很像回溯算法做「做选择」和「撤销选择」，区别在于位置，回溯算法的「做选择」和「撤销选择」在 for 循环里面，而对 <code>visited</code> 数组的操作在 for 循环外面。在 for 循环里面和外面唯一的区别就是对根节点的处理。对于这里「图」的遍历，我们应该把 <code>visited</code> 的操作放到 for 循环外面，否则会漏掉起始点的遍历。</p>
<h2 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797. 所有可能的路径"></a><a class="link" href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径<i class="fas fa-external-link-alt"></i></a></h2><p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p>
<p>二维数组的第 <code>i</code> 个数组中的单元都表示有向图中 <code>i</code> 号节点所能到达的下一些节点，空就是没有下一个结点了。</p>
<p><strong>示例 1</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="3.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：graph &#x3D; [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="1.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：graph &#x3D; [[4,3,1],[3,2,4],[3],[4],[]]</span><br><span class="line">输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：graph &#x3D; [[1],[]]</span><br><span class="line">输出：[[0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：graph &#x3D; [[1,2,3],[2],[3],[]]</span><br><span class="line">输出：[[0,1,2,3],[0,2,3],[0,3]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：graph &#x3D; [[1,3],[2],[3],[]]</span><br><span class="line">输出：[[0,1,2,3],[0,3]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">n &#x3D;&#x3D; graph.length</span><br><span class="line">2 &lt;&#x3D; n &lt;&#x3D; 15</span><br><span class="line">0 &lt;&#x3D; graph[i][j] &lt; n</span><br><span class="line">graph[i][j] !&#x3D; i（即，不存在自环）</span><br><span class="line">graph[i] 中的所有元素 互不相同</span><br><span class="line">保证输入为 有向无环图（DAG）</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;从0为起点开始遍历图，将遍历到的每个节点加入到辅助数组<code>path</code>中，当遍历到节点值为n-1时停止遍历，将<code>path</code>保存的路径拷贝到输出结构<code>res</code>中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allPathsSourceTarget</span><span class="params">(graph [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([][]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    travel(path, graph, &amp;res, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(path []<span class="keyword">int</span>, graph [][]<span class="keyword">int</span>, res *[][]<span class="keyword">int</span>, start <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    path = <span class="built_in">append</span>(path,start)</span><br><span class="line">    n := <span class="built_in">len</span>(graph)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> start == n &#123;</span><br><span class="line">        dst := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>(path))</span><br><span class="line">        <span class="built_in">copy</span>(dst,path) <span class="comment">// 由于在回溯的时候path会动态变化，所以要重新拷贝后传入res</span></span><br><span class="line">        *res = <span class="built_in">append</span>(*res,dst)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> graph[start] &#123;</span><br><span class="line">        travel(path, graph, res, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="有向图的环检测"><a href="#有向图的环检测" class="headerlink" title="有向图的环检测"></a>有向图的环检测</h1><h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a class="link" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表<i class="fas fa-external-link-alt"></i></a></h2><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code>。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 必须 先学习课程  <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; numCourses &lt;&#x3D; 105</span><br><span class="line">0 &lt;&#x3D; prerequisites.length &lt;&#x3D; 5000</span><br><span class="line">prerequisites[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; ai, bi &lt; numCourses</span><br><span class="line">prerequisites[i] 中的所有课程对 互不相同</span><br></pre></td></tr></table></figure>



<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;什么时候无法修完所有课程？当存在循环依赖的时候。其实这种场景在现实生活中也十分常见，比如我们写代码 import 包也是一个例子，必须合理设计代码目录结构，否则会出现循环依赖，编译器会报错，所以编译器实际上也使用了类似算法来判断你的代码是否能够成功编译。</p>
<p>&emsp;&emsp;<strong>看到依赖问题，首先想到的就是把问题转化成「有向图」这种数据结构，只要图中存在环，那就说明存在循环依赖</strong>。具体来说，我们首先可以把课程看成「有向图」中的节点，节点编号分别是 <code>0, 1, ..., numCourses-1</code>，把课程之间的依赖关系看做节点之间的有向边。</p>
<p>&emsp;&emsp;比如说必须修完课程 <code>1</code> 才能去修课程 <code>3</code>，那么就有一条有向边从节点 <code>1</code> 指向 <code>3</code>。所以我们可以根据题目输入的 <code>prerequisites</code> 数组生成一幅类似这样的图：</p>
<p><img lazyload src="/images/loading.svg" data-src="4.jpg" alt="avatar"></p>
<p>&emsp;&emsp;<strong>如果发现这幅有向图中存在环，那就说明课程之间存在循环依赖，肯定没办法全部上完；反之，如果没有环，那么肯定能上完全部课程</strong>。所以第一步，我们要讲本题的这种依赖关系转换成图。</p>
<ul>
<li>先写一个建图函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildGraph</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    graph := <span class="built_in">make</span>([][]<span class="keyword">int</span>,numCourses)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        from := v[<span class="number">1</span>]</span><br><span class="line">        to := v[<span class="number">0</span>]</span><br><span class="line">        graph[from] = <span class="built_in">append</span>(graph[from], to)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以把 <code>traverse</code> 看做在图中节点上游走的指针，只需要再添加一个布尔数组 <code>onPath</code> 记录当前 <code>traverse</code> 经过的路径。完整代码如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    graph := buildGraph(numCourses, prerequisites)</span><br><span class="line">    onPath := <span class="built_in">make</span>([]<span class="keyword">bool</span>,numCourses)</span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="keyword">bool</span>,numCourses)</span><br><span class="line">    isCycle := <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    traverse = <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> onPath[s] == <span class="literal">true</span> &#123; <span class="comment">// 发现环</span></span><br><span class="line">            isCycle = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> visited[s] || onPath[s] &#123; <span class="comment">// 若是遍历过的节点或是存在于环内的节点，直接回溯</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历代码</span></span><br><span class="line">        visited[s] = <span class="literal">true</span></span><br><span class="line">        onPath[s] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _,v := <span class="keyword">range</span> graph[s] &#123;</span><br><span class="line">            traverse(v)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历代码</span></span><br><span class="line">        onPath[s] = <span class="literal">false</span> <span class="comment">// 在回溯的过程中将遍历过的节点标记为无环状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123;  <span class="comment">// 遍历图中所有节点</span></span><br><span class="line">        traverse(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !isCycle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildGraph</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    graph := <span class="built_in">make</span>([][]<span class="keyword">int</span>,numCourses)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        from := v[<span class="number">1</span>]</span><br><span class="line">        to := v[<span class="number">0</span>]</span><br><span class="line">        graph[from] = <span class="built_in">append</span>(graph[from], to)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="拓扑排序（无环图的后续遍历的反转）"><a href="#拓扑排序（无环图的后续遍历的反转）" class="headerlink" title="拓扑排序（无环图的后续遍历的反转）"></a>拓扑排序（<font color="red">无环图的后续遍历的反转</font>）</h1><h3 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a class="link" href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II<i class="fas fa-external-link-alt"></i></a></h3><p>现在你总共有 <em>n</em> 门课需要选，记为 <code>0</code> 到 <code>n-1</code>。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: <code>[0,1]</code></p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: [0,1]</span><br><span class="line">解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3]。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>输入的先决条件是由<strong>边缘列表</strong>表示的图形，而不是邻接矩阵。详情请参见<a class="link" href="http://blog.csdn.net/woaidapaopao/article/details/51732947">图的表示法<i class="fas fa-external-link-alt"></i></a>。</li>
<li>你可以假定输入的先决条件中没有重复的边。</li>
</ol>
<p>提示:</p>
<ul>
<li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li>
<li>拓扑排序也可以通过 BFS 完成。</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;这道题就是上道题的进阶版，不是仅仅让你判断是否可以完成所有课程，而是进一步让你返回一个合理的上课顺序，保证开始修每个课程时，前置的课程都已经修完。<strong>如果把课程抽象成节点，课程之间的依赖关系抽象成有向边，那么这幅图的拓扑排序结果就是上课顺序</strong>。首先，我们先判断一下题目输入的课程依赖是否成环，成环的话是无法进行拓扑排序的，所以我们可以复用上一道题的主函数。<strong>将后序遍历的结果进行反转，就是拓扑排序的结果</strong>。<strong>为什么后序遍历的反转结果就是拓扑排序呢</strong>？<strong>后序遍历的这一特点很重要，之所以拓扑排序的基础是后序遍历，是因为一个任务必须在等到所有的依赖任务都完成之后才能开始开始执行</strong>。你把每个任务理解成二叉树里面的节点，这个任务所依赖的任务理解成子节点，那你是不是应该先把所有子节点处理完再处理父节点？这是不是就是后序遍历？所以只需要在遍历节点的时候使用一个<code>postorder</code>数组存储后续遍历结果即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOrder</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    postorder := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> canFinish(numCourses, prerequisites, &amp;postorder) == <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125; <span class="comment">// 先判断是否有环，有环的话直接输出空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>,numCourses)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123; <span class="comment">// 无环的话将后续遍历的结果反转即可</span></span><br><span class="line">        res[i] = postorder[numCourses-i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>, postorder *[]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    graph := buildGraph(numCourses, prerequisites)</span><br><span class="line">    onPath := <span class="built_in">make</span>([]<span class="keyword">bool</span>,numCourses)</span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="keyword">bool</span>,numCourses)</span><br><span class="line">    isCycle := <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    traverse = <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> onPath[s] == <span class="literal">true</span> &#123; <span class="comment">// 发现环</span></span><br><span class="line">            isCycle = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> visited[s] || onPath[s] &#123; <span class="comment">// 若是遍历过的节点或是存在于环内的节点，直接回溯</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历代码</span></span><br><span class="line">        visited[s] = <span class="literal">true</span></span><br><span class="line">        onPath[s] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _,v := <span class="keyword">range</span> graph[s] &#123;</span><br><span class="line">            traverse(v)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历代码</span></span><br><span class="line">        onPath[s] = <span class="literal">false</span> <span class="comment">// 在回溯的过程中将遍历过的节点标记为无环状态</span></span><br><span class="line">        *postorder = <span class="built_in">append</span>(*postorder,s) <span class="comment">// 存储后续遍历的结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;numCourses; i++ &#123;  <span class="comment">// 遍历图中所有节点</span></span><br><span class="line">        traverse(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !isCycle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildGraph</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123; <span class="comment">// 生成图结构</span></span><br><span class="line">    graph := <span class="built_in">make</span>([][]<span class="keyword">int</span>,numCourses)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        from := v[<span class="number">1</span>]</span><br><span class="line">        to := v[<span class="number">0</span>]</span><br><span class="line">        graph[from] = <span class="built_in">append</span>(graph[from], to)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>Union-Find(并查集)</title>
    <url>/2021/09/15/Union-Find(%E5%B9%B6%E6%9F%A5%E9%9B%86)/</url>
    <content><![CDATA[<h2 id="并查集介绍"><a href="#并查集介绍" class="headerlink" title="并查集介绍"></a>并查集介绍</h2><h3 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h3><p>&emsp;&emsp;对于无向图，对其进行遍历时：</p>
<ul>
<li>若是连通图，仅需从图中任一顶点出发，就能访问图中的所有顶点。</li>
<li>若是非连通图，需从图中多个顶点出发。每次从一个新顶点出发所访问的顶点集序列恰好是各个连通分量的顶点集。</li>
</ul>
<p>&emsp;&emsp;比如下面这幅图，总共有 10 个节点，他们互不相连，分别用 0~9 标记：</p>
<p><img lazyload src="/images/loading.svg" data-src="1.jpg" alt="avatar"></p>
<p>&emsp;&emsp;「连通」是一种等价关系，也就是说具有如下三个性质：</p>
<ol>
<li>自反性：节点 <code>p</code> 和 <code>p</code> 是连通的。</li>
<li>对称性：如果节点 <code>p</code> 和 <code>q</code> 连通，那么 <code>q</code> 和 <code>p</code> 也连通。</li>
<li>传递性：如果节点 <code>p</code> 和 <code>q</code> 连通，<code>q</code> 和 <code>r</code> 连通，那么 <code>p</code> 和 <code>r</code> 也连通。</li>
</ol>
<h3 id="函数签名-基本模型"><a href="#函数签名-基本模型" class="headerlink" title="函数签名(基本模型)"></a>函数签名(基本模型)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">union</span><span class="params">(p,q <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 将p，q节点连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connected</span><span class="params">(p,q <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="comment">// 判断p，q节点是否连通</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countUF</span><span class="params">(graph *Vertax)</span> <span class="title">int</span></span> &#123; <span class="comment">// 返回途中有多少个连通分量 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>比如说之前那幅图，0～9 任意两个<strong>不同</strong>的点都不连通，调用 <code>connected</code> 都会返回 false，连通分量为 10 个。</li>
<li>如果现在调用 <code>union(0, 1)</code>，那么 0 和 1 被连通，连通分量降为 9 个。</li>
<li>再调用 <code>union(1, 2)</code>，这时 0,1,2 都被连通，调用 <code>connected(0, 2)</code> 也会返回 true，连通分量变为 8 个。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="2.jpg" alt="avatar"></p>
<p>&emsp;&emsp;判断这种「等价关系」非常实用，比如说编译器判断同一个变量的不同引用，比如社交网络中的朋友圈计算等等。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>&emsp;&emsp;我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。比如说刚才那幅 10 个节点的图，一开始的时候没有相互连通，就是这样：</p>
<p><img lazyload src="/images/loading.svg" data-src="3.jpg" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UF <span class="keyword">struct</span> &#123;</span><br><span class="line">  	count			<span class="keyword">int</span>		<span class="comment">// 记录连通分量</span></span><br><span class="line">  	parent		[]<span class="keyword">int</span>	<span class="comment">// 节点x的父节点是parent[x]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">construct</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">UF</span></span> &#123;</span><br><span class="line">  	p := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">    	p[i] = i</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> UF&#123;</span><br><span class="line">      count : n		<span class="comment">// 一开始互不连通</span></span><br><span class="line">      parent : p	<span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上</strong>：</p>
<p><img lazyload src="/images/loading.svg" data-src="4.jpg" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">union</span><span class="params">(p,q <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  	rootP := u.find(p)</span><br><span class="line">  	rootQ := u.find(q)</span><br><span class="line">  	<span class="keyword">if</span> rootP == rootQ &#123;</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 将两棵树合为一棵树</span></span><br><span class="line">  	u.parent[rootP] = rootQ</span><br><span class="line">  	<span class="comment">// u.parent[rootQ] = rootP也一样</span></span><br><span class="line">  	u.count--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">find</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根节点的u.parent[x]=x</span></span><br><span class="line">  	<span class="keyword">for</span> u.parent[x] != x &#123;</span><br><span class="line">    	x = u.parent[x]</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>这样，如果节点</strong> <strong><code>p</code></strong> <strong>和</strong> <strong><code>q</code></strong> <strong>连通的话，它们一定拥有相同的根节点</strong>：</p>
<p><img lazyload src="/images/loading.svg" data-src="5.jpg" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">connected</span><span class="params">(p,q <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  	rootP := u.find(p)</span><br><span class="line">  	rootQ := u.find(q)</span><br><span class="line">  	<span class="keyword">return</span> rootP == rootQ</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;主要 API <code>connected</code> 和 <code>union</code> 中的复杂度都是 <code>find</code> 函数造成的，所以说它们的复杂度和 <code>find</code> 一样。<code>find</code> 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是 <code>logN</code>，但这并不一定。<code>logN</code> 的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度最坏情况下可能变成 <code>N</code>。所以说上面这种解法，<code>find</code> , <code>union</code> , <code>connected</code> 的时间复杂度都是 O(N)。这个复杂度很不理想的，你想图论解决的都是诸如社交网络这样数据规模巨大的问题，对于 <code>union</code> 和 <code>connected</code> 的调用非常频繁，每次调用需要线性时间完全不可忍受。<strong>问题的关键在于，如何想办法避免树的不平衡呢</strong>？</p>
<h2 id="平衡性优化"><a href="#平衡性优化" class="headerlink" title="平衡性优化"></a>平衡性优化</h2><p>&emsp;&emsp;我们要知道哪种情况下可能出现不平衡现象，关键在于 <code>union</code> 过程：我们一开始就是简单粗暴的把 <code>p</code> 所在的树接到 <code>q</code> 所在的树的根节点下面，那么这里就可能出现「头重脚轻」的不平衡状况，比如下面这种局面：</p>
<p><img lazyload src="/images/loading.svg" data-src="7.jpg" alt="avatar"></p>
<p>&emsp;&emsp;长此以往，树可能生长得很不平衡。<strong>我们其实是希望，小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些</strong>。解决方法是额外使用一个 <code>size</code> 数组，记录每棵树包含的节点数，我们不妨称为「重量」：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UF <span class="keyword">struct</span> &#123;</span><br><span class="line">  	count			<span class="keyword">int</span>		<span class="comment">// 记录连通分量</span></span><br><span class="line">  	parent		[]<span class="keyword">int</span>	<span class="comment">// 节点x的父节点是parent[x]</span></span><br><span class="line">  	size			[]<span class="keyword">int</span>	<span class="comment">// 新增一个数组用于记录树的“重量”,这个数组只对根节点有意义，在使用前需要先判别是否是根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">construct</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">UF</span></span> &#123;</span><br><span class="line">  	p := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  	s := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">    	p[i] = i	<span class="comment">// 最初每棵树只有一个节点</span></span><br><span class="line">      s[i] = <span class="number">1</span>	<span class="comment">// 重量应该初始化为1</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> UF&#123;</span><br><span class="line">      count : n		<span class="comment">// 一开始互不连通</span></span><br><span class="line">      parent : p	<span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">      size : s		<span class="comment">// 每个节点的重量应该初始化为1</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;比如说 <code>size[3] = 5</code> 表示，以节点 <code>3</code> 为根的那棵树，总共有 <code>5</code> 个节点。这样我们可以修改一下 <code>union</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">union</span><span class="params">(p,q <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  	rootP := u.find(p)</span><br><span class="line">  	rootQ := u.find(q)</span><br><span class="line">  	<span class="keyword">if</span> rootP == rootQ &#123;</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 小树接到大树下面，较平衡</span></span><br><span class="line">  	<span class="keyword">if</span> u.size[rootP] &gt; u.size[rootQ] &#123;</span><br><span class="line">    		u.parent[rootQ] = rootP</span><br><span class="line">    		u.size[rootP] += u.size[rootQ]</span><br><span class="line">  	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		u.parent[rootP] = rootQ</span><br><span class="line">    		u.size[rootQ] += u.size[rootP]</span><br><span class="line">  	&#125;</span><br><span class="line">  	u.count--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在 <code>logN</code> 这个数量级，极大提升执行效率。此时，<code>find</code> , <code>union</code> , <code>connected</code> 的时间复杂度都下降为 O(logN)，即便数据规模上亿，所需时间也非常少。</p>
<h2 id="路经压缩"><a href="#路经压缩" class="headerlink" title="路经压缩"></a>路经压缩</h2><p>&emsp;&emsp;这步优化特别简单，所以非常巧妙。我们能不能进一步压缩每棵树的高度，使树高始终保持为常数？</p>
<p><img lazyload src="/images/loading.svg" data-src="8.jpg" alt="avatar"></p>
<p>&emsp;&emsp;这样 <code>find</code> 就能以 O(1) 的时间找到某一节点的根节点，相应的，<code>connected</code> 和 <code>union</code> 复杂度都下降为 O(1)。要做到这一点，非常简单，只需要在 <code>find</code> 中加一行代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">find</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  	<span class="keyword">for</span> u.parent[x] != x &#123;</span><br><span class="line">    	u.parent[x] = u.parent[u.parent[x]]	<span class="comment">// 指向爷爷节点 </span></span><br><span class="line">    	x = u.parent[x]											<span class="comment">// 定位到爷爷节点</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个操作有点匪夷所思，看个 GIF 就明白它的作用了（为清晰起见，这棵树比较极端）：</p>
<p><img lazyload src="/images/loading.svg" data-src="9.gif" alt="avatar"></p>
<p>&emsp;&emsp;可见，调用 <code>find</code> 函数每次向树根遍历的同时，顺手将树高缩短了，最终所有树高都不会超过 3（<code>union</code> 的时候树高可能达到 3）。PS：读者可能会问，这个 GIF 图的find过程完成之后，树高恰好等于 3 了，但是如果更高的树，压缩后高度依然会大于 3 呀？不能这么想。这个 GIF 的情景是我编出来方便大家理解路径压缩的，但是实际中，每次find都会进行路径压缩，所以树本来就不可能增长到这么高，你的这种担心应该是多余的。</p>
<h2 id="算法模板总结"><a href="#算法模板总结" class="headerlink" title="算法模板总结"></a>算法模板总结</h2><p>&emsp;&emsp;先看一下完整代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UF <span class="keyword">struct</span> &#123;</span><br><span class="line">  	count			<span class="keyword">int</span></span><br><span class="line">  	parent		[]<span class="keyword">int</span></span><br><span class="line">  	size			[]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">construct</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">UF</span></span> &#123; <span class="comment">// 初始化UF</span></span><br><span class="line">  	p := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  	s := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">  	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">    	p[i] = i</span><br><span class="line">    	size[i] = <span class="number">1</span></span><br><span class="line"> 		&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">return</span> UF&#123;</span><br><span class="line">      count : n,</span><br><span class="line">      parent : p,</span><br><span class="line">      size : s</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">find</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;	<span class="comment">// 查找两节点是否连通</span></span><br><span class="line">  	<span class="keyword">for</span> u.parent[x] != x &#123;</span><br><span class="line">    	u.parent[x] = u.parent[u.parent[x]]</span><br><span class="line">    	x = u.parent[x]</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">union</span><span class="params">(p,q <span class="keyword">int</span>)</span></span> &#123;	<span class="comment">// 使p，q节点连通</span></span><br><span class="line">  	rootP := u.find(p)</span><br><span class="line">  	rootQ := u.find(q)</span><br><span class="line">  	<span class="keyword">if</span> rootP == rootQ &#123;</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">if</span> u.size[rootP] &gt; u.size[rootQ] &#123;</span><br><span class="line">    	u.paremt[rootQ] = rootP</span><br><span class="line">    	u.size[rootP] += u.size[rootQ]</span><br><span class="line">  	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	u.parent[rootP] = rootQ</span><br><span class="line">    	u.size[rootQ] += u.size[rootP]</span><br><span class="line">  	&#125;</span><br><span class="line">  	u.count--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">connected</span><span class="params">(p,q <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;	<span class="comment">// 查看p，q节点是否连通</span></span><br><span class="line">  	rootP := u.find(p)</span><br><span class="line">  	rootQ := u.find(q)</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">return</span> rootP == rootQ</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">countUF</span><span class="params">()</span> <span class="title">int</span></span> &#123;	<span class="comment">// 查看连通分量</span></span><br><span class="line">  	<span class="keyword">return</span> u.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Union-Find 算法的复杂度可以这样分析：构造函数初始化数据结构需要 O(N) 的时间和空间复杂度；连通两个节点 <code>union</code>、判断两个节点的连通性 <code>connected</code>、计算连通分量 <code>count</code> 所需的时间复杂度均为 O(1)。</p>
<h2 id="并查集相关题目"><a href="#并查集相关题目" class="headerlink" title="并查集相关题目"></a>并查集相关题目</h2><h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a class="link" href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域<i class="fas fa-external-link-alt"></i></a></h3><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="10.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">输出：[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 &#39;O&#39; 都不会被填充为 &#39;X&#39;。 任何不在边界上，或不与边界上的 &#39;O&#39; 相连的 &#39;O&#39; 最终都会被填充为 &#39;X&#39;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;X&quot;]]</span><br><span class="line">输出：[[&quot;X&quot;]]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>m == board.length</li>
<li>n == board[i].length</li>
<li>1 &lt;= m, n &lt;= 200</li>
<li>board[i] [j]为 ‘X’ 或 ‘O’</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;必须是四面被围的 <code>O</code> 才能被换成 <code>X</code>，也就是说边角上的 <code>O</code> 一定不会被围，进一步，与边角上的 <code>O</code> 相连的 <code>O</code> 也不会被 <code>X</code> 围四面，也不会被替换。解决这个问题的传统方法也不困难，先用 for 循环遍历棋盘的<strong>四边</strong>，用 DFS 算法把那些与边界相连的 <code>O</code> 换成一个特殊字符，比如 <code>#</code>；然后再遍历整个棋盘，把剩下的 <code>O</code> 换成 <code>X</code>，把 <code>#</code> 恢复成 <code>O</code>。这样就能完成题目的要求，时间复杂度 O(MN)。这个问题也可以用 Union-Find 算法解决。</p>
<p>&emsp;&emsp;<strong>你可以把那些不需要被替换的</strong> <strong><code>O</code></strong> <strong>看成一个拥有独门绝技的门派，它们有一个共同祖师爷叫</strong> **<code>dummy</code>**<strong>，这些</strong> <strong><code>O</code></strong> <strong>和</strong> <strong><code>dummy</code></strong> <strong>互相连通，而那些需要被替换的</strong> <strong><code>O</code></strong> <strong>与</strong> <strong><code>dummy</code></strong> <strong>不连通</strong>。</p>
<p><img lazyload src="/images/loading.svg" data-src="11.jpg" alt="avatar"></p>
<p>&emsp;&emsp;这就是 Union-Find 的核心思路，明白这个图，就很容易看懂代码了。首先要解决的是，根据我们的实现，Union-Find 底层用的是一维数组，构造函数需要传入这个数组的大小，而题目给的是一个二维棋盘。</p>
<p>&emsp;&emsp;这个很简单，二维坐标 <code>(x,y)</code> 可以转换成 <code>x * n + y</code> 这个数（<code>m</code> 是棋盘的行数，<code>n</code> 是棋盘的列数）。敲黑板，<strong>这是将二维坐标映射到一维的常用技巧</strong>。</p>
<p>&emsp;&emsp;其次，我们之前描述的「祖师爷」是虚构的，需要给他老人家留个位置。索引 <code>[0.. m*n-1]</code> 都是棋盘内坐标的一维映射，那就让这个虚拟的 <code>dummy</code> 节点占据索引 <code>m * n</code> 好了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UF <span class="keyword">struct</span> &#123;</span><br><span class="line">    count   <span class="keyword">int</span></span><br><span class="line">    parent  []<span class="keyword">int</span></span><br><span class="line">    size    []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">construct</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">UF</span></span> &#123; <span class="comment">// 初始化UF结构体</span></span><br><span class="line">    p := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        p[i] = i</span><br><span class="line">        s[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UF&#123;</span><br><span class="line">        count:n,</span><br><span class="line">        parent:p,</span><br><span class="line">        size:s,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">find</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">// 查找根节点的方法</span></span><br><span class="line">    <span class="keyword">for</span> u.parent[x] != x &#123;</span><br><span class="line">        u.parent[x] = u.parent[u.parent[x]]</span><br><span class="line">        x = u.parent[x]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">union</span><span class="params">(p,q <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 连通两节点的方法</span></span><br><span class="line">    rootP := u.find(p)</span><br><span class="line">    rootQ := u.find(q)</span><br><span class="line">    <span class="keyword">if</span> rootP == rootQ &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> u.size[rootP] &gt; u.size[rootQ] &#123;</span><br><span class="line">        u.parent[rootQ] = rootP</span><br><span class="line">        u.size[rootP] += u.size[rootQ]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        u.parent[rootP] = rootQ</span><br><span class="line">        u.size[rootQ] += u.size[rootP]</span><br><span class="line">    &#125;</span><br><span class="line">    u.count--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u UF)</span> <span class="title">connected</span><span class="params">(p,q <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;  <span class="comment">// 查看是否连通的方法</span></span><br><span class="line">    rootP := u.find(p)</span><br><span class="line">    rootQ := u.find(q)</span><br><span class="line">    <span class="keyword">return</span> rootP == rootQ</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solve</span><span class="params">(board [][]<span class="keyword">byte</span>)</span></span>  &#123; <span class="comment">// 函数主题</span></span><br><span class="line">    m := <span class="built_in">len</span>(board)</span><br><span class="line">    n := <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">    u := construct(m*n+<span class="number">1</span>)  <span class="comment">// 初始化并查集，多将一位数加入并查集，作为dummy节点（边缘&#x27;O&#x27;的根节点）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;m; i++ &#123; <span class="comment">// 将第一列和最后一列的&#x27;O&#x27;元素与位于m*n处的dummy连通</span></span><br><span class="line">        <span class="keyword">if</span> board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">            u.union(i*n, m*n)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> board[i][n<span class="number">-1</span>] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">            u.union(i*n+(n<span class="number">-1</span>), m*n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;n<span class="number">-1</span>; j++ &#123; <span class="comment">// 将第一行和最后一行的&#x27;O&#x27;元素与位于m*n处的dummy连通</span></span><br><span class="line">        <span class="keyword">if</span> board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">            u.union(j, m*n)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> board[m<span class="number">-1</span>][j] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">            u.union((m<span class="number">-1</span>)*n+j, m*n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d := [][]<span class="keyword">int</span>&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125; <span class="comment">// 方向数组 d 是上下左右搜索的常用手法</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;m<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;n<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">              <span class="comment">// 将此 O 与上下左右的 O 连通</span></span><br><span class="line">                <span class="keyword">for</span> k:=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++ &#123;</span><br><span class="line">                    x := i+d[k][<span class="number">0</span>]</span><br><span class="line">                    y := j+d[k][<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> board[x][y] == <span class="string">&#x27;O&#x27;</span> &#123;</span><br><span class="line">                        u.union(i*n+j, x*n+y)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 所有不和 dummy 连通的 O，都要被替换</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;m<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span>; j&lt;n<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (!u.connected(i*n+j, m*n)) &#123;</span><br><span class="line">                board[i][j] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记</title>
    <url>/2021/09/16/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>&emsp;&emsp;学习视频地址：<a class="link" href="https://www.bilibili.com/video/BV1S54y1R7SB?p=4&spm_id_from=pageDriver">【狂神说Java】Redis最新超详细版教程通俗易懂<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="为什么要用NoSQL"><a href="#为什么要用NoSQL" class="headerlink" title="为什么要用NoSQL"></a>为什么要用NoSQL</h1><p>&emsp;&emsp;用户的个人信息、社交网络、地理位置、用户自己产生的数据、用户日志等等爆发式增长。使用NoSQL数据库可以很好的解决上述情况。</p>
<h1 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h1><p>&emsp;&emsp;NoSQL=Not Only SQL。泛指非关系型数据库。随着web2.0互联网的诞生，传统的关系型数据库很难应付此时的需求。尤其是超大规模，高并发的社区。NoSQL在当今大数据时代下十分通用，Redis是发展最快的。</p>
<p>&emsp;&emsp;很多的数据类型用户的个人信息、社交网络、地理位置等数据的存储不需要一个固定的格式。不需要多余的操作就可以横向扩展（使用键值对来存储）。</p>
<p>&emsp;&emsp;特点：</p>
<ol>
<li>方便扩展（数据之间没有关系，很好扩展）</li>
<li>大数据条件下性能高（Redis一秒写8万次，读取11万次，NoSQL的缓存）</li>
<li>数据类型多样，不需要事先设计数据库，随取随用</li>
<li>传统的RDBMS和NoSQL</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传统的RDBMS</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都在单独的表中</span><br><span class="line">- 数据操作语言，数据定义语言</span><br><span class="line">- 严格的一致性</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NoSQL</span><br><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储、列存储、文档存储、图形数据库（社交关系）</span><br><span class="line">- 最终一致性</span><br><span class="line">- CAP定理和BASE（异地多活）</span><br><span class="line">- 高性能、高可用、高可扩展</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;NoSQL的四大分类：</p>
<ol>
<li>kv键值对：<strong>Redis</strong>、memcache</li>
<li>文档型数据库（bson和json格式）：</li>
</ol>
<ul>
<li><strong>MangoDB</strong><ul>
<li>MangoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档</li>
<li>MangoDB是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库中功能最丰富的，最像关系型数据库的</li>
</ul>
</li>
<li>CouchDB</li>
</ul>
<ol start="3">
<li>列存储数据库</li>
</ol>
<ul>
<li><strong>HBase</strong></li>
<li>分布式文件系统</li>
</ul>
<ol start="4">
<li>图关系数据库（存放关系，比如：朋友圈，广告推荐）</li>
</ol>
<ul>
<li><strong>Neo4j</strong></li>
<li>InfoGrid</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>NoSQL数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU算法</title>
    <url>/2021/09/21/LRU%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="LRU算法介绍"><a href="#LRU算法介绍" class="headerlink" title="LRU算法介绍"></a>LRU算法介绍</h1><p>&emsp;&emsp;LRU算法(Least Recently Used)算法实质上是一种缓存机制，常用于操作系统的缓存。计算机的缓存容量是有限的，如果缓存满了就要给新的内容腾位置。那淘汰哪些缓存，哪些继续以何种方式留在缓存中就是一个策略性的问题。LRU算法就是其中一种淘汰策略。其内核就是<strong>认为最近使用过的数据是最有用的，很久都没使用的数据是无用的，内存满了就应该优先淘汰很久没用过的数据</strong>。</p>
<p>&emsp;&emsp;举一个实际例子，安卓手机都可以把软件放到后台运行，比如我先后打开了「设置」「手机管家」「日历」，那么现在他们在后台排列的顺序是这样的：</p>
<p><img lazyload src="/images/loading.svg" data-src="1.jpg#pic_center" alt="avatar"></p>
<p>&emsp;&emsp;但是这时候如果我访问了一下「设置」界面，那么「设置」就会被提前到第一个，变成这样：</p>
<p><img lazyload src="/images/loading.svg" data-src="2.jpg#pic_center" alt="avatar"></p>
<p>&emsp;&emsp;假设我的手机只允许我同时开 3 个应用程序，现在已经满了。那么如果我新开了一个应用「时钟」，就必须关闭一个应用为「时钟」腾出一个位置，关那个呢？按照 LRU 的策略，就关最底下的「手机管家」，因为那是最久未使用的，然后把新开的应用放到最上面：</p>
<p><img lazyload src="/images/loading.svg" data-src="3.jpg#pic_center" alt="avatar"></p>
<h1 id="LRU算法的函数签名"><a href="#LRU算法的函数签名" class="headerlink" title="LRU算法的函数签名"></a>LRU算法的函数签名</h1><p>&emsp;&emsp;函数签名可以参考<a class="link" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制<i class="fas fa-external-link-alt"></i></a>的题目要求：</p>
<p>运用你所掌握的数据结构，设计和实现一个 <a class="link" href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存机制<i class="fas fa-external-link-alt"></i></a> 。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity) </code>以正整数作为容量 capacity 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li>
<li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>
</ul>
<p><strong>进阶</strong>：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache &#x3D; new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1&#125;</span><br><span class="line">lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1, 2&#x3D;2&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 1</span><br><span class="line">lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 &#123;1&#x3D;1, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 &#123;4&#x3D;4, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    &#x2F;&#x2F; 返回 3</span><br><span class="line">lRUCache.get(4);    &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>1 &lt;= capacity &lt;= 3000</li>
<li>0 &lt;= key &lt;= 10000</li>
<li>0 &lt;= value &lt;= 105</li>
<li>最多调用 2 * 105 次 get 和 put</li>
</ul>
<h1 id="LRU算法设计"><a href="#LRU算法设计" class="headerlink" title="LRU算法设计"></a>LRU算法设计</h1><p>&emsp;&emsp;分析上面的操作过程，要让 <code>put</code> 和 <code>get</code> 方法的时间复杂度为 O(1)，我们可以总结出 <code>cache</code> 这个数据结构必要的条件：</p>
<ol>
<li>显然 <code>cache</code> 中的元素必须有顺序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。</li>
<li>我们要在 <code>cache</code> 中快速找某个 <code>key</code> 是否已存在并得到对应的 <code>val</code>；</li>
<li>每次访问 <code>cache</code> 中的某个 <code>key</code>，需要将这个元素变为最近使用的，也就是说 <code>cache</code> 要支持在任意位置快速插入和删除元素。</li>
</ol>
<p>&emsp;&emsp;那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表 <code>LinkedHashMap</code>。LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：</p>
<p><img lazyload src="/images/loading.svg" data-src="4.jpg" alt="avatar"></p>
<p>&emsp;&emsp;借助这个结构，我们来逐一分析上面的 3 个条件：</p>
<ol>
<li>如果我们每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。</li>
<li>对于某一个 <code>key</code>，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 <code>val</code>。</li>
<li>链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 <code>key</code> 快速映射到任意一个链表节点，然后进行插入和删除。</li>
</ol>
<p>&emsp;&emsp;这里先引出两个问题：<strong>为什么要是双向链表，单链表行不行？另外，既然哈希表中已经存了</strong> **<code>key</code>**<strong>，为什么链表中还要存</strong> <strong><code>key</code></strong> <strong>和</strong> <strong><code>val</code></strong> <strong>呢，只存</strong> <strong><code>val</code></strong> <strong>不就行了</strong>？</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="双链表的实现"><a href="#双链表的实现" class="headerlink" title="双链表的实现"></a>双链表的实现</h2><p>&emsp;&emsp;首先实现连表的每个节点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key			<span class="keyword">int</span></span><br><span class="line">    value		<span class="keyword">int</span></span><br><span class="line">    prev		*node</span><br><span class="line">    next		*node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后依靠着这些节点实现一个双链表：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DoubleList <span class="keyword">struct</span> &#123;</span><br><span class="line">    head		*node		<span class="comment">// 头部虚节点</span></span><br><span class="line">    tail		*node		<span class="comment">// 尾部虚节点</span></span><br><span class="line">    size		<span class="keyword">int</span>			<span class="comment">// 连表节点数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructDL</span><span class="params">()</span> *<span class="title">DoubleList</span></span> &#123;	<span class="comment">// 初始化双链表</span></span><br><span class="line">    dh := &amp;node&#123;</span><br><span class="line">        key : <span class="number">0</span>,</span><br><span class="line">        value : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dt := &amp;node&#123;</span><br><span class="line">        key : <span class="number">0</span>,</span><br><span class="line">        value : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dh.next,dt.prev = dt,dh <span class="comment">// 收尾虚节点形成双链表</span></span><br><span class="line">    <span class="keyword">return</span> &amp;DoubleList&#123;</span><br><span class="line">        head : dh,</span><br><span class="line">    	tail : dt,</span><br><span class="line">    	size : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="双链表的几个API的实现"><a href="#双链表的几个API的实现" class="headerlink" title="双链表的几个API的实现"></a>双链表的几个API的实现</h2><p>&emsp;&emsp;接下来我们实现操作双链表的几个API:</p>
<ol>
<li><code>addLast(x *node)</code>：将最近使用的节点加入到双链表中（从尾部进入双链表）</li>
<li><code>remove(x *node)</code>：删除双链表中的节点x（节点x一定存在的条件下）</li>
<li><code>removeFirst()</code>：当容量满时，将最久未使用的节点（表首的节点）删除</li>
<li><code>dlSize()</code>：返回双链表的节点数</li>
</ol>
<h3 id="addLast-x-node-方法的实现细节"><a href="#addLast-x-node-方法的实现细节" class="headerlink" title="addLast(x *node)方法的实现细节"></a><code>addLast(x *node)</code>方法的实现细节</h3><p>&emsp;&emsp;在双链表的尾部虚节点之前插入节点，需要注意插入过程中<code>prev</code>和<code>next</code>指针的插入顺序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">addLast</span><span class="params">(x *node)</span></span> &#123; <span class="comment">// 在链表尾部添加节点 x，时间 O(1)</span></span><br><span class="line">    x.prev = dl.tail.prev</span><br><span class="line">    x.next = dl.tail</span><br><span class="line">    dl.tail.prev.next = x</span><br><span class="line">    dl.tail.prev = x</span><br><span class="line">    dl.size++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="remove-x-node-方法的实现细节"><a href="#remove-x-node-方法的实现细节" class="headerlink" title="remove(x *node)方法的实现细节"></a><code>remove(x *node)</code>方法的实现细节</h3><p>&emsp;&emsp;删除连表中的某一节点，x存在时才能使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">remove</span><span class="params">(x *node)</span></span> &#123; <span class="comment">// 由于是双链表且给的是目标 Node 节点，时间 O(1)</span></span><br><span class="line">    x.prev.next = x.next</span><br><span class="line">    x.next.prev = x.prev</span><br><span class="line">    dl.size--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="removeFirst-方法的实现细节"><a href="#removeFirst-方法的实现细节" class="headerlink" title="removeFirst()方法的实现细节"></a><code>removeFirst()</code>方法的实现细节</h3><p>&emsp;&emsp;缓存的空间占满，删除最久不使用节点（首部节点）。返回被删除的节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">removeFirst</span><span class="params">()</span> *<span class="title">node</span></span> &#123; <span class="comment">// 删除链表中第一个节点，并返回该节点，时间 O(1)</span></span><br><span class="line">    <span class="keyword">if</span> dl.head.next == dl.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> dl.head</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    first := dl.head.next</span><br><span class="line">    dl.remove(first)</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="dlSize-返回链表长度"><a href="#dlSize-返回链表长度" class="headerlink" title="dlSize()返回链表长度"></a><code>dlSize()</code>返回链表长度</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">dlSize</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="comment">// 返回链表长度，时间 O(1)</span></span><br><span class="line">    <span class="keyword">return</span> dl.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="LRUCache类的实现"><a href="#LRUCache类的实现" class="headerlink" title="LRUCache类的实现"></a>LRUCache类的实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashMap		<span class="keyword">map</span>[<span class="keyword">int</span>]*node</span><br><span class="line">    cache		*DoubleList</span><br><span class="line">    <span class="built_in">cap</span>			<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity)</span> <span class="title">LRUCache</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node,capacity)</span><br><span class="line">    dl := constructDL()</span><br><span class="line">    <span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">        hashMap	:	m,</span><br><span class="line">        cache	:	dl,</span><br><span class="line">        <span class="built_in">cap</span>		:	capacity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="抽象后的中间层"><a href="#抽象后的中间层" class="headerlink" title="抽象后的中间层"></a>抽象后的中间层</h2><p>&emsp;&emsp;为了避免直接对缓存进行操作时忘记同时对双链表和哈希表同时进行删除和插入操作，所以在具体的LRU的方法和数据结构之间添加一层作为抽象层（直接对数据结构进行操作）。</p>
<h3 id="makeRecently-key-int-将某个节点提升为最近使用"><a href="#makeRecently-key-int-将某个节点提升为最近使用" class="headerlink" title="makeRecently(key int)将某个节点提升为最近使用"></a><code>makeRecently(key int)</code>将某个节点提升为最近使用</h3><p>&emsp;&emsp;当某个节点被使用后，变为最近使用节点，被放到链表尾部。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">makeRecently</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := this.hashMap[key]</span><br><span class="line">    this.cache.remove(x)	<span class="comment">// 现在双链表删除该节点</span></span><br><span class="line">    this.cache.addLast(x)	<span class="comment">// 然后将该节点添加到双链表尾部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="addRecently-key-int-val-将某个新节点提升为最近使用"><a href="#addRecently-key-int-val-将某个新节点提升为最近使用" class="headerlink" title="addRecently(key int, val)将某个新节点提升为最近使用"></a><code>addRecently(key int, val)</code>将某个新节点提升为最近使用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">addRecently</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := node&#123;</span><br><span class="line">        key	:	key,</span><br><span class="line">        value	:	val,</span><br><span class="line">    &#125;</span><br><span class="line">    this.cache.addLast(&amp;x)</span><br><span class="line">    this.hashMap[key] = &amp;x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="deleteKey-key-int-删除某一个节点"><a href="#deleteKey-key-int-删除某一个节点" class="headerlink" title="deleteKey(key int)删除某一个节点"></a><code>deleteKey(key int)</code>删除某一个节点</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">deleteKey</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := this.hashMap[key]</span><br><span class="line">    <span class="built_in">delete</span>(this.hashMap,x)</span><br><span class="line">    this.cache.remove(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="deleteLeastRecently-删除最久未使用节点"><a href="#deleteLeastRecently-删除最久未使用节点" class="headerlink" title="deleteLeastRecently()删除最久未使用节点"></a><code>deleteLeastRecently()</code>删除最久未使用节点</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">deleteLeastRecently</span><span class="params">()</span></span> &#123;</span><br><span class="line">    deleteNode := this.cache.removeFirst()</span><br><span class="line">    deleteKey := deleteNode.key</span><br><span class="line">    <span class="built_in">delete</span>(this.hashMap,deleteKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="LRUCache类的更新Get-和淘汰Put-方法"><a href="#LRUCache类的更新Get-和淘汰Put-方法" class="headerlink" title="LRUCache类的更新Get()和淘汰Put()方法"></a>LRUCache类的更新Get()和淘汰Put()方法</h2><p>&emsp;&emsp;<code>Get(key int)</code>方法：如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.hashMap[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.makeRecently(key)	<span class="comment">// 关键字存在于缓存中，将其置于双链表尾部位置</span></span><br><span class="line">    <span class="keyword">return</span> this.hashMap[key].value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;<code>Put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.hashMap[key]; ok &#123; <span class="comment">// 如果存在与缓存中</span></span><br><span class="line">        this.deleteKey(key)	<span class="comment">// 先删除原来节点（避免出现更新value的情况）</span></span><br><span class="line">        this.addRecently(key)	<span class="comment">// 然后再将该节点重新插入</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> this.<span class="built_in">cap</span> == this.cache.dlSize &#123; <span class="comment">// 缓存容量已经达到上限</span></span><br><span class="line">            this.deleteLeastRecently()	<span class="comment">// 删除最不常使用节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        this.addRecntly(key,val)	<span class="comment">// 然后将该新节点添加到缓存中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key     <span class="keyword">int</span></span><br><span class="line">    value   <span class="keyword">int</span></span><br><span class="line">    prev    *node</span><br><span class="line">    next    *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DoubleList <span class="keyword">struct</span> &#123;</span><br><span class="line">    head    *node</span><br><span class="line">    tail    *node</span><br><span class="line">    size    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructDL</span><span class="params">()</span> *<span class="title">DoubleList</span></span> &#123;</span><br><span class="line">    dh := &amp;node&#123;</span><br><span class="line">        key :   <span class="number">0</span>,</span><br><span class="line">        value : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dt := &amp;node&#123;</span><br><span class="line">        key :   <span class="number">0</span>,</span><br><span class="line">        value : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dh.next,dt.prev = dt,dh</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;DoubleList&#123;</span><br><span class="line">        head    :   dh,</span><br><span class="line">        tail    :   dt,</span><br><span class="line">        size    :   <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">addLast</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev = dl.tail.prev</span><br><span class="line">    x.next = dl.tail</span><br><span class="line">    dl.tail.prev.next = x</span><br><span class="line">    dl.tail.prev = x</span><br><span class="line">    dl.size++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">remove</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev.next = x.next</span><br><span class="line">    x.next.prev = x.prev</span><br><span class="line">    dl.size--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">removeFirst</span><span class="params">()</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dl.head.next == dl.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> dl.head</span><br><span class="line">    &#125;</span><br><span class="line">    first := dl.head.next</span><br><span class="line">    dl.remove(first)</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">dlSize</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dl.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashMap     <span class="keyword">map</span>[<span class="keyword">int</span>]*node</span><br><span class="line">    cache       *DoubleList</span><br><span class="line">    <span class="built_in">cap</span>         <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LRUCache</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node,capacity)</span><br><span class="line">    dl := constructDL()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">        hashMap :   m,</span><br><span class="line">        cache   :   dl,</span><br><span class="line">        <span class="built_in">cap</span>     :   capacity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.hashMap[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.makeRecently(key)</span><br><span class="line">    <span class="keyword">return</span> this.hashMap[key].value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.hashMap[key]; ok &#123;</span><br><span class="line">        this.deleteKey(key)</span><br><span class="line">        this.addRecently(key,value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> this.<span class="built_in">cap</span> == this.cache.dlSize() &#123;</span><br><span class="line">            this.deleteLeastRecently()</span><br><span class="line">        &#125;</span><br><span class="line">        this.addRecently(key,value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">makeRecently</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := this.hashMap[key]</span><br><span class="line">    this.cache.remove(x)</span><br><span class="line">    this.cache.addLast(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">addRecently</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := &amp;node&#123;</span><br><span class="line">        key :   key,</span><br><span class="line">        value : val,</span><br><span class="line">    &#125;</span><br><span class="line">    this.cache.addLast(x)</span><br><span class="line">    this.hashMap[key] = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">deleteKey</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := this.hashMap[key]</span><br><span class="line">    this.cache.remove(x)</span><br><span class="line">    <span class="built_in">delete</span>(this.hashMap,key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">deleteLeastRecently</span><span class="params">()</span></span> &#123;</span><br><span class="line">    deleteNode := this.cache.removeFirst()</span><br><span class="line">    deleteKey := deleteNode.key</span><br><span class="line">    <span class="built_in">delete</span>(this.hashMap, deleteKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>LFU算法</title>
    <url>/2021/09/22/LFU%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="LFU算法介绍"><a href="#LFU算法介绍" class="headerlink" title="LFU算法介绍"></a>LFU算法介绍</h1><h2 id="LFU缓存机制"><a href="#LFU缓存机制" class="headerlink" title="LFU缓存机制"></a>LFU缓存机制</h2><p>&emsp;&emsp;LFU 算法的淘汰策略是 Least Frequently Used，也就是每次淘汰那些使用次数最少的数据。对比于在<a href="https://jiahaohong1997.github.io/2021/09/21/LRU%E7%AE%97%E6%B3%95/">LRU算法</a>中介绍的LRU 缓存淘汰算法，LRU 算法的淘汰策略是 Least Recently Used，也就是每次淘汰那些最久没被使用的数据。LRU 算法的核心数据结构是使用哈希链表 <code>LinkedHashMap</code>，首先借助链表的有序性使得链表元素维持插入顺序，同时借助哈希映射的快速访问能力使得我们可以在 O(1) 时间访问链表的任意元素。</p>
<p>&emsp;&emsp;而 LFU 算法相当于是把数据按照访问频次进行排序，这个需求恐怕没有那么简单，而且还有一种情况，如果多个数据拥有相同的访问频次，我们就得删除最早插入的那个数据。也就是说 LFU 算法是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>&emsp;&emsp;要求你写一个类，接受一个 <code>capacity</code> 参数，实现 <code>get</code> 和 <code>put</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LFUCache</span></span> &#123;&#125; <span class="comment">// 构造容量为 capacity 的缓存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;&#125;  <span class="comment">// 在缓存中查询 key</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;&#125; <span class="comment">// 将 key 和 val 存入缓存</span></span><br></pre></td></tr></table></figure>

<p><code>Get(key)</code> 方法会去缓存中查询键 <code>key</code>，如果 <code>key</code> 存在，则返回 <code>key</code> 对应的 <code>val</code>，否则返回 -1。</p>
<p><code>Put(key, value)</code> 方法插入或修改缓存。如果 <code>key</code> 已存在，则将它对应的值改为 <code>val</code>；如果 <code>key</code> 不存在，则插入键值对 <code>(key, val)</code>。</p>
<p>&emsp;&emsp;当缓存达到容量 <code>capacity</code> 时，则应该在插入新的键值对之前，删除使用频次（后文用 <code>freq</code> 表示）最低的键值对。如果 <code>freq</code> 最低的键值对有多个，则删除其中最旧的那个。</p>
<h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>&emsp;&emsp;首先我们需要理解LFU算法执行过程的几个事实：</p>
<ol>
<li>调用<code>Get(key int)</code>方法时，要返回<code>key</code>对应的<code>val</code>。</li>
<li>只要用到<code>Get</code>或<code>Put</code>方法访问一次某个<code>key</code>，该<code>key</code>的<code>freq</code>就要加一。</li>
<li>如果在容量满了的时候插入，则需要将 <code>freq</code> 最小的 <code>key</code> 删除，如果最小的 <code>freq</code> 对应多个 <code>key</code>，则删除其中最旧的那一个。</li>
</ol>
<p>&emsp;&emsp;现在我们来逐一解决:</p>
<ol>
<li>调用<code>Get(key int)</code>方法时，要返回<code>key</code>对应的<code>val</code>。</li>
</ol>
<p>&emsp;&emsp;使用一个 <code>HashMap</code> 存储 <code>key</code> 到 <code>val</code> 的映射，就可以快速计算 <code>get(key)</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">keyToVal := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>只要用到<code>Get</code>或<code>Put</code>方法访问一次某个<code>key</code>，该<code>key</code>的<code>freq</code>就要加一。</li>
</ol>
<p>&emsp;&emsp;使用一个 <code>HashMap</code> 存储 <code>key</code> 到 <code>freq</code> 的映射，就可以快速操作 <code>key</code> 对应的 <code>freq</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">keyToFreq := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>如果在容量满了的时候插入，则需要将 <code>freq</code> 最小的 <code>key</code> 删除，如果最小的 <code>freq</code> 对应多个 <code>key</code>，则删除其中最旧的那一个。</li>
</ol>
<p>&emsp;&emsp;这个需求应该是 LFU 算法的核心，所以我们分开说。</p>
<ul>
<li>首先，肯定是需要 <code>freq</code> 到 <code>key</code> 的映射，用来找到 <code>freq</code> 最小的 <code>key</code>。</li>
<li>将 <code>freq</code> 最小的 <code>key</code> 删除，那你就得快速得到当前所有 <code>key</code> 最小的 <code>freq</code> 是多少。想要时间复杂度 O(1) 的话，肯定不能遍历一遍去找，那就用一个变量 <code>minFreq</code> 来记录当前最小的 <code>freq</code> 吧。</li>
<li>可能有多个 <code>key</code> 拥有相同的 <code>freq</code>，所以 <strong><code>freq</code></strong> <strong>对</strong> <strong><code>key</code></strong> <strong>是一对多的关系</strong>，即一个 <code>freq</code> 对应一个 <code>key</code> 的列表。</li>
<li>希望 <code>freq</code> 对应的 <code>key</code> 的列表是<strong>存在时序</strong>的，便于快速查找并删除最旧的 <code>key</code>。</li>
<li>希望<strong>能够快速删除</strong> <strong><code>key</code></strong> <strong>列表中的任何一个</strong> **<code>key</code>**，因为如果频次为 <code>freq</code> 的某个 <code>key</code> 被访问，那么它的频次就会变成 <code>freq+1</code>，就应该从 <code>freq</code> 对应的 <code>key</code> 列表中删除，加到 <code>freq+1</code> 对应的 <code>key</code> 的列表中。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">freqToKeys := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet)</span><br><span class="line">minFreq := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key		<span class="keyword">int</span></span><br><span class="line">    prev	*node</span><br><span class="line">    next	*node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DoubleList <span class="keyword">struct</span> &#123;</span><br><span class="line">    head	*node</span><br><span class="line">    tail	*node</span><br><span class="line">    size	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorDL</span><span class="params">()</span> *<span class="title">DoubleList</span></span> &#123;</span><br><span class="line">    dh := &amp;node&#123;</span><br><span class="line">        key		:	<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dt := &amp;node &#123;</span><br><span class="line">        key		:	<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dh.next,dt.prev = dt,dh</span><br><span class="line">    <span class="keyword">return</span> &amp;DoubleList&#123;</span><br><span class="line">        head	:	dh,</span><br><span class="line">        tail	:	dt,</span><br><span class="line">        size	:	<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LinkedHashSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashMap		<span class="keyword">map</span>[<span class="keyword">int</span>]*node</span><br><span class="line">    doubleList	*DoubleList    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorLH</span><span class="params">()</span> *<span class="title">LinkedHashSet</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node)</span><br><span class="line">    dl := constructorDL()</span><br><span class="line">    <span class="keyword">return</span> &amp;LinkedHashSet&#123;</span><br><span class="line">        hashMap		:	m,</span><br><span class="line">        doubleList	:	dl,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>LinkedHashSet</code> 顾名思义，是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插入元素具有时序；哈希集合中的元素无序，但是可以对元素进行快速的访问和删除。那么，它俩结合起来就兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，又可以保持插入的时序。</p>
<p>综上，我们可以写出 LFU 算法的基本数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    keyToVal	<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>				<span class="comment">// key 到 val 的映射，我们后文称为 KV 表</span></span><br><span class="line">    keyToFreq	<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>				<span class="comment">// key 到 freq 的映射，我们后文称为 KF 表</span></span><br><span class="line">    freqToKeys	<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet	<span class="comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span></span><br><span class="line">    minFreq		<span class="keyword">int</span>						<span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="built_in">cap</span>			<span class="keyword">int</span>						<span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity)</span> <span class="title">LFUCache</span></span> &#123;</span><br><span class="line">    kv := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    kf := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    fk := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet)</span><br><span class="line">    <span class="keyword">return</span> LFUCache&#123;</span><br><span class="line">        keyToVal	:	kv,</span><br><span class="line">        keyToFreq	:	kf,</span><br><span class="line">        freqToKeys	:	fk,</span><br><span class="line">        minFreq		:	<span class="number">0</span>,</span><br><span class="line">        <span class="built_in">cap</span>			:	capacity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;&#125;  <span class="comment">// 在缓存中查询 key</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;&#125; <span class="comment">// 将 key 和 val 存入缓存</span></span><br></pre></td></tr></table></figure>



<h1 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h1><h2 id="实现Get-key-int-方法"><a href="#实现Get-key-int-方法" class="headerlink" title="实现Get(key int)方法"></a>实现<code>Get(key int)</code>方法</h2><p>&emsp;&emsp;逻辑很简单，返回 <code>key</code> 对应的 <code>val</code>，然后增加 <code>key</code> 对应的 <code>freq</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.increaseFreq(key)</span><br><span class="line">    <span class="keyword">return</span> this.keyToVal[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;增加<code>key</code>对应的<code>freq</code>是LFU算法的核心，所以我们干脆抽象一个方法<code>increaseFreq</code>，这样<code>Get</code>方法就比较简洁。</p>
<h2 id="实现Put-key-int-val-int-方法"><a href="#实现Put-key-int-val-int-方法" class="headerlink" title="实现Put(key int,val int) 方法"></a>实现<code>Put(key int,val int)</code> 方法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; ok &#123;  <span class="comment">// 若key已存在，修改对应的val即可</span></span><br><span class="line">        this.keyToVal[key] = value</span><br><span class="line">        this.increaseFreq(key)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// key不存在，需要插入</span></span><br><span class="line">    <span class="comment">// 容量已满的话需要淘汰一个freq最小的key</span></span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> == <span class="built_in">len</span>(this.keyToVal) &#123;</span><br><span class="line">        this.removeMinFreqKey()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入key和val，对应的freq为1</span></span><br><span class="line">    this.keyToVal[key] = value	<span class="comment">// 插入KV表</span></span><br><span class="line">    this.keyToFreq[key] = <span class="number">1</span>		<span class="comment">// 插入KF表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[<span class="number">1</span>]; !ok &#123;  <span class="comment">// 如果没有freq为1的LinkedHashSet，则生成一个</span></span><br><span class="line">        this.freqToKeys[<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,<span class="number">1</span>)  <span class="comment">// 插入新key后的freq肯定是1</span></span><br><span class="line">    this.minFreq = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实现核心逻辑（中间抽象层）"><a href="#实现核心逻辑（中间抽象层）" class="headerlink" title="实现核心逻辑（中间抽象层）"></a>实现核心逻辑（中间抽象层）</h2><h3 id="实现removeMinFreqKey方法"><a href="#实现removeMinFreqKey方法" class="headerlink" title="实现removeMinFreqKey方法"></a>实现<code>removeMinFreqKey</code>方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">removeMinFreqKey</span><span class="params">()</span></span> &#123;</span><br><span class="line">    keyList := this.freqToKeys[this.minFreq].doubleList	<span class="comment">// 获得最小freq的LinkedHashSet</span></span><br><span class="line">    deleteKey := keyList.removeFirst()	<span class="comment">// 删除LinkedHashSet的双链表头的元素</span></span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[this.minFreq].hashMap,deleteKey.key)		<span class="comment">// 删除LinkedHashSet的哈希表对应元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[this.minFreq].hashMap) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,this.minFreq)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delete</span>(this.keyToVal,deleteKey.key)		<span class="comment">// 更新KV表</span></span><br><span class="line">    <span class="built_in">delete</span>(this.keyToFreq,deleteKey.key)	<span class="comment">// 更新KF表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;删除某个<code>key</code>肯定是要同时映射三个表的，借助<code>minFreq</code>参数可以从<code>FK</code>表中找到<code>freq</code>最小的<code>keyList</code>，删除其表头元素即可，同时删除<code>Fk</code>表中<code>freq</code>最小的<code>hashMap</code>对应的元素。然后根据要被淘汰的<code>deleteKey</code>删除其余两个表中的映射关系。</p>
<p>&emsp;&emsp;这里有个细节问题，如果<code>keyList</code>中只有一个元素，那么删除之后<code>minFreq</code>对应的<code>key</code>列表就为空了，也就是<code>minFreq</code>变量需要更新。实际上没办法快速计算<code>minFreq</code>，只能线性遍历<code>FK</code>表或者<code>KF</code>表来计算，这样肯定不能保证 O(1) 的时间复杂度。<strong>但是，其实这里没必要更新<code>minFreq</code>变量</strong>，因为你想想<code>removeMinFreqKey</code>这个函数是在什么时候调用？在<code>put</code>方法中插入新<code>key</code>时可能调用。而你回头看<code>put</code>的代码，插入新<code>key</code>时一定会把<code>minFreq</code>更新成 1，所以说即便这里<code>minFreq</code>变了，我们也不需要管它。</p>
<h3 id="实现increaseFreq方法"><a href="#实现increaseFreq方法" class="headerlink" title="实现increaseFreq方法"></a>实现<code>increaseFreq</code>方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">increaseFreq</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    freq := this.keyToFreq[key]</span><br><span class="line">    this.keyToFreq[key] = freq+<span class="number">1</span>	<span class="comment">// 更新KF表</span></span><br><span class="line">    <span class="comment">// 将key从freq对应的列表和哈希表中删除</span></span><br><span class="line">    this.freqToKeys[freq].doubleList.remove(this.freqToKeys[freq].hashMap[key])</span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[freq].hashMap,key)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[freq].hashMap) == <span class="number">0</span> &#123; <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,freq)</span><br><span class="line">        <span class="keyword">if</span> freq == this.minFreq &#123;  <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">            this.minFreq++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将key加入到freq+1对应的列表和哈希表中</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[freq+<span class="number">1</span>]; !ok &#123;</span><br><span class="line">        this.freqToKeys[freq+<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,freq+<span class="number">1</span>)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="实现addRecently方法"><a href="#实现addRecently方法" class="headerlink" title="实现addRecently方法"></a>实现<code>addRecently</code>方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">addRecently</span><span class="params">(key <span class="keyword">int</span>, freq <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := &amp;node&#123;</span><br><span class="line">        key		:	key,</span><br><span class="line">    &#125;</span><br><span class="line">    this.freqToKeys[freq].doubleList.addLast(x)</span><br><span class="line">    this.freqToKeys[freq].hashMap[key] = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在插入新的节点时，需要修改<code>FK</code>表的哈希表和双链表。</p>
<h2 id="对底层数据结构进行操作"><a href="#对底层数据结构进行操作" class="headerlink" title="对底层数据结构进行操作"></a>对底层数据结构进行操作</h2><p>&emsp;&emsp;该层的主要作用是对我们实现的<code>LinkedHashSet</code>结构封装一些通用操作，用以满足<code>FK</code>表的更新和删除操作，主要包含以下几个方法：</p>
<ol>
<li>删除<code>DoubleList</code>中某一节点的方法<code>remove(x *node)</code>。</li>
<li>删除<code>DoubleList</code>中表首元素的方法<code>removeFirst()</code>。</li>
<li>在<code>DoubleList</code>中表尾部增加新元素的<code>addLast()</code>。</li>
</ol>
<h3 id="实现remove方法"><a href="#实现remove方法" class="headerlink" title="实现remove方法"></a>实现<code>remove</code>方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">remove</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev.next = x.next</span><br><span class="line">    x.next.prev = x.prev</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="实现removeFirst方法"><a href="#实现removeFirst方法" class="headerlink" title="实现removeFirst方法"></a>实现<code>removeFirst</code>方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">removeFirst</span><span class="params">()</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dl.head.next == dl.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    first := dl.head.next</span><br><span class="line">    dl.remove(first)</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现addLast方法"><a href="#实现addLast方法" class="headerlink" title="实现addLast方法"></a>实现<code>addLast</code>方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">addLast</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev = dl.tail.prev</span><br><span class="line">    x.next = dl.tail</span><br><span class="line">    dl.tail.prev.next = x</span><br><span class="line">    dl.tail.prev = x</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h1 id="总体算法"><a href="#总体算法" class="headerlink" title="总体算法"></a>总体算法</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ###############基础数据结构###################</span></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key		<span class="keyword">int</span></span><br><span class="line">    prev	*node</span><br><span class="line">    next	*node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双端链表</span></span><br><span class="line"><span class="keyword">type</span> DoubleList <span class="keyword">struct</span> &#123;</span><br><span class="line">    head	*node</span><br><span class="line">    tail	*node</span><br><span class="line">    size	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化双端链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorDL</span><span class="params">()</span> *<span class="title">DoubleList</span></span> &#123;</span><br><span class="line">    dh := &amp;node&#123;</span><br><span class="line">        key		:	<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dt := &amp;node &#123;</span><br><span class="line">        key		:	<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    dh.next,dt.prev = dt,dh</span><br><span class="line">    <span class="keyword">return</span> &amp;DoubleList&#123;</span><br><span class="line">        head	:	dh,</span><br><span class="line">        tail	:	dt,</span><br><span class="line">        size	:	<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造LinkedHashSet作为freqToKeys表</span></span><br><span class="line"><span class="keyword">type</span> LinkedHashSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashMap		<span class="keyword">map</span>[<span class="keyword">int</span>]*node</span><br><span class="line">    doubleList	*DoubleList    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化LinkedHashSet</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructorLH</span><span class="params">()</span> *<span class="title">LinkedHashSet</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*node)</span><br><span class="line">    dl := constructorDL()</span><br><span class="line">    <span class="keyword">return</span> &amp;LinkedHashSet&#123;</span><br><span class="line">        hashMap		:	m,</span><br><span class="line">        doubleList	:	dl,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ##############底层方法（用于直接操作数据结构）####################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除双端链表中的某一节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">remove</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev.next = x.next</span><br><span class="line">    x.next.prev = x.prev</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除双端链表表头元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">removeFirst</span><span class="params">()</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dl.head.next == dl.tail &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    first := dl.head.next</span><br><span class="line">    dl.remove(first)</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在双端链表尾部添加新元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl *DoubleList)</span> <span class="title">addLast</span><span class="params">(x *node)</span></span> &#123;</span><br><span class="line">    x.prev = dl.tail.prev</span><br><span class="line">    x.next = dl.tail</span><br><span class="line">    dl.tail.prev.next = x</span><br><span class="line">    dl.tail.prev = x</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ###############LFU类的实现##################</span></span><br><span class="line"><span class="keyword">type</span> LFUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    keyToVal	<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>				<span class="comment">// key 到 val 的映射，我们后文称为 KV 表</span></span><br><span class="line">    keyToFreq	<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>				<span class="comment">// key 到 freq 的映射，我们后文称为 KF 表</span></span><br><span class="line">    freqToKeys	<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet	<span class="comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span></span><br><span class="line">    minFreq		<span class="keyword">int</span>						<span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="built_in">cap</span>			<span class="keyword">int</span>						<span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化LFU类，加载KV表、KF表以及FK表，设置最小频率树minFreq</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LFUCache</span></span> &#123;</span><br><span class="line">    kv := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    kf := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    fk := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*LinkedHashSet)</span><br><span class="line">    <span class="keyword">return</span> LFUCache&#123;</span><br><span class="line">        keyToVal	:	kv,</span><br><span class="line">        keyToFreq	:	kf,</span><br><span class="line">        freqToKeys	:	fk,</span><br><span class="line">        minFreq		:	<span class="number">0</span>,</span><br><span class="line">        <span class="built_in">cap</span>			:	capacity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.increaseFreq(key)</span><br><span class="line">    <span class="keyword">return</span> this.keyToVal[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Put方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> _,ok := this.keyToVal[key]; ok &#123;  <span class="comment">// 若key已存在，修改对应的val即可</span></span><br><span class="line">        this.keyToVal[key] = value</span><br><span class="line">        this.increaseFreq(key)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// key不存在，需要插入</span></span><br><span class="line">    <span class="comment">// 容量已满的话需要淘汰一个freq最小的key</span></span><br><span class="line">    <span class="keyword">if</span> this.<span class="built_in">cap</span> &lt;= <span class="built_in">len</span>(this.keyToVal) &#123;</span><br><span class="line">        this.removeMinFreqKey()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入key和val，对应的freq为1</span></span><br><span class="line">    this.keyToVal[key] = value	<span class="comment">// 插入KV表</span></span><br><span class="line">    this.keyToFreq[key] = <span class="number">1</span>		<span class="comment">// 插入KF表</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[<span class="number">1</span>]; !ok &#123;  <span class="comment">// 如果没有freq为1的LinkedHashSet，则生成一个</span></span><br><span class="line">        this.freqToKeys[<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,<span class="number">1</span>)  <span class="comment">// 插入新key后的freq肯定是1</span></span><br><span class="line">    this.minFreq = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ################中间抽象层####################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除使用频率最低节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">removeMinFreqKey</span><span class="params">()</span></span> &#123;</span><br><span class="line">    keyList := this.freqToKeys[this.minFreq].doubleList	<span class="comment">// 获得最小freq的LinkedHashSet</span></span><br><span class="line">    deleteKey := keyList.removeFirst()	<span class="comment">// 删除LinkedHashSet的双链表头的元素</span></span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[this.minFreq].hashMap,deleteKey.key)		<span class="comment">// 删除LinkedHashSet的哈希表对应元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[this.minFreq].hashMap) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,this.minFreq)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">delete</span>(this.keyToVal,deleteKey.key)		<span class="comment">// 更新KV表</span></span><br><span class="line">    <span class="built_in">delete</span>(this.keyToFreq,deleteKey.key)	<span class="comment">// 更新KF表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加某一节点的使用频数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">increaseFreq</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    freq := this.keyToFreq[key]</span><br><span class="line">    this.keyToFreq[key] = freq+<span class="number">1</span>	<span class="comment">// 更新KF表</span></span><br><span class="line">    <span class="comment">// 将key从freq对应的列表和哈希表中删除</span></span><br><span class="line">    this.freqToKeys[freq].doubleList.remove(this.freqToKeys[freq].hashMap[key])</span><br><span class="line">    <span class="built_in">delete</span>(this.freqToKeys[freq].hashMap,key)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.freqToKeys[freq].hashMap) == <span class="number">0</span> &#123; <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">        <span class="built_in">delete</span>(this.freqToKeys,freq)</span><br><span class="line">        <span class="keyword">if</span> freq == this.minFreq &#123;  <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">            this.minFreq++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将key加入到freq+1对应的列表和哈希表中</span></span><br><span class="line">    <span class="keyword">if</span> _,ok := this.freqToKeys[freq+<span class="number">1</span>]; !ok &#123;</span><br><span class="line">        this.freqToKeys[freq+<span class="number">1</span>] = constructorLH()</span><br><span class="line">    &#125;</span><br><span class="line">    this.addRecently(key,freq+<span class="number">1</span>)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 对最近使用的节点的处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LFUCache)</span> <span class="title">addRecently</span><span class="params">(key <span class="keyword">int</span>, freq <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x := &amp;node&#123;</span><br><span class="line">        key		:	key,</span><br><span class="line">    &#125;</span><br><span class="line">    this.freqToKeys[freq].doubleList.addLast(x)</span><br><span class="line">    this.freqToKeys[freq].hashMap[key] = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>LFU</tag>
      </tags>
  </entry>
  <entry>
    <title>链表习题解析</title>
    <url>/2021/09/24/%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="链表高频题目"><a href="#链表高频题目" class="headerlink" title="链表高频题目"></a>链表高频题目</h1><h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a class="link" href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加<i class="fas fa-external-link-alt"></i></a></h4><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="addtwonumber1.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;本题很自然的就想到先将两个链表保存的数都转化成变量的形式存储下来，直接相加后再逐位用链表保存后输出。但是，在提交代码后，发现其中一个测试用例没有通过。原来是其中一个链表转换成数字变量后，它直接溢出了，导致出错。所以要完全AC这道题，这种方法肯定是不行的。</p>
<p>&emsp;&emsp;由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为<code>n1,n2</code>，进位值为<code>carry</code>，他们的和为<code>n1+n2+carry</code>，其中答案链表处相应位置的数字为<code>(n1+n2+carry)%10</code>，而新的进位值为<code>(n1+n2+carry)/10</code>。</p>
<p>&emsp;&emsp;如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0 。此外，如果链表遍历结束后，有 <code>carry&gt;0</code>，还需要在答案链表的后面附加一个节点，节点的值为 <code>carry</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    carry := <span class="number">0</span></span><br><span class="line">    v := <span class="number">0</span></span><br><span class="line">    h1 := l1	<span class="comment">// 保存头节点</span></span><br><span class="line">    f1 := l1	<span class="comment">// 记录前一节点，方便拼接</span></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;	<span class="comment">// 当l1和l2都没有遍历到表尾</span></span><br><span class="line">        v = (l1.Val+l2.Val+carry)%<span class="number">10</span>	<span class="comment">// 值</span></span><br><span class="line">        carry = (l1.Val+l2.Val+carry)/<span class="number">10</span>   <span class="comment">//	进位</span></span><br><span class="line">        l1.Val = v		<span class="comment">//	保存到l1中（直接替换掉这个位置节点的值）</span></span><br><span class="line">        f1 = l1			<span class="comment">//	f1跟进</span></span><br><span class="line">        l1 = l1.Next	<span class="comment">//	l1指向其Next</span></span><br><span class="line">        l2 = l2.Next	<span class="comment">//	l2指向其Next</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &amp;&amp; carry != <span class="number">0</span> &#123;	<span class="comment">// l1和l2等长且最后还有一位进位</span></span><br><span class="line">        f1.Next = &amp;ListNode&#123;	<span class="comment">// 创造一个节点，其值为进位值</span></span><br><span class="line">            Val     :       carry,</span><br><span class="line">            Next    :       <span class="literal">nil</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;	<span class="comment">//	l1更长，处理完l1剩余的节点</span></span><br><span class="line">        <span class="keyword">for</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            v = (l1.Val+carry)%<span class="number">10</span></span><br><span class="line">            carry = (l1.Val+carry)/<span class="number">10</span>        </span><br><span class="line">            l1.Val = v</span><br><span class="line">            f1 = l1</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> carry != <span class="number">0</span> &#123;	<span class="comment">//	考虑最后是否有进位</span></span><br><span class="line">            f1.Next = &amp;ListNode&#123;</span><br><span class="line">                Val     :       carry,</span><br><span class="line">                Next    :       <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;	<span class="comment">//	l2更长，处理完l2剩余的节点</span></span><br><span class="line">        f1.Next = l2</span><br><span class="line">        <span class="keyword">for</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            v = (l2.Val+carry)%<span class="number">10</span></span><br><span class="line">            carry = (l2.Val+carry)/<span class="number">10</span>     </span><br><span class="line">            l2.Val = v</span><br><span class="line">            f1 = l2</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> carry != <span class="number">0</span> &#123;	<span class="comment">//	考虑最后是否有进位</span></span><br><span class="line">            f1.Next = &amp;ListNode&#123;</span><br><span class="line">                Val     :       carry,</span><br><span class="line">                Next    :       <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h1><h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a class="link" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表<i class="fas fa-external-link-alt"></i></a></h4><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="merge_ex1.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<p>这题思路很简单，用下图就可以概括：</p>
<p><img lazyload src="/images/loading.svg" data-src="1.gif" alt="avatar"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    dummy := &amp;ListNode&#123;Val:<span class="number">0</span>,Next:<span class="literal">nil</span>,&#125;</span><br><span class="line">    tail := dummy</span><br><span class="line">    <span class="keyword">var</span> node *ListNode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l1.Val &lt;= l2.Val &#123;</span><br><span class="line">            node = &amp;ListNode&#123;</span><br><span class="line">                Val     :   l1.Val,</span><br><span class="line">                Next    :   <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = &amp;ListNode&#123;</span><br><span class="line">                Val     :   l2.Val,</span><br><span class="line">                Next    :   <span class="literal">nil</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        tail.Next = node</span><br><span class="line">        tail = node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        tail.Next = l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        tail.Next = l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a class="link" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表<i class="fas fa-external-link-alt"></i></a></h4><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：lists &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：lists &#x3D; [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>



<p>提示：</p>
<ul>
<li><code>k == lists.length</code></li>
<li><code>0 &lt;= k &lt;= 10^4</code></li>
<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>
<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>
<li><code>lists[i]</code> 按 升序 排列</li>
<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>
</ul>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="反转整个链表"><a href="#反转整个链表" class="headerlink" title="反转整个链表"></a>反转整个链表</h2><ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;	<span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    last := reverse(head.Next)</span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    first := head.Next.Next</span><br><span class="line">    second := head.Next</span><br><span class="line">    third := head</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> first != <span class="literal">nil</span> &#123;</span><br><span class="line">        second.Next = third</span><br><span class="line">        third = second</span><br><span class="line">        second = first</span><br><span class="line">        first = first.Next</span><br><span class="line">    &#125;</span><br><span class="line">    second.Next = third</span><br><span class="line">    <span class="keyword">return</span> second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="反转链表前n个节点"><a href="#反转链表前n个节点" class="headerlink" title="反转链表前n个节点"></a>反转链表前n个节点</h2><p>&emsp;&emsp;比如说对于下图链表，执行 <code>reverseN(head, 3)</code>：</p>
<p><img lazyload src="/images/loading.svg" data-src="6.jpg" alt="avatar"></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> successor *ListNode	<span class="comment">// 后驱节点</span></span><br><span class="line">successor = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseN</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        successor = head.Next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    last := reverseN(head.Next,n<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    head.Next = successor</span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseN</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    first := head.Next.Next</span><br><span class="line">    second := head.Next</span><br><span class="line">    third := head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;		<span class="comment">// n=1,不需要翻转</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> &#123;		<span class="comment">// n=2,直接翻转前两个节点即可</span></span><br><span class="line">        second.Next = third</span><br><span class="line">        third.Next = first</span><br><span class="line">        <span class="keyword">return</span> second</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> n<span class="number">-2</span> &gt; <span class="number">0</span> &#123;	<span class="comment">// n&gt;2时的情况，结合上图来推一遍会比较清晰</span></span><br><span class="line">        second.Next = third</span><br><span class="line">        third = second</span><br><span class="line">        second = first</span><br><span class="line">        first = first.Next</span><br><span class="line">        n--</span><br><span class="line">    &#125;</span><br><span class="line">    second.Next = third</span><br><span class="line">    third.Next = first</span><br><span class="line">    <span class="keyword">return</span> second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="反转链表的一部分"><a href="#反转链表的一部分" class="headerlink" title="反转链表的一部分"></a>反转链表的一部分</h2><p>&emsp;&emsp;给一个索引区间 <code>[m,n]</code>（索引从 1 开始），仅仅反转区间中的链表元素。</p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, m,n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">1</span> &#123;	<span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">return</span> reverseN(head,n)	<span class="comment">// 相当于反转前n个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">    head.Next = reverseBetween(head.Next, m<span class="number">-1</span>, n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>迭代</li>
</ul>
<p><a class="link" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>示例 1：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="rev2ex2.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4</span><br><span class="line">输出：[1,4,3,2,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [5], left &#x3D; 1, right &#x3D; 1</span><br><span class="line">输出：[5]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目为 <code>n</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>-500 &lt;= Node.val &lt;= 500</code></li>
<li><code>1 &lt;= left &lt;= right &lt;= n</code></li>
</ul>
<p><strong>解题思路：</strong></p>
<p>&emsp;&emsp;我们以下图中黄色区域的链表反转为例。</p>
<p><img lazyload src="/images/loading.svg" data-src="1615105129-iUPoGi-image.png" alt="avatar"></p>
<p>&emsp;&emsp;反转 <code>left</code> 到 <code>right</code> 部分以后，再拼接起来。我们还需要记录 <code>left</code>的前一个节点，和 <code>right</code> 的后一个节点。如图所示：</p>
<p><img lazyload src="/images/loading.svg" data-src="1615105150-pfWiGq-image.png" alt="avatar"></p>
<ul>
<li>第 1 步：先将待反转的区域反转；</li>
<li>第 2 步：把 pre 的 next 指针指向反转以后的链表头节点，把反转以后的链表的尾节点的 next 指针指向 succ</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    dummyNode := &amp;ListNode&#123;Val:<span class="number">-1</span>&#125;</span><br><span class="line">    dummyNode.Next = head</span><br><span class="line">    pre := dummyNode</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;left<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        pre = pre.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点</span></span><br><span class="line">    rightNode := pre</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; right-left+<span class="number">1</span>; i++ &#123;</span><br><span class="line">        rightNode = rightNode.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 3 步：切断出一个子链表（截取链表）</span></span><br><span class="line">    leftNode := pre.Next;</span><br><span class="line">    curr := rightNode.Next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：切断链接</span></span><br><span class="line">    pre.Next = <span class="literal">nil</span></span><br><span class="line">    rightNode.Next = <span class="literal">nil</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 第4步：反转区间</span></span><br><span class="line">    reverse(leftNode)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第 5 步：接回到原来的链表中</span></span><br><span class="line">    pre.Next = rightNode</span><br><span class="line">    leftNode.Next = curr</span><br><span class="line">    <span class="keyword">return</span> dummyNode.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉堆的Go语言实现</title>
    <url>/2021/09/27/%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="二叉堆的简介"><a href="#二叉堆的简介" class="headerlink" title="二叉堆的简介"></a>二叉堆的简介</h1><p>&emsp;&emsp;首先，二叉堆和二叉树有啥关系呢，为什么人们总数把二叉堆画成一棵二叉树？因为，二叉堆在逻辑上其实是一种特殊的二叉树<strong>（完全二叉树）</strong>，只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针：</p>
<p>&emsp;&emsp;画个图你立即就能理解了，比如 <code>arr</code> 是一个字符数组，注意数组的第一个索引 0 空着不用：</p>
<p><img lazyload src="/images/loading.svg" data-src="2.png" alt="avatar"></p>
<p>&emsp;&emsp;因为这棵二叉树是<font color="red">「完全二叉树」</font>，所以把 <code>arr[1]</code> 作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。</p>
<p>&emsp;&emsp;为了方便讲解，下面都会画的图都是二叉树结构，相信你能把树和数组对应起来。二叉堆还分为最大堆和最小堆。<strong>最大堆的性质是：每个节点都大于等于它的两个子节点。</strong>类似的，最小堆的性质是：每个节点都小于等于它的子节点。</p>
<h1 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h1><p>&emsp;&emsp;在Go语言的标准库<code>container/heap</code>中，实现了二叉堆，我们先来看看这个包下面有什么内容。</p>
<ol>
<li>接口定义</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，这个堆结构继承自 sort.Interface, 回顾下 <a href="https://jiahaohong1997.github.io/2021/06/10/%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89sort%E5%87%BD%E6%95%B0/">sort.Interface</a>，它需要实现三个方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">	Len() <span class="keyword">int</span></span><br><span class="line">	Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">	Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上堆接口定义的两个方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(h Interface, x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span> <span class="title">interface</span></span>&#123;&#125; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;也就是说，要实现一个堆需要完整实现上述5个方法。</p>
<ol start="2">
<li>上浮<code>up</code>和下沉<code>down</code>方法</li>
</ol>
<p>&emsp;&emsp;我们要讲的是最小堆，每个节点都比它的两个子节点小，但是在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。</p>
<p>&emsp;&emsp;对于最小堆，会破坏堆性质的有有两种情况：</p>
<ul>
<li><code>down</code>：如果某个节点 A 比它的子节点（中的一个）大，那么 A 就不配做父节点，应该下去，下面那个更小的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">down</span><span class="params">(h Interface, i0, n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	i := i0</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		j1 := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> j1 &gt;= n || j1 &lt; <span class="number">0</span> &#123; <span class="comment">// j1 &lt; 0 after int overflow</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		j := j1 <span class="comment">// left child</span></span><br><span class="line">		<span class="keyword">if</span> j2 := j1 + <span class="number">1</span>; j2 &lt; n &amp;&amp; h.Less(j2, j1) &#123;</span><br><span class="line">			j = j2 <span class="comment">// = 2*i + 2  // right child</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !h.Less(j, i) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		h.Swap(i, j)</span><br><span class="line">		i = j</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i &gt; i0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>up</code>：如果某个节点 A 比它的父节点小，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">up</span><span class="params">(h Interface, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		i := (j - <span class="number">1</span>) / <span class="number">2</span> <span class="comment">// parent</span></span><br><span class="line">		<span class="keyword">if</span> i == j || !h.Less(j, i) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		h.Swap(i, j)</span><br><span class="line">		j = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，错位的节点 A 可能要上浮（或下沉）很多次，才能到达正确的位置，恢复堆的性质。所以代码中肯定有一个 <code>for</code> 循环。</p>
<ul>
<li><code>fix</code>：当堆中某一节点的值发生改变后，要对其进行<strong>上浮</strong>或<strong>下沉</strong>操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fix</span><span class="params">(h Interface, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !down(h, i, h.Len()) &#123;</span><br><span class="line">		up(h, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>初始化结构体（建堆）</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(h Interface)</span></span> &#123;</span><br><span class="line">	<span class="comment">// heapify</span></span><br><span class="line">	n := h.Len()</span><br><span class="line">	<span class="keyword">for</span> i := n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		down(h, i, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可见，在Go语言中是以<code>0</code>为首开始存储的，所以对于这歌满二叉树，索引为<code>x</code>的节点左子树索引为<code>2*x+1</code>，右子树为<code>2*x+2</code>。</p>
<ol start="4">
<li>堆的增，出堆和删操作</li>
</ol>
<ul>
<li>增<code>Push</code></li>
</ul>
<p>&emsp;&emsp;当在当前堆中增加元素时，先在队列的最末尾处（完全二叉树的最后一个节点）将其插入，然后再利用<strong>上浮</strong>操作调整其位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Push pushes the element x onto the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(h Interface, x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    h.Push(x)	<span class="comment">// h.Push(x)是外层实体的方法，与本方法不相同</span></span><br><span class="line">	up(h, h.Len()<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>出堆<code>Pop</code></li>
</ul>
<p>&emsp;&emsp;堆的Pop操作是先将堆顶元素与最后一个元素交换位置，然后再将交换后的堆顶元素<strong>下沉</strong>到属于它的位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pop removes and returns the minimum element (according to Less) from the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="comment">// Pop is equivalent to Remove(h, 0).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	n := h.Len() - <span class="number">1</span></span><br><span class="line">	h.Swap(<span class="number">0</span>, n)</span><br><span class="line">	down(h, <span class="number">0</span>, n)</span><br><span class="line">    <span class="keyword">return</span> h.Pop()	<span class="comment">// 这里的h.Pop()是用户自己定义的方法，以上部分操作都只负责将堆顶元素放到末尾并使堆保持其规则，最后这一行是用户自己对实体的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>删除任意节点<code>Remove</code></li>
</ul>
<p>&emsp;&emsp;删除任意节点的索引为<code>i</code>，将其与最后一个节点调换位置，然后将调换到索引<code>i</code>处的节点<strong>下沉</strong>到属于它的位置。特别的：出堆操作就是删除第一个节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Remove removes and returns the element at index i from the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(h Interface, i <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	n := h.Len() - <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> n != i &#123;</span><br><span class="line">		h.Swap(i, n)</span><br><span class="line">		<span class="keyword">if</span> !down(h, i, n) &#123;</span><br><span class="line">			up(h, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h.Pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="实现int类型的二叉堆"><a href="#实现int类型的二叉堆" class="headerlink" title="实现int类型的二叉堆"></a>实现int类型的二叉堆</h1><p>&emsp;&emsp;在官方文档给的示例中<a class="link" href="https://github1s.com/golang/go/blob/master/src/container/heap/example_intheap_test.go">example_intheap_test.go<i class="fas fa-external-link-alt"></i></a>，介绍了怎么通过调用heap包来实现int类型的二叉堆。我们来看看其具体的实现流程。</p>
<ol>
<li>定义一个新的类型，实现五个固定的方法</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;	<span class="comment">// 小端堆用&lt;，大端堆则反过来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;		<span class="comment">// 增添一个新元素</span></span><br><span class="line">	<span class="comment">// Push and Pop use pointer receivers because they modify the slice&#x27;s length,</span></span><br><span class="line">	<span class="comment">// not just its contents.</span></span><br><span class="line">	*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;	<span class="comment">// 推出最后一个元素</span></span><br><span class="line">	old := *h</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	x := old[n<span class="number">-1</span>]</span><br><span class="line">	*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>完整代码</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 2012 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This example demonstrates an integer heap built using the heap interface.</span></span><br><span class="line"><span class="keyword">package</span> heap_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/heap&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Push and Pop use pointer receivers because they modify the slice&#x27;s length,</span></span><br><span class="line">	<span class="comment">// not just its contents.</span></span><br><span class="line">	*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	old := *h</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	x := old[n<span class="number">-1</span>]</span><br><span class="line">	*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example inserts several ints into an IntHeap, checks the minimum,</span></span><br><span class="line"><span class="comment">// and removes them in order of priority.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example_intHeap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">	heap.Init(h)	<span class="comment">// 初始化这个堆，此时堆已经建好了</span></span><br><span class="line">	heap.Push(h, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;minimum: %d\n&quot;</span>, (*h)[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, heap.Pop(h))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Output:</span></span><br><span class="line">	<span class="comment">// minimum: 1</span></span><br><span class="line">	<span class="comment">// 1 2 3 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Go语言标准库</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
</search>
